<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="author" content="Jamsa" />
        <meta name="robots" content="index, follow"/>

        <meta property="og:title" content="Jamsa的笔记 - Jamsa"/>
        <meta property="og:url" content="../author/jamsa.html"/>
        <meta property="og:site_name" content="Jamsa的笔记"/>
        <meta property="og:type" content="website"/>

        <link rel="canonical" href="../author/jamsa.html" />

        <title>Jamsa的笔记 - Jamsa | Jamsa的笔记</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" />
        

        <link rel="stylesheet" type="text/css" href="../theme/css/main.css" />

        <script type="text/javascript">var switchTo5x=true;</script>
        <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
        <script type="text/javascript">
         stLight.options({
             publisher: "",
             doNotHash: false,
             doNotCopy: false,
             hashAddressBar: false
         });
        </script>
    </head>

    <body id="index">
        <div class="row-fluid">
            <div class="span10 offset1">
                <header id="banner" >
                    <h1>
                        <a href="../">Jamsa的笔记 </a>
                    </h1>
                    <nav class="navbar">
                        <div class="navbar-inner">
                            <ul class="nav">
                                <li ><a href="../category/da-shu-ju.html">大数据</a></li>
                                <li ><a href="../category/fang-fa.html">方法</a></li>
                                <li ><a href="../category/ji-qi-xue-xi.html">机器学习</a></li>
                                <li ><a href="../category/kai-fa.html">开发</a></li>
                                <li ><a href="../category/qian-duan.html">前端</a></li>
                                <li ><a href="../category/xiao-lu.html">效率</a></li>
                                <li ><a href="../category/yi-dong.html">移动</a></li>
                            </ul>

                        </div>
                    </nav>
                </header><!-- /#banner -->
            </div>
        </div>

        <div class="row-fluid">
            <div class="span10 offset1">
                <div class="row-fluid">
<div class="span9">
                <section>
                    <ol id="posts-list" class="hfeed" start="9">
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="../jtvkai-fa-bi-ji-1-kai-shi.html" rel="bookmark" title="Permalink to JTV开发笔记1-开始">
                                       JTV开发笔记1-开始
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../author/jamsa.html">Jamsa</a>
    </address>

    in <a href="../category/kai-fa.html">开发</a>

    on 2018-07-17

        |
        tags:         <a href="../tag/scala.html">scala</a>
        <a href="../tag/netty.html">netty</a>


        |
        <a href="../jtvkai-fa-bi-ji-1-kai-shi.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>本文是<a href="http://jamsa.github.com/Jamsa/jtv">Jtv</a>的开发笔记。Jtv是一个远程桌面工具。</p>
<h1>起因</h1>
<p>因为工作原因，我经常需要进行远程桌面操作。尝试过多种不同的远程桌面方案，如：QQ远程、Teamviewer、Windows远程桌面、Hamachi等等。在速度比较稳定的，且支持内网连接的工具里只有Teamviewer和QQ远程能稳定使用。切换至Mac环境后，Teamviewer就成了唯一选择，Teamviewer被判定为商业使用后，每5分钟会中断一次，无法正常使用。之间也尝试过使用ngrok配合其它内网vnc工具来进行远程连接。但这些方式都不太方便，比如使用ngrok + Windows远程桌面也能连接，但是远程桌面和VNC都无法与远程用户共享桌面。</p>
<p>由于这些原因，就有了自己开发一个简化版远程桌面工具的想法。</p>
<h1>目标</h1>
<p>仅把它当作个业余项目，近期目标是实现：以中心服务器进行交换，支持内网连接的远程桌面和控制功能。</p>
<h1>技术选型</h1>
<p>个人项目选型上比较自由，主要考虑以下几个方面：</p>
<ul>
<li>
<p>考虑到跨平台使用，选定在Java平台上。</p>
</li>
<li>
<p>利用Swing的Robot类可实现对键盘、鼠标的控制。</p>
</li>
<li>
<p>Java语言写Swing相关的内容太啰嗦，选Scala了。</p>
</li>
<li>
<p>网络通讯模块选择netty。</p>
</li>
</ul>
<p>选择的版本如下：</p>
<ul>
<li>
<p>scala 2.12.6</p>
</li>
<li>
<p>sbt 1.1 …</p></li></ul>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="../jtvkai-fa-bi-ji-1-kai-shi.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="../jtvkai-fa-bi-ji-2-wang-luo-tong-xun.html" rel="bookmark" title="Permalink to JTV开发笔记2-网络通讯">
                                       JTV开发笔记2-网络通讯
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../author/jamsa.html">Jamsa</a>
    </address>

    in <a href="../category/kai-fa.html">开发</a>

    on 2018-07-17

        |
        tags:         <a href="../tag/scala.html">scala</a>
        <a href="../tag/netty.html">netty</a>


        |
        <a href="../jtvkai-fa-bi-ji-2-wang-luo-tong-xun.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>本文是<a href="http://jamsa.github.com/Jamsa/jtv">Jtv</a>的开发笔记。Jtv是一个远程桌面工具。</p>
<h1>协议</h1>
<p>为实现远程控制，我们需要处理两类通讯，客户端与服务器的通讯、客户端与客户端的通讯。</p>
<p>客户端与服务端的通讯主要有：</p>
<ol>
<li>
<p>登录：客户端发送登录请求后，由服务端进行认证，并分配会话ID。</p>
</li>
<li>
<p>连接申请类：客户端创建新连接，通过这个连接发送连接申请，这个连接是源连接。服务端需要将这一申请转发给目标客户端，目标客户端接收到消息后，创建新连接至服务端，这个连接是目标连接。服务端在源连接与目标连接间建立绑定关系后，两个客户端间就可以实现点对点的通讯了。</p>
</li>
</ol>
<p>客户端与客户端的通讯消息主要有以下几类：</p>
<ol>
<li>
<p>文本消息传输：如错误信息，连接关闭通知等。</p>
</li>
<li>
<p>屏幕画面消息：被控端以一定的频度获取屏幕画面，并将它传输至控制端。控制端将其绘制到控制窗口中。</p>
</li>
<li>
<p>鼠标键盘事件：控制端在控制窗口中查看被控端画面，针对该画面操作的键盘和鼠标事件需要被传递到被控端，被控端根据这些事件进行事件的回放。</p>
</li>
</ol>
<h1>消息对象</h1>
<p>为满足上述通讯要求，我们需要定义一套用于消息传输的对象。</p>
<div class="highlight"><pre><span></span><span class="c1">//消息</span>
<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">JtvMessage</span>

<span class="c1">//服务端处理的会话消息</span>
<span class="k">trait</span> <span class="nc">ServerSessionMessage</span> <span class="k">extends</span> <span class="nc">JtvMessage</span>
<span class="c1">//客户端处理的会话消息</span>
<span class="k">trait …</span></pre></div>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="../jtvkai-fa-bi-ji-2-wang-luo-tong-xun.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="../spring-cloud-shang-shou-12-rong-qi-hua.html" rel="bookmark" title="Permalink to Spring Cloud 上手12-容器化">
                                       Spring Cloud 上手12-容器化
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../author/jamsa.html">Jamsa</a>
    </address>

    in <a href="../category/kai-fa.html">开发</a>

    on 2018-06-15

        |
        tags:         <a href="../tag/spring-cloud.html">spring cloud</a>
        <a href="../tag/kubernetes.html">kubernetes</a>
        <a href="../tag/docker.html">docker</a>


        |
        <a href="../spring-cloud-shang-shou-12-rong-qi-hua.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p><code>重要提示：本篇文章的目标在Edgware.SR3上并未成功</code></p>
<p>原因在于在这个版本上<code>Eureka Client</code>运行在<code>Docker</code>中时，无法以<code>Eureka Client IP</code>地址进行注册，服务消费方从注册中心获取到的是<code>Pod</code>的名称，通过此名称无法访问到服务所在的机器。例如：应用在启动时，查询到<code>sc-config</code>配置中心的主机是<code>sc-config-f54cdc656-2524j</code>这样的主机名，通过个主机名去获取配置信息将会因网络无法连接而失败，进而导致应用无法正常启动。</p>
<p>注册中心本向使用了StatefulSets进行部署，客户端是使用固定的域名进行访问的，因此没有这个问题。如果我们将其它服务都变成StatefulSets方式进行部署在<code>Edgware.SR3</code>上也许也能成功。但这样整个应用就变成了Sateful Service了，将失去动态扩容的能力。</p>
<p>问题的根源在于：即使在Eureka Server上添加<code>eureka.instance.prefer-ip-address = true</code>也不能较好解决（添加这个参数后在容器外是有效的，客户端会以IP进行注册）。</p>
<p>具体问题可参考：</p>
<p><a href="https://github.com/sparcs360/axon-demo/issues/18">axon-demo/issue …</a></p>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="../spring-cloud-shang-shou-12-rong-qi-hua.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="../spring-cloud-shang-shou-11-pei-zhi-you-hua.html" rel="bookmark" title="Permalink to Spring Cloud 上手11-配置优化">
                                       Spring Cloud 上手11-配置优化
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../author/jamsa.html">Jamsa</a>
    </address>

    in <a href="../category/kai-fa.html">开发</a>

    on 2018-06-14

        |
        tags:         <a href="../tag/spring-cloud.html">spring cloud</a>


        |
        <a href="../spring-cloud-shang-shou-11-pei-zhi-you-hua.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>这是Spring Cloud上手系列的第十一篇，代码放在<a href="https://github.com/Jamsa/sc-cloud">GitHub</a>上，随着本系列文章更新。</p>
<h1>概述</h1>
<p>本篇主要对各应用的配置进行优化，原因主要有两个：</p>
<ul>
<li>
<p>此前<a href="../spring-cloud-shang-shou-7-pei-zhi-zhong-xin.html">配置中心</a>一文中只把<code>provider:service</code>与配置中心进行了集成，其它应用仍是读取本地的配置信息。</p>
</li>
<li>
<p>写至本篇的时候，发现各个模块的配置文件已经比较乱了，存在大量重复配置，配置文件中也存在一些不需要的配置项，需要进行一轮整理。</p>
</li>
<li>
<p>增加<code>profile</code>支持为后面将容器化做准备。</p>
</li>
</ul>
<p>优化的目标：</p>
<ul>
<li>
<p>配置中心（config）和注册中心（registry）读取本地配置信息外（先有鸡还是先有蛋的问题，只能读取本地配置文件）。</p>
</li>
<li>
<p>服务网关(gateway)、服务提供者（provider:service）、服务消费者（consumer:service）、调用链分析（zipkin）应用都只保留<code>boostrap.yml</code>配置文件，且该配置文件中只保留注册中心地址、应用名称、端口等基本信息。其余配置信息移至配置中心的共享配置文件 …</p></li></ul>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="../spring-cloud-shang-shou-11-pei-zhi-you-hua.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="../spring-cloud-shang-shou-10-ri-zhi-shou-ji.html" rel="bookmark" title="Permalink to Spring Cloud 上手10-日志收集">
                                       Spring Cloud 上手10-日志收集
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../author/jamsa.html">Jamsa</a>
    </address>

    in <a href="../category/kai-fa.html">开发</a>

    on 2018-06-13

        |
        tags:         <a href="../tag/spring-cloud.html">spring cloud</a>


        |
        <a href="../spring-cloud-shang-shou-10-ri-zhi-shou-ji.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>这是Spring Cloud上手系列的第十篇，代码放在<a href="https://github.com/Jamsa/sc-cloud">GitHub</a>上，随着本系列文章更新。</p>
<h1>ELK简介</h1>
<p>ELK是Logstash、ElasticSearch和Kibana的组合。Logstash处理日志的收集，ElasticSearch处理日志的检索，Kibana对日志进行可视化展示和查询。</p>
<p>在Spring Cloud微服务架构下可以使用ElasticSearch来存储两类信息：一类是通过Logstash收集的各个应用的日志，另一类是作为Zipkin的持久化存储。</p>
<h2>Zipkin持久化</h2>
<p>Zipkin本身支持采用ElasticSearch作为其存储引擎，它可以直接与ElasticSearch交互，将跟踪信息保存至ElasticSearch。</p>
<h2>日志收集方式</h2>
<p>微服务应用的日志则情况更复杂。ELK与Spring Cloud的集成有两种方式：</p>
<ul>
<li>一种是各个微服务节点上部署Logstash实例。微服务输出日志时，按Logstash的需要输出为json格式。Logstash则监控这些日志目录，并将这些日志发送至ElasticSearch。由于Logstash是采用jruby实现的，fatjar有20M左右，并且它进行日志处理时候会消耗较多的cpu资源，会影响到微服务节点的性能，因此一般不建议采用此方案。</li>
</ul>
<p><img alt="日志收集-elk-logstash1" src="../spring_cloud_tut/logstash1.png"/></p>
<ul>
<li>另一种方式是微服务节点上部署轻量化的日志收集器。通过日志收集器收集日志并转发至独立的Logstash节点。收集器的形式有很多种，可以直接使用Logger将日志转发给Logstash（这篇文章里我们使用这种方式），也可以使用轻量化的日志收集器Filebeat、rsyslog等。</li>
</ul>
<p><img alt="日志收集-elk-logstash2" src="../spring_cloud_tut/logstash2.png"/></p>
<h1>准备ELK环境</h1>
<p>为测试方便，我们使用Docker来运行ELK镜像，这里不直接使用ELK官方镜像。官方镜像的E L K各个组件是独立的。为了测试方便，我们使用集成了ELK三个组件的像 …</p>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="../spring-cloud-shang-shou-10-ri-zhi-shou-ji.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="../spring-cloud-shang-shou-9-fu-wu-jian-kong.html" rel="bookmark" title="Permalink to Spring Cloud 上手9-服务监控">
                                       Spring Cloud 上手9-服务监控
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../author/jamsa.html">Jamsa</a>
    </address>

    in <a href="../category/kai-fa.html">开发</a>

    on 2018-06-12

        |
        tags:         <a href="../tag/spring-cloud.html">spring cloud</a>


        |
        <a href="../spring-cloud-shang-shou-9-fu-wu-jian-kong.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>这是Spring Cloud上手系列的第九篇，代码放在<a href="https://github.com/Jamsa/sc-cloud">GitHub</a>上，随着本系列文章更新。</p>
<h1>Spring Cloud Sleuth</h1>
<p>在Spring Cloud应用中，各服务之间存在复杂的调用关系链。Spring Cloud Sleuth主要的功能就是提供服务调用链追踪功能。</p>
<p>例如，访问<code>gateway</code>的<code>/api/consumer/hello</code>端点时，会调用<code>consumer:service</code>的<code>/consumer/hello</code>端点，之后调用<code>provider:service</code>的<code>/provider/hello</code>端点。在大型系统中，这种调用关系可能会非常复杂，因此需要有机制能对整个调用链进行追踪。</p>
<p>较早提供这种追踪组件的是Google的Dapper链路跟踪组件，于2010年发表了相关论文，相关的文章是实现链路追踪的理论基础。目前，除Dapper外，还有Twitter和Zipkin，阿里的Eagleeye等。</p>
<p>Spring Cloud Sleuth中能方便的集成Zipkin …</p>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="../spring-cloud-shang-shou-9-fu-wu-jian-kong.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="../spring-cloud-shang-shou-8-xiao-xi-zong-xian.html" rel="bookmark" title="Permalink to Spring Cloud 上手8-消息总线">
                                       Spring Cloud 上手8-消息总线
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../author/jamsa.html">Jamsa</a>
    </address>

    in <a href="../category/kai-fa.html">开发</a>

    on 2018-06-11

        |
        tags:         <a href="../tag/spring-cloud.html">spring cloud</a>


        |
        <a href="../spring-cloud-shang-shou-8-xiao-xi-zong-xian.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>这是Spring Cloud上手系列的第八篇，代码放在<a href="https://github.com/Jamsa/sc-cloud">GitHub</a>上，随着本系列文章更新。</p>
<h1>Spring Cloud Bus简介</h1>
<p>Spring Cloud Bus以Spring Cloud Stream为基础，建立应用间的通讯通道。消息服务即可用于服务监控，也可以用作应用间的通讯和服务解耦。</p>
<h1>将Spring Cloud Bus用于配置中心</h1>
<p>在<a href="../spring-cloud-shang-shou-7-pei-zhi-zhong-xin.html">前一篇</a>文章的最后一节，我们通过发送POST请求至应用的<code>/refresh</code>端点，可以让应用重新获取配置。如果我们要同时更新所有节点则需要逐个应用发送请求，这样管理起来并不方便。通过集成<code>spring-cloud-starter-bus-amqp</code>可以让我们通过配置中心应用统一管理各个应用配置信息的刷新。</p>
<p>集成之后的配置刷新机制如下图：</p>
<p><img alt="配置中心-bus" src="../spring_cloud_tut/bus-config-server.png"/></p>
<p>当访问配置中心的<code>/bus/refresh</code>时，它将通过总线发送广播消息。各个客户端接收到消息后，将重新读取配置信息。这样所有配置中心客户端就都能及时获取配置信息的变化。</p>
<h2>安装消息中间件</h2>
<p>Spring Cloud Bus支持RabbitMQ和Kafka两种服务。这里我们选择RabbitMQ。安装完毕后，默认的服务端口是<code>5672</code>，默认安装会安装管理控制台 …</p>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="../spring-cloud-shang-shou-8-xiao-xi-zong-xian.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="../spring-cloud-shang-shou-7-pei-zhi-zhong-xin.html" rel="bookmark" title="Permalink to Spring Cloud 上手7-配置中心">
                                       Spring Cloud 上手7-配置中心
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../author/jamsa.html">Jamsa</a>
    </address>

    in <a href="../category/kai-fa.html">开发</a>

    on 2018-06-07

        |
        tags:         <a href="../tag/spring-cloud.html">spring cloud</a>


        |
        <a href="../spring-cloud-shang-shou-7-pei-zhi-zhong-xin.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>这是Spring Cloud上手系列的第七篇，代码放在<a href="https://github.com/Jamsa/sc-cloud">GitHub</a>上，随着本系列文章更新。</p>
<h1>概述</h1>
<p>通过Spring Cloud Config可以对各个系统的配置信息进行集中管理和维护。</p>
<p>Spring Cloud Config服务端读取git、svn或本地目录（包括classpath路径)中保存的配置信息。</p>
<p>将Spring Cloud Config服务作为Eureka客户端，则为Config Server提供高可用。Config Client程序可以通过Eureka获取Config Server的信息并读取配置。</p>
<h1>Spring Cloud Config Server配置</h1>
<h2>添加依赖</h2>
<p>Spring Config 服务相关的两个依赖是<code>org.springframework.cloud:spring-cloud-config-server</code>和<code>org.springframework.cloud:spring-cloud-config-client</code>，分别对应于配置服务的服务端和客户端。</p>
<p>我们先在根模块的<code>build.gradle</code>中添加程序库依赖。</p>
<div class="highlight"><pre><span></span><span class="c1">//依赖</span>
<span class="n">ext</span><span class="o">.</span><span class="na">libs</span> <span class="o">=</span> <span class="o">[</span>
        <span class="s2">"spring-cloud …</span></pre></div>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="../spring-cloud-shang-shou-7-pei-zhi-zhong-xin.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="../spring-cloud-shang-shou-6-fu-zai-jun-heng.html" rel="bookmark" title="Permalink to Spring Cloud 上手6-负载均衡">
                                       Spring Cloud 上手6-负载均衡
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../author/jamsa.html">Jamsa</a>
    </address>

    in <a href="../category/kai-fa.html">开发</a>

    on 2018-06-05

        |
        tags:         <a href="../tag/spring-cloud.html">spring cloud</a>


        |
        <a href="../spring-cloud-shang-shou-6-fu-zai-jun-heng.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>这是Spring Cloud上手系列的第六篇，代码放在<a href="https://github.com/Jamsa/sc-cloud">GitHub</a>上，随着本系列文章更新。</p>
<h1>Ribbon 概述</h1>
<p>Ribbon是一个客户端负载均衡器。Feign中使用到了Ribbon。Ribbon与Eureka结合使用时，Ribbon可以从Eureka注册中心中获取服务端列表。</p>
<h1>验证Feign中的负载均衡</h1>
<p>Feign包含了对Ribbon的支持，不需要编写额外的代码和配置。我们启动以下应用，来验证：</p>
<p>registry，运行在9001:</p>
<div class="highlight"><pre><span></span>java -jar registry/build/libs/sc-registry-0.0.1.jar
</pre></div>
<p>provider1，运行在9010:</p>
<div class="highlight"><pre><span></span>java -jar provider/service/build/libs/sc-provider-service-0.0.1.jar
</pre></div>
<p>provider2，运行在9012:</p>
<div class="highlight"><pre><span></span>java -Dserver.port=9012 -jar provider/service/build …</pre></div>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="../spring-cloud-shang-shou-6-fu-zai-jun-heng.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="../spring-cloud-shang-shou-5-fu-wu-wang-guan.html" rel="bookmark" title="Permalink to Spring Cloud 上手5-服务网关">
                                       Spring Cloud 上手5-服务网关
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="../author/jamsa.html">Jamsa</a>
    </address>

    in <a href="../category/kai-fa.html">开发</a>

    on 2018-06-04

        |
        tags:         <a href="../tag/spring-cloud.html">spring cloud</a>


        |
        <a href="../spring-cloud-shang-shou-5-fu-wu-wang-guan.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>这是Spring Cloud上手系列的第五篇，代码放在<a href="https://github.com/Jamsa/sc-cloud">GitHub</a>上，随着本系列文章更新。</p>
<h1>ZUUL概述</h1>
<p>服务网关是微服务中向外部系统提供REST API过程中起服务路由、负载均衡的角色。也可将权限控制等功能放在服务网关上，为微服务提供保护。</p>
<p>SpringCloud Netflix中的Zuul承担了这样的功能。它可以作为Eureka客户端与Eureka集成，实现自动的服务路由。也可以通过配置文件来调整路由的策略，对内部服务提供保护。</p>
<p>使用Zuul的典型场景是这样的：</p>
<p><img alt="Zuul服务网关" src="../spring_cloud_tut/zuul.png"/></p>
<p>外部调用通过Zuul调用内部的REST服务，通常情况下内部并不会把所有服务都暴露给外部。上图中的<code>Sercie A/B provider</code>就只是供内部调用的，<code>consumer</code>供外部系统调用的服务。</p>
<h1>使用Zuul开发服务网关</h1>
<p>在我们的示例中服务网关放在<code>gateway</code>模块中。</p>
<h2>依赖配置</h2>
<p><code>gateway</code>模块的<code>build.gradle</code>:</p>
<div class="highlight"><pre><span></span><span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">compile</span> <span class="n">libs</span><span class="o">.</span><span class="s1">'zuul'</span>
    <span class="n">compile</span> <span class="n">libs</span><span class="o">.</span><span class="s1">'eureka-client'</span>
<span class="o">}</span>

<span class="n">jar</span> <span class="o">{</span>
    <span class="n">manifest</span> <span class="o">{</span>
        <span class="n">attributes</span> <span class="s2">"Manifest-Version"</span><span class="o">:</span> <span class="mf">1 …</span></pre></div>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="../spring-cloud-shang-shou-5-fu-wu-wang-guan.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    </ol><!-- /#posts-list -->
<p class="paginator">
    Page 1 / 9
        <a href="../author/jamsa2.html">&raquo;</a>
</p>
                </section><!-- /#content -->
</div>
<div class="span3">
    <section id="sidebar">
            <div>
                <h2>Browse content by</h2>
                <ul class="fa-ul">
                <li><a href="../categories.html"><i class="fa-li fa fa-tags"></i> Categories</a></li>
                <li><a href="../archives.html"><i class="fa-li fa fa-calendar"></i> Dates</a></li>
                <li><a href="../tags.html"><i class="fa-li fa fa-tag"></i> Tags</a></li>

                </ul>
            </div><!-- /.browse -->
<!-- /.Tags -->
    </section><!-- /#sidebar -->
</div>
                </div>
            </div>
        </div>

        <footer id="site-footer">
            <div class="row-fluid">
                <div class="span10 offset1">
                    <address>
                        <p>
                        This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                        </p>
                        <p>
                            <a href="http://github.com/jsliang/pelican-fresh/">Fresh</a> is a responsive theme designed by <a href="http://jsliang.com/">jsliang</a> and <a href="https://github.com/jsliang/pelican-fresh/graphs/contributors">contributors</a>.
                        Special thanks to <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a> and <a href="http://getbootstrap.com/">Twitter Bootstrap</a>.
                        </p>
                    </address>
                </div>
            </div>
        </footer>

<script type="text/javascript">
    var disqus_shortname = 'jamsa-github-io';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
        <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>

        <link href="http://apps.bdimg.com/libs/highlight.js/9.1.0/styles/default.min.css" rel="stylesheet">
        <script src="http://apps.bdimg.com/libs/highlight.js/9.1.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script>
         var _hmt = _hmt || [];
         (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?5e20e9cdd1185d24ece1dae11118a04f";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
         })();
        </script>
</body>
</html>