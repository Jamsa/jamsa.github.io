<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="author" content="Jamsa" />
        <meta name="robots" content="index, follow"/>

        <meta property="og:title" content="Jamsa的笔记"/>
        <meta property="og:url" content="."/>
        <meta property="og:site_name" content="Jamsa的笔记"/>
        <meta property="og:type" content="website"/>

        <link rel="canonical" href="." />

        <title>Jamsa的笔记</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" />
        

        <link rel="stylesheet" type="text/css" href="./theme/css/main.css" />

        <script type="text/javascript">var switchTo5x=true;</script>
        <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
        <script type="text/javascript">
         stLight.options({
             publisher: "",
             doNotHash: false,
             doNotCopy: false,
             hashAddressBar: false
         });
        </script>
    </head>

    <body id="index">
        <div class="row-fluid">
            <div class="span10 offset1">
                <header id="banner" >
                    <h1>
                        <a href="./">Jamsa的笔记 </a>
                    </h1>
                    <nav class="navbar">
                        <div class="navbar-inner">
                            <ul class="nav">
                                <li ><a href="./category/da-shu-ju.html">大数据</a></li>
                                <li ><a href="./category/fang-fa.html">方法</a></li>
                                <li ><a href="./category/ji-qi-xue-xi.html">机器学习</a></li>
                                <li ><a href="./category/kai-fa.html">开发</a></li>
                                <li ><a href="./category/qian-duan.html">前端</a></li>
                                <li ><a href="./category/xiao-lu.html">效率</a></li>
                                <li ><a href="./category/yi-dong.html">移动</a></li>
                            </ul>

                        </div>
                    </nav>
                </header><!-- /#banner -->
            </div>
        </div>

        <div class="row-fluid">
            <div class="span10 offset1">
                <div class="row-fluid">
<div class="span9">
                <section>
                    <ol id="posts-list" class="hfeed" start="9">
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="./rustbian-liang-sheng-ming-zhou-qi-guan-li.html" rel="bookmark" title="Permalink to Rust变量生命周期管理">
                                       Rust变量生命周期管理
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-08-21

        |
        tags:         <a href="./tag/rust.html">rust</a>


        |
        <a href="./rustbian-liang-sheng-ming-zhou-qi-guan-li.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>本文是读《Rust程序设计语言第二版》生命周期相关内容的笔记。</p>
<h1>生命周期</h1>
<p>Rust生命周期用于控制变量的作用域，主要目标是避免悬垂引用。</p>
<p>以下面的代码为例</p>
<div class="highlight"><pre><span></span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"r: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>编译时会产生如下错误：</p>
<div class="highlight"><pre><span></span>error: `x` does not live long enough
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</pre></div>
<p>因为<code>x</code>变量离开作用域后会被释放，导致 …</p>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="./rustbian-liang-sheng-ming-zhou-qi-guan-li.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="./shi-yong-chocolatey-zai-win10-xia-pei-zhi-rust-kai-fa-huan-jing.html" rel="bookmark" title="Permalink to 使用 Chocolatey 在 Win10 下配置 rust 开发环境">
                                       使用 Chocolatey 在 Win10 下配置 rust 开发环境
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-07-29

        |
        tags:         <a href="./tag/rust.html">rust</a>
        <a href="./tag/chocolatey.html">chocolatey</a>
        <a href="./tag/cargo.html">cargo</a>
        <a href="./tag/msvc.html">msvc</a>
        <a href="./tag/racer.html">racer</a>


        |
        <a href="./shi-yong-chocolatey-zai-win10-xia-pei-zhi-rust-kai-fa-huan-jing.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <h1>简介</h1>
<p>最近因学习<code>rust</code>编程语言，需要在家中的 Win10 系统上安装<code>rust</code>开发环境。</p>
<p>安装的目标是在<code>vscode</code>中配合<code>racer</code>实现代码提示功能。</p>
<p>因刚开始接触<code>rust</code>对于<code>rust</code>的不同<code>channel</code>、<code>toolchain</code>及<code>racer</code>的情况都不太了解所以起了不少弯路，所以编写本文档记录下相关的过程。</p>
<p>主要参考了：</p>
<ul>
<li>
<p><a href="https://github.com/rust-lang-nursery/rustup.rs/#other-installation-methods">rustup 安装说明</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/26944087?open_source=weibo_search">Rust 开发环境指北</a></p>
</li>
<li>
<p><a href="https://github.com/racer-rust/racer">racer 安装说明</a></p>
</li>
</ul>
<p>基础概念：</p>
<ul>
<li>
<p><code>rustup</code>：是<code>rust</code>官方推荐的<code>rust</code>多版本维护工具。它的功能类似于<code>Python</code>的<code>Conda</code>或<code>pyenv</code>这类工具。</p>
</li>
<li>
<p><code>cargo</code>：是<code>rust</code>的构建工具 …</p></li></ul>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="./shi-yong-chocolatey-zai-win10-xia-pei-zhi-rust-kai-fa-huan-jing.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="./scalaji-cheng-javafan-xing-fang-fa-de-wen-ti.html" rel="bookmark" title="Permalink to Scala继承Java泛型方法的问题">
                                       Scala继承Java泛型方法的问题
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-07-23

        |
        tags:         <a href="./tag/scala.html">scala</a>
        <a href="./tag/jtv.html">jtv</a>


        |
        <a href="./scalaji-cheng-javafan-xing-fang-fa-de-wen-ti.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <h1>问题</h1>
<p>在使用Scala实现<a href="./jtvkai-fa-bi-ji-4-ke-hu-duan.html">JTV</a>客户端界面程序时，我遇到了Scala重载Java类中的泛型方法的问题。</p>
<p>因为界面上的<code>JList</code>使用了自定义的元素类型，我需要自定义<code>ListCellRender</code>来列表对象中元素行的显示。最简单的方法就是直接继承<code>DefaultListCellRenderer</code>，它会将<code>JList</code>中的数据元素渲染为<code>JLabel</code>，我只需要覆盖其<code>getListCellRendererComponent</code>实现元素转<code>JLabel</code>的逻辑即可。</p>
<p>自定义类的结构如下：</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FileRender</span> <span class="k">extends</span> <span class="nc">DefaultListCellRenderer</span><span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">getListCellRendererComponent</span><span class="o">(</span><span class="n">list</span><span class="k">:</span> <span class="kt">JList</span><span class="o">[</span><span class="k">_</span><span class="o">],</span> <span class="n">value</span><span class="k">:</span> <span class="kt">scala.Any</span><span class="o">,</span> <span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">isSelected</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">cellHasFocus</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Component</span> <span class="o">=</span> <span class="k">super</span><span class="o">.</span><span class="n">getListCellRendererComponent</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">value</span><span class="o">,</span> <span class="n">index</span><span class="o">,</span> <span class="n">isSelected</span><span class="o">,</span> <span class="n">cellHasFocus …</span></pre></div>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="./scalaji-cheng-javafan-xing-fang-fa-de-wen-ti.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="./jtvkai-fa-bi-ji-3-fu-wu-duan.html" rel="bookmark" title="Permalink to JTV开发笔记3-服务端">
                                       JTV开发笔记3-服务端
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-07-19

        |
        tags:         <a href="./tag/scala.html">scala</a>
        <a href="./tag/netty.html">netty</a>
        <a href="./tag/jtv.html">jtv</a>


        |
        <a href="./jtvkai-fa-bi-ji-3-fu-wu-duan.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>本文是<a href="https://github.com/Jamsa/jtv">Jtv</a>的开发笔记。Jtv是一个远程桌面工具。</p>
<h1>概述</h1>
<p>本文记录的是服务端的程序设计。在写完服务端和客户端程序的时候，我发现整个程序对连接的管理不太完善。于是对客户端程序进行了一次重构，采用连接对象对<code>Channel</code>和消息处理回调进行了封装。在考虑服务端程序的重构时，还没有较好的思路，暂时先用这版服务程序了。</p>
<h1>设计</h1>
<h2>功能要求</h2>
<p>服务端程序需要处理以下任务：</p>
<ol>
<li>
<p>会话和连接的管理：会话连接是个单独的连接，它处理客户端与服务端的命令交互，不参与屏幕和键盘、鼠标事件的传输。客户端进行点对点连接等操作时，由会话连接进行协调来建立点对点连接。</p>
</li>
<li>
<p>点对点消息的传输：当前这版未重构的程序是使用连接对来处理点对点的连接。在会话连接和服务程序的协助下，两个客户端之间可以建立起新的点对点连接。经点对点连接发送的消息将被直接发送到另一端，服务端不对消息进行处理。这里有当前版本可以优化的一个点，在点对点连接建立之后，<code>pipeline</code>应该可以进行动态调节，减少消息的编码和解码开销。</p>
</li>
<li>
<p>管理会话及其连接：管理会话、会话连接、点对点工作连接。在连接中断时，自动从会话的工作连接中移除。如果中断的是会话连接，则应该关闭所有与这个会话相关联的连接，关闭与这个会话中任何一个连接建立的点对点连接。</p>
</li>
</ol>
<h1>实现</h1>
<h2>会话管理</h2>
<p>服务端的会话和连接由会话管理器<code>ServerSessionManager</code>进行管理 …</p>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="./jtvkai-fa-bi-ji-3-fu-wu-duan.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="./jtvkai-fa-bi-ji-4-ke-hu-duan.html" rel="bookmark" title="Permalink to JTV开发笔记4-客户端">
                                       JTV开发笔记4-客户端
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-07-19

        |
        tags:         <a href="./tag/scala.html">scala</a>
        <a href="./tag/netty.html">netty</a>
        <a href="./tag/jtv.html">jtv</a>


        |
        <a href="./jtvkai-fa-bi-ji-4-ke-hu-duan.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>本文是<a href="https://github.com/Jamsa/jtv">Jtv</a>的开发笔记。Jtv是一个远程桌面工具。</p>
<h1>概述</h1>
<p>当前的客户端程序已经经过一轮重构。这轮重构将会话管理和控制窗口进行了分离。会话管理与主窗口关联。远程控制窗口使用自己的管理类，由这个类管理本窗口相关的连接，这样也方便后续增加同时控制多台远程机器的功能。</p>
<h1>设计</h1>
<h2>功能设计</h2>
<p>客户端程序主要处理这些任务：</p>
<ol>
<li>
<p>客户端连接管理：由<code>ConnectionFactory</code>管理连接的创建和销毁。</p>
</li>
<li>
<p>主窗口及会话管理：程序主窗口<code>MainFrame</code>，这个窗口的模型类<code>MainFrameManager</code>管理会话连接，处理登录、注销等与服务端交互的命令。</p>
</li>
<li>
<p>充当被控服务：当接收到远程控制请求时，<code>MainFrameManager</code>负责建立被控连接。被控连接建立后，启动屏幕捕捉线程。该线程按一定的频率，获取屏幕截图，并将它发送至被控连接。<code>MainFrameManager</code>的被控接收到鼠标键盘事件后，也负责处理事件的回放。由<code>MainFrameManager</code>来充当被控端，主要是考虑将来在服务端可以在被控端和控制端建立一对多的连接关系，被控方只需要发送一份屏幕截图，多个控制端都可以收到。</p>
</li>
<li>
<p>远程控制：当客户端作为控制端时，通过创建新的控制窗口<code>RemoteFrame</code>来实现对远程桌面的监控和操作。<code>RemoteFrame …</code></p></li></ol>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="./jtvkai-fa-bi-ji-4-ke-hu-duan.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="./jtvkai-fa-bi-ji-1-kai-shi.html" rel="bookmark" title="Permalink to JTV开发笔记1-开始">
                                       JTV开发笔记1-开始
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-07-17

        |
        tags:         <a href="./tag/scala.html">scala</a>
        <a href="./tag/netty.html">netty</a>
        <a href="./tag/jtv.html">jtv</a>


        |
        <a href="./jtvkai-fa-bi-ji-1-kai-shi.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>本文是<a href="https://github.com/Jamsa/jtv">Jtv</a>的开发笔记。Jtv是一个远程桌面工具。</p>
<h1>起因</h1>
<p>因为工作原因，我经常需要进行远程桌面操作。尝试过多种不同的远程桌面方案，如：QQ远程、Teamviewer、Windows远程桌面、Hamachi等等。在速度比较稳定的，且支持内网连接的工具里只有Teamviewer和QQ远程能稳定使用。切换至Mac环境后，Teamviewer就成了唯一选择，Teamviewer被判定为商业使用后，每5分钟会中断一次，无法正常使用。之间也尝试过使用ngrok配合其它内网vnc工具来进行远程连接。但这些方式都不太方便，比如使用ngrok + Windows远程桌面也能连接，但是远程桌面和VNC都无法与远程用户共享桌面。</p>
<p>由于这些原因，就有了自己开发一个简化版远程桌面工具的想法。</p>
<h1>目标</h1>
<p>仅把它当作个业余项目，近期目标是实现：以中心服务器进行交换，支持内网连接的远程桌面和控制功能。</p>
<h1>技术选型</h1>
<p>个人项目选型上比较自由，主要考虑以下几个方面：</p>
<ul>
<li>
<p>考虑到跨平台使用，选定在Java平台上。</p>
</li>
<li>
<p>利用Swing的Robot类可实现对键盘、鼠标的控制。</p>
</li>
<li>
<p>Java语言写Swing相关的内容太啰嗦，选Scala了。</p>
</li>
<li>
<p>网络通讯模块选择netty。</p>
</li>
</ul>
<p>选择的版本如下：</p>
<ul>
<li>
<p>scala 2.12.6</p>
</li>
<li>
<p>sbt 1.1 …</p></li></ul>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="./jtvkai-fa-bi-ji-1-kai-shi.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="./jtvkai-fa-bi-ji-2-wang-luo-tong-xun.html" rel="bookmark" title="Permalink to JTV开发笔记2-网络通讯">
                                       JTV开发笔记2-网络通讯
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-07-17

        |
        tags:         <a href="./tag/scala.html">scala</a>
        <a href="./tag/netty.html">netty</a>
        <a href="./tag/jtv.html">jtv</a>


        |
        <a href="./jtvkai-fa-bi-ji-2-wang-luo-tong-xun.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>本文是<a href="https://github.com/Jamsa/jtv">Jtv</a>的开发笔记。Jtv是一个远程桌面工具。</p>
<h1>协议</h1>
<p>为实现远程控制，我们需要处理两类通讯，客户端与服务器的通讯、客户端与客户端的通讯。</p>
<p>客户端与服务端的通讯主要有：</p>
<ol>
<li>
<p>登录：客户端发送登录请求后，由服务端进行认证，并分配会话ID。</p>
</li>
<li>
<p>连接申请类：客户端创建新连接，通过这个连接发送连接申请，这个连接是源连接。服务端需要将这一申请转发给目标客户端，目标客户端接收到消息后，创建新连接至服务端，这个连接是目标连接。服务端在源连接与目标连接间建立绑定关系后，两个客户端间就可以实现点对点的通讯了。</p>
</li>
</ol>
<p>客户端与客户端的通讯消息主要有以下几类：</p>
<ol>
<li>
<p>文本消息传输：如错误信息，连接关闭通知等。</p>
</li>
<li>
<p>屏幕画面消息：被控端以一定的频度获取屏幕画面，并将它传输至控制端。控制端将其绘制到控制窗口中。</p>
</li>
<li>
<p>鼠标键盘事件：控制端在控制窗口中查看被控端画面，针对该画面操作的键盘和鼠标事件需要被传递到被控端，被控端根据这些事件进行事件的回放。</p>
</li>
</ol>
<h1>消息对象</h1>
<p>为满足上述通讯要求，我们需要定义一套用于消息传输的对象。</p>
<div class="highlight"><pre><span></span><span class="c1">//消息</span>
<span class="k">sealed</span> <span class="k">trait</span> <span class="nc">JtvMessage</span>

<span class="c1">//服务端处理的会话消息</span>
<span class="k">trait</span> <span class="nc">ServerSessionMessage</span> <span class="k">extends</span> <span class="nc">JtvMessage</span>
<span class="c1">//客户端处理的会话消息</span>
<span class="k">trait …</span></pre></div>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="./jtvkai-fa-bi-ji-2-wang-luo-tong-xun.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="./spring-cloud-shang-shou-12-rong-qi-hua.html" rel="bookmark" title="Permalink to Spring Cloud 上手12-容器化">
                                       Spring Cloud 上手12-容器化
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-06-15

        |
        tags:         <a href="./tag/spring-cloud.html">spring cloud</a>
        <a href="./tag/kubernetes.html">kubernetes</a>
        <a href="./tag/docker.html">docker</a>


        |
        <a href="./spring-cloud-shang-shou-12-rong-qi-hua.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p><code>重要提示：本篇文章的目标在Edgware.SR3上并未成功</code></p>
<p>原因在于在这个版本上<code>Eureka Client</code>运行在<code>Docker</code>中时，无法以<code>Eureka Client IP</code>地址进行注册，服务消费方从注册中心获取到的是<code>Pod</code>的名称，通过此名称无法访问到服务所在的机器。例如：应用在启动时，查询到<code>sc-config</code>配置中心的主机是<code>sc-config-f54cdc656-2524j</code>这样的主机名，通过个主机名去获取配置信息将会因网络无法连接而失败，进而导致应用无法正常启动。</p>
<p>注册中心本向使用了StatefulSets进行部署，客户端是使用固定的域名进行访问的，因此没有这个问题。如果我们将其它服务都变成StatefulSets方式进行部署在<code>Edgware.SR3</code>上也许也能成功。但这样整个应用就变成了Sateful Service了，将失去动态扩容的能力。</p>
<p>问题的根源在于：即使在Eureka Server上添加<code>eureka.instance.prefer-ip-address = true</code>也不能较好解决（添加这个参数后在容器外是有效的，客户端会以IP进行注册）。</p>
<p>具体问题可参考：</p>
<p><a href="https://github.com/sparcs360/axon-demo/issues/18">axon-demo/issue …</a></p>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="./spring-cloud-shang-shou-12-rong-qi-hua.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="./spring-cloud-shang-shou-11-pei-zhi-you-hua.html" rel="bookmark" title="Permalink to Spring Cloud 上手11-配置优化">
                                       Spring Cloud 上手11-配置优化
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-06-14

        |
        tags:         <a href="./tag/spring-cloud.html">spring cloud</a>


        |
        <a href="./spring-cloud-shang-shou-11-pei-zhi-you-hua.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>这是Spring Cloud上手系列的第十一篇，代码放在<a href="https://github.com/Jamsa/sc-cloud">GitHub</a>上，随着本系列文章更新。</p>
<h1>概述</h1>
<p>本篇主要对各应用的配置进行优化，原因主要有两个：</p>
<ul>
<li>
<p>此前<a href="./spring-cloud-shang-shou-7-pei-zhi-zhong-xin.html">配置中心</a>一文中只把<code>provider:service</code>与配置中心进行了集成，其它应用仍是读取本地的配置信息。</p>
</li>
<li>
<p>写至本篇的时候，发现各个模块的配置文件已经比较乱了，存在大量重复配置，配置文件中也存在一些不需要的配置项，需要进行一轮整理。</p>
</li>
<li>
<p>增加<code>profile</code>支持为后面将容器化做准备。</p>
</li>
</ul>
<p>优化的目标：</p>
<ul>
<li>
<p>配置中心（config）和注册中心（registry）读取本地配置信息外（先有鸡还是先有蛋的问题，只能读取本地配置文件）。</p>
</li>
<li>
<p>服务网关(gateway)、服务提供者（provider:service）、服务消费者（consumer:service）、调用链分析（zipkin）应用都只保留<code>boostrap.yml</code>配置文件，且该配置文件中只保留注册中心地址、应用名称、端口等基本信息。其余配置信息移至配置中心的共享配置文件 …</p></li></ul>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="./spring-cloud-shang-shou-11-pei-zhi-you-hua.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    <li>
                        <article>
                            <header>
                                <h1 class="entry-title">
                                    <a href="./spring-cloud-shang-shou-10-ri-zhi-shou-ji.html" rel="bookmark" title="Permalink to Spring Cloud 上手10-日志收集">
                                       Spring Cloud 上手10-日志收集
                                    </a>
                                </h1>
                            </header>
                            <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-06-13

        |
        tags:         <a href="./tag/spring-cloud.html">spring cloud</a>


        |
        <a href="./spring-cloud-shang-shou-10-ri-zhi-shou-ji.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->                                <p>这是Spring Cloud上手系列的第十篇，代码放在<a href="https://github.com/Jamsa/sc-cloud">GitHub</a>上，随着本系列文章更新。</p>
<h1>ELK简介</h1>
<p>ELK是Logstash、ElasticSearch和Kibana的组合。Logstash处理日志的收集，ElasticSearch处理日志的检索，Kibana对日志进行可视化展示和查询。</p>
<p>在Spring Cloud微服务架构下可以使用ElasticSearch来存储两类信息：一类是通过Logstash收集的各个应用的日志，另一类是作为Zipkin的持久化存储。</p>
<h2>Zipkin持久化</h2>
<p>Zipkin本身支持采用ElasticSearch作为其存储引擎，它可以直接与ElasticSearch交互，将跟踪信息保存至ElasticSearch。</p>
<h2>日志收集方式</h2>
<p>微服务应用的日志则情况更复杂。ELK与Spring Cloud的集成有两种方式：</p>
<ul>
<li>一种是各个微服务节点上部署Logstash实例。微服务输出日志时，按Logstash的需要输出为json格式。Logstash则监控这些日志目录，并将这些日志发送至ElasticSearch。由于Logstash是采用jruby实现的，fatjar有20M左右，并且它进行日志处理时候会消耗较多的cpu资源，会影响到微服务节点的性能，因此一般不建议采用此方案。</li>
</ul>
<p><img alt="日志收集-elk-logstash1" src="./spring_cloud_tut/logstash1.png"/></p>
<ul>
<li>另一种方式是微服务节点上部署轻量化的日志收集器。通过日志收集器收集日志并转发至独立的Logstash节点。收集器的形式有很多种，可以直接使用Logger将日志转发给Logstash（这篇文章里我们使用这种方式），也可以使用轻量化的日志收集器Filebeat、rsyslog等。</li>
</ul>
<p><img alt="日志收集-elk-logstash2" src="./spring_cloud_tut/logstash2.png"/></p>
<h1>准备ELK环境</h1>
<p>为测试方便，我们使用Docker来运行ELK镜像，这里不直接使用ELK官方镜像。官方镜像的E L K各个组件是独立的。为了测试方便，我们使用集成了ELK三个组件的像 …</p>
                                <p class="readmore">
                                    <a class="btn btn-small btn-info" href="./spring-cloud-shang-shou-10-ri-zhi-shou-ji.html">Read more...</a>
                                </p>
                            </div><!-- /.entry-content -->
                            <hr/>
                        </article>
                    </li>
                    </ol><!-- /#posts-list -->
<p class="paginator">
    Page 1 / 10
        <a href="./index2.html">&raquo;</a>
</p>
                </section><!-- /#content -->
</div>
<div class="span3">
    <section id="sidebar">
            <div>
                <h2>Browse content by</h2>
                <ul class="fa-ul">
                <li><a href="./categories.html"><i class="fa-li fa fa-tags"></i> Categories</a></li>
                <li><a href="./archives.html"><i class="fa-li fa fa-calendar"></i> Dates</a></li>
                <li><a href="./tags.html"><i class="fa-li fa fa-tag"></i> Tags</a></li>

                </ul>
            </div><!-- /.browse -->
<!-- /.Tags -->
    </section><!-- /#sidebar -->
</div>
                </div>
            </div>
        </div>

        <footer id="site-footer">
            <div class="row-fluid">
                <div class="span10 offset1">
                    <address>
                        <p>
                        This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                        </p>
                        <p>
                            <a href="http://github.com/jsliang/pelican-fresh/">Fresh</a> is a responsive theme designed by <a href="http://jsliang.com/">jsliang</a> and <a href="https://github.com/jsliang/pelican-fresh/graphs/contributors">contributors</a>.
                        Special thanks to <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a> and <a href="http://getbootstrap.com/">Twitter Bootstrap</a>.
                        </p>
                    </address>
                </div>
            </div>
        </footer>

<script type="text/javascript">
    var disqus_shortname = 'jamsa-github-io';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
        <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>

        <link href="http://apps.bdimg.com/libs/highlight.js/9.1.0/styles/default.min.css" rel="stylesheet">
        <script src="http://apps.bdimg.com/libs/highlight.js/9.1.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script>
         var _hmt = _hmt || [];
         (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?5e20e9cdd1185d24ece1dae11118a04f";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
         })();
        </script>
</body>
</html>