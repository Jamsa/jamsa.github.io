<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="author" content="Jamsa" />
        <meta name="robots" content="index, follow"/>

        <meta property="og:title" content="Ext JS 5 手册 核心概念（三）组件"/>
        <meta property="og:url" content="./ext-js-5-shou-ce-he-xin-gai-nian-san-zu-jian.html"/>
        <meta property="og:site_name" content="Jamsa的笔记"/>
        <meta property="og:type" content="article"/>

        <link rel="canonical" href="./ext-js-5-shou-ce-he-xin-gai-nian-san-zu-jian.html" />

        <title>Ext JS 5 手册 核心概念（三）组件 | Jamsa的笔记</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" />
        

        <link rel="stylesheet" type="text/css" href="./theme/css/main.css" />

        <script type="text/javascript">var switchTo5x=true;</script>
        <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
        <script type="text/javascript">
         stLight.options({
             publisher: "",
             doNotHash: false,
             doNotCopy: false,
             hashAddressBar: false
         });
        </script>
    </head>

    <body id="index">
        <div class="row-fluid">
            <div class="span10 offset1">
                <header id="banner" >
                    <h1>
                        <a href="./">Jamsa的笔记 </a>
                    </h1>
                    <nav class="navbar">
                        <div class="navbar-inner">
                            <ul class="nav">
                                <li ><a href="./category/da-shu-ju.html">大数据</a></li>
                                <li ><a href="./category/fang-fa.html">方法</a></li>
                                <li ><a href="./category/ji-qi-xue-xi.html">机器学习</a></li>
                                <li ><a href="./category/kai-fa.html">开发</a></li>
                                <li class="active"><a href="./category/qian-duan.html">前端</a></li>
                                <li ><a href="./category/xiao-lu.html">效率</a></li>
                                <li ><a href="./category/yi-dong.html">移动</a></li>
                            </ul>

                        </div>
                    </nav>
                </header><!-- /#banner -->
            </div>
        </div>

        <div class="row-fluid">
            <div class="span10 offset1">
                <div class="row-fluid">
<div class="span10 offset1">
  <section>
    <article>
      <header>
        <h1 class="entry-title">
          <a href="./ext-js-5-shou-ce-he-xin-gai-nian-san-zu-jian.html" rel="bookmark"
             title="Permalink to Ext JS 5 手册 核心概念（三）组件">Ext JS 5 手册 核心概念（三）组件</a></h1>
      </header>
      <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/qian-duan.html">前端</a>

    on 2015-05-17

        |
        tags:         <a href="./tag/javascript.html">javascript</a>
        <a href="./tag/extjs.html">extjs</a>


        |
        <a href="./ext-js-5-shou-ce-he-xin-gai-nian-san-zu-jian.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->

        <h1>Ext JS 5 手册 核心概念（三）组件</h1>
<h2>核心概念</h2>
<h3 id="zu-jian">组件</h3>
<p>Ext JS 应用中的 UI 是由一个或多个被称为<code>组件(Components)</code>的构件组成的。所有组件都是<code>Ext.Component</code>的子类，它能自动管理组件的生命周期，如：实例化、渲染、改变大小和位置、销毁。</p>
<h4 id="zu-jian-de-ceng-ji">组件的层级</h4>
<p><code>Container</code>是一种特殊的能包含其它组件的组件。一个典型的应用是由一些树状嵌套的组件组成的，由<code>container</code>来负责管理组件和它们的子组件的生命周期，包括它们的：创建、渲染、改变大小和位置、销毁。一个典型应用的组件层级是由顶部的<code>Viewport</code>开始，它包含了其它<code>containers</code>和组件嵌套而成：
<img alt="组件层级" src="./extjs5_guide/component_heirarchy_5.png"/>
子组件通过<code>Container</code>的<code>items</code>配置属性添加到<code>Container</code>中。</p>
<p><code>Containers</code>使用布局管理器来确定子组件的大小和位置。</p>
<h4 id="xtypeshe-yan-shi-shi-li-hua">XTypes和延时实例化</h4>
<p>每个组件都有个被称为<code>xtype</code>的符号名称。比如<code>Ext.panel.Panel</code>的<code>xtype</code>是<code>panel</code>。在大型应用中，并不是所有界面上用到的组件都需要立即被实例化，某些组件在应用中可能永远都不会使用，因此不需要被实例化。这也是使用<code>xtype</code>的一个原因，它能让<code>Container</code>的子元素先进行配置，但是直到<code>Container</code>决定在必要时才进行实例化。</p>
<h4 id="xian-shi-he-yin-cang">显示和隐藏</h4>
<p>所有组件都有内置的<code>show</code>和<code>hide</code>方法。默认使用的 CSS 的<code>display:none</code>来隐藏组件，但是也可以通过<code>hideMode</code>配置属性来进行控制：</p>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">panel</span> <span class="o">=</span> <span class="nx">Ext</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="s1">'Ext.panel.Panel'</span><span class="p">,</span> <span class="p">{</span>
        <span class="nx">renderTo</span><span class="o">:</span> <span class="nx">Ext</span><span class="p">.</span><span class="nx">getBody</span><span class="p">(),</span>
        <span class="nx">title</span><span class="o">:</span> <span class="s1">'Test'</span><span class="p">,</span>
        <span class="nx">html</span><span class="o">:</span> <span class="s1">'Test Panel'</span><span class="p">,</span>
        <span class="nx">hideMode</span><span class="o">:</span> <span class="s1">'visibility'</span> <span class="c1">// 使用 CSS 的 visibility 属性来控制组件的显示和隐藏</span>
    <span class="p">});</span>

    <span class="nx">panel</span><span class="p">.</span><span class="nx">hide</span><span class="p">();</span> <span class="c1">// hide the component</span>

    <span class="nx">panel</span><span class="p">.</span><span class="nx">show</span><span class="p">();</span> <span class="c1">// show the component</span>
</pre></div>
<h4 id="fu-dong-zu-jian">浮动组件</h4>
<p>浮动组件使用了 CSS 绝对定位，不参与它所属的<code>Container</code>的布局。像<code>Window</code>这样的组件默认就是浮动的，但是任何组件都可以通过<code>floating</code>配置项被设置为浮动组件。</p>
<p>通常的组件要么具有<code>renderTo</code>配置项，要么被添加为某个<code>Container</code>的子组件，但是浮动组件不需要这样。浮动组件在初次调用<code>show</code>方法时被自动渲染到<code>body</code>中。</p>
<p>其它几个与浮动组件相关的配置项和方法：
 - <code>draggable</code> 允许组件在屏幕上拖动
 - <code>shadow</code> 自定义浮动组件的阴影效果
 - <code>alignTo()</code> 将浮动组件对齐到某个特定的元素
 - <code>center()</code> 将浮动组件定位到<code>Container</code>的中心位置</p>
<h4 id="chuang-jian-zi-ding-yi-zu-jian">创建自定义组件</h4>
<h5 id="zu-he-huo-kuo-zhan">组合或扩展</h5>
<p>创建新的 UI 类时，可以使用组合或继承<code>Component</code>的方法。</p>
<p>推荐继承功能性最接近的类。因为它能使用 Ext JS 提供的自动化生命周期管理。</p>
<h5 id="zi-lei-hua">子类化</h5>
<p><code>Ext.Base</code>是所有类型的基础，这个类的原型和静态成员被所有其它类所继承。</p>
<p>可以向这个<code>Ext.Base</code>中添加低层次的功能。</p>
<h5 id="mo-ban-fang-fa">模板方法</h5>
<p>Ext JS 使用模板方法模式将行为委派给子类，行为只对子类型有效。</p>
<p>继承链中的每个类都可以向组件的生命周期的某个阶段&ldquo;贡献&rdquo;出额外的逻辑代码。每个类都实现了特定的行为并允许继承链中的其它类&ldquo;贡献&rdquo;它们的逻辑。</p>
<p>以<code>render</code>方法为例，它是<code>Component</code>中定义的方法。它的职责是启动组件的渲染阶段。<code>render</code>不允许被覆盖，但它会调用<code>onRender</code>来允许子类添加它们自己的处理过程。每个子类在<code>onRender</code>方法中必须先调用它们的父类的<code>onRender</code>方法。</p>
<p>下面的图描述了<code>onRender</code>模板方法的运行机制。</p>
<p><code>Render</code>方法被调用时（通常由<code>Container</code>的布局管理器）。这个方法可能没有被覆盖，而是继承自<code>Ext.base</code>类。它调用当前的子类中实现的<code>this.onRender</code>（如果有）。这将调用父类型中的方法。最后，每个类中的功能都调用到了，控制权返回到render函数
<img alt="模板方法调用机制" src="./extjs5_guide/template_pattern.png"/>
以下是一个<code>Component</code>的子类实现的<code>onRender</code>方法：</p>
<div class="highlight"><pre><span></span><span class="nx">Ext</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="s1">'My.custom.Component'</span><span class="p">,</span> <span class="p">{</span>
    <span class="nx">extend</span><span class="o">:</span> <span class="s1">'Ext.Component'</span><span class="p">,</span>
    <span class="nx">onRender</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">callParent</span><span class="p">(</span><span class="nx">arguments</span><span class="p">);</span> <span class="c1">// call the superclass onRender method</span>

        <span class="c1">// perform additional rendering tasks here.</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>
<p>需要注意的是很多模板方法也有对应的事件。比如<code>render</code>事件，它在组件被渲染之后触发。当进行子类化时，必须使用模板方法在生命周期的重要阶段执行它的逻辑，而不使用事件。事件可以以编程的方式挂起，或被事件处理器停止。</p>
<p>以下是<code>Component</code>的子类型可以实现的模板方法：
 - <code>initComponent</code> 这个方法由构造器调用。它用于初始化数据，设置配置项和添加事件处理器。
 - <code>beforeShow</code> 这个方法在组件显示前被调用。
 - <code>onShow</code> 在显示操作时添加行为。在调用父类的<code>onShow</code>之后，组件将被显示。
 - <code>afterShow</code> 这个方法在组件显示后被调用。
 - <code>onShowComplete</code> 这个方法在调用调用完<code>afterShow</code>之后执行。
 - <code>onHide</code> 在隐藏操作时添加行为。在调用你类的<code>onHide</code>之后，组件将被隐藏。
 - <code>onRender</code> 在渲染阶段添加行为。
 - <code>afterRender</code> 在渲染完成之后添加行为。在这个阶段组件的 DOM 元素将按配置被设置样式，会具有任何配置了的 CSS 类名称，并且会被按配置设置为显示和启用状态。
 - <code>onEnable</code> 在启用操作时添加行为。在调用父类的<code>onEnable</code>之后，组件被启用。
 - <code>onDisable</code> 在禁用操作时添加行为。在调用父类的<code>onDisable</code>之后，组件被禁用。
 - <code>onAdded</code> 在组件被添加到<code>Container</code>时添加行为。在这个阶段，组件已经存在于父<code>Container</code>的子项集合中。在调用父类的<code>onAdded</code>之后，<code>ownerCt</code>引用将会存在，如果配置了<code>ref</code>，<code>refOwner</code>将被设置。
 - <code>onRemoved</code> 在组件从<code>Container</code>中移除时添加行为。在这个阶段，组件已经被从父<code>Container</code>中移出，但是还未被销毁（它将在父<code>Container</code>的<code>autoDestroy</code>被设置为<code>true</code>或调用<code>remove</code>时传递的第二个参数为<code>true</code>时被销毁）。在调用完父类的<code>onRemoved</code>之后，<code>ownerCt</code>和<code>refOwner</code>将不再存在。
 - <code>onResize</code> 在改变大小时添加行为。
 - <code>onPosition</code> 在改变位置时添加行为。
 - <code>onDestroy</code> 在销毁操作时添加行为。在调用父类的<code>onDestroy</code>后，组件将被销毁。
 - <code>beforeDestroy</code> 在组件被销毁前执行。
 - <code>afterSetPosition</code> 在组件的位置被设置之后执行。
 - <code>afterComponentLayout</code> 在组件被布局之后执行。
 - <code>beforeComponentLayout</code> 在组件被布局之前执行。</p>
<h5 id="ji-cheng-na-ge-lei">继承哪个类</h5>
<p>无论 UI 组件是否需要被渲染和管理，总是倾向于继承<code>Ext.panel.Panel</code>。</p>
<p><code>Panel</code>类有非常多的功能：
 - 边框
 - 头部
 - 头部工具条
 - 底部
 - 底部按钮
 - 顶部工具条
 - 底部工具条
 - 容纳和管理子组件</p>
<h6 id="component">Component</h6>
<p>如果需要的 UI 组件不需要包含其它组件，而只是一些 HTML，则继承<code>Ext.Component</code>也是合适的。</p>
<h6 id="container">Container</h6>
<p>如果需要的 UI 组件要能包含其它的组件，但是不需要<code>Panel</code>的其它功能，则可以继承<code>Ext.container.Container</code>。需要记住<code>Ext.layout.container.Container</code>用于渲染和管理子组件。</p>
<p><code>Container</code>有下列额外的模板方法：
 - <code>onBeforeAdd</code> 这个方法在添加了新的子组件时被调用。它会传递这个新的组件，以便修改这个组件，或以其它方式准备<code>Container</code>。返回<code>false</code>时将中止添加操作。
 - <code>onAdd</code> 这个方法在添加了新的组件之后执行。它将会传递这个新添加的组件。这个方法可以用于根据子组件的状态更新内部结构。
 - <code>onRemove</code> 在子组件被删除时被调用。它将传递要被删除的组件。这个方法可以用于根据子组件的状态更新内部结构。
 - <code>beforeLayout</code> 这个方法在<code>Container</code>对它的子组件进布局（和渲染）之前执行。
 - <code>afterLayout</code> 这个方法在<code>Container</code>对它的子组件进行而已（和渲染）之后执行。</p>
<h6 id="panel">Panel</h6>
<p>如果需要的 UI 组件需要头、尾或工具栏时，应该继承<code>Ext.panel.Panel</code>。</p>
<p>重点：<code>Panel</code>是一个<code>Container</code>。<code>Layout</code>是用于渲染和管理子组件的。</p>
<p>继承<code>Ext.panel.Panel</code>是应用中经常使用的，用于将 UI 组件进行布局的类，并能使用<code>tbar</code>和<code>bbar</code>来提供操作。</p>
<p><code>Panel</code>有以下额外的模板方法：
 - <code>afterCollapse</code> 这个方法在<code>Panel</code>收缩时被调用。
 - <code>afterExpand</code> 这个方法在<code>Panel</code>展开时被调用。
 - <code>onDockedAdd</code> 这个方法在<code>Docked</code>项添加到<code>Panel</code>上后被调用。
 - <code>onDockedRemove</code> 这个方法在<code>Docked</code>项从<code>Panel</code>上删除后被调用。</p>

      </div><!-- /.entry-content -->
      <div class="comments">
        <h2>Comments</h2>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          var disqus_identifier = "ext-js-5-shou-ce-he-xin-gai-nian-san-zu-jian.html";
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//jamsa-github-io.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
      </div>

    </article>
  </section>
</div>
                </div>
            </div>
        </div>

        <footer id="site-footer">
            <div class="row-fluid">
                <div class="span10 offset1">
                    <address>
                        <p>
                        This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                        </p>
                        <p>
                            <a href="http://github.com/jsliang/pelican-fresh/">Fresh</a> is a responsive theme designed by <a href="http://jsliang.com/">jsliang</a> and <a href="https://github.com/jsliang/pelican-fresh/graphs/contributors">contributors</a>.
                        Special thanks to <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a> and <a href="http://getbootstrap.com/">Twitter Bootstrap</a>.
                        </p>
                    </address>
                </div>
            </div>
        </footer>

<script type="text/javascript">
    var disqus_shortname = 'jamsa-github-io';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
        <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>

        <link href="http://apps.bdimg.com/libs/highlight.js/9.1.0/styles/default.min.css" rel="stylesheet">
        <script src="http://apps.bdimg.com/libs/highlight.js/9.1.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>