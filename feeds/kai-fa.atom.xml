<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jamsa的笔记 - 开发</title><link href="/" rel="alternate"></link><link href="/feeds/kai-fa.atom.xml" rel="self"></link><id>/</id><updated>2015-06-29T00:00:00+08:00</updated><entry><title>Begin Mac Programming 笔记</title><link href="/begin-mac-programming-bi-ji.html" rel="alternate"></link><published>2015-06-29T00:00:00+08:00</published><updated>2015-06-29T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-06-29:/begin-mac-programming-bi-ji.html</id><summary type="html">&lt;h1&gt;关于对象&lt;/h1&gt;
&lt;h2&gt;Objective-C 中的对象类型&lt;/h2&gt;
&lt;p&gt;Mac中使用苹果公司的的Cocoa框架。在Xcode中创建类都继承于NSObject这个基类。&lt;/p&gt;
&lt;p&gt;当我们在Objective-c中实例化一个对象后，它立即会发送一个消息来初始化自己。这个消息被称为&lt;code&gt;init&lt;/code&gt;，它通设置初始值。&lt;/p&gt;
&lt;p&gt;类定义包括&lt;code&gt;.h&lt;/code&gt;和&lt;code&gt;.m&lt;/code&gt;两个文件。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.h&lt;/code&gt;文件结构：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//  NotifyingClass.h&lt;/span&gt;
&lt;span class="c1"&gt;//  TextApp&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//  Created by Tim Isted on 08/09/2009.&lt;/span&gt;
&lt;span class="c1"&gt;//  Copyright 2009 __MyCompanyName__. All rights reserved.&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="cp"&gt;#import &amp;lt;Cocoa/Cocoa.h&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="nc"&gt;NotifyingClass&lt;/span&gt; : &lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Objective-c中，使用某个类具有某个&lt;code&gt;public interface&lt;/code&gt;来描述哪些消息能发送给这个类。&lt;code&gt;@interface&lt;/code&gt;这一行的冒号后面指定这个类的父类，这里指向的是NSObject …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;关于对象&lt;/h1&gt;
&lt;h2&gt;Objective-C 中的对象类型&lt;/h2&gt;
&lt;p&gt;Mac中使用苹果公司的的Cocoa框架。在Xcode中创建类都继承于NSObject这个基类。&lt;/p&gt;
&lt;p&gt;当我们在Objective-c中实例化一个对象后，它立即会发送一个消息来初始化自己。这个消息被称为&lt;code&gt;init&lt;/code&gt;，它通设置初始值。&lt;/p&gt;
&lt;p&gt;类定义包括&lt;code&gt;.h&lt;/code&gt;和&lt;code&gt;.m&lt;/code&gt;两个文件。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.h&lt;/code&gt;文件结构：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//  NotifyingClass.h&lt;/span&gt;
&lt;span class="c1"&gt;//  TextApp&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//  Created by Tim Isted on 08/09/2009.&lt;/span&gt;
&lt;span class="c1"&gt;//  Copyright 2009 __MyCompanyName__. All rights reserved.&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="cp"&gt;#import &amp;lt;Cocoa/Cocoa.h&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="nc"&gt;NotifyingClass&lt;/span&gt; : &lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Objective-c中，使用某个类具有某个&lt;code&gt;public interface&lt;/code&gt;来描述哪些消息能发送给这个类。&lt;code&gt;@interface&lt;/code&gt;这一行的冒号后面指定这个类的父类，这里指向的是NSObject，它是Cocoa框架的基类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@interface&lt;/code&gt;段中的大括号用于指定类的属性。&lt;/p&gt;
&lt;p&gt;右大括号和&lt;code&gt;@end&lt;/code&gt;间的内容用于指定类可以接收的消息。&lt;/p&gt;
&lt;p&gt;定义Interface的语法结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="nc"&gt;nameOfClass&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;nameOfClassToInheritFrom&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;messages&lt;/span&gt; &lt;span class="n"&gt;responded&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;

&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;code&gt;.m&lt;/code&gt;文件结构：&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.m&lt;/code&gt;文件包含对象的实现。编写的方法放在&lt;code&gt;@implementation&lt;/code&gt;和&lt;code&gt;@end&lt;/code&gt;之间。&lt;/p&gt;
&lt;p&gt;用于响应&lt;code&gt;init&lt;/code&gt;消息的初始化方法默认会调用NSObject基类中的实现。通过查看&lt;code&gt;NSObject.h&lt;/code&gt;可以找到它定义的初始化消息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;NSLog日志类&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@implementation&lt;/span&gt; &lt;span class="nc"&gt;NotifyingClass&lt;/span&gt;

&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Hello World! I'm a new NotifyingClass instance!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;消息机制&lt;/h1&gt;
&lt;h2&gt;消息的定义：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;allocWithZone:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSZone&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;zone&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;messageName&lt;/span&gt; &lt;span class="err"&gt;&amp;raquo;&lt;/span&gt; &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt;或&lt;code&gt;-&lt;/code&gt;用于标明它是一个类方法或是实例方法。&lt;code&gt;&amp;laquo;word&amp;raquo;&lt;/code&gt;指定方法的返回类型。在&lt;code&gt;.h&lt;/code&gt;中的方法签名列表中，可以看到使用&lt;code&gt;void&lt;/code&gt;或&lt;code&gt;id&lt;/code&gt;作为返回类型。&lt;/p&gt;
&lt;h2&gt;Target-Action机制&lt;/h2&gt;
&lt;p&gt;某些由Cocoa框架提供的对象允许你为他们提供&lt;code&gt;target&lt;/code&gt;对象和指定&lt;code&gt;action&lt;/code&gt;&amp;mdash;&amp;mdash;发送给这个对象的消息。比如，在Xcode的界面设计器中创建NSButton实例后，我们可以指定这个按钮被点击时调用NotifyingClass实例（&lt;code&gt;target&lt;/code&gt;）的displaySomeText方法（&lt;code&gt;action&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;如果消息名称的右边有冒号，表明它接收一个或多个参数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;buildHouse:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;House&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;houseToBeBuilt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;括号中内容（House*）用于指定参数类型，括号后面是参数名称。&lt;/p&gt;
&lt;h2&gt;发送消息&lt;/h2&gt;
&lt;p&gt;方法调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;displaySomeText:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;sender&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"displaySomeText just got called!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;变量与内存&lt;/h1&gt;
&lt;p&gt;类似C的变量指针。&lt;/p&gt;
&lt;h1&gt;对象和内存管理&lt;/h1&gt;
&lt;h2&gt;对象内存分配&lt;/h2&gt;
&lt;p&gt;NSObject提供了类方法&lt;code&gt;alloc&lt;/code&gt;用于分配内存。永远不需要重载这个方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;someNewObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将分配一块足够容纳NSObject实例的内存并将这块内存的地址返回给someNewObject指针。&lt;code&gt;alloc&lt;/code&gt;方法将所有实例变量设置为零或nil（指针类型），但它不会进行更进一步的『设置』。在使用对象前应该先初始化它的属性。&lt;/p&gt;
&lt;h3 id="dui-xiang-chu-shi-hua"&gt;对象初始化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Hello world~"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应该在使用对象前对它的属性进行初始化，因此应该在分配内存后立即调用&lt;code&gt;init&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;我们应该合并内存分配和初始化代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;NotifyingClass&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myFavoriteNotifier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;NotifyingClass&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我们嵌套的调用了&lt;code&gt;alloc&lt;/code&gt;和&lt;code&gt;init&lt;/code&gt;方法，因此需要让&lt;code&gt;init&lt;/code&gt;方法返回初始化后的对象地址，并传递给指针。&lt;/p&gt;
&lt;p&gt;继承时的初始化：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当从NSObject继承时，不需要调用父类的&lt;code&gt;init&lt;/code&gt;方法，因为NSObject不做任何的初始化，&lt;code&gt;isa&lt;/code&gt;实例变量是在&lt;code&gt;alloc&lt;/code&gt;中设置的。考虑到后期有可能修改父类型，比较好的实践方法是始终调用&lt;code&gt;[super init]&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;在代码中创建对象&lt;/h2&gt;
&lt;h3 id="fen-pei-nei-cun"&gt;分配内存&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;displaySomeText:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;sender&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;wonderfulValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;storedNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;
        &lt;span class="nl"&gt;stringWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"My Wonderful Value = %f&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wonderfulValue&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中存在问题，通过查看NSObject文档中关于『Creating, Copying, and Deallocating Objects.』相关的内容，能找到NSObject有&lt;code&gt;``dealloc&lt;/code&gt;方法。文档中指出，『永远不要直接发送&lt;code&gt;dealloc&lt;/code&gt;消息』。应该使用"release" NSObject protocol方法。&lt;/p&gt;
&lt;p&gt;当对象从内存中删除时它会接收到&lt;code&gt;dealloc&lt;/code&gt;消息。&lt;/p&gt;
&lt;p&gt;可以在类的&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;dealloc&lt;/code&gt;中输出日志，查看释放情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@implementation&lt;/span&gt; &lt;span class="nc"&gt;WonderfulNumber&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;storedNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"A WonderfulNumber object was initialized!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;dealloc&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"A WonderfulNumber object was deallocated!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;dealloc&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;setStoredNumber:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;newNumber&lt;/span&gt;
&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;continues&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回到之前displaySomeText的代码。添加上述日志后，再执行时会发现&lt;code&gt;dealloc&lt;/code&gt;中的日志未被输出。myWonderfulNumber未被释放，会产生内存泄漏。&lt;/p&gt;
&lt;p&gt;因此，我们需要某种方法来标明某个对象不再需要使用，可以被释放掉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;需要重申的是，苹果建议永远不要直接调用&lt;code&gt;dealloc&lt;/code&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;对象的生命周期&lt;/h2&gt;
&lt;h3 id="yin-yong-ji-shu"&gt;引用计数&lt;/h3&gt;
&lt;p&gt;假设某个程序需要在屏幕上显示一个数字。当点击菜单上的一个选项时，会创建一个WonderfulNumber对象，并将它显示在窗口中。用户可以打开多个窗口，每次新窗口将显示WonderfulNumber中数字。当所有窗口都被关闭时WonderfulNumber对象才不再被需要。&lt;/p&gt;
&lt;p&gt;我们可能需要在创建WonderfulNumber代码的结尾处调用&lt;code&gt;removeYourselfFromMemory&lt;/code&gt;方法。但是问题是我们不知道它被多少个其它的对象所需要。&lt;/p&gt;
&lt;p&gt;我们需要某种方法来跟踪有多少个对象对这个实例『感兴趣』。&lt;/p&gt;
&lt;h4 id="yin-yong-ji-shu-de-jie-shao"&gt;引用计数的介绍&lt;/h4&gt;
&lt;p&gt;Cocoa框架使用了『引用计数』来处理这个问题。这项技术允许对象声明它们对某个对象感兴趣或不再对它感兴趣。&lt;/p&gt;
&lt;p&gt;如果objectA要声明它对objectB感兴趣，objectA向objectB发送&lt;code&gt;retain&lt;/code&gt;。当objectA决定不再需要objectB时，它向objectB发送&lt;code&gt;release&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;引用计数是通过在每个对象上维护一个&lt;code&gt;retain count&lt;/code&gt;来工作的。在对象上调用&lt;code&gt;retain&lt;/code&gt;后，计数加1，调用&lt;code&gt;releas&lt;/code&gt;后，计数减1。当对象的引用计数为0时，它将自动从内存中释放。&lt;/p&gt;
&lt;p&gt;比如前面提到的每个新窗口都显示那个WonderfulNumber对象，这些窗口都retain这个WonderfulNumber对象。任何一个窗口关闭时，窗口都release对象。当所有窗口都关闭时，引用计数为0，WonderFulNumber对象被释放。&lt;/p&gt;
&lt;h4 id="nei-cun-fen-pei-hou-de-yin-yong-ji-shu"&gt;内存分配后的引用计数&lt;/h4&gt;
&lt;p&gt;因为引用计数为0时，对象会被释放。因此在对象分配内存后，它的计数初始为1。当我们编写下面这行代码时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它不只是为对象分配了内存，同样它声明了我们对这个对象感兴趣，因此我们不需要显式的retain这个对象。&lt;/p&gt;
&lt;p&gt;从另一个角度来看，使用了&lt;code&gt;alloc&lt;/code&gt;来创建对象，就表示我们『同意』对它『负责』。即我们同意当我们不需要使用它时会&lt;code&gt;release&lt;/code&gt;它。&lt;/p&gt;
&lt;p&gt;因此完整的代码应该是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;displaySomeText:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;sender&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="nl"&gt;setStoredNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;wonderfulValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;storedNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;
        &lt;span class="nl"&gt;stringWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"My Wonderful Value = %f&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wonderfulValue&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;拒绝对内存管理负责&lt;/h2&gt;
&lt;p&gt;上节提到需要对创建的对象负责。但在某些情况下『对对象负责的责任』并不是非常清析。&lt;/p&gt;
&lt;p&gt;比如，在类的方法中返回字符串指针时，这个类并不应该对字符串对象的最终释放负责。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;storedNumberAsString&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stringToReturn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                     &lt;span class="nl"&gt;initWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"%f"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;storedNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;stringToReturn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法分配并初始化了一个新的的字符串并在方法结束的地方返回了这个字符串。在这里应该要意识到我们分配了新的对象但是并没有释放它&amp;mdash;&amp;mdash;我们没有对我们创建的对象完全负责。&lt;/p&gt;
&lt;p&gt;如果我们在返回对象前使用&lt;code&gt;[stringToReturn relaase]&lt;/code&gt;释放它，那么它会立即被释放掉，方法的返回值将是个无效的对象。&lt;/p&gt;
&lt;p&gt;我们也不希望在其它使用了&lt;code&gt;storedNumberAsString&lt;/code&gt;这类方法的地方使用&lt;code&gt;release&lt;/code&gt;&amp;mdash;&amp;mdash;除非我们调用了&lt;code&gt;alloc] init]&lt;/code&gt;或&lt;code&gt;retain&lt;/code&gt;，否则我们不需要调用&lt;code&gt;release&lt;/code&gt;，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="nl"&gt;setStoredNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;storedNumberAsString&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;numberString&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Uh-oh!&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上在的代码并不是个好主意，我们需要的效果是提供某种机制使得使用WonderfulNumber对象的人总是会释放他们通过&lt;code&gt;storedNumberAsString&lt;/code&gt;所得到的字符串。&lt;/p&gt;
&lt;p&gt;我们需要某种方法将对象传递到其它地方，明确的解除我们对它的内存管理『责任』。&lt;/p&gt;
&lt;h3 id="autorelease_1"&gt;autorelease&lt;/h3&gt;
&lt;p&gt;Cocoa提供了&lt;code&gt;autoreleasing&lt;/code&gt;机制来处理这种情况。&lt;/p&gt;
&lt;p&gt;通过在对象上调用&lt;code&gt;autorelease&lt;/code&gt;而不是&lt;code&gt;release&lt;/code&gt;，我们可以将对象的&lt;code&gt;release&lt;/code&gt;延时至下一个事件循环。即它在当前执行的代码上会一直存在。一旦程序代码执行完毕，应用程序等侍用户输入时，这个对象就会被&lt;code&gt;release&lt;/code&gt;。如果此时它的引用计数为0，则它被释放。&lt;/p&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//WonderfulNumber.m&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;storedNumberAsString&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stringToReturn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                     &lt;span class="nl"&gt;initWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"%f"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;storedNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stringToReturn&lt;/span&gt; &lt;span class="n"&gt;autorelease&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//NotifyingClass.m&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;displaySomeText:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;sender&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="nl"&gt;setStoredNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;storedNumberAsString&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里在WonderfulNumber对象创建之后，我们创建了一个指向字符串对象的指针&lt;code&gt;numberString&lt;/code&gt;，并把它插入了textViewer中。&lt;/p&gt;
&lt;p&gt;我们只需要对&lt;code&gt;myWonderfulNumber&lt;/code&gt;对象调用&lt;code&gt;release&lt;/code&gt;，因为它是在这方法中唯一一个使用&lt;code&gt;alloc&lt;/code&gt;分配出来的对象。当&lt;code&gt;displaySomeText&lt;/code&gt;方法结束后，&lt;code&gt;numberString&lt;/code&gt;指针将不再处于作用范围，由于这里是当前的事件响应代码的『最后一行』，因此这个由&lt;code&gt;storedNumberAsString&lt;/code&gt;所返回的字符串对象将在随后被释放（下一事件循环）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;我的思考：autorelease的运行方式：执行autorelease时标记在下一事件循环中，需要对该对象进行release。当进入下一次事件循环后，先对这一对象进行release，发现引用计数为0时，进行释放。这样也能保证在当前这次事件循环中&lt;code&gt;[textView insertText&lt;/code&gt;执行时，对象仍然存在&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;对象初始化参数&lt;/h2&gt;
&lt;p&gt;类似于NSString中的&lt;code&gt;initWithFormat&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;通过提供支持参数的&lt;code&gt;init&lt;/code&gt;方法来初始化对象的属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;initWithNumber:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;newNumber&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;storedNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNumber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Object was initialized!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以编写下面这样支持初始化参数的代码了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;displaySomeText:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;sender&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;storedNumberAsString&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何避免用户直接调用&lt;code&gt;[[WonderfulNumber alloc] init]&lt;/code&gt;而不提供初始化参数呢？我们可以在&lt;code&gt;init&lt;/code&gt;中提供某些默认值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@implementation&lt;/span&gt; &lt;span class="nc"&gt;WonderfulNumber&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;initWithNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;initWithNumber:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;newNumber&lt;/span&gt;
&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;continues&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;工具类类方法&lt;/h2&gt;
&lt;p&gt;在NSString中定义了很多类方法，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;stringWithFormat:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;localizedStringWithFormat:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;stringWithCharacters:length:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;stringWithString:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这此工具方法可以直接在NSString类上调用，它们会返回一个初始化过的对象。使用这些方法的好处在于它们的返回值都是&lt;code&gt;autorelease&lt;/code&gt;的。这意味着你可以不使用&lt;code&gt;alloc&lt;/code&gt;来创建NSString的实例而不需要对它调用&lt;code&gt;release&lt;/code&gt;。因为这些方法返回的是一个已经构建好的对象，因此它们经常被称为&lt;code&gt;factory&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;因此我们可以用这个方法来简化我们的&lt;code&gt;storedNumberAsString&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;storedNumberAsString&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stringToReturn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="nl"&gt;stringWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"%f"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;storedNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;stringToReturn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为NSString的类方法返回的是一个已经&lt;code&gt;autorelease&lt;/code&gt;的字符串对象，因此我们不需要在返回前再对它调用&lt;code&gt;autorelease&lt;/code&gt;了。&lt;/p&gt;
&lt;h3 id="bian-xie-zi-ji-de-lei-gong-han-fang-fa"&gt;编写自己的类工厂方法&lt;/h3&gt;
&lt;p&gt;遵循习惯性约定，工厂方法的命名一般按下面的格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;laquo;objectType&amp;raquo;With&amp;laquo;optional arguments:&amp;raquo;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WonderfulNumber的工厂方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;wonderfulNumberWithFloat:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;newNumber&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numberToReturn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                             &lt;span class="nl"&gt;initWithNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;newNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;numberToReturn&lt;/span&gt; &lt;span class="n"&gt;autorelease&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="lei-fang-fa-zhong-de-self"&gt;类方法中的&lt;code&gt;self&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;考虑到将来WonderfulNumber类可能会存在子类型EvenMoreWonderfulNumber。子类型会继承父类型的方法，当调用`[EvenMoreWonderfulNumber wonderfulNumberWithFloat:55.4]时，它将会返回一个新的WonderfulNumber类型的对象，而不是EvenMoreWonderfulNumber类型的对象。&lt;/p&gt;
&lt;p&gt;为了确保这个方法返回正确的类型我们需要将方法修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;wonderfulNumberWithFloat:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;newNumber&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;numberToReturn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;newNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;numberToReturn&lt;/span&gt; &lt;span class="n"&gt;autorelease&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类方法中的&lt;code&gt;self&lt;/code&gt;关键字指向的是类本身，而不是类的实例。这里返回的类型是&lt;code&gt;id&lt;/code&gt;类型的，工厂方法基本上都是返回这一类型，这是因为我们不希望在工厂方法中对类型进行硬编码。&lt;/p&gt;
&lt;h3 id="he-shi-shi-yong-alloche-shi-shi-yong-gong-han-fang-fa"&gt;何时使用&lt;code&gt;alloc&lt;/code&gt;，何时使用工厂方法&lt;/h3&gt;
&lt;p&gt;到目前为止似乎总是应该使用工厂方法。&lt;/p&gt;
&lt;p&gt;但是有时我们会需要一个对象在内存中保留一段时间，在当前事件循环结束后能继续存在。比如，A对象的某个实例变量指向了B对象，在A对象的生命周期中它都需要B对象存在。那么我们应该在A对象的&lt;code&gt;init&lt;/code&gt;方法中使用B对象的&lt;code&gt;alloc] init]&lt;/code&gt;方法来初始化它，并在A对象的&lt;code&gt;dealloc&lt;/code&gt;方法中&lt;code&gt;release&lt;/code&gt;这个实例。&lt;/p&gt;
&lt;h1&gt;集合&lt;/h1&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;Cocoa提供了&lt;code&gt;NSArray&lt;/code&gt;类。它的常用初始化方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithArray:&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithArray:copyItems:&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithContentsOfFile:&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithContentsOfURL:&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithObjects:&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithObjects:count:&lt;/span&gt;
&lt;span class="c1"&gt;//工厂方法&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;array&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithArray:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithContentsOfFile:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithContentsOfURL:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithObject:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithObjects:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithObjects:count:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以认为类方法只是调用实例方法并返回一个autorelease的数组。&lt;/p&gt;
&lt;h3 id="xiang-fang-fa-chuan-di-duo-ge-can-shu"&gt;向方法传递多个参数&lt;/h3&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;personWithFirstName:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;firstName&lt;/span&gt; &lt;span class="nf"&gt;lastName:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;Person&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;somebody&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt; &lt;span class="nl"&gt;personWithFirstName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Jane"&lt;/span&gt; &lt;span class="nl"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Doe"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个工厂方法的名称为&lt;code&gt;personWithFirstName:lastName:&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;NSArray的&lt;code&gt;arrayWithObjects&lt;/code&gt;可以接收多个参数，但它并不是&lt;code&gt;arrayWithObject1:object2:object3:&lt;/code&gt;，因为它需要接收任意数量的对象。&lt;/p&gt;
&lt;p&gt;Objective-C支持可变长度参数，只需要在调用时在最后一个参数的后面提供一个&lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;arrayWithObjects:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;firstObj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Milk"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Eggs"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;thirdObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Butter"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="nl"&gt;arrayWithObjects&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;secondObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;thirdObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="nl"&gt;stringWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"shoppingListArray = %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//%@用于显示数组&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

 &lt;span class="n"&gt;stringToOutput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt;
           &lt;span class="nl"&gt;stringByAppendingString&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt;
                                      &lt;span class="nl"&gt;componentsJoinedByString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@", "&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;&lt;span class="c1"&gt;//拼接数组&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shu-zu-yuan-su-suo-yin"&gt;数组元素索引&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt;
        &lt;span class="nl"&gt;stringByAppendingString&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="nl"&gt;objectAtIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;&lt;span class="c1"&gt;//第二个元素&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;indexOfObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="nl"&gt;indexOfObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//元素索引&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Objective-C中数组索引是从0开始的。&lt;/p&gt;
&lt;h3 id="shu-zu-yuan-su-shu-liang"&gt;数组元素数量&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;nmberOfItems&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;对象可变性&lt;/h2&gt;
&lt;p&gt;NSString和NSArray都是不可变对象。&lt;/p&gt;
&lt;p&gt;NSString类的&lt;code&gt;stringByAppendingString&lt;/code&gt;不是修改已有的字符串，而是返回一个包含旧内容和新内容的字符串。&lt;/p&gt;
&lt;p&gt;NSArray提供了类似的方法&lt;code&gt;arrayByAddingObject&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="ke-bian-de-shu-zu-he-zi-fu-chuan"&gt;可变的数组和字符串&lt;/h3&gt;
&lt;p&gt;如果一个对象是可变(&lt;code&gt;mutable&lt;/code&gt;)的，则它的内容可以动态的修改。&lt;/p&gt;
&lt;p&gt;Cocoa提供了多个可变类，它们是是基于不可变类型的。如：NSMutableString、NSMutableArray等。&lt;/p&gt;
&lt;p&gt;NSMutableArray提供了额外的方法，如&lt;code&gt;addObject&lt;/code&gt;或&lt;code&gt;insertObject:atIndex:&lt;/code&gt;等可以在数组的中间位置插入新元素。也提供了对应的方法从数组中删除元素。&lt;/p&gt;
&lt;p&gt;创建NSMutableArray对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSMutableArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;changingArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSMutableArray&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// changingArray is currently an empty array&lt;/span&gt;
&lt;span class="c1"&gt;// calling [changingArray count] at this point would return 0&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"The first string"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;changingArray&lt;/span&gt; &lt;span class="nl"&gt;addObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"The second string"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;changingArray&lt;/span&gt; &lt;span class="nl"&gt;addObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shu-zu-de-xiao-lu"&gt;数组的效率&lt;/h3&gt;
&lt;p&gt;如果知道最终要保存在数组中的元素数量，我们可以使用&lt;code&gt;initWithCapacity&lt;/code&gt;或&lt;code&gt;arrayWithCapacity&lt;/code&gt;工厂方法来初始化数组。这样在存储元素时速度会更快。超出初始容量时，仍然可以存储，效率比在初始容量中存储差一些。&lt;/p&gt;
&lt;p&gt;这是因为在没有能容纳所有元素的大块内存或我们在原始容量之外添加添加新元素时，数组对象会需要跟踪多个内存块来维护它所保存的对象指针。&lt;/p&gt;
&lt;h3 id="xiu-gai-shu-zu-yuan-su-nei-rong"&gt;修改数组元素内容&lt;/h3&gt;
&lt;p&gt;NSArray数组虽然是不可变的，但它的元素内容是可变的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Milk"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Eggs"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fixedArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="nl"&gt;arrayWithObjects&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;secondObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Bread"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Contents of Array = %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fixedArray&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码输出的内容是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Contents of Array = (
    Milk,
Eggs )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Contents of Array = (
    Milk,
Bread )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是因为数组会&lt;code&gt;retain&lt;/code&gt;添加到其中的元素。当给&lt;code&gt;secondObject&lt;/code&gt;重新赋值时，是让它指向一个新的内存地址，之前它与数组元素所指向的内存地址相同，重新赋值后，它指向了一个新地址，这对于数组里的内容没有影响。&lt;/p&gt;
&lt;p&gt;如果我们在不可变数组中保存可变字符串，那么数组元素中的内容仍然是可以修改的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSMutableString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSMutableString&lt;/span&gt; &lt;span class="nl"&gt;stringWithString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Milk"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="bp"&gt;NSMutableString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSMutableString&lt;/span&gt; &lt;span class="nl"&gt;stringWithString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Eggs"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fixedArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="nl"&gt;arrayWithObjects&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;secondObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="nl"&gt;setString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Bread"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Contents of Array = %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fixedArray&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Contents&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Array&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;Milk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;Bread&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式虽然可以修改数组元素的内容，但是并不能向数组中添加、删除元素。&lt;/p&gt;
&lt;h3 id="zi-fu-chuan-de-gao-ji-te-xing"&gt;字符串的高级特性&lt;/h3&gt;
&lt;p&gt;构建NSString时使用的&lt;code&gt;@"string"&lt;/code&gt;格式与上面的代码是等效的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="nl"&gt;stringWithCString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;"this is a C string"&lt;/span&gt; &lt;span class="nl"&gt;encoding&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="tian-jia-shu-zu-yuan-su"&gt;添加数组元素&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;typedValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textField&lt;/span&gt; &lt;span class="n"&gt;stringValue&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="nl"&gt;arrayByAddingObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;typedValue&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建新应用&lt;/h2&gt;</content><category term="objective-c"></category><category term="mac"></category></entry><entry><title>C Primer Plus 笔记</title><link href="/c-primer-plus-bi-ji.html" rel="alternate"></link><published>2015-06-29T00:00:00+08:00</published><updated>2015-06-29T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-06-29:/c-primer-plus-bi-ji.html</id><summary type="html">&lt;h1&gt;C Primer Plus 笔记&lt;/h1&gt;
&lt;h2&gt;起步&lt;/h2&gt;
&lt;h3 id="biao-zhun"&gt;标准&lt;/h3&gt;
&lt;p&gt;C89 标准是由 1983 年由 ANSI 起草，于 1989 年被正式接受，它定义了语言和标准 C 程序库。C99 标准是 ISO于 1990 年制定的。ISO 和 ANSI 的标准在本质上是相同的。通常说的 ANSI C 就是指的 ANSI 版本。
C99 标准在 1994 年开始制定，目标是在原有 C90 基础上保持语言小而简单。在三个方面对它进行增强：
 1. 添加了对国际化字符集的处理。
 2. 修复明显的不足（如，64 位处理器）
 3. 数值计算方面的增强 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;C Primer Plus 笔记&lt;/h1&gt;
&lt;h2&gt;起步&lt;/h2&gt;
&lt;h3 id="biao-zhun"&gt;标准&lt;/h3&gt;
&lt;p&gt;C89 标准是由 1983 年由 ANSI 起草，于 1989 年被正式接受，它定义了语言和标准 C 程序库。C99 标准是 ISO于 1990 年制定的。ISO 和 ANSI 的标准在本质上是相同的。通常说的 ANSI C 就是指的 ANSI 版本。
C99 标准在 1994 年开始制定，目标是在原有 C90 基础上保持语言小而简单。在三个方面对它进行增强：
 1. 添加了对国际化字符集的处理。
 2. 修复明显的不足（如，64 位处理器）
 3. 数值计算方面的增强（代替 FORTRAN ）
C11 标准是在 2007 年提出的，最初叫 C1X。在 C11 中标准委员会考虑到 C99 并未像 C90 那样广泛会厂商支持，因此 C99 中的一些内容在 C11 中变成了可选功能。&lt;/p&gt;
&lt;h3 id="bian-cheng"&gt;编程&lt;/h3&gt;
&lt;p&gt;C 实现将编写过程分为编译和链接两步。编译器将代码转换为中间代码，链接器将它与其它代码组合成执行文件。C 使用这两部分来实现程序的模块化。&lt;/p&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;h3 id="guan-yu-han-shu-shen-ming"&gt;关于函数申明&lt;/h3&gt;
&lt;p&gt;C90 标准中中添加了原型，旧编译器可能不识别。原型申明对于编译器来说是个特殊的函数，称为&lt;strong&gt;函数申明&lt;/strong&gt;。它需要指定函数的所有属性。
旧的 C 在函数申明时有更多的限制，只能指定返回值，不能说明参数。C90，C99 和 C11 编译器能识别这一写法但会指出不要再使用它。
C 标准推荐提供所有函数的原型。&lt;/p&gt;
&lt;h3 id="cheng-xu-zhuang-tai"&gt;程序状态&lt;/h3&gt;
&lt;p&gt;简单来说就是在程序某个时间点上所有变量的值的集合。它是当前计算状态的快照&lt;/p&gt;
&lt;h3 id="guan-jian-zi"&gt;关键字&lt;/h3&gt;
&lt;p&gt;C99 增加的关键字：
&lt;code&gt;signed, const, enum, volatile&lt;/code&gt;
C11 增加的关键字：
&lt;code&gt;inline, _Alignas, _Alignof, _Bool, _Complex, _Generic, _Imaginary, _Noreturn, _Static_Assert, #_Thread_local&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;C 中的数据&lt;/h2&gt;
&lt;h3 id="shu-ju-lei-xing"&gt;数据类型&lt;/h3&gt;
&lt;p&gt;bit, Byte, Word 中 byte 通常是计算机的内存单元。word 是特定计算机平台上内存的自然单位。比如 16 位机器，就是 word 为 16 位。&lt;/p&gt;
&lt;p&gt;浮点数与数学上的实数对应。在机器中表示为分数和它的指数两部分。因此对浮点数进行某些数学操作时（如减去一个较大的数）会丢失精度。浮点数不可能表示所有的数字，因此它会取近似值。比如将 7.0 存储为 6.99999。浮点操作也比整数操作慢。&lt;/p&gt;
&lt;h3 id="ji-chu-lei-xing"&gt;基础类型&lt;/h3&gt;
&lt;h4 id="zheng-shu-lei-xing"&gt;整数类型&lt;/h4&gt;
&lt;p&gt;C 提供了多种整数类型
 1. int 为表示有符号整数。
 2. short int 或称 short
 3. long int 或称 long
 4. long long int 或称 long long (C99)，最少为 64 位。
 5. unsigned int 或称 unsigned 用于非负整数
 6. unsigned long int 或称 unsigned long。unsigned short int 或称 unsigned short 都来自于 C90 标准。C99 还添加了 unsigned long long int 或称 unsigned long long。
 7. . signed 关键字可以显式的用于前面的那些类型。&lt;/p&gt;
&lt;p&gt;这么多的整数类型，C 只保证 short 不会比 int 长，long 不会比 int 短。对于当前的 PC，通常认为 long long 为 64 位，long 为 32 位，short 为 16 位，int 为 16 或 32位，这依赖于具体的机器的 word 长度。
在 printf 中使用 &lt;code&gt;%u&lt;/code&gt;打印 unsigned int，&lt;code&gt;%hd%&lt;/code&gt;打印 long，&lt;code&gt;%ld&lt;/code&gt;打印 long long。&lt;/p&gt;
&lt;h4 id="zi-fu-xing"&gt;字符型&lt;/h4&gt;
&lt;p&gt;char 用于存储字符，但在技术上来说存的是整数。用数字来描述某个字符。标准 ASCII 代码用 0 至 127 表示。这个范围用 7 位就够了，char 类型通常定义为一个内存单元大小（8-bit）。很多字符集用 127 或 255 不够表示。Unicode 可以描述超过 110000 个字符。ISO/IEC 开发的 10646 与 unicode 字符集兼容。
C 将 byte 定义为 char 使用的 bit 数量，因此有 16-bit 或 32-bit 的 char 类型。&lt;/p&gt;
&lt;p&gt;Signed 和 Unsigned char，分别用 -128 至 127 或 0 至 255 表示 char，需要查看编译器手册或检查 limits.h 来了解你的编译器所使用的类型。C90 标准中允许使用 signed char 或 unsigned char。&lt;/p&gt;
&lt;h4 id="_bool-xing"&gt;_Bool 型&lt;/h4&gt;
&lt;p&gt;C99 中添加的类型，可以为 true 或 false。由于 C 中使用 1 作为 true，0 作为 false，因此 _Bool 类型实际上只是整型。&lt;/p&gt;
&lt;h4 id="ke-yi-zhi-lei-xing-stdinth-he-inttypesh"&gt;可移植类型：stdint.h 和 inttypes.h&lt;/h4&gt;
&lt;p&gt;C 提供了非常多的整数类型。同一个名称在不同平台上可能代表的含义不同。C99 中为不同平台的名称定义了统一的含义，定义在 stdint.h 中。比如，int32_t 表示 32 位有符号整数。
为避免某些平台不支持明确的整数宽度（比如指定为 32 位），C99 和 C11 提供了另一种类型的名称。这套名称保证提供的满足需要的最小类型，这些类型被称为&lt;em&gt;最小宽度类型&lt;/em&gt;。比如，&lt;code&gt;int_least8_t&lt;/code&gt;能提供保存 8 位整数的类型。如果在 16 位系统上，&lt;code&gt;int8_t&lt;/code&gt;类型可能没有定义。但是，&lt;code&gt;int_least8_t&lt;/code&gt;类型将是可用的，有可能它会使用一个 16 位的整数。
有些程序员可能会更关心速度而不是空间。对他们来说，C99 和 C11 中定义了鼍一套用于快速计算的类型。这些类型被称为&lt;em&gt;快速最小宽度类型&lt;/em&gt;。比如&lt;code&gt;int_fast8_t&lt;/code&gt;定义了用于代替整数的提供最快计算速度的的 8 位无符号值。
最后，对于一些程序员来说，最大的&lt;/p&gt;</content><category term="c"></category></entry><entry><title>Learing Go 笔记</title><link href="/learing-go-bi-ji.html" rel="alternate"></link><published>2015-06-05T00:00:00+08:00</published><updated>2015-06-05T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-06-05:/learing-go-bi-ji.html</id><summary type="html">&lt;h1&gt;Learing Go 笔记&lt;/h1&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;h3 id="chi-xian-wen-dang"&gt;离线文档&lt;/h3&gt;
&lt;p&gt;Go自带&lt;code&gt;godoc&lt;/code&gt;用于查看程序模块的文档。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;godoc &lt;span class="nb"&gt;builtin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="hello-world"&gt;Hello World&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* 这行是必须的，所有 Go 文件都必须以 package 开头，对于可单独运行的程序来说，package main 是必须的 */&lt;/span&gt;
&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;"fmt"&lt;/span&gt; &lt;span class="c1"&gt;//导入 fmt 包&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="c1"&gt;//可执行程序入口函数&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello, world; or 汉字"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bian-liang-lei-xing-he-guan-jian-zi"&gt;变量、类型和关键字&lt;/h3&gt;
&lt;p&gt;Go 使用类似 C 的语法，行结尾不需要分号，同一行放两个以上语句需要用分号隔开。Go 的变量类型放在变量名后面。如不写作&lt;code&gt;int …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Learing Go 笔记&lt;/h1&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;h3 id="chi-xian-wen-dang"&gt;离线文档&lt;/h3&gt;
&lt;p&gt;Go自带&lt;code&gt;godoc&lt;/code&gt;用于查看程序模块的文档。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;godoc &lt;span class="nb"&gt;builtin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="hello-world"&gt;Hello World&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* 这行是必须的，所有 Go 文件都必须以 package 开头，对于可单独运行的程序来说，package main 是必须的 */&lt;/span&gt;
&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;"fmt"&lt;/span&gt; &lt;span class="c1"&gt;//导入 fmt 包&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="c1"&gt;//可执行程序入口函数&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello, world; or 汉字"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bian-liang-lei-xing-he-guan-jian-zi"&gt;变量、类型和关键字&lt;/h3&gt;
&lt;p&gt;Go 使用类似 C 的语法，行结尾不需要分号，同一行放两个以上语句需要用分号隔开。Go 的变量类型放在变量名后面。如不写作&lt;code&gt;int a&lt;/code&gt;而应该写作&lt;code&gt;a int&lt;/code&gt;。声明变量时，变量就被赋予了这种类型的&amp;ldquo;自然&amp;rdquo;空值。如&lt;code&gt;var a int&lt;/code&gt;，&lt;code&gt;a&lt;/code&gt;值为&lt;code&gt;0&lt;/code&gt;。&lt;code&gt;var a string&lt;/code&gt;，&lt;code&gt;a&lt;/code&gt;值为&lt;code&gt;""&lt;/code&gt;。也可以将变量的声明和赋值合并为一步：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与下面的写法是同等的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以同时声明多个变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;和&lt;code&gt;import&lt;/code&gt;也支持这种写法。声明多个变量时还可以使用&lt;code&gt;var x, y int&lt;/code&gt;，并且还可以同时赋值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下划线&lt;code&gt;_&lt;/code&gt;是个特殊的变量，任何赋给它的值都将被丢弃&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;申明却未使用的变量在 Go 中是编译错误。&lt;/p&gt;
&lt;h4 id="bu-er-xing"&gt;布尔型&lt;/h4&gt;
&lt;p&gt;布尔值由常量&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;描述，类型为&lt;code&gt;bool&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="shu-zhi-lei-xing"&gt;数值类型&lt;/h4&gt;
&lt;p&gt;Go 有如&lt;code&gt;int&lt;/code&gt;的数值类型。这些类型的长度与机器相关，32 位机器上它是 32 位的，64 位机器上是 64 位的。int 只有 32 位或 64 位，没有其它的定义。&lt;code&gt;uint&lt;/code&gt;也是同样的情况。
如果想使用明确的长度，也可以使用&lt;code&gt;int32&lt;/code&gt;或&lt;code&gt;uint32&lt;/code&gt;。可用的整数类型列表：&lt;code&gt;int8, int16, int32, int64, byte, uint8, uint16, uint32, uint64&lt;/code&gt;。&lt;code&gt;byte&lt;/code&gt;是&lt;code&gt;uint8&lt;/code&gt;的别名。没有&lt;code&gt;float&lt;/code&gt;类型，只有&lt;code&gt;float32, float64&lt;/code&gt;。
所有这些类型的赋值是严格检查的，混合使用这些类型会产生编译错误。&lt;/p&gt;
&lt;h4 id="chang-liang"&gt;常量&lt;/h4&gt;
&lt;p&gt;Go 中的常量在编译时创建，只允许是数值、字符串或布尔型。可以使用&lt;code&gt;iota&lt;/code&gt;建立枚举值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;iota&lt;/span&gt;
    &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;iota&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行&lt;code&gt;iota&lt;/code&gt;产生的值为&lt;code&gt;0&lt;/code&gt;，每行增加&lt;code&gt;1&lt;/code&gt;。甚至可以让 Go 自己重复&lt;code&gt;iota&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;iota&lt;/span&gt;
    &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="c1"&gt;//隐式的 b = iota&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="zi-fu-chuan"&gt;字符串&lt;/h4&gt;
&lt;p&gt;Go 中的字符串是用双引号包括的 UTF-8 字符串。单引号中的是 UTF-8 字符，而不是字符串。
字符串是不可变的。如果希望像 C 中那样以数组的方式操作字符串，则需要使用&lt;code&gt;rune&lt;/code&gt;，它能将字符串转化为数组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;
&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="nb"&gt;rune&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'c'&lt;/span&gt;
&lt;span class="nx"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="duo-xing-zi-fu-chuan"&gt;多行字符串&lt;/h4&gt;
&lt;p&gt;由于 Go 会自动在行末插入分号，因此需要小心使用多行字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;"Starting part"&lt;/span&gt;       &lt;span class="c1"&gt;//;&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;"Ending part"&lt;/span&gt;         &lt;span class="c1"&gt;//;&lt;/span&gt;
&lt;span class="nx"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;"Starting part"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;     &lt;span class="c1"&gt;//不会添加;&lt;/span&gt;
      &lt;span class="s"&gt;"Ending part"&lt;/span&gt;         &lt;span class="c1"&gt;//;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;s1 写法是错误的。
另一种方法是使用反引号：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;`Starting part&lt;/span&gt;
&lt;span class="s"&gt;    Ending part`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要注意这种写法包含了反引号之间的所有字符（换行 ）。&lt;/p&gt;
&lt;h4 id="rune"&gt;Rune&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Rune&lt;/code&gt;是&lt;code&gt;int32&lt;/code&gt;的别名。它是一个 UTF-8 编码的指针。可以用于遍历字符串中的单个字符。&lt;/p&gt;
&lt;h4 id="fu-shu"&gt;复数&lt;/h4&gt;
&lt;p&gt;Go 原生支持复数类型。对应的类型是&lt;code&gt;complex128&lt;/code&gt;（64 位实部和 64 位虚部）或&lt;code&gt;complex64&lt;/code&gt;（32 位实部和 32 位虚部）。复数写作&lt;code&gt;re + imi&lt;/code&gt;，&lt;code&gt;re&lt;/code&gt;是实部，&lt;code&gt;im&lt;/code&gt;是虚部：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;complex64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;5i&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Value is: %v"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="cuo-wu"&gt;错误&lt;/h4&gt;
&lt;p&gt;Go 内置了错误类型。&lt;code&gt;var e error&lt;/code&gt;创建了一个&lt;code&gt;error&lt;/code&gt;类型的变量&lt;code&gt;e&lt;/code&gt;，它的值为&lt;code&gt;nil&lt;/code&gt;。&lt;code&gt;error&lt;/code&gt;类型是一个接口。&lt;/p&gt;
&lt;h3 id="cao-zuo-fu-he-nei-zhi-han-shu_1"&gt;操作符和内置函数&lt;/h3&gt;
&lt;p&gt;Go 支持通常的数值操作符。
Go 不支持操作符重载（或方法重载），但是一些内置的操作符是被重载过的。如：&lt;code&gt;+&lt;/code&gt;可以用于整数、浮点、复数和字符串。&lt;/p&gt;
&lt;h3 id="guan-jian-zi"&gt;关键字&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func&lt;/code&gt;定义函数
&lt;code&gt;return&lt;/code&gt;从函数中返回
&lt;code&gt;go&lt;/code&gt;用于并发编程
&lt;code&gt;select&lt;/code&gt;用于选择不同类型的通讯
&lt;code&gt;interface&lt;/code&gt;
&lt;code&gt;struct&lt;/code&gt;用于定义类型
&lt;code&gt;type&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="kong-zhi-jie-gou"&gt;控制结构&lt;/h3&gt;
&lt;p&gt;Go 的控制结构比较少。比如只有&lt;code&gt;for&lt;/code&gt;是用于循环。&lt;code&gt;switch&lt;/code&gt;和&lt;code&gt;if&lt;/code&gt;都能像&lt;code&gt;for&lt;/code&gt;一样接收初始化语句。另外还有被称为&lt;code&gt;type switch&lt;/code&gt;和&lt;code&gt;multiway communications multiplexer(多路通信多路复用器)&lt;/code&gt;的&lt;code&gt;select&lt;/code&gt;。语法与&lt;code&gt;C&lt;/code&gt;也有些不同，括号不是必需的，并且左括花号不换行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// { 是必需的，且不能放到下一行&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;y&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;switch&lt;/code&gt;支持初始化语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;Chmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8664&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//err的作用域被限制在 if 的 body 区&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="goto"&gt;Goto&lt;/h3&gt;
&lt;p&gt;Go 有&lt;code&gt;goto&lt;/code&gt;语句，它能跳转到当前函数范围内的&lt;code&gt;label&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="for"&gt;For&lt;/h3&gt;
&lt;p&gt;Go 的&lt;code&gt;for&lt;/code&gt;循环有三种形式，只有一种带分号：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;post&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  &lt;span class="c1"&gt;//类似 C 中的 for&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;//类似 while&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;//无限循环&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Go 没有逗号操作符，&lt;code&gt;++&lt;/code&gt;和&lt;code&gt;--&lt;/code&gt;是语句不是表达式，如果你想要在&lt;code&gt;for&lt;/code&gt;中使用多个变量就要使用并行赋值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="break-he-continue"&gt;Break 和 continue&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;break&lt;/code&gt;可以退出当前循环。也可以用于跳转到指定的标签位置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;J&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="nx"&gt;J&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nb"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;continue&lt;/code&gt;可以立即开始下一次循环。&lt;/p&gt;
&lt;h3 id="range"&gt;Range&lt;/h3&gt;
&lt;p&gt;关键字&lt;code&gt;range&lt;/code&gt;可以用于循环。它可以用于&lt;code&gt;slices, array, strings, maps, channel&lt;/code&gt;的循环。&lt;code&gt;range&lt;/code&gt;是个迭代器，调用它时，它将返回它迭代对象的下一个键值对。
当对&lt;code&gt;slice&lt;/code&gt;和&lt;code&gt;array&lt;/code&gt;循环时&lt;code&gt;range&lt;/code&gt;返回&lt;code&gt;slice&lt;/code&gt;的&lt;code&gt;index&lt;/code&gt;和对应位置的值。
也可以直接在字符串上使用&lt;code&gt;range&lt;/code&gt;。它将解析 UTF-8 字符串并返回单个 Unicode 字符和它的位置。&lt;/p&gt;
&lt;h3 id="switch"&gt;Switch&lt;/h3&gt;
&lt;p&gt;Go 的&lt;code&gt;switch&lt;/code&gt;非常具有弹性。表达式不需要是常量甚至不需要是整数；&lt;code&gt;case&lt;/code&gt;从上至下求值，直到找到一个匹配。因此可以使用它编写一个&lt;code&gt;if-else-if-else&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;unhex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;byte&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'0'&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;'9'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;'0'&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'a'&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;'f'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;'a'&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'A'&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;'F'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;'A'&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用&lt;code&gt;default&lt;/code&gt;匹配未能匹配的情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;case&lt;/code&gt;可以是逗号分隔的列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;shouldEscape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;' '&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'?'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'&amp;amp;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'='&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'+'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="nei-zhi-han-shu"&gt;内置函数&lt;/h3&gt;
&lt;p&gt;内置函数不需要包含其它的包。
 - &lt;code&gt;close&lt;/code&gt;：用于&lt;code&gt;channel&lt;/code&gt;通讯中关闭&lt;code&gt;channel&lt;/code&gt;。
 - &lt;code&gt;delete&lt;/code&gt;：用于从&lt;code&gt;map&lt;/code&gt;中删除一个元素。
 - &lt;code&gt;len&lt;/code&gt;和&lt;code&gt;cap&lt;/code&gt;：被用于多种不同的类型，&lt;code&gt;len&lt;/code&gt;用于返回字符串&lt;code&gt;slice&lt;/code&gt;和数组类型的长度。
 - &lt;code&gt;new&lt;/code&gt;：用于为用户定义的数据类型分配内存。
 - &lt;code&gt;make&lt;/code&gt;：用于为内置类型（&lt;code&gt;map, slice, channel&lt;/code&gt;）分配内存。
 - &lt;code&gt;copy&lt;/code&gt;：用于复制&lt;code&gt;slice&lt;/code&gt;。
 - &lt;code&gt;append&lt;/code&gt;：用于拼接&lt;code&gt;slice&lt;/code&gt;。
 - &lt;code&gt;panic&lt;/code&gt;和&lt;code&gt;recover&lt;/code&gt;：用于异常机制。
 - &lt;code&gt;print&lt;/code&gt;和&lt;code&gt;println&lt;/code&gt;：低层次的打印函数可以不依赖于&lt;code&gt;fmt&lt;/code&gt;包使用。主要用于调试。
 - &lt;code&gt;complex, real, img&lt;/code&gt;：用于处理得数类型。&lt;/p&gt;
&lt;h3 id="array-slice-he-map"&gt;Array, slice 和 map&lt;/h3&gt;
&lt;h4 id="array"&gt;Array&lt;/h4&gt;
&lt;p&gt;定义为：&lt;code&gt;[n]&amp;lt;type&amp;gt;&lt;/code&gt;，&lt;code&gt;n&lt;/code&gt;是数组的长度，&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;是数组元素的类型。数组的大小是它的类型的一部分，不能增长。数组是值：将一个数组赋值给另一个将会复制所有元素。如果将它传递给函数，函数接收到的将是数组的副本，而不是指针。
定义数组时可以将：&lt;code&gt;a := [3]int{1,2,3}&lt;/code&gt;写作&lt;code&gt;a := [...]int{1,2,3}&lt;/code&gt;，Go 会自动计数。
所有字段都必须指定，因此如果定义多维数组将会是如下的结构：
&lt;code&gt;a := [2][2]int{ [2]int{1,2}, [2]int{3,4}}&lt;/code&gt;或写作&lt;code&gt;a := [2][2]int{ [...]int{1,2}, [...]int{3,4}}&lt;/code&gt;声明数组时总是会需要在方括号中输入数字或三个点。
定义 Array，slice 和 map 的表达方式已经被简化了：
&lt;code&gt;a := [2][2]int{ {1,2}, {3,4}}&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="slice"&gt;Slice&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Slice&lt;/code&gt;与&lt;code&gt;Array&lt;/code&gt;类似，但它可以添加元素。&lt;code&gt;slice&lt;/code&gt;总是指向它内部的&lt;code&gt;array&lt;/code&gt;。&lt;code&gt;slice&lt;/code&gt;与是指向&lt;code&gt;array&lt;/code&gt;的指针；&lt;code&gt;slice&lt;/code&gt;是引用类型，将一个 slice 赋值给另一个 slice 时，两者指向同一个内部&lt;code&gt;array&lt;/code&gt;。
&lt;code&gt;s1 := make([]int ,10)&lt;/code&gt;创建了一个可以保存 10 个元素的&lt;code&gt;slice&lt;/code&gt;。&lt;code&gt;slice := array[0:n]&lt;/code&gt;从 array 中创建&lt;code&gt;slice&lt;/code&gt;。&lt;code&gt;len(array) == cap(array) == m&lt;/code&gt;。
使用&lt;code&gt;[I:J]&lt;/code&gt;语法可以从&lt;code&gt;array&lt;/code&gt;或&lt;code&gt;slice&lt;/code&gt;中创建新的&lt;code&gt;slice&lt;/code&gt;，包含从 I 至 J 的元素，长度为 J - I。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nx"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nx"&gt;s3&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[:]&lt;/span&gt;
&lt;span class="nx"&gt;s4&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nx"&gt;s5&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;[:]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;超出容量时会产生运行时错误。
使用&lt;code&gt;append&lt;/code&gt;和&lt;code&gt;copy&lt;/code&gt;可以扩展&lt;code&gt;slice&lt;/code&gt;的元素。使用&lt;code&gt;append&lt;/code&gt;向&lt;code&gt;slice&lt;/code&gt;中添加0个或多个值到&lt;code&gt;slice&lt;/code&gt;中将返回如果结果&lt;code&gt;slice&lt;/code&gt; 的容量不够则会重新分配一块足够大的&lt;code&gt;slice&lt;/code&gt;存放原有&lt;code&gt;slice&lt;/code&gt;和新的元素。因此，返回的&lt;code&gt;slice&lt;/code&gt;内部的数组有可能不是原来的数组。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;s0&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;s3&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;20.&lt;/span&gt;&lt;span class="p"&gt;..)&lt;/span&gt;     &lt;span class="c1"&gt;//s3 == []int{0,0,2,3,5,7,0,0}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;copy&lt;/code&gt;函数将源&lt;code&gt;slice&lt;/code&gt;中的元素复制到目标&lt;code&gt;slice&lt;/code&gt;，并返回复制的元素个数。源和目标可以重叠。可复制的数量是&lt;code&gt;len(src)&lt;/code&gt;和&lt;code&gt;len(dst)&lt;/code&gt;的最小值。&lt;/p&gt;
&lt;h4 id="map"&gt;Map&lt;/h4&gt;
&lt;p&gt;声明方式：&lt;code&gt;map[&amp;lt;from type&amp;gt;]&amp;lt;to type&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;monthdays&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="kd"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;"Jan"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Feb"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Mar"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Apr"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"May"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Jun"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Jul"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Aug"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Sep"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Oct"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Nov"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Dec"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="c1"&gt;//需要这个逗号&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;make&lt;/code&gt;定义&lt;code&gt;map&lt;/code&gt;：&lt;code&gt;monthdays := make(map[string]int)&lt;/code&gt;。
使用方括号定位元素：&lt;code&gt;fmt.Printf("%d\n", somedays["Dec"])&lt;/code&gt;
遍历 map 中的元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;year&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;days&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="nx"&gt;monthdays&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//key 未使用，因此是 _&lt;/span&gt;
    &lt;span class="nx"&gt;year&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nx"&gt;days&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加元素：&lt;code&gt;monthdays["Undecim"] = 30&lt;/code&gt;，测试检测元素是否存在：&lt;code&gt;value,present = monthdays["Jane"]&lt;/code&gt;，如果存在，则&lt;code&gt;present&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;。
删除元素：&lt;code&gt;delete(monthdays, "Mar")&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;函数&lt;/h2&gt;
&lt;p&gt;函数声明的格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;mytype&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="nx"&gt;mytype&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;funcname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;q&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nx"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;func&lt;/code&gt;：关键字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p mtype&lt;/code&gt;：函数可以被绑定到指定的类型上。它被称为接收者（&lt;code&gt;receiver&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;funcname&lt;/code&gt;：函数名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q int&lt;/code&gt;：函数参数声明。参数是值传递的，会被复制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r,s int&lt;/code&gt;：返回值类型声明。函数可以返回多个值。可以不给出具体名称，只声明类型。只有一个返回值时外部可以不加括号。没有返回值时，可以完全省略掉这个部分。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return 0,0&lt;/code&gt;：函数体。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数声明不需要是有序的。编译器会扫描整个文件，不需要先声明函数原型。&lt;/p&gt;
&lt;h3 id="zuo-yong-yu_1"&gt;作用域&lt;/h3&gt;
&lt;p&gt;定义在函数外的变量是全局变量。定义在函数内的是局部变量。如果名称相同，局部变量会隐藏局部变量。&lt;/p&gt;
&lt;h3 id="duo-zhi-fan-hui"&gt;多值返回&lt;/h3&gt;
&lt;h3 id="ming-ming-de-fan-hui-can-shu"&gt;命名的返回参数&lt;/h3&gt;
&lt;p&gt;在函数内可以像使用变量一样使用命名的返回参数。当命名了返回参数时，它们会在函数开始时被初始化为对应类型的零值。如果函数执行没有参数的&lt;code&gt;return&lt;/code&gt;语句，则命名名返回参数的当前值会被返回。
命名并不是必须的，但它可以让代码变得简短清晰。&lt;/p&gt;
&lt;h3 id="yan-shi-zhi-xing-de-dai-ma-deferred-code"&gt;延时执行的代码（Deferred code）&lt;/h3&gt;
&lt;p&gt;Go 中的&lt;code&gt;defer&lt;/code&gt;语句可以指定一个函数，该函数在当前函数退出之前执行。利用它可以编写以下代码，该代码能保证文件在函数退出前被关闭掉：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;ReadWrite&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"file"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//将 file.Close() 添加到 defer list&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;failureX&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;    &lt;span class="c1"&gt;//Close() 会被调用&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;failureY&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;    &lt;span class="c1"&gt;//在这里执行&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;         &lt;span class="c1"&gt;//在这里执行&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以将多个函数添加到&lt;code&gt;deferred list&lt;/code&gt;中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;延时执行函数按&lt;code&gt;LIFO&lt;/code&gt;执行。因此上面的代码将输出：4，3，2，1，0。
甚至可以在延时执行函数中修改返函数的返回值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="nx"&gt;ret&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;ret&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;         &lt;span class="c1"&gt;//括号是必须的&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="c1"&gt;//实际将返回1。&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ke-bian-chang-du-can-shu-variadic-parameters"&gt;可变长度参数（Variadic parameters）&lt;/h3&gt;
&lt;p&gt;声明方式：&lt;code&gt;func myfunc(arg ...int) {}&lt;/code&gt;
在函数内部这些参数是一个&lt;code&gt;slice&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="nx"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"And the number is: %d\n"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不指定可变长度参数的类型，它默认为空接口&lt;code&gt;interface{}&lt;/code&gt;。参数传递：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arg&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;myfunc2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arg&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;myfunc2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="han-shu-zuo-wei-zhi"&gt;函数作为值&lt;/h3&gt;
&lt;p&gt;函数也是值，可以被赋值给变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="nb"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;fmt.Printf("%T\n",a)&lt;/code&gt;来显示&lt;code&gt;a&lt;/code&gt;的类型，它将显示为&lt;code&gt;func()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="hui-diao"&gt;回调&lt;/h3&gt;
&lt;p&gt;因为函数也是值，因此它们也可以作为回调函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;printit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%v\n"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//打印出结果&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="panic-and-recovering"&gt;Panic and recovering&lt;/h3&gt;
&lt;p&gt;Go 没有这机制。它提供了&lt;code&gt;panic-and-recover&lt;/code&gt;机制。应该将它作为最后的手段。&lt;/p&gt;
&lt;h4 id="panic"&gt;Panic&lt;/h4&gt;
&lt;p&gt;它是一个用于停止处理流程并进行&lt;code&gt;panicking&lt;/code&gt;的内置函数。当函数&lt;code&gt;F&lt;/code&gt;调用&lt;code&gt;panic&lt;/code&gt;时，执行过程被停止，延时执行函数（deferred function）被正常执行。&lt;code&gt;F&lt;/code&gt;将返回。对于调用者来说&lt;code&gt;F&lt;/code&gt;的行为就像是在调用&lt;code&gt;panic&lt;/code&gt;函数。这个过程会在调用栈上持续，超越到当前&lt;code&gt;goroutine&lt;/code&gt;返回，在这个时候程序崩溃。&lt;/p&gt;
&lt;h4 id="recover"&gt;Recover&lt;/h4&gt;
&lt;p&gt;内置函数&lt;code&gt;recover&lt;/code&gt;将获取到&lt;code&gt;panicking goroutine&lt;/code&gt;控制权。Recover 只在 deferred 函数内有效。
在正常执行过程中，调用&lt;code&gt;recover&lt;/code&gt;将不产生任何效果，并返回&lt;code&gt;nil&lt;/code&gt;。如果当前&lt;code&gt;goroutine&lt;/code&gt;处于&lt;code&gt;panicking&lt;/code&gt;状态，调用&lt;code&gt;recover&lt;/code&gt;将会捕获到传递给&lt;code&gt;panic&lt;/code&gt;的值并恢复正常执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;throwsPanic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;//参数f是有可能产生 panic 的函数&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;recover&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;//在defer中检查是否产生了 panic&lt;/span&gt;
            &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;                    &lt;span class="c1"&gt;//产生 panic 时修改返回值&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;包&lt;/h2&gt;
&lt;p&gt;包是函数和数据的集合。文件名可以与包名不同。通常包名用小写字符。包可能会包含多个文件，它们共享相同的名称。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;even&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;Env&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;      &lt;span class="c1"&gt;//可导出函数&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;odd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;      &lt;span class="c1"&gt;//私有函数&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大写开头的函数是可导出的，小写开头的函数是私有函数。&lt;/p&gt;
&lt;h3 id="biao-shi-fu_1"&gt;标识符&lt;/h3&gt;
&lt;h4 id="bao-ming"&gt;包名&lt;/h4&gt;
&lt;p&gt;包名应该是简单的小写单词；不要使用下划线或混合大小写。导入时可以重命名&lt;code&gt;import bar "bytes"&lt;/code&gt;。
包名是基于它的源码目录的；位于&lt;code&gt;src/pkg/compress/gzip&lt;/code&gt;使用&lt;code&gt;compress/gzip&lt;/code&gt;来导入，但是使用时的名称是&lt;code&gt;bzip&lt;/code&gt;而不是&lt;code&gt;compress_gzip&lt;/code&gt;或&lt;code&gt;compressGzip&lt;/code&gt;。
导入的包需要使用名称来引用它的内容，因此包中的导出名称可以避免重复。比如&lt;code&gt;bufio&lt;/code&gt;中的&lt;code&gt;Reader&lt;/code&gt;，不需要称为&lt;code&gt;BufReader&lt;/code&gt;，因为用户必须使用&lt;code&gt;bufio.Reader&lt;/code&gt;来引用它。
Go 使用&lt;code&gt;MizedCaps, mixedCaps&lt;/code&gt;格式而不推荐使用下划线分隔多个单词。&lt;/p&gt;
&lt;h4 id="bao-wen-dang"&gt;包文档&lt;/h4&gt;
&lt;p&gt;每个包都应该包含包注释，包注释放在包语句的前面。包含多个文件的包，包注释应该只在一个文件中存在。包注释应该介绍并提供整个包的信息。它将会出现在&lt;code&gt;godoc&lt;/code&gt;的最前面。
每个定义（被导出）的函数应该有一行简单短的注释对其进行说明。&lt;/p&gt;
&lt;h3 id="ce-shi-bao_1"&gt;测试包&lt;/h3&gt;
&lt;p&gt;测试文件保存在包目录中，并且命名为&lt;code&gt;*_test.go&lt;/code&gt;，测试文件与其它 Go 程序一样，但是&lt;code&gt;go test&lt;/code&gt;只会执行这些测试函数。每个测试函数都有相同的签名，并且名称都是以&lt;code&gt;Test&lt;/code&gt;开头：&lt;code&gt;func TestXxx(t *testing.T)&lt;/code&gt;测试成功的函数只需要返回即可，测试失败时可以用下面的函数通知&lt;code&gt;go test&lt;/code&gt;：
 - &lt;code&gt;func (t *T) Fail()&lt;/code&gt;：标明测试函数失败，但继续执行。
 - &lt;code&gt;func (t *T) FailNow()&lt;/code&gt;：标明测试函数失败并停止执行，同一文件中的其它测试被跳过，然后继续执行下一个测试。
 - &lt;code&gt;func (t *T) Log(args ...interface{})&lt;/code&gt;：以类似&lt;code&gt;Print()&lt;/code&gt;的方式格式化它的参数，并记录错误日志。
 - &lt;code&gt;func (t *T) Fatal(args ...interface{})&lt;/code&gt;：等效于在&lt;code&gt;Log()&lt;/code&gt;后执行&lt;code&gt;FailNow()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;even&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;"testing"&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;TestEven&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;testing&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt; &lt;span class="nx"&gt;Even&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"2 should be even!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Fail&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Go 测试工具也允许你编写示例函数，它可以作为文档和测试用例，这些函数需要以&lt;code&gt;Example&lt;/code&gt;开头：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;ExampleEven&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;Even&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Is even\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// Output:&lt;/span&gt;
    &lt;span class="c1"&gt;// Is even&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的两行注释是&lt;code&gt;example&lt;/code&gt;的一部分，&lt;code&gt;go test&lt;/code&gt;使用它来检查输出并以此判断测试是否失败。&lt;/p&gt;
&lt;h3 id="chang-yong-bao"&gt;常用包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fmt&lt;/code&gt;：格式化输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;io&lt;/code&gt;：提供原始的 I/O 接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bufio&lt;/code&gt;：实现缓冲 I/O。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort&lt;/code&gt;：集合排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strconv&lt;/code&gt;：字符串与基础数据类型的转换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os&lt;/code&gt;：操作系统功能接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sync&lt;/code&gt;：提供同步基础功能，如排它锁等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flag&lt;/code&gt;：命令行参数解析。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoding/json&lt;/code&gt;：用于编码解码&lt;code&gt;JSON&lt;/code&gt;对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;html/template&lt;/code&gt;：生成文本输出的数据驱动模板。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net/http&lt;/code&gt;：解析&lt;code&gt;HTTP&lt;/code&gt;请求响应，URL提供了一个可扩展的&lt;code&gt;HTTP&lt;/code&gt;服务和客户端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsafe&lt;/code&gt;：提供超出 Go 类型安全的功能（指针类型转换等）。通常应该不使用它。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reflect&lt;/code&gt;：用于实现运行时反射功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os/exec&lt;/code&gt;：用于运行外部命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基础知识&lt;/h2&gt;
&lt;p&gt;Go 有指针但没有指针运算，因此他们更像 C 里的引用。调用函数时，总是传值的。因此为了修改传递的参数，应该使用指针。
新声明的指针与其它类型一样也被赋了零值，它的值为&lt;code&gt;nil&lt;/code&gt;，表示它不指向任何东西。为了让它指向某些东西，需要使用取地址操作符&lt;code&gt;&amp;amp;&lt;/code&gt;来获取地址。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%v"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;//nil&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%v"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;//指针地址&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%v\n"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="nei-cun-fen-pei"&gt;内存分配&lt;/h3&gt;
&lt;p&gt;Go 有垃圾收集器，使用&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;make&lt;/code&gt;分配内存。它们的区别：&lt;/p&gt;
&lt;h4 id="new"&gt;&lt;code&gt;new&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;的行为与其它语言中差不多：&lt;code&gt;new(T)&lt;/code&gt;分配&lt;code&gt;T&lt;/code&gt;类型的零值并返回它的地址，值为&lt;code&gt;*T&lt;/code&gt;类型。
要注意返回的是零值。比如&lt;code&gt;bytes.Buffer&lt;/code&gt;的零值为空的缓冲。&lt;code&gt;sync.Mutex&lt;/code&gt;的零值是一个未上锁的互斥量。
分配内存与声明都会初始化为零值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;SyncedBuffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="nx"&gt;SyncedBuffer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的&lt;code&gt;p&lt;/code&gt;和&lt;code&gt;v&lt;/code&gt;都能马上使用。&lt;/p&gt;
&lt;h4 id="make"&gt;&lt;code&gt;make&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;make(T, args)&lt;/code&gt;与&lt;code&gt;new(T)&lt;/code&gt;的目标不同，它只用于创建&lt;code&gt;slice&lt;/code&gt;，&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;channel&lt;/code&gt;，并且它返回的是初始化过的（非零值）&lt;code&gt;T&lt;/code&gt;而不是&lt;code&gt;*T&lt;/code&gt;。原因在于这三种类型的底层数据结构在使用前需要初始化。以&lt;code&gt;slice&lt;/code&gt;为例如果不初始化它的初始值为&lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="gou-zao-qi-he-chu-shi-hua"&gt;构造器和初始化&lt;/h4&gt;
&lt;p&gt;有些情况下零值不能直接使用需要进行初始化。以&lt;code&gt;os&lt;/code&gt;中的一个方法为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;NewFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;File&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;fd&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;File&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;fd&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;direinfo&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;nepipe&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以简化为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;NewFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;File&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;fd&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;File&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的创建文件对象的一行，还可以简化为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;File&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未传递的字段将会是字段类型的零值。即&lt;code&gt;new(File)&lt;/code&gt;与&lt;code&gt;&amp;amp;File{}&lt;/code&gt;是等效的。&lt;/p&gt;
&lt;h3 id="zi-ding-yi-lei-xing_1"&gt;自定义类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;type foo int&lt;/code&gt;创建了一个与&lt;code&gt;int&lt;/code&gt;相同的类型。更复杂的类型需要使用&lt;code&gt;struct&lt;/code&gt;关键字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;NameAge&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="c1"&gt;//不导出&lt;/span&gt;
    &lt;span class="nx"&gt;age&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;     &lt;span class="c1"&gt;//不导出&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="jie-gou-zi-duan"&gt;结构字段&lt;/h4&gt;
&lt;p&gt;结构体的每个项是一个字段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;A&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;F&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果忽略字段名，那么会创建一个匿名字段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;T1&lt;/span&gt;      &lt;span class="c1"&gt;//自动产生名称为 T1 的字段&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;T2&lt;/span&gt;     &lt;span class="c1"&gt;//自动产生名称为 *T2 的字段&lt;/span&gt;
    &lt;span class="nx"&gt;P&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;T3&lt;/span&gt;    &lt;span class="c1"&gt;//自动产生名称为 T3 的字段&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字段名以大写开头的会被导出，可以被其它包读写。小写开头的字段是对当前包私有的。&lt;/p&gt;
&lt;h4 id="fang-fa"&gt;方法&lt;/h4&gt;
&lt;p&gt;有两种方法可以创建处理所定义的类型的函数：
1. 函数调用：创建函数时带类型参数（即函数参数类型）：&lt;code&gt;func doSomething(n1 *NameAge, n2 int){}&lt;/code&gt;
2. 方法调用：创建只工作于特定类型的函数：&lt;code&gt;func (n1 *NameAge) doSomething(n2 int){}&lt;/code&gt;，使用：&lt;code&gt;var n*NameAge; n.doSomething(2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用函数或方法取决于程序员，但是满足接口时必须使用方法。
在上面的情况中这种代码不是错误：&lt;code&gt;var n NameAge; n.doSomething(2)&lt;/code&gt;这里&lt;code&gt;a&lt;/code&gt;不是指针。这种情况下 Go 会搜索类型&lt;code&gt;NameAge&lt;/code&gt;的方法列表，找不到之后将会搜索类型&lt;code&gt;*NameAge&lt;/code&gt;的方法列表，然后将方法调用转化为&lt;code&gt;(&amp;amp;n).doSomething(2)&lt;/code&gt;。
定义结构时的方法不同会导致结构所包含的方法也不同，有结构体&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Mutex&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;Unlock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后定义两种新的类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;NewMutex&lt;/span&gt; &lt;span class="nx"&gt;Mutex&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;PrintableMutex&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在&lt;code&gt;NewMutex&lt;/code&gt;与&lt;code&gt;Mutex&lt;/code&gt;是相等的，但是它没有&lt;code&gt;Mutex&lt;/code&gt;的任何方法，它的方法是空的。但是&lt;code&gt;PrintableMutex&lt;/code&gt;继承了&lt;code&gt;Mutex&lt;/code&gt;的方法，它的&lt;code&gt;Mutex&lt;/code&gt;属性上绑定了&lt;code&gt;Lock&lt;/code&gt;和&lt;code&gt;Unlock&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id="lei-xing-zhuan-huan_1"&gt;类型转换&lt;/h3&gt;
&lt;p&gt;类型转换由操作符完成，但看起来像是函数调用，如：&lt;code&gt;byte()&lt;/code&gt;。不是所有转换都是允许的。
别名类型同样需要转换，不能直接赋值。&lt;/p&gt;
&lt;h3 id="zu-he"&gt;组合&lt;/h3&gt;
&lt;p&gt;当前的 Go 不是面向对象的编程语言因此没有继承，需要实现&amp;ldquo;继承&amp;rdquo;效果时可以嵌入一个类型。&lt;/p&gt;
&lt;h2&gt;接口&lt;/h2&gt;
&lt;p&gt;Go 中&lt;code&gt;interface&lt;/code&gt;有多种含义。所有类型都有一个接口，就是该类型定义的方法的集合。例如：
```type S struct { i int}
func (p &lt;em&gt;S) Get() int {return p.i }
func (p &lt;/em&gt;S) Put(v int) { p.i = v }&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;你可以定义一个接口类型：
```go
type I inteface {
    Get() int
    Put(int)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;是实现了接口&lt;code&gt;I&lt;/code&gt;的，因为它定义了两个&lt;code&gt;I&lt;/code&gt;所需要的方法。注意，实现接口并不需要显式的声明。
使用接口值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="nx"&gt;I&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里&lt;code&gt;p&lt;/code&gt;是一个接口类型的值。&lt;code&gt;S&lt;/code&gt;实现了接口&lt;code&gt;I&lt;/code&gt;，我们可以传递指向类型&lt;code&gt;S&lt;/code&gt;的指针给函数：&lt;code&gt;var s S; f(&amp;amp;s)&lt;/code&gt;。这里需要传递指针的原因在于我们将方法定义在操作指针类型上了。这不是必需的&amp;mdash;&amp;mdash;我们可以将方法定义的值上&amp;mdash;&amp;mdash;但是&lt;code&gt;Put&lt;/code&gt;方法将不会按期望的方式工作。
事实上 Go 是鸭式类型，不需要声明一个类型是否实现了某一类型。但它不是纯的鸭式类型，因为 Go 编译嘎嘎将进行静态类型检查，检查精英是否实现了接口。但是，Go 有真正的动态特性，它将一种接口转化为另一接口。通常情况下，这一转换发生在运行时。如果转换失败，程序将出错并产生运行时错误。
Go 中的接口与其它语言中的理念类似：&lt;code&gt;C++&lt;/code&gt;中的纯抽像虚拟基类，&lt;code&gt;Haskell&lt;/code&gt;中的&lt;code&gt;typeclasses&lt;/code&gt;或&lt;code&gt;Python&lt;/code&gt;中的鸭式类型。但是其它语言没有能组合接口值、静态类型检查、运行时动态类型转换并且不需要显式的在类型声明时声明它满足某个接口。因此 Go 中的接口是非常强大、具有弹性、高效并且易于编写的。
当有多个类型实现某一接口时，可以根据类型进行处理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="nx"&gt;I&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;S&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;R&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;S&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;R&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;code&gt;switch&lt;/code&gt;之外使用&lt;code&gt;(type)&lt;/code&gt;是非法的。这并不是唯一一种在运行时检查类型的方法。你也可以使用&lt;code&gt;; ok&lt;/code&gt;的格式检查接口类型是否实现了特定的接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;something&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="nx"&gt;I&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// something 实现了接口 I&lt;/span&gt;
    &lt;span class="c1"&gt;// t 是类型&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当你确定变量实现了某一接口时可以用&lt;code&gt;t := something.(I)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;空接口&lt;/em&gt;
因为每个类型都满足空接口：&lt;code&gt;interface {}&lt;/code&gt;。我们可以定义一个通用函数以空接口作为它的参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;something&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;something&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="nx"&gt;I&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;Get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用这一方法是要注意，传递给&lt;code&gt;g&lt;/code&gt;的参数不管是否实现了接口&lt;code&gt;I&lt;/code&gt;时都不会产生编译错误，但在运行时，如果参数未实现接口&lt;code&gt;I&lt;/code&gt;就会产生运行时错误。&lt;/p&gt;
&lt;h3 id="fang-fa_1"&gt;方法&lt;/h3&gt;
&lt;p&gt;方法是有接收者的函数。可以在任何类型上定义方法（不能定义在属于其它包的类型上，同样也包括内置的&lt;code&gt;int&lt;/code&gt;类型）。但是你可以定义自己的&lt;code&gt;int&lt;/code&gt;类型然后添加方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;self&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;Emit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%v"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Emitter&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;Emit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="jie-kou-lei-xing-shang-de-fang-fa"&gt;接口类型上的方法&lt;/h4&gt;
&lt;p&gt;接口定义了方法集，方法包含了实际的代码。即方法是接口的实现。因此接收者（receiver）不能是接口类型。
接收类型必须是&lt;code&gt;T&lt;/code&gt;或&lt;code&gt;*T&lt;/code&gt;格式，&lt;code&gt;T&lt;/code&gt;是类型名。&lt;code&gt;T&lt;/code&gt;被称为接收者基础类型。这个基础类型不能是指针或接口类型必须定义在与方法相同的包里。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;接口指针&lt;/em&gt;
Go 中使用接口指针是没有必要的。实际上创建指向接口值的指针是非法的。&lt;/p&gt;
&lt;h3 id="jie-kou-ming-cheng_1"&gt;接口名称&lt;/h3&gt;
&lt;p&gt;通常，只有一个方法的接口被命名为方法名加&lt;code&gt;-er&lt;/code&gt;后缀。&lt;/p&gt;
&lt;h4 id="nei-sheng-he-fan-she"&gt;内省和反射&lt;/h4&gt;
&lt;p&gt;下例展示了如何通过反射包检查定义在类型&lt;code&gt;Person&lt;/code&gt;中的&lt;code&gt;tag&lt;/code&gt;（&lt;code&gt;namestr&lt;/code&gt;）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Person&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="s"&gt;"namestr"&lt;/span&gt;   &lt;span class="c1"&gt;// namestr 是 tag&lt;/span&gt;
    &lt;span class="nx"&gt;age&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;ShowTag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//使用 *Person 来调用&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TypeOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Kind&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Ptr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nx"&gt;tag&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Elem&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;Tag&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用反射获取类型和值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TypeOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//类型元数据&lt;/span&gt;
            &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//实际值&lt;/span&gt;
            &lt;span class="nx"&gt;tag&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Elem&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;Tag&lt;/span&gt;
            &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Elem&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;String&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置值的方式与获取值的方式类似，但是只允许在导出成员上使用，在私有成员上使用时会产生运行时错误。&lt;/p&gt;
&lt;h2&gt;并发程序&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;goroutine&lt;/code&gt;与已有的线程、协程或进程等概念不完全一样。它有自己的模型：它是与其它&lt;code&gt;goroutine&lt;/code&gt;并行执行的，有着相同的地址空间的函数。它是轻量级的，仅比分配栈空间多一点点消耗。而初始时栈是很小的，所以它们也是廉价的，并且随着需要在堆空间上分配（和释放）。
&lt;code&gt;goroutine&lt;/code&gt;是个普通函数，只需要使用关键字&lt;code&gt;go&lt;/code&gt;作为 开头。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tea"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;//普通函数调用&lt;/span&gt;
&lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tea"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//作为 goroutine 运行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在程序退出时，所有&lt;code&gt;goroutine&lt;/code&gt;都会停止。为了修复这个问题，需要一些能够同&lt;code&gt;goroutine&lt;/code&gt;通讯的机制。这一机制通过&lt;code&gt;channels&lt;/code&gt;的形式使用。&lt;code&gt;channel&lt;/code&gt;与&lt;code&gt;Unix shell&lt;/code&gt;中的双向管道类似：可以通过它发送或接收值。这些值只能是特定的类型：&lt;code&gt;channel&lt;/code&gt;类型。定义它时也需要定义发送到&lt;code&gt;channel&lt;/code&gt;的值的类型。必须使用&lt;code&gt;make&lt;/code&gt;创建&lt;code&gt;channel&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="c1"&gt;//定义传输整数的全局的 channel&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;sec&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;ft&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"is ready!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;      &lt;span class="c1"&gt;//发送整数 1&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//初始化 c&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tea"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//开始 goroutine&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Coffee"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"I'm waiting, but not too long"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;     &lt;span class="c1"&gt;//从 channel 上接收值，收到的值将被丢弃&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个列子仍然有些问题，它从&lt;code&gt;channel&lt;/code&gt;上读取了两次。如果在不知道启动了多少个&lt;code&gt;goroutine&lt;/code&gt;的情况下怎么办呢？这就要使用到 Go 的另一个关键字：&lt;code&gt;select&lt;/code&gt;。通过&lt;code&gt;select&lt;/code&gt;可以监听&lt;code&gt;channel&lt;/code&gt;上输入的数据。将上例中的两行&lt;code&gt;&amp;lt;-c&lt;/code&gt;换以下代码之后，程序会一直等下去，只到从&lt;code&gt;channel c&lt;/code&gt;上收到多个响应时才会退出循环L。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;L&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="nx"&gt;L&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然&lt;code&gt;goroutine&lt;/code&gt;是并发执行的，但它们并不是并行运行的。如果不告诉 Go 额外的东西，同一时刻只会有一个&lt;code&gt;goroutine&lt;/code&gt;执行。利用&lt;code&gt;runetime.GOMAXPROCS(n)&lt;/code&gt;可以设置&lt;code&gt;goroutine&lt;/code&gt;并行执行的数量。
&lt;code&gt;GOMAXPROCS&lt;/code&gt;设置了同时运行的&lt;code&gt;CPU&lt;/code&gt;的最大数量，并返回之前的设置。如果&lt;code&gt;n&amp;lt;1&lt;/code&gt;，不会改变当前设置。也可以通过设置环境变量&lt;code&gt;GOMAXPROCS&lt;/code&gt;为它设置值。&lt;/p&gt;
&lt;h3 id="geng-duo-guan-yu-channel_1"&gt;更多关于 channel&lt;/h3&gt;
&lt;p&gt;在 Go 中使用&lt;code&gt;ch := make(chan bool)&lt;/code&gt;创建&lt;code&gt;channel&lt;/code&gt;时，&lt;code&gt;bool&lt;/code&gt;型的无缓冲&lt;code&gt;channel&lt;/code&gt;将被创建。这意味着：首先，如果读取（&lt;code&gt;value := &amp;lt;- ch&lt;/code&gt;）它将会被阻塞，直到有数据接收。其次，任何发送（&lt;code&gt;ch&amp;lt;-5&lt;/code&gt;）将会被阻塞，直到数据被读出。无缓冲&lt;code&gt;channel&lt;/code&gt;可以方便的在多个&lt;code&gt;goroutine&lt;/code&gt;间同步。
Go 也允许指定&lt;code&gt;channel&lt;/code&gt;缓冲区的大小，用于设定&lt;code&gt;channel&lt;/code&gt;可存储元素的数量。&lt;code&gt;ch := make(chan bool, 4)&lt;/code&gt;创建了可以存储 4 个元素的&lt;code&gt;bool&lt;/code&gt;型&lt;code&gt;channel&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关闭 channel &lt;/em&gt;
当&lt;code&gt;channel&lt;/code&gt;被关闭后，读取端需要知道这个事情。下面的代码演示了如何检查&lt;code&gt;channel&lt;/code&gt;是否被关闭:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当&lt;code&gt;ok&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;时意味着&lt;code&gt;channel&lt;/code&gt;未被关闭，可以读取数据。否则表示它已经被关闭了。&lt;/p&gt;
&lt;h2&gt;通讯&lt;/h2&gt;
&lt;h3 id="ioreader"&gt;io.Reader&lt;/h3&gt;
&lt;p&gt;Go 的 I/O 核心是接口&lt;code&gt;io.Reader&lt;/code&gt;和&lt;code&gt;io.Writer&lt;/code&gt;。
在 Go 中读写文件使用&lt;code&gt;os&lt;/code&gt;包就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;"os"&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/etc/passwd"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Stdout&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缓冲 I/O，则需要&lt;code&gt;bufio&lt;/code&gt;包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"os"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="s"&gt;"bufio"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/etc/passwd"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nx"&gt;r&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;bufio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewReader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;bufio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewWriter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Stdout&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;r&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ming-ling-xing-can-shu"&gt;命令行参数&lt;/h3&gt;
&lt;p&gt;命令行参数在程序中通过&lt;code&gt;os.Args&lt;/code&gt;获取。&lt;code&gt;flags&lt;/code&gt;包提供了接口来解析参数。&lt;/p&gt;
&lt;h3 id="zhi-xing-ming-ling"&gt;执行命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;os/exec&lt;/code&gt;包可以执行外部命令，这也是在 Go 中主要的执行命令的方法。&lt;/p&gt;
&lt;h3 id="wang-luo"&gt;网络&lt;/h3&gt;
&lt;p&gt;所有网络相关的类型和函数可以在&lt;code&gt;net&lt;/code&gt;包中找到。&lt;/p&gt;</content><category term="go"></category></entry><entry><title>Scala Cookbook 笔记</title><link href="/scala-cookbook-bi-ji.html" rel="alternate"></link><published>2015-05-21T00:00:00+08:00</published><updated>2015-05-21T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-21:/scala-cookbook-bi-ji.html</id><summary type="html">&lt;h1&gt;Scala Cookbook 笔记&lt;/h1&gt;
&lt;h2&gt;String&lt;/h2&gt;
&lt;h3 id="jian-jie"&gt;简介&lt;/h3&gt;
&lt;p&gt;Scala String 是 Java String，可以使用 Java 中 String 对象的方法。由于 Scala 提供了隐式转换，因此 String（即使它是 final 的） 实例也可以使用 StringOps 类中的所有方法，因此你可以将字符串实例当作字符序列。对它使用 foreach 或使用 for 循环。字符串的另一些功能来自于 StringLike 和 WrappedString 等类。String 类至 StringOps 的隐式转换源于 Predef 对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;
&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Scala Cookbook 笔记&lt;/h1&gt;
&lt;h2&gt;String&lt;/h2&gt;
&lt;h3 id="jian-jie"&gt;简介&lt;/h3&gt;
&lt;p&gt;Scala String 是 Java String，可以使用 Java 中 String 对象的方法。由于 Scala 提供了隐式转换，因此 String（即使它是 final 的） 实例也可以使用 StringOps 类中的所有方法，因此你可以将字符串实例当作字符序列。对它使用 foreach 或使用 for 循环。字符串的另一些功能来自于 StringLike 和 WrappedString 等类。String 类至 StringOps 的隐式转换源于 Predef 对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;
&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scala String 同时拥有字符串和集合特性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"scala"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;drop&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;take&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="xiang-deng-xing"&gt;相等性&lt;/h3&gt;
&lt;p&gt;Scala 中直接使用 &lt;code&gt;==&lt;/code&gt; 比较字符串。这个操作不会在对象为 &lt;code&gt;null&lt;/code&gt; 时抛出空指针异常。如果在比较时要忽略大小写，则可以将要比较的字符串都转换为大写或小写。在 &lt;code&gt;null&lt;/code&gt; 上调用大小写转换方法时是会产生空指针异常的。也可以直接使用 Java String 的&lt;code&gt;equalsIgnoreCase&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s3&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s4&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;
&lt;span class="n"&gt;s3&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;s4&lt;/span&gt;
&lt;span class="n"&gt;s4&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;s3&lt;/span&gt; &lt;span class="c1"&gt;//不产生异常&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scala 中使用&lt;code&gt;==&lt;/code&gt;比较对象相等性，而不是使用&lt;code&gt;equals&lt;/code&gt;方法。&lt;code&gt;==&lt;/code&gt;定义在 AnyRef 中，它会先检查是否为 null，然后再调用&lt;code&gt;equal&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id="duo-xing-zi-fu-chuan"&gt;多行字符串&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"""This is&lt;/span&gt;
&lt;span class="s"&gt;a multiline&lt;/span&gt;
&lt;span class="s"&gt;String"""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多行字符串的对齐&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//默认按|对齐&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;speech&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"""Four score and&lt;/span&gt;
&lt;span class="s"&gt;|seven years ago"""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stripMargin&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;speech&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"""Four score and&lt;/span&gt;
&lt;span class="s"&gt;#seven years ago"""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stripMargin&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;//多行转单行&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;speech&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"""Four score and&lt;/span&gt;
&lt;span class="s"&gt;#seven years ago"""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stripMargin&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;replaceAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zi-fu-chuan-fen-ge"&gt;字符串分割&lt;/h3&gt;
&lt;p&gt;字符串分割时使用的&lt;code&gt;split&lt;/code&gt;来自于 Java String 类型，如果传递的参数是字符则使用的是来自 StringLike 类的方法。两者不同的地方在于返回值的类型为 Array[java.lang.String] 和 Array[String]，一般情况下这一区别并不重要。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"hello world"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Array[java.lang.String] = Array(hello, world)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"eggs, milk, butter, Coco Puffs"&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;","&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Array[java.lang.String] = Array(eggs, " milk", " butter", " Coco Puffs")&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;","&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Array[java.lang.String] = Array(eggs, milk, butter, Coco Puffs)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ti-huan-zi-fu-chuan-zhong-de-bian-liang"&gt;替换字符串中的变量&lt;/h3&gt;
&lt;p&gt;Scala 2.10 开始你可以使用 string interpolation。使用时需要在字符串前加 &lt;code&gt;s&lt;/code&gt; 前缀，在字符串中包含的变量名前添加 &lt;code&gt;$&lt;/code&gt; 符号。表达式则需要嵌入在 &lt;code&gt;${}&lt;/code&gt; 间。&lt;code&gt;s&lt;/code&gt;是一种前缀，使用&lt;code&gt;f&lt;/code&gt;时可以使用&lt;code&gt;printf&lt;/code&gt;方式格式化显示内容。使用&lt;code&gt;raw&lt;/code&gt;前缀时不会对内容进行转义。除了这3种 Scala 2.10 内置的解析器外，你也可以定义自己的解析器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Fred"&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;200.00&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s"&lt;/span&gt;&lt;span class="si"&gt;$name&lt;/span&gt;&lt;span class="s"&gt; is &lt;/span&gt;&lt;span class="si"&gt;$age&lt;/span&gt;&lt;span class="s"&gt; years old, and weight &lt;/span&gt;&lt;span class="si"&gt;$weight&lt;/span&gt;&lt;span class="s"&gt; pounds."&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s"Age next years: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s"You are 33 years old: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Student&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;score&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;hannah&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Student&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hannah"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;95&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s"&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;hannah&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt; has a score of &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;hannah&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;f"&lt;/span&gt;&lt;span class="si"&gt;$name&lt;/span&gt;&lt;span class="s"&gt; is &lt;/span&gt;&lt;span class="si"&gt;$age&lt;/span&gt;&lt;span class="s"&gt; years old, and weighs &lt;/span&gt;&lt;span class="si"&gt;$weight&lt;/span&gt;&lt;span class="s"&gt;%.2f pounds."&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Fred is 33 years old, and weighs 200.00 pounds.&lt;/span&gt;

&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;f"&lt;/span&gt;&lt;span class="si"&gt;$name&lt;/span&gt;&lt;span class="s"&gt; is &lt;/span&gt;&lt;span class="si"&gt;$age&lt;/span&gt;&lt;span class="s"&gt; years old, and weighs &lt;/span&gt;&lt;span class="si"&gt;$weight&lt;/span&gt;&lt;span class="s"&gt;%.0f pounds."&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Fred is 33 years old, and weighs 200 pounds.&lt;/span&gt;

&lt;span class="s"&gt;raw"foo\nbar"&lt;/span&gt;
&lt;span class="c1"&gt;//foo\nbar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.10 之前的版本可以使用 string 的&lt;code&gt;format&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"%s is %d years old"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Fred is 33 years old&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以在类的&lt;code&gt;toString&lt;/code&gt;中使用这一方法来输出对象内容。&lt;/p&gt;
&lt;h3 id="chu-li-zi-fu-chuan-zhong-de-zi-fu"&gt;处理字符串中的字符&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello world"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUpper&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello world"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUpper&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello, world"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUpper&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUpper&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s"&gt;"hello, world"&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUpper&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toLower&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toByte&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;
&lt;span class="s"&gt;"HELLO"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;toLower&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;toLower&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toByte&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;
&lt;span class="s"&gt;"HELLO"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;toLower&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zi-fu-chuan-mo-shi-pi-pei"&gt;字符串模式匹配&lt;/h3&gt;
&lt;p&gt;调用字符串的&lt;code&gt;.r&lt;/code&gt;方法可以创建正则表达式对象，使用它的&lt;code&gt;findFirstIn&lt;/code&gt;返回第一个匹配，使用&lt;code&gt;findAllIn&lt;/code&gt;返回所有匹配。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;numPattern&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"[0=9]+"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"123 Main Street Suite 101"&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;match1&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numPattern&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findFirstIn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//match1: Option[String] = Some(123)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;matchs&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numPattern&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAllIn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//matches: scala.util.matching.Regex.MatchIterator = non-empty iterator&lt;/span&gt;
&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;matches&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numPattern&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAllIn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toArray&lt;/span&gt;
&lt;span class="c1"&gt;//Array[String] = Array(123, 101)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建&lt;code&gt;Regex&lt;/code&gt;对象的另一方式是使用&lt;code&gt;scala.util.matching.Regex&lt;/code&gt;类。
&lt;code&gt;findFirstIn&lt;/code&gt;的结果是&lt;code&gt;Option[String]&lt;/code&gt;，它可能的值为&lt;code&gt;Some(String)&lt;/code&gt;或&lt;code&gt;None&lt;/code&gt;。使用&lt;code&gt;Options&lt;/code&gt;的几种方法：
 - 调用&lt;code&gt;getOrElse&lt;/code&gt;获取值
 - 在&lt;code&gt;match&lt;/code&gt;表达式中使用&lt;code&gt;Option&lt;/code&gt;
 - 在&lt;code&gt;foreach&lt;/code&gt;中使用&lt;code&gt;Option&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="zi-fu-chuan-mo-shi-ti-huan"&gt;字符串模式替换&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"123 Main Street"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"[0-9]"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;regex&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"[0-9]"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;newAddress&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;regex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceAllIn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"123 Main Street"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceFirst&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"[0-9]"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;regex&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"H"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;regex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceFirstIn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello world"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"J"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zi-fu-chuan-mo-shi-ti-qu"&gt;字符串模式提取&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"([0-9]+) ([A-Za-z]+)"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fruit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"100 Bananas"&lt;/span&gt;
&lt;span class="c1"&gt;//count: String = 100&lt;/span&gt;
&lt;span class="c1"&gt;//fruit: String = Bananas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语法看起来有些奇怪像是将&lt;code&gt;pattern&lt;/code&gt;定义了两次。&lt;/p&gt;
&lt;h3 id="fang-wen-zi-fu-chuan-zhong-de-zi-fu"&gt;访问字符串中的字符&lt;/h3&gt;
&lt;p&gt;使用 Java 中的&lt;code&gt;charAt&lt;/code&gt;方法，或是像 Scala 的数组那样使用字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;charAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常可以用&lt;code&gt;map&lt;/code&gt;或&lt;code&gt;foreach&lt;/code&gt;来遍历字符串中的字符，也可以把字符串当作数组。&lt;/p&gt;
&lt;h3 id="xiang-string-lei-zhong-tian-jia-fang-fa"&gt;向 String 类中添加方法&lt;/h3&gt;
&lt;p&gt;从 Scala 2.10，你可以定义隐式类，通过这个类里的方法来增加你需要的功能。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StringImprovements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;隐式类必须定义在类、对象或包对象里。然后在需要使用的地方导入这个类。
对于 Scala 2.10 之前的版本可以通过隐式转换的方式向类中添加方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StringImprovements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;stringToString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;StringImprovements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建议在隐式转换类中定义的方法应该注明返回值。特别是在遇到编译器找不到你的隐式类中的方法时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StringImprovements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 显式的标明每个方法都返回一个字符串&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;decrement&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;hideAll&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"."&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尽管上面的例子都是返回的字符串，但是你可以在这些方法中返回任何类型。&lt;/p&gt;
&lt;h2&gt;数字&lt;/h2&gt;
&lt;h3 id="jie-shao"&gt;介绍&lt;/h3&gt;
&lt;p&gt;Scala 中所有数值类型都是对象。获取表达范围：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;Short&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;MinValue&lt;/span&gt;
&lt;span class="nc"&gt;Short&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;MaxValue&lt;/span&gt;
&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;MinValue&lt;/span&gt;
&lt;span class="nc"&gt;Float&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;MinValue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于&lt;em&gt;复数和日期&lt;/em&gt;等复杂类型来说，有很多第三方项目提供了支持。如&lt;code&gt;Spire project&lt;/code&gt;提供了有理数、复数、实数等类型，而&lt;code&gt;nscala-time&lt;/code&gt;则提供了对&lt;code&gt;Joda Time&lt;/code&gt;的封装。&lt;/p&gt;
&lt;h3 id="cong-wen-ben-zhong-jie-xi-shu-zi"&gt;从文本中解析数字&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;StringLike&lt;/code&gt;trait 提供了&lt;code&gt;to*&lt;/code&gt;方法用于将字符串转换成数字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;
&lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toByte&lt;/span&gt;
&lt;span class="s"&gt;"foo"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt; &lt;span class="c1"&gt;//出错&lt;/span&gt;
&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="n"&gt;`&lt;/span&gt;
&lt;span class="n"&gt;如果想要标明转换时可能发生异常可以使用`&lt;/span&gt;&lt;span class="nd"&gt;@throws&lt;/span&gt;&lt;span class="n"&gt;`注解，特别是给 Java 调用时。&lt;/span&gt;
&lt;span class="n"&gt;`&lt;/span&gt;&lt;span class="err"&gt;``&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;
&lt;span class="c1"&gt;//不需要添加 throws &lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;

&lt;span class="nd"&gt;@throws&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;classOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;NumberFormatException&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者使用&lt;code&gt;Option/Some/None&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Optiion&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;NumberFormatException&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后使用&lt;code&gt;getOrElse&lt;/code&gt;或&lt;code&gt;match&lt;/code&gt;来取值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;getOrElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aString&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Boom! That wasn't a number."&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aString&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="zai-shu-zhi-lei-xing-jian-zhuan-huan"&gt;在数值类型间转换&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mf"&gt;19.45&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;     &lt;span class="c1"&gt;// 19&lt;/span&gt;
&lt;span class="mf"&gt;19.&lt;/span&gt;&lt;span class="n"&gt;toFloat&lt;/span&gt;      &lt;span class="c1"&gt;// 19.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不能像在 Java 中那样进行数值类型间的转换，而应该使用&lt;code&gt;to*&lt;/code&gt;方法。
为了避免转换失败，可以使用&lt;code&gt;isValid&lt;/code&gt;方法进行类型的检查：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100L&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isValidByte&lt;/span&gt;       &lt;span class="c1"&gt;// false&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isValidShort&lt;/span&gt;      &lt;span class="c1"&gt;// true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="fu-gai-mo-ren-de-shu-zhi-lei-xing"&gt;覆盖默认的数值类型&lt;/h4&gt;
&lt;p&gt;Scala 会在定义数值型变量时给予默认的数据类型。也可以覆盖默认的类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;span class="c1"&gt;//Int&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;      &lt;span class="c1"&gt;//Double&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;      &lt;span class="c1"&gt;//Float&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000L&lt;/span&gt;   &lt;span class="c1"&gt;//Long&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种方式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Byte&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x20&lt;/span&gt;    &lt;span class="c1"&gt;//Int 32&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x20&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;   &lt;span class="c1"&gt;//Long 32&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="dai-ti-he-"&gt;代替&lt;code&gt;++&lt;/code&gt;和&lt;code&gt;--&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;val&lt;/code&gt;是不可变的，因此不能使用自增和自减。但是&lt;code&gt;var Int&lt;/code&gt;是可以使用&lt;code&gt;+=&lt;/code&gt;和&lt;code&gt;-=&lt;/code&gt;来修改的，同样也可以使&lt;code&gt;*=&lt;/code&gt;和&lt;code&gt;/=&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="bi-jiao-fu-dian-shu-zhi"&gt;比较浮点数值&lt;/h4&gt;
&lt;p&gt;与在 Java 和其它语言类似，通过一个方法来指定需要比较的精度：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;~=(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;precision&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;={&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;precision&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外还可以结合隐式转换和工具类来处理。&lt;/p&gt;
&lt;h4 id="chu-li-fei-chang-da-de-shu-zhi"&gt;处理非常大的数值&lt;/h4&gt;
&lt;p&gt;使用 Scala 提供的&lt;code&gt;BigInt&lt;/code&gt;和&lt;code&gt;BigDecimal&lt;/code&gt;来处理大数值。与 Java 中不同的是这两个类支持其它数值类型的所有操作符，它们的底层仍然是 Java 中的&lt;code&gt;BigInteger&lt;/code&gt;和&lt;code&gt;BigDecimal&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="sheng-cheng-sui-ji-shu-zi"&gt;生成随机数字&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;scala.util.Random&lt;/code&gt;生成随机数。这个类可以处理所有常见的用例，也可以用它来生成随机字符。&lt;/p&gt;
&lt;h4 id="chuang-jian-rang-listhuo-shu-zi-shu-zu"&gt;创建&lt;code&gt;Rang&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;或数字数组&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;            &lt;span class="c1"&gt;//Range(1,3,5,7,9)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;     &lt;span class="c1"&gt;//Vector(2,4,6,8,10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="ge-shi-hua-shu-zi-he-jin-e"&gt;格式化数字和金额&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pi&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"$p%1.5f"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;//3.14159&lt;/span&gt;
&lt;span class="s"&gt;f"&lt;/span&gt;&lt;span class="si"&gt;$pi&lt;/span&gt;&lt;span class="s"&gt;%1.5f"&lt;/span&gt;             &lt;span class="c1"&gt;//3.14159&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scala 2.10 之前的版本可以使用format方法。&lt;/p&gt;
&lt;h2&gt;控制结构&lt;/h2&gt;</content><category term="scala"></category></entry><entry><title>设计模式回顾</title><link href="/she-ji-mo-shi-hui-gu.html" rel="alternate"></link><published>2014-11-04T00:00:00+08:00</published><updated>2014-11-04T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2014-11-04:/she-ji-mo-shi-hui-gu.html</id><summary type="html">&lt;h1&gt;设计模式回顾&lt;/h1&gt;
&lt;h2&gt;创建模式&lt;/h2&gt;
&lt;h3 id="simple-factory"&gt;Simple Factory&lt;/h3&gt;
&lt;p&gt;工厂类提供静态方法来创建某一接口类型的具体实现，该方法根据传入的参数来决定需要创建哪种类型的实现，因此传入的参数一般带有具体的类型信息（ class 的完整名称，或在某个包下的简称等等）。
举例：音乐盒接口的实现有钢琴音乐盒，小提琴音乐盒，有一音乐盒工厂类，它的 createMusicBox 方法内部根据参数来创建钢琴音乐盒或小提琴音乐盒。&lt;/p&gt;
&lt;h3 id="abstract-factory"&gt;Abstract Factory&lt;/h3&gt;
&lt;p&gt;抽象工厂模式一般用于创建一套对象，它将具体的某套对象的创建方法封装在对应的工厂类实现里。这些工厂类实现了同一接口（抽象工厂）。工厂类接口中的各个方法都返回接口类型。在具体工厂类的实现中它的各个方法能返回一套实现中不同类型的对象。
举例：多套 UI 组件具有不同的外观，每一套都由实现同一抽象工厂接口的具体工厂类型来创建。抽象工厂接口里规定了能创建哪些 UI 组件，各个组件的接口类型是什么。具体工厂实现里的各个方法会根据它的风格创建出对应的UI组件。&lt;/p&gt;
&lt;h3 id="builder"&gt;Builder&lt;/h3&gt;
&lt;p&gt;当创建复杂的对象或结构时，需要一个负责指挥的的导演类对象，它根据传递给它的 IBuilder ，按某一步骤来进行对象的构建。IBuider中 的各个方法代表构建过程的不同步骤。IBuilder 可以有多个不同的实现。&lt;/p&gt;
&lt;h3 id="factory-method"&gt;Factory Method&lt;/h3&gt;
&lt;p&gt;Factory Method 会在抽象类中留下某个创建 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;设计模式回顾&lt;/h1&gt;
&lt;h2&gt;创建模式&lt;/h2&gt;
&lt;h3 id="simple-factory"&gt;Simple Factory&lt;/h3&gt;
&lt;p&gt;工厂类提供静态方法来创建某一接口类型的具体实现，该方法根据传入的参数来决定需要创建哪种类型的实现，因此传入的参数一般带有具体的类型信息（ class 的完整名称，或在某个包下的简称等等）。
举例：音乐盒接口的实现有钢琴音乐盒，小提琴音乐盒，有一音乐盒工厂类，它的 createMusicBox 方法内部根据参数来创建钢琴音乐盒或小提琴音乐盒。&lt;/p&gt;
&lt;h3 id="abstract-factory"&gt;Abstract Factory&lt;/h3&gt;
&lt;p&gt;抽象工厂模式一般用于创建一套对象，它将具体的某套对象的创建方法封装在对应的工厂类实现里。这些工厂类实现了同一接口（抽象工厂）。工厂类接口中的各个方法都返回接口类型。在具体工厂类的实现中它的各个方法能返回一套实现中不同类型的对象。
举例：多套 UI 组件具有不同的外观，每一套都由实现同一抽象工厂接口的具体工厂类型来创建。抽象工厂接口里规定了能创建哪些 UI 组件，各个组件的接口类型是什么。具体工厂实现里的各个方法会根据它的风格创建出对应的UI组件。&lt;/p&gt;
&lt;h3 id="builder"&gt;Builder&lt;/h3&gt;
&lt;p&gt;当创建复杂的对象或结构时，需要一个负责指挥的的导演类对象，它根据传递给它的 IBuilder ，按某一步骤来进行对象的构建。IBuider中 的各个方法代表构建过程的不同步骤。IBuilder 可以有多个不同的实现。&lt;/p&gt;
&lt;h3 id="factory-method"&gt;Factory Method&lt;/h3&gt;
&lt;p&gt;Factory Method 会在抽象类中留下某个创建 IProduct 类型对象的方法(即创建对象的工厂方法)没有实现，而抽象类中其它方法都使用 IProduct 接口来操作该对象。
通常抽象类自己会调用这个抽像方法，并将创建出来的对象保存在抽象类的某个属性中，抽象类的其它方法直接使用 IProduct 接口来操作这一对象实例。&lt;/p&gt;
&lt;h3 id="prototype"&gt;Prototype&lt;/h3&gt;
&lt;p&gt;通过 clone 原型对象来创建新的实例。&lt;/p&gt;
&lt;h3 id="singleton"&gt;Singleton&lt;/h3&gt;
&lt;p&gt;单例模式的观念简单但很多时候会根据具体的环境进行调整和变化，比如多线程，lazy 实例化等。&lt;/p&gt;
&lt;h3 id="registry-of-singleton"&gt;Registry of Singleton&lt;/h3&gt;
&lt;p&gt;处理 Singleton 存在子类型的问题。
Singleton 的类型中定义一个 Map 保存 Singleton 各子类型的单实例对象，并提供一个 register 方法给 Singleton 的子类型注册其单实例。在 Singleton 的 getInstance 方法会根据当前的环境或配置到 map 中去 lookup 满足条件的实例。
在情况比较简单的情况下也可以不使用 register 方法，而直接根据当前的环境或配置通过反射获取类型并进行 Singleton 子类对象的实例化。&lt;/p&gt;
&lt;h2&gt;结构模式&lt;/h2&gt;
&lt;h3 id="default-adapter"&gt;Default Adapter&lt;/h3&gt;
&lt;p&gt;继承实现了某一接口的类（实现的方法中几乎什么都不做），而不是直接实现该接口的所有方法。这个实现了接口的类就是这一接口的缺省适配器，它能避免实现接口时需要实现该接口所有方法的问题。&lt;/p&gt;
&lt;h3 id="object-adapter"&gt;Object Adapter&lt;/h3&gt;
&lt;p&gt;Adapter 通过实现目标 ITarget 接口，将被适配类型 Adaptee 的实例包装成 ITarget 类型。这一模式中 Adapter 类型不需要继承 Adaptee 类型，它只需要用一个实例变量来保存 Adaptee 类型的实例。&lt;/p&gt;
&lt;h3 id="class-adapter"&gt;Class Adapter&lt;/h3&gt;
&lt;p&gt;Adapter 直接继承被适配类型 Adaptee 和 Target 类型，这需要语言层面支持多继承。在 Java 中只能实现继承 Adaptee 类型和 实例 ITarget 接口，这一限制也导致它在 Java 中的使用场合较少。&lt;/p&gt;
&lt;h3 id="bridget"&gt;Bridget&lt;/h3&gt;
&lt;p&gt;GOF 中指出 Bridge 的目的是：&amp;ldquo;将抽象部分与它的实现部分分享，使它们都可以独立的变化。&amp;rdquo;，即将对象的行为定义与针对于特定类型的行为实现进行分离。这样可以让行为定义部分和行为实现两部分互不交错，都可以持续的扩充下去。&lt;/p&gt;
&lt;h3 id="composite"&gt;Composite&lt;/h3&gt;
&lt;p&gt;使用 Composite 类型来定义树状组合结构。Composite 对象中可以添加其它的 Composite 对象，这样可以组合出更为复杂的大对象。而对 Composite 实例的方法调用，可以触发属于它的 Composite 实例的方法调用，保持整个 Composite 行为的一致。
举例：以绘图程序来说，定义一个图像 Component 为基础类型，直线、文字、矩形都是它的子类型，它们都实现了 Component 中定义的 draw 等基本接口，而图像容器 Container 则实现了 Component 的添加、删除、获取子图像的接口，它的 draw 方法会调用属于它的所有子元素的 draw 方法。这样就能通过将 Component 对象的嵌套，构造出复杂的结构。&lt;/p&gt;
&lt;h3 id="decorator"&gt;Decorator&lt;/h3&gt;
&lt;p&gt;装饰器模式能动态的为被装饰的对象添加新功能。
举例：Swing 中的 JTextArea 并没有带滚动条，只需要给它加上 JScrollPane 装饰器就可以实现滚动条的功能。抽象的装饰器与被装饰对象都实现了同样的接口，抽象装饰器中通常包含了一个被装饰的对象实例，对装饰器的调用会被转换为对被装饰对象的调用。包含其它功能的装饰器，可以继承自抽象装饰器，以实现更多的功能。
举例：GOF 中 Stream 抽象类和 StreamDecorator 类，Stream 的子类有 MemoryStream 和 FileStream，它们负责处理不同类型的流，但这些类都只负责最基本的字节处理。实现流压缩等功能则没有被编码到 Stream 子类，而是被实现为 StreamDecorator，由它们来提供这些额外的功能，由使用者来决定是否使用这些额外的功能。&lt;/p&gt;
&lt;h3 id="adapter-yu-decorator-de-bi-jiao"&gt;Adapter 与 Decorator 的比较&lt;/h3&gt;
&lt;p&gt;Adapter 与 Decorator 从定义上比较：
 - 都有个别名叫&lt;code&gt;包装模式&lt;/code&gt;
 - 装饰模式以对客户端透明的方式扩展对象，是继承关系的替代方案，比继承提供更多的灵活性。使用装饰类的实例，把客户端的调用委派到被装饰类。
 - 适配器模式则是把一个类的接口变换为客户端所期侍的另一种接口，从而使原本类型不匹配的两个类能一起工作。&lt;/p&gt;
&lt;p&gt;Adapter 与 Decorator 从使用条件上比较：
 - 装饰模式在需要扩展一个类的功能或者给这个类附加责任时使用；需要动态的给对象增加功能，这些附加的功能和责任可以撤销；所要增加的功能较多，并且排列组合量非常大，使用继承关系变得不现实
 - 适配器模式一般是新系统需要使用现有的类，但这个类已经不符合新系统的要求了。通常在系统升级时使用频率较高。&lt;/p&gt;
&lt;h3 id="facade"&gt;Facade&lt;/h3&gt;
&lt;p&gt;门面模式用于隐藏各个组件之间的合作行为，以及组件本身的操作与设置细节。它会让门面类的使用者损失一些直接操作各个组件细节的方便性。
举例：邮件程序可能要使用 FileUpload, Calendar, SimpleSMTP 等组件，因此可以定义一个 IFacade 及其实现 ConcreteFacade ，由 ConcreteFacade 来调用各个合作组的工作，由 IFacade 向外部提供统一的接口。&lt;/p&gt;
&lt;h3 id="flyweight"&gt;Flyweight&lt;/h3&gt;
&lt;p&gt;享元模式在描述数量多且性质接近的对象时将对象的信息分为两个部分：内部状态与外部状态。内部状态是对象的可共享部分，外部状态则依赖于具体的场景。
举例：Java 中的字符串使用的就是 Flyweight 模式，它维护了一个 String Pool，对于可共享的字符串对象，它会在 String Pool 中查找是否存在相同的内容，如果有就直接使用。两个指向相同内容的字符串使用 == 进行比较时，有可能返回的就是 true，因为它们可能引用的 String Pool 中的同一对象。&lt;/p&gt;
&lt;h3 id="proxy"&gt;Proxy&lt;/h3&gt;
&lt;p&gt;GOF 中给代理模式的目的定义是：给其它对象提供一种代理，以控制对这一对象的访问。
举例：文档中嵌入图片的例子，文档嵌入时并不直接加载图片，而是加载一个图片的代理，它代替图片被加载，以提升加载文档的速度。当文档滚动到图片所在的页数时，这时再加载图片。
代理的实现有两种：静态代理和动态代理：
 - 静态代理直接继承被代理对象的接口，并保存有一个被代理对象的实例。代理对象在调用被代理对象的方法前后加上需要的操作。
 - Java JDK 1.3 之后添加了 Dynamic Proxy 功能，定义一个实现 InvocationHandler 接口的类，它的bind方法将返回一个代理对象，它的 invoke 方法能捕捉到对被代理对象的方法调用。&lt;/p&gt;
&lt;h3 id="proxy-yu-decorator-de-qu-bie"&gt;Proxy 与 Decorator 的区别&lt;/h3&gt;
&lt;p&gt;两者都能很容易的在真实对象的方法前后加上自定义的方法。
装饰器模式关注于在对象上动态的添加方法，而代理模式关注于控制对对象的方法。代理类对客户端隐藏对象的具体信息，因此通常在代理类中创建对象实例。而使用装假模式的时候，通常是装饰原始的对象作为参数传递给装饰器的构造器。&lt;/p&gt;
&lt;h2&gt;行为模式&lt;/h2&gt;
&lt;h3 id="chain-of-responsibility"&gt;Chain of Responsibility&lt;/h3&gt;
&lt;p&gt;GOF 中的定义：使多个对象都有机会处理请求，以避免请求的发送者与接收者之间的耦合关系，将这些对象组合为一个链，并沿着这个链传递请求，直到有对象处理它为止。
因此链上的每个 Handler 都会有个类似于 successor 的对象，它是处理链上的下一个 Handler 。&lt;/p&gt;
&lt;h3 id="command"&gt;Command&lt;/h3&gt;
&lt;p&gt;以 Swing 中的菜单为例，每个菜单项都有一个 Command 与它对应，actionListener 根据点击的项，获取到对应的 Command 并调用它的方法进行处理。
很多 Web  MVC 框架也是使用这种方式来设计 Controller，由 Invoker 根据客户端请求的路径信息来决定调用某个具体的 Controller。
在使用中通常会将所有 ICommand 接口的实现注册到 Invoker 的一个集合属性中，客户端代码通过调用 Invoker.request 发起请求时，Invoker 根据请求信息（或参数），从集合中获取相应的 ICommand 对象，并调用它实现的 ICommand.execute 方法。&lt;/p&gt;
&lt;h3 id="interpreter"&gt;Interpreter&lt;/h3&gt;
&lt;p&gt;用于处理层次节点关系中解析每一个节点。（ AST？）&lt;/p&gt;
&lt;h3 id="iterator"&gt;Iterator&lt;/h3&gt;
&lt;p&gt;与期在集合对象上直接设计遍历的方法，不如设计为一个 Iterator 接口。当需要对它进行遍历时，将对象包装为一个 Iterator 后返回给客户端。
Iterator 模式可以简化集合对象的使用。&lt;/p&gt;
&lt;h3 id="mediator"&gt;Mediator&lt;/h3&gt;
&lt;p&gt;使用一个中间对象来封装对象之间的交互，对象之间不需要知道对方的存在，这样可以降低对象之间的耦合。当某个对象的状态发生变化时，它只需要通知 Mediator，由 Mediator 来处理与之相关的其它对象的状态。如果要改变对象之间的交互行为，也只需要对 Mediator 进行修改。&lt;/p&gt;
&lt;h3 id="memento"&gt;Memento&lt;/h3&gt;
&lt;p&gt;它为对象提供恢复机制。将对象的状态恢复机制放在对象之外，可以减轻对象本身的职责。
Memento 模式中，在 Originator 中有两个方法，一个方法用于获取代表它当前状态的 Memento 对象，另一个方法接收一个 Menento 对象，并将自己恢复为与它相同的状态。Memento 可能包含有 Originator 的所有属性。在外部有一个 Caretaker 来对 Memento 进行维护，每对 Originator 进行一个操作，Caretaker 就将操作前 Originator 的状态保存到它的 Memento 属性中，如果要恢复 Originator 的状态，就只要由 Caretaker 取得 Memento 属性，并对 Originator 进行状态恢复。&lt;/p&gt;
&lt;h3 id="observer"&gt;Observer&lt;/h3&gt;
&lt;p&gt;Observer 模式中的主角为主题（Subject）和观察者（Observer），观察者订阅它感兴趣的主题，一个主题可以被多个观察者订阅，当主题的状态发生变化时，它必须通知（notify）所有订阅它的观察者，观察者检查主题的状态变化，并作出对应的动作，因此 Observer 模式也被称为 Publish - Subscribe 模式。
举例：Java 中实现 Observer 接口的是观察者，这个接口定义了 update 方法，这个方法会在主题对象发生变化时被调用。主题是 Observable 的子类，这个类中有两个重要的方法： setChanged() 和 notifyObserver()。setChanged() 方法用于标明主题对象已经被修改，而 notifyObserver() 方法会通知所有订阅主题对象的观察者，并调用它们的 update() 方法。&lt;/p&gt;
&lt;h3 id="state"&gt;State&lt;/h3&gt;
&lt;p&gt;状态模式中 IObject 的每个可能的状态都实现 IState 接口。IObject 中的 current 属性是 IState 类型的，用于描述 IObject 的当前状态。当 IObject 的状态需要修改时，则它会调用 current 中的相关方法，并将自己传递给该方法，current 的这个方法会调用这个 IObject 的 setCurrentState() 方法来更新状态。
这样处理的好处是，当状态迁移关系是复杂的网状结构时，各个 IState 的实现可以根据传递进来的 IObject 的属性和自身的信息，决定 IObject 的下一个状态。即在设置下一个合理的状态时，只需要考虑当前的状态值，而不需要从整个状态迁移网来判断下一状态，避免大量的判断和检查。&lt;/p&gt;
&lt;h3 id="strategy"&gt;Strategy&lt;/h3&gt;
&lt;p&gt;将策略封装成对象，而不是将策略写死在某个类中，这样策略可以独立于客户端运行，随时可以增加新策略，减少策略，即使是修改某个策略也不会对客户端造成影响。
举例：在 CMS 区块内容的设置时，不应该根据区块内容的类型写死每个类型的处理策略。而应该将不同的类型包装为多个单独的策略（将所有策略注册为字典），这样就可以很方便的增加新策略。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;IState&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;switchFire&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FireSwitch&lt;/span&gt; &lt;span class="n"&gt;sw&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OffState&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;IState&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;switchFire&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FireSwitch&lt;/span&gt; &lt;span class="n"&gt;sw&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;sw&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SmallState&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SmallState&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;IState&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;switchFire&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FireSwitch&lt;/span&gt; &lt;span class="n"&gt;sw&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;sw&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OffState&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FireSwitch&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;IState&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OffState&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;//状态设置方法&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;//状态切换接口&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;switchFire&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;switchFire&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="template-method"&gt;Template Method&lt;/h3&gt;
&lt;p&gt;举例：比如在需要按一定的流程规则处理一些步骤时，可以在抽像类中将处理流程规划好，而具体流程中的各个步骤留给具体的实现类来处理。
Factory Method 可以将对象的创建推迟至子类来决定，而 Template Method 则是将流程中各步骤的具体实现推迟至子类来实现。&lt;/p&gt;
&lt;h3 id="visitor"&gt;Visitor&lt;/h3&gt;
&lt;p&gt;当集合中保存有实现了同一接口的多种类型的对象，而在遍历这些对象时，需要调用这些元素的具体类型上的方法时，可以使用 IVisitor 来实现，IVisitor 中的 visit 方法通过方法重载能处理集合中的各种类型。
Visitor 是基于方法重载而实现的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;IElement&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;accept&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IVisitor&lt;/span&gt; &lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//或&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;AbstractElement&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;accept&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IVisitor&lt;/span&gt; &lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;visit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;IVisitor&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;visit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ElementA&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;visit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ElementB&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;visit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ElementC&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;多线程相关&lt;/h2&gt;
&lt;h3 id="guarded-suspension"&gt;Guarded Suspension&lt;/h3&gt;
&lt;p&gt;举例：服务器需要处理来自多个客户端的请求，为了不丢失客户端的请求，它需要维持一个缓冲区，客户端的请求先被保存在缓冲区，服务器从缓冲区中读取请求并执行，如果缓冲区没有请求，服务器就一直等侍，直到有新的请求存入缓冲区。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RequestQueue&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LinkedList&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;synchronized&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt; &lt;span class="nf"&gt;getRequest&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;size&lt;/span&gt;&lt;span class="o"&gt;()&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;removeFirst&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;synchronized&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;putRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addLast&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;notifyAll&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="producer-consumer"&gt;Producer Consumer&lt;/h3&gt;
&lt;p&gt;它与 Guarded Suspension 是类似的，只不过 Guarded Suspension 模式并不限制缓冲区的长度，Producer Consumer 模式假设所生产的产品旋转在一个长度有限的缓冲区中。缓冲区满了，则生产者必须停止继续将产品放入缓冲区，直到消费者取走了产品而有了空间，如果缓冲区中没有产品，则消费者必须等侍，直到有新的产品放入缓冲区。&lt;/p&gt;
&lt;h3 id="worker-thread"&gt;Worker Thread&lt;/h3&gt;
&lt;p&gt;它对于 Request 的管理上像是 Producer Consumer 模式，而在 Request 的行为上像上 Command 模式。Consumer 取得 Request 之后，执行 Request 中指定的请求方法，也就是使用 Command 模式。
在这一模式下，通常 Request 缓冲区还管理了 Consumer，即在 Request 中有一个 WorkerThread 池，Consumer 初始化时会启动这个池中的所有线程，这些线程自己从 Consumer 中获取 Request（Command）, 并调用它的 exeucute 方法。当 Request 缓冲区中没有新的 Request 时，线程从缓冲区获取 Reuqest 的操作会被阻塞。&lt;/p&gt;
&lt;h3 id="thread-per-message"&gt;Thread-Per-Message&lt;/h3&gt;
&lt;p&gt;简单来说就是在某个请求发生时，生成一个执行线程来执行该请求，而主线程继续向下执行。&lt;/p&gt;
&lt;h3 id="future"&gt;Future&lt;/h3&gt;
&lt;p&gt;Future 模式可以看成 Proxy 模式与 Thread-Per-Message 模式的结合。Future 模式中在请求发生时，会先产生一个 Future 对象给发出请求的客户，它的作用就像是 Proxy 对象，与此同时，客户端真正需要的目标对象在一个新的线程（Thread-Per-Message）中开始创建，等到创建过程结束，就将它放入 Future 之中，当客户端真正需要该对象时，它就已经准备好了，可以让客户端提取。&lt;/p&gt;
&lt;h3 id="read-write-lock"&gt;Read-Write-Lock&lt;/h3&gt;
&lt;p&gt;简单来说就是读取和写入某个文件或对象时都需要先取得锁。这样可以保证读取方始终得到的是最新的数据。
可以在处理过程中添加类似 writeFirst 的标记，确保在读写请求都存在时写入请求先被执行。&lt;/p&gt;
&lt;h3 id="two-phase-termination"&gt;Two-phase Termination&lt;/h3&gt;
&lt;p&gt;两阶段终止，在线程的终止时使用两阶段终止，可以尽量让线程完成当前周期的工作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SomeThread&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;isContinue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;terminate&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;isTerminated&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;interrupt&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;beforeShutdown&lt;/span&gt;&lt;span class="o"&gt;(){}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;isTerminated&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;

            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;beforeShutdown&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="thread-specific-storage"&gt;Thread-Specific Storage&lt;/h3&gt;
&lt;p&gt;各个线程之间不共享资源，而是各自使用一个资源的副本，将每个线程的数据存储行为加以隔离。
举例：Java 中的 ThreadLocal。&lt;/p&gt;</content><category term="java"></category><category term="design pattern"></category></entry><entry><title>Practical Clojure 记笔</title><link href="/practical-clojure-ji-bi.html" rel="alternate"></link><published>2012-03-12T00:00:00+08:00</published><updated>2010-07-30T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2012-03-12:/practical-clojure-ji-bi.html</id><summary type="html">&lt;h1&gt;状态管理&lt;/h1&gt;
&lt;p&gt;Clojure主张消除状态管理。而现实世界仍要需要状态变化。&lt;/p&gt;
&lt;p&gt;多数语言将事物（things）描述为变量或对象，并允许修改它们。这造成了对锁的需求。&lt;/p&gt;
&lt;h2&gt;状态和identity&lt;/h2&gt;
&lt;p&gt;Clojure引入新的思考事物的哲学。它将事物分解为2个独立的概念&amp;mdash;&amp;mdash;状态和identity。状态是与identity关联的某一时间点的值，而identity是事物不会改变的那个部分，它会与不同时间的不同状态建立连接。每个状态下的值都是不可变的。改变通过将identity指向（refer）不同的状态入口而模拟产生的。&lt;/p&gt;
&lt;p&gt;Clojure中的状态可以是任何Clojure中的数据类型。Identity是由三种引用类型（reference type）所表示的：ref、agent、atom和var。每种都描述了一个identity并指向一个状态。分别用于不同的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ref管理同步的coordinated（协调）状态&lt;/li&gt;
&lt;li&gt;agent管理异步的independent（独立，不受约束）状态&lt;/li&gt;
&lt;li&gt;atom管理同步的independent状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Coordinated与Independent状态&lt;/h2&gt;
&lt;p&gt;许多系统都需要对identity的修改是以协调的方式进行以确保数据的完整性。Coordinated的修改方式下将管理多个独立的identities以确保所有修改都会同时进行。例如，在2个银行帐户间转帐操作时，钱存入一个帐号，必须也保证从另一个帐号减去相应的量，这两个动作必须同时发生。Clojure使用ref来提供这种coodinated状态。&lt;/p&gt;
&lt;p&gt;与coordinated状态管理对应的是independent状态。Independent identity只处理自身，而不与其它identities相关联 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;状态管理&lt;/h1&gt;
&lt;p&gt;Clojure主张消除状态管理。而现实世界仍要需要状态变化。&lt;/p&gt;
&lt;p&gt;多数语言将事物（things）描述为变量或对象，并允许修改它们。这造成了对锁的需求。&lt;/p&gt;
&lt;h2&gt;状态和identity&lt;/h2&gt;
&lt;p&gt;Clojure引入新的思考事物的哲学。它将事物分解为2个独立的概念&amp;mdash;&amp;mdash;状态和identity。状态是与identity关联的某一时间点的值，而identity是事物不会改变的那个部分，它会与不同时间的不同状态建立连接。每个状态下的值都是不可变的。改变通过将identity指向（refer）不同的状态入口而模拟产生的。&lt;/p&gt;
&lt;p&gt;Clojure中的状态可以是任何Clojure中的数据类型。Identity是由三种引用类型（reference type）所表示的：ref、agent、atom和var。每种都描述了一个identity并指向一个状态。分别用于不同的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ref管理同步的coordinated（协调）状态&lt;/li&gt;
&lt;li&gt;agent管理异步的independent（独立，不受约束）状态&lt;/li&gt;
&lt;li&gt;atom管理同步的independent状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Coordinated与Independent状态&lt;/h2&gt;
&lt;p&gt;许多系统都需要对identity的修改是以协调的方式进行以确保数据的完整性。Coordinated的修改方式下将管理多个独立的identities以确保所有修改都会同时进行。例如，在2个银行帐户间转帐操作时，钱存入一个帐号，必须也保证从另一个帐号减去相应的量，这两个动作必须同时发生。Clojure使用ref来提供这种coodinated状态。&lt;/p&gt;
&lt;p&gt;与coordinated状态管理对应的是independent状态。Independent identity只处理自身，而不与其它identities相关联。这仍然需要以某种方式进行控制，但是这种处理方式比起由多个identities参与的coodinating修改会要高效一些。修改independent的identities通常比修改coordinated的identities要快。Clojure提供了agent和atom来处理independent identity。&lt;/p&gt;
&lt;h2&gt;同步和异步更新&lt;/h2&gt;
&lt;p&gt;同步更新会使identities的值在同一线程中立即被修改。在修改操作完成之前将不会继续向下执行，这与多数程序员的需求是一致的。在Clojure中修改ref和atom时都是同步的。&lt;/p&gt;
&lt;p&gt;异步修改不会立即发生，但它会在未指定的将来（与修改点较近的）某个时间发生，通常是在另一线程中。代码将继续运行下去，而不等侍修改的完成。异步修改对于并行编程是非常有用的，特别对于基于事件的编程模型。但是Clojure并不保证异步更新具体在什么时候发生。Clojure中用agent来实现异步修改identities。&lt;/p&gt;
&lt;h2&gt;Ref和事务&lt;/h2&gt;
&lt;p&gt;Ref是Clojure中实现同步coordinated identities的机制。对每个identity的操作能在事务中进行，由事务保证各个identities的值在整个事务中处于一致的状态（不会被其它线程修改）。即STM。&lt;/p&gt;
&lt;p&gt;在事务之外修改ref将抛出错误。&lt;/p&gt;
&lt;h3 id="xiu-gai-ref"&gt;修改ref&lt;/h3&gt;
&lt;p&gt;有多个函数可以修改ref的值，它们的区别是在于性能方面。&lt;/p&gt;
&lt;h3 id="shi-wu"&gt;事务&lt;/h3&gt;
&lt;p&gt;Clojure的事务与数据库事务类似。同一事务中的修改操作是在同一时刻原子性地提交的。ref的值的一致性是有保证的。&lt;/p&gt;
&lt;p&gt;事务也是隔离的，没有事务能看到其它事务正在运行时的值。事务开始时，它获取所有参与事务的ref的值的快照。随后在事务之外对些值的修改也不会被事务中的代码看到，就好像事务中的进行的修改对于外部的世界完全不可见，直到它完成和提交。当然，事务中进行的修改对于同一事务中的其它代码是可见的。对一个处于事务中的ref进行取值时返回的总是ref的&amp;ldquo;in-transaction&amp;rdquo;（从下面的章节看，这个值应该是初次进入事务时的快照值）值，which reflects any updates that have been made since the beginning of the transaction。（前面这句不懂，难道是指能获取到事务中已经修改，但还未提交的值？这样就没达到隔离效果啊？）&lt;/p&gt;
&lt;p&gt;对于嵌套事务。内部的事务只是简单的变成外面事务的一部分，只到外面的事务提交了整个事务才提交。&lt;/p&gt;
&lt;p&gt;Clojure中的事务是采用的乐观锁。这意味着事务不会等侍其它事务执行完才开始。事务永远不会在等侍另一个更新时阻塞线程。当一个事务发现状态已经被另一个事务修改时，事务将被重试，它重新获取到新的值的快照并重新运行自己。由系统来确定提交的顺序，它保证不管对ref有多少个争用都会执行完。&lt;/p&gt;
&lt;p&gt;高并发的情况下将可能导致STM系统产生非常多的重试并导致它变慢。但是多数发问下它都比使用锁要快。在最坏的情况下设计完美的锁系统可能会比STM要快，但是Clojure还是认为STM所带来的认知负担的减轻和简单化的方案仍然是值得的。&lt;/p&gt;
&lt;p&gt;很多人可能会认为STM会带来内存管理和垃圾收集方面的问题：但是多数情况下它还是表现得足够快。&lt;/p&gt;
&lt;h3 id="geng-xin-refde-gong-ju"&gt;更新ref的工具&lt;/h3&gt;
&lt;p&gt;最重要的是dosync宏，它初始化事务并接收任意数量的forms。事务中的form被依次执行。最后一个form的值被作为事务提交后的返回值。如果任何一个form发生异常则整个事务终止且不会被提交。&lt;/p&gt;
&lt;p&gt;在dosync中使用ref-set来修改ref的状态。&lt;/p&gt;
&lt;p&gt;另一个修改ref的函数是alter。它接收一个ref和一个函数和任意数量的参数。传给alter的函数要注意，因为它有可能会在事务重试时多次被执行。&lt;/p&gt;
&lt;p&gt;最后一个函数是commute。它与alter用法类似，但有一个区别：在竟争性事务中，它也会重启整个事务，但它将会使用新值来进行重试，而不是使用in-transaction（in-transaction应该是表示初次执行事务时得到的快照）值。这意味着commute操作产生的争议会更少，在高竟态情况下能得到更好的性能。&lt;/p&gt;
&lt;p&gt;这也意味着commute操作并不能完美的支持事务隔离。如果传递给commute的函数逻辑上或者在数学上是交替的，那将不会有区别。&lt;/p&gt;
&lt;p&gt;交替函数是那些可能按任意顺序来调用而不会影响最终结果的函数&lt;/p&gt;
&lt;p&gt;还有另一个用于操作ref的函数：ensure。它接收单个参数，一个ref。与其它ref函数类似，它也只能用于事务中。与其它ref函数不同的是，它并不实际修改ref。它所做的是在事务中ref被修改则强制事务重试。当然，你将不会在事务中看到这种修改，因为事务的隔离性。但是，如果你不在事务中修改ref，则这个ref将不会被包含在最终提交的一致性保证中（我的理解是如果你在事务中不修改某个ref，则这个ref可以被其它事务所修改，从而触发ensure）。如果在一个事务之后基于coordination的原因你想要确保一个ref在你没有修改时不允许被更新，则可以在事务中使用ensure。&lt;/p&gt;
&lt;h2&gt;Atom&lt;/h2&gt;
&lt;p&gt;它是Clojure中的实现同步修改uncoordinated identities的实现。Atoms是基于java.util.concurrent.atomic中的Java类的。它提供了一种原子性的修改值的方法而不会被发生竞争条件下影响值修改的机制。但是与Java中的atomic包不同，Clojure中的atom是无锁的。读取atom是不会被阻塞的，而对atom的更新将会在atom正在进行更新操作之后重试，与ref类似。&lt;/p&gt;
&lt;p&gt;实际上，atom与ref是类似的，只是它不需要与其它ref协调工作，因此不需要特殊的事务处理。&lt;/p&gt;
&lt;h3 id="he-shi-shi-yong-atom"&gt;何时使用atom&lt;/h3&gt;
&lt;p&gt;对于独立的identity操作，它是最正确的选择。它是最轻量级的identity类型。&lt;/p&gt;
&lt;h2&gt;用于异步处理的agent&lt;/h2&gt;
&lt;p&gt;Agents是Clojure中独有的强大功能。对它的值的修改由专用的独立的由系统管理的线程池来异步的管理。&lt;/p&gt;
&lt;p&gt;这意味着agent不只是一种在并发环境下存储和管理状态的手仙，它也是一种在程序中引入并发的工具。使用agent时，不需要手工产生线程，管理线程池或者用其它方法显式地来进行并发编程。&lt;/p&gt;
&lt;h3 id="chuang-jian-he-shi-yong-agent"&gt;创建和使用agent&lt;/h3&gt;
&lt;p&gt;通过send或send-off向agent发送一个action函数来修改agent的值。&lt;/p&gt;
&lt;p&gt;send-off与send有完全相同的签名。唯一不同的是这两个函数会导致不同的性能表现。send用于CPU密集型的操作，而send-off用于会进行IO阻塞的耗时的操作。&lt;/p&gt;
&lt;h3 id="geng-xin-de-yu-yi"&gt;更新的语义&lt;/h3&gt;
&lt;p&gt;尽管agent不保证何时会执行更新，但是我们仍然可以使用下面的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传递给各个agent的actions是串行执行的，而不是并发的。在竟争条件下发送给同一agent的更新操作不会互相覆盖。&lt;/li&gt;
&lt;li&gt;由同一线程发送给同一agent的多个actions将会按发送的顺序被执行。但是对于由不同线程所发送的action则没有这种保证。&lt;/li&gt;
&lt;li&gt;如果一个action函数中包含了向其它agent或者自己发送action的代码。则这些agent具体发送会发生在action函数返回agent值已经被修改之后。这允许action触发其它action而不产生更新冲突。&lt;/li&gt;
&lt;li&gt;如果一个对agent发送的更新操作发生在STM事务之中，则发送动作在事务提交之前不会产生。这意味着在STM事务中可以安全将动作发送给atom（这里为什么是atom呢？）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="agentde-cuo-wu-chu-li"&gt;Agent的错误处理&lt;/h3&gt;
&lt;p&gt;由于action是在独立线程中异步执行的，因此需要一个特殊的错误处理机制。&lt;/p&gt;
&lt;p&gt;Agent有两种可能的失败处理模型:fail或者:continue。如果是:continue，则在调用错误处理函数之后，action会继续执行就像action导致的异常从来没发生过。如果是:fail，则agent会牌failed状态，并且不会再接收其它的action，直到它被重启（仍然会保留当前的action队列）。&lt;/p&gt;
&lt;p&gt;通常agent会使用:continue模式，并且带有错误处理函数。否则就是默认的:fail模式。&lt;/p&gt;
&lt;h3 id="chu-li-agentde-failedzhuang-tai"&gt;处理Agent的failed状态&lt;/h3&gt;
&lt;p&gt;restart-agent&lt;/p&gt;
&lt;h3 id="deng-shi-agent"&gt;等侍agent&lt;/h3&gt;
&lt;p&gt;尽管agent是异步处理的，但是有时仍然可能需要等侍某个agent更新结果。可以用await和await-for来等侍agent的操作。&lt;/p&gt;
&lt;h3 id="guan-bi-agent"&gt;关闭agent&lt;/h3&gt;
&lt;p&gt;shutdown-agents应该在应用程序关闭之前执行，因为在这之后，所有send和send-off都将导致异常。&lt;/p&gt;</content><category term="clojure"></category></entry><entry><title>Practical Common Lisp笔记</title><link href="/practical-common-lispbi-ji.html" rel="alternate"></link><published>2011-06-03T00:00:00+08:00</published><updated>2011-06-03T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2011-06-03:/practical-common-lispbi-ji.html</id><summary type="html">&lt;h1&gt;环境搭建&lt;/h1&gt;
&lt;p&gt;尝试了多种common lisp的实现，在windows下使用Lispbox时并不能使用slime。而gnu common lisp和ansi common lisp好像也不能在windows中与emacs 23和slime一起工作。结果发现只有gnu clisp的win32版本可以与win32 slime emacs23配合工作。emacs23的.emacs文件如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-to-list&lt;/span&gt; &lt;span class="ss"&gt;'load-path&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nv"&gt;site-lisp-path&lt;/span&gt; &lt;span class="s"&gt;"/slime"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;;;(setq inferior-lisp-program "D:\\GCL-2.6.1\\bin\\gcl.bat") ; your Lisp system&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;inferior-lisp-program&lt;/span&gt; &lt;span class="s"&gt;"D:/clisp-2.46/clisp.exe"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="ss"&gt;'slime&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;slime-setup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Introduction Why Lisp?&lt;/h1&gt;
&lt;h1&gt;Lather, Rinse, Repeat: A …&lt;/h1&gt;</summary><content type="html">&lt;h1&gt;环境搭建&lt;/h1&gt;
&lt;p&gt;尝试了多种common lisp的实现，在windows下使用Lispbox时并不能使用slime。而gnu common lisp和ansi common lisp好像也不能在windows中与emacs 23和slime一起工作。结果发现只有gnu clisp的win32版本可以与win32 slime emacs23配合工作。emacs23的.emacs文件如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-to-list&lt;/span&gt; &lt;span class="ss"&gt;'load-path&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nv"&gt;site-lisp-path&lt;/span&gt; &lt;span class="s"&gt;"/slime"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;;;(setq inferior-lisp-program "D:\\GCL-2.6.1\\bin\\gcl.bat") ; your Lisp system&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;inferior-lisp-program&lt;/span&gt; &lt;span class="s"&gt;"D:/clisp-2.46/clisp.exe"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="ss"&gt;'slime&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;slime-setup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Introduction Why Lisp?&lt;/h1&gt;
&lt;h1&gt;Lather, Rinse, Repeat: A Tour of the REPL&lt;/h1&gt;
&lt;p&gt;使用SLIME来编辑Lisp程序。&lt;/p&gt;
&lt;h2&gt;选择一个Lisp实现&lt;/h2&gt;
&lt;p&gt;与其它语言同Common Lisp是通过规范定义的不只有一个实现。&lt;/p&gt;
&lt;p&gt;使用标准的Common Lisp可以获得较好的通用性，可以在不同的实现上运行。&lt;/p&gt;
&lt;p&gt;某些Common Lisp实现针对特定的方面有所增强，可以根据需要来选择。&lt;/p&gt;
&lt;p&gt;在不同的平台上可以选择不同的实现Franz开发的Allegro Common Lisp在Linux，Windows和OS X上都有试用版本。SBCL是一个高质量的开源实现，它可以在多种Unix系统，包括Linux和OS X上将代码编译为本机代码执行。SBCL是从CMUCL派生出来的，CMUCL是Carnegie Mellon University开发的。CMUCL自身也是另一个较好选择，SBCL易于安装，运行21-bit Unicode。对于OS X用户，OpenMCL是一个优秀的选择&amp;mdash;&amp;mdash;它编译为本机代码，支持线程，并且与OS X的Carbon和Cocoa工具包集成得很好。&lt;/p&gt;
&lt;p&gt;书中所有代码应该都能运行于任何Common Lisp实现，SLIME也将消除不同实现间的差异以提供一个公共的Lisp界面。书中的例子的输出来自于运行在GNU/Linux上的Allegro；某些情况可能会产生一些不同的的错误或调试信息。&lt;/p&gt;
&lt;h2&gt;Lisp in a Box&lt;/h2&gt;
&lt;p&gt;Lisp in a Box包用于提供给初学者使用。它使用Emacs作为编辑器。&lt;/p&gt;
&lt;p&gt;在SLIME中可以使用C-c C-z切换到与Lisp解释器交互的缓冲区。&lt;/p&gt;
&lt;h2&gt;交互式的编程&lt;/h2&gt;
&lt;p&gt;REPL是read-eval-print loop的简写。&lt;/p&gt;
&lt;h2&gt;Lisp风格的"Hello, World"&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; "hello, world"
"hello, world"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lisp读取双引号中的字符串，求值时它显示同样的格式的字符串。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (format t "hello, world")
hello, world
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FORMAT可带多个参数，但只有两个是必须的，分别是发送的目标和一个字符串。NIL表示FORMAT的返回值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (defun hello-world () (format t "hello, world"))
HELLO-WORLD
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DEFUN后的hello-world是函数名称。Common Lisp中符号名称使用-是合法的。&lt;/p&gt;
&lt;h2&gt;保存代码&lt;/h2&gt;
&lt;p&gt;SLIME REPL中可以使用C-c C-l调用slime-load-file，或者在REPL中用(load "file.lisp")加载文件中的代码。C-c C-z在SLIME中切换到REPL中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (load (compile-file "hello.lisp"))
;;; Compiling file hello.lisp
;;; Writing fasl file hello.fasl
;;; Fasl write complete
; Fast loading /home/peter/my-lisp-programs/hello.fasl
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加载文件之前也可以使用COMPILE-FILE将文件转换为FASL（fast-load file的简称）文件，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (load (compile-file "hello.lisp"))
;;; Compiling file hello.lisp
;;; Writing fasl file hello.fasl
;;; Fasl write complete
; Fast loading /home/peter/my-lisp-programs/hello.fasl
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这种方式并不一定会加快加载的速度，因为有些Common Lisp实现总是会自动编译文件。可以在SLIME中输入C-c C-k将当前缓冲区对应的文件编译为FASL文件将重新加载。&lt;/p&gt;
&lt;p&gt;在修改的函数上按C-c C-c重新编译函数定义将会立即反应到REPL中。&lt;/p&gt;
&lt;h1&gt;实践：一个简单的数据库&lt;/h1&gt;
&lt;p&gt;本章将逐渐创建一个CD数据库。&lt;/p&gt;
&lt;h2&gt;CD和记录集&lt;/h2&gt;
&lt;p&gt;为保存单张CD记录我们需要将它描述为一条数据库记录。Common Lisp提供了许多保存结构化数据的选择。&lt;/p&gt;
&lt;p&gt;使用LIST函数创建一个list。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (list 1 2 3)
(1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种list叫作property list，简称为plist。用plist保存CD记录更合适一些。plist中的元素以一个symbol开头，这个symbol描述了list中的下一个元素（这里不讨论什么是symbol，根本上来说它是一个名称）。使用symbol来以CD数据库中的字段命名，这里可以使用一种特殊的symbol，这种symbol被称为keyword symbol。keyword是以冒号开头的名称，例如，:foo。下面是一个以keyword symbol作为plist的property name的list：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (list :a 1 :b 2 :c 3)
(:A 1 :B 2 :C 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建plist时也是使用LIST函数。&lt;/p&gt;
&lt;p&gt;使得plist更适合于描述数据库记录的是GETF函数，这个函数接收一个plist和symbol，返回plist中这个symbol后面值，这使得plist像类种贫血的hash table。Lisp有真正hash table，但是plist在这里已经够用了并且它易于保存于文件中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (getf (list :a 1 :b 2 :c 3) :a)
1
CL-USER&amp;gt; (getf (list :a 1 :b 2 :c 3) :c)
3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以编写一个函数make-cd来接收四个参数并返回一个plist来描述CD了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun make-cd (title artist rating ripped)
  (list :title title :artist artist :rating rating :ripped ripped))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DEFUN关键字告诉我们这个form正在定义一个新的函数。函数名是make-cd。函数名后是参数列表。这个函数有四个参数。参数列表后面函数体。这个函数的使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (make-cd "Roses" "Kathy Mattea" 7 t)
(:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;整理CD&lt;/h2&gt;
&lt;p&gt;单个记录还不能构成数据库。因此需要一些大型的结构来保存记录集。list看起来仍然是不错的选择。这里使用DEFVAR宏定义全局变量&lt;em&gt;db&lt;/em&gt;。星号在Lisp命名约定中表示全局变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defvar *db* nil)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用PUSH宏向&lt;em&gt;db&lt;/em&gt;中添加项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun add-record (cd) (push cd *db*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以结合使用add-record和make-cd来将CD添加到数据库。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (add-record (make-cd "Roses" "Kathy Mattea" 7 t))
((:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))
CL-USER&amp;gt; (add-record (make-cd "Fly" "Dixie Chicks" 8 t))
((:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
 (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))
CL-USER&amp;gt; (add-record (make-cd "Home" "Dixie Chicks" 9 t))
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
 (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在REPL中将显示每次添加新记录后的返回值。&lt;/p&gt;
&lt;h2&gt;查看数据库内容&lt;/h2&gt;
&lt;p&gt;虽然可以在REPL中输入&lt;em&gt;db&lt;/em&gt;查看&lt;em&gt;db&lt;/em&gt;的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; *db*
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
 (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但更好的办法是写一个dump-db函数以便于阅读的格式显示出数据库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TITLE&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;Home&lt;/span&gt;
&lt;span class="n"&gt;ARTIST&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;Dixie&lt;/span&gt; &lt;span class="n"&gt;Chicks&lt;/span&gt;
&lt;span class="n"&gt;RATING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="n"&gt;RIPPED&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;T&lt;/span&gt;

&lt;span class="n"&gt;TITLE&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;Fly&lt;/span&gt;
&lt;span class="n"&gt;ARTIST&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;Dixie&lt;/span&gt; &lt;span class="n"&gt;Chicks&lt;/span&gt;
&lt;span class="n"&gt;RATING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;RIPPED&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;T&lt;/span&gt;

&lt;span class="n"&gt;TITLE&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;Roses&lt;/span&gt;
&lt;span class="n"&gt;ARTIST&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;Kathy&lt;/span&gt; &lt;span class="n"&gt;Mattea&lt;/span&gt;
&lt;span class="n"&gt;RATING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;RIPPED&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;T&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun dump-db ()
  (dolist (cd *db*)
    (format t "~{~a:~10t~a~%~}~%" cd)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数使用DOLIST宏遍历&lt;em&gt;db&lt;/em&gt;中的元素，将每个元素依次绑定到变量cd。并使用FORMAT函数打印cd。&lt;/p&gt;
&lt;p&gt;FORMAT接收至少两个参数，第一个是它要输出的流；t是&lt;em&gt;standard-output&lt;/em&gt;的简写形式。&lt;/p&gt;
&lt;p&gt;第二个参数是一个格式字符串，它包含纯文本和告诉FORMAT函数如何显示其它参数的转义字符。转义字符以~开头（与printf中的%类似）。FORMAT函数有许多的转义字符。在这里只了解编写dump-db需要的转义符。&lt;/p&gt;
&lt;p&gt;~a是一个美化转义符；它消耗掉一个参数并将它以便于阅读的形式输出。这将使输出不包含:和引号。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (format t "~a" "Dixie Chicks")
Dixie Chicks
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (format t "~a" :title)
TITLE
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;~t转义符表示缩进。~10t告诉FORMAT在处理下一个~a前缩进足够的空间到第10列。另外，~t不消耗任何参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (format t "~a:~10t~a" :artist "Dixie Chicks")
ARTIST:   Dixie Chicks
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当FORMAT遇到~{时下个被消耗的参数必须是一个list。FORMAT将遍历这个list，以~{和~}间的转义符处理list中的每个元素。~%转义符不消耗任何参数但它使得FORMAT进行换行。~}之前的那个~%在输出数据库的一个字段后换行。~}之后的那个~%在输出一条记录后换行。&lt;/p&gt;
&lt;p&gt;技术上来说，可以让FORMAT自己来遍历数据库，将dump-db函数写为一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun dump-db ()
  (format t "~{~{~a:~10t~a~%~}~%~}" *db*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常cool。&lt;/p&gt;
&lt;h2&gt;改进用户交互&lt;/h2&gt;
&lt;p&gt;在用户需要添加很多记录时将需要提示帮助用户录入CD。因此需要一些提示用户输入并读入输出的方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun prompt-read (prompt)
  (format *query-io* "~a: " prompt)
  (force-output *query-io*)
  (read-line *query-io*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用FORMAT提示输入。调用FORCE-OUTPUT确保提示显示出来。&lt;/p&gt;
&lt;p&gt;使用READ-LINE函数读取单行文本。&lt;em&gt;query-io&lt;/em&gt;是一个全局变量，它包含连接的终端的输入。prompt-read的返回值是最后一个form的值，READ-LINE返回读取的字符串（不包含换行符）。&lt;/p&gt;
&lt;p&gt;可以结合make-cd和prompt-read构建一个函数根据输入来构建一个新的CD记录。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun prompt-for-cd ()
  (make-cd
   (prompt-read "Title")
   (prompt-read "Artist")
   (prompt-read "Rating")
   (prompt-read "Ripped [y/n]")))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有两个问题，Rating和Ripped字符，应该分别是number和boolean型。在这里我们只简单的处理一下：以PARSE-INTEGER函数处理rating：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(parse-integer (prompt-read "Rating"))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PARSE-INTEGER在将字符串解析为integer失败时出错。它有一个可选参数:junk-allowed，它不会出错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(parse-integer (prompt-read "Rating") :junk-allowed t)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但仍然有一个问题：如果它不仍不能解析，PARSE-INTEGER将返回NIL而不是一个number。在这里我们简单的将它处理为0并继续执行程序。Lisp的OR宏可以处理个，这接受一连串的表达式，依次执行表达式，并返回第一个non-nil值（或NIL，如果它们全为NIL）。因此你可以使用下面的表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置默认值为0。&lt;/p&gt;
&lt;p&gt;修正Ripped则简单一些。可以使用Common Lisp函数Y-OR-N-P。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(y-or-n-p "Ripped [y/n]: ")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上，这将是prompt-for-cd中最健壮的部分，如果用户的输入是心y，Y，n或N开头Y-OR-N-P将一直提示用户。&lt;/p&gt;
&lt;p&gt;完整的prompt-for-cd函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun prompt-for-cd ()
  (make-cd
   (prompt-read "Title")
   (prompt-read "Artist")
   (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
   (y-or-n-p "Ripped [y/n]: ")))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，可以用循环将prompt-for-cd函数包装起来，反复提示用户录入CD。这可以通过使用LOOP宏，它重复执行它的body表达式，直到它使用RETURN退出。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun add-cds ()
  (loop (add-record (prompt-for-cd))
      (if (not (y-or-n-p "Another? [y/n]: ")) (return))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以使用add-cds添加更多的CD到数据库了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (add-cds)
Title: Rockin' the Suburbs
Artist: Ben Folds
Rating: 6
Ripped  [y/n]: y
Another?  [y/n]: y
Title: Give Us a Break
Artist: Limpopo
Rating: 10
Ripped  [y/n]: y
Another?  [y/n]: y
Title: Lyle Lovett
Artist: Lyle Lovett
Rating: 9
Ripped  [y/n]: y
Another?  [y/n]: n
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;保存和装载数据库&lt;/h2&gt;
&lt;p&gt;保存数据库save-db函数接收一个文件名作为参数并保存当前的数据库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun save-db (filename)
  (with-open-file (out filename
                   :direction :output
                   :if-exists :supersede)
    (with-standard-io-syntax
      (print *db* out))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WITH-OPEN-FILE宏打开一个文件，将流绑定到一个变量，执行一组表达式，并关闭文件。它将确保文件被关闭，即使在执行它的body过程中出现了错误。WITH-OPEN-FILE后面list不是一个函数调用而是WITH-OPEN-FILE定义的语法的一部分。它包含了保存文件流的变量名，它用于在WITH-OPEN-FILE的body中进行写入操作；还有文件名和一些控制如何打开文件的选项。比如用于指定以写入方式打开文件的选项:direction :output和用于覆盖已经存在的文件的选项:if-exists :supersede。&lt;/p&gt;
&lt;p&gt;打开文件后，只需使用&lt;code&gt;(print *db* out)&lt;/code&gt;要将内容print到数据库。与FORMAT不同的是PRINT输出的Lisp对象可以被Lisp reader读取为Lisp对象。宏WITH-STANDARD-IO-SYNTAX确保某些变量的值，这使得PRINT的行为表现为标准的状态。在将数据读取回来时为保证Lisp reader和printer的操作的兼容将需要使用相同的宏。&lt;/p&gt;
&lt;p&gt;save-db的参数是一个包含了要保存数据库的文件名。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (save-db "~/my-cds.db")
((:TITLE "Lyle Lovett" :ARTIST "Lyle Lovett" :RATING 9 :RIPPED T)
 (:TITLE "Give Us a Break" :ARTIST "Limpopo" :RATING 10 :RIPPED T)
 (:TITLE "Rockin' the Suburbs" :ARTIST "Ben Folds" :RATING 6 :RIPPED
  T)
 (:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
 (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 9 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读取数据库的函数与写入的函数是相类似的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun load-db (filename)
  (with-open-file (in filename)
    (with-standard-io-syntax
      (setf *db* (read in)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里在没有在WITH-OPEN-FILE中指定:direction选项，因为它的默认值就是:input。这里的READ函数用于从流in中读取。这个reader与REPL中使用的reader是相同的可以读取任何能在REPL中使用的Lisp表达式。但是在这个函数里只是读取和保存表达式，并没有对它求值。通过使用WITH-STANDARD-IO-SYNTAX宏确保了READ使用与save-db中的PRINT相同的规则来读取。&lt;/p&gt;
&lt;p&gt;SETF宏是Common Lisp中主要的赋值操作符。它设置它的第一个参数为第二个参数的求值结果。因此，load-db的&lt;code&gt;*db*&lt;/code&gt;变量将包含从文件中读取的对象，即由save-db写入的由list构成的多个list。&lt;/p&gt;
&lt;h2&gt;查询数据库&lt;/h2&gt;
&lt;p&gt;在有了用于添加数据的UI界面和保存、装载数据的功能后。你将需要一个查询数据库的方法。例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(select :artist "Dixie Chicks")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以获取artist为Dixie Chicks的记录的list。&lt;/p&gt;
&lt;p&gt;函数REMOVE-IF-NOT以predicate和list为参数返回list中与predicate匹配的元素的list。REMOVE-IF-NOT并不从list中删除元素而是创建一个新的list，原始的list并不会被改变。predicate参数可以是任何接收单个参数并返回boolean值（NIL为false，其它值为true）的函数。&lt;/p&gt;
&lt;p&gt;例如，提取list中的偶数元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9 10))
(2 4 6 8 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里predicate是函数EVENP，如果它的参数为偶数则返回true。#'标记的含义是&amp;ldquo;获取后面名称的函数&amp;rdquo;。如果没有#'，Lisp会将evenp变量名并查找这个变量的值，而不会把evenp函数。&lt;/p&gt;
&lt;p&gt;另外，也可以向REMOVE-IF-NOT函数传递匿名函数。比如，如果EVENP不存在，你可以将前面的表达式修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (remove-if-not #'(lambda (x) (= 0 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10))
(2 4 6 8 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LAMBDA表达式看起来有点像一个DEFUN语句：关键字lambda后面跟参数列表，然后是函数体。&lt;/p&gt;
&lt;p&gt;为了使用REMOVE-IF-NOT函数从数据库中查找记录，还需要一个函数来检查记录的artist字段是否为&amp;ldquo;Dixie Chicks&amp;rdquo;。我们可以使用GETF从plist中获取特定的字段。使用EQUAL检查字符串是否相等。因此，&lt;code&gt;(equal (getf cd :artist) "Dixie Chicks")&lt;/code&gt;可以测试CD的artist字段是否为&amp;ldquo;Dixie Chicks&amp;rdquo;。现在只需要将这个表达式封装为lambda表达式并传递给REMOVE-IF-NOT。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (remove-if-not
  #'(lambda (cd) (equal (getf cd :artist) "Dixie Chicks")) *db*)
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将整个表达式封装到函数中，这个函数只需要artist参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun select-by-artist (artist)
  (remove-if-not
   #'(lambda (cd) (equal (getf cd :artist) artist))
   *db*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意匿名函数，它包含的代码只有在REMOVE-IF-NOT中被调用时才会运行，它能够访问artist变量。在这里，匿名函数不仅使得避免了编写正式的函数，也使得你编写的函数只在它所嵌入的上下文中才有含义。&lt;/p&gt;
&lt;p&gt;现在select-by-artist已经完成了。但通过artist查询只是你需要的查询方式中的一种。可以编写select-by-title，select-by-rating，select-by-title-and-artis，等等。但它们除了匿名函数外基本是相同的。我们可以写一个更通用的以一个函数为参数的select函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun select (selector-fn)
  (remove-if-not selector-fn *db*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里不需要#'。因为这里的REMOVE-IF-NOT需要使用selector-fn函数。这里需要使用匿名函数作为参数。因此，#'重新出现在对select的调用中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (select #'(lambda (cd) (equal (getf cd :artist) "Dixie Chicks")))
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这看起来仍然不美观。我们可以将匿名函数的创建封装起来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun artist-selector (artist)
  #'(lambda (cd) (equal (getf cd :artist) artist)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数返回一个指向函数的变量。对于不同的artist参数这个函数将返回不同的函数来匹配不同的artist。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (select (artist-selector "Dixie Chicks"))
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们需要更多的函数来生成选择器函数。但这又将导致重复代码的产生，并且它们不能处理组合查询条件。我们需要一个函数根据字段或多个字段生成选择器函数。为实现这个目标，我们需要先了解keyword parameter。&lt;/p&gt;
&lt;p&gt;通常的函数结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (a b c) (list a b c))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它包含了一个参数列表。有时我们需要编写的函数支持可变数量的参数。Keyword parameter就是用于这个目的的。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (&amp;amp;key a b c) (list a b c))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与上一个例子不同之处在于&amp;amp;key。但是，在调用方式上却有些不同。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo :a 1 :b 2 :c 3)  ==&amp;gt; (1 2 3)
(foo :c 3 :b 2 :a 1)  ==&amp;gt; (1 2 3)
(foo :a 1 :c 3)       ==&amp;gt; (1 NIL 3)
(foo)                 ==&amp;gt; (NIL NIL NIL)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在面的代码中，传了值的将被绑定到对应的参数上，未传递的值为NIL。为了区分NIL值是传递过来的参数值还是由于没有传递参数而产生的默认NIL值，我们可以使用另一个称为supplied-p的参数。根据keyword parameter是否显式的传递了参数，suupplied-p参数将被设置为true或false。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (&amp;amp;key a (b 20) (c 30 c-p)) (list a b c c-p))
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo :a 1 :b 2 :c 3)  ==&amp;gt; (1 2 3 T)
(foo :c 3 :b 2 :a 1)  ==&amp;gt; (1 2 3 T)
(foo :a 1 :c 3)       ==&amp;gt; (1 20 3 T)
(foo)                 ==&amp;gt; (NIL 20 30 NIL)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回到上面通用选择器函数生成器的问题，我们可以像使用SQL数据库一样来使用select：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(select (where :artist "Dixie Chicks"))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(select (where :rating 10 :ripped nil))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun where (&amp;amp;key title artist rating (ripped nil ripped-p))
  #'(lambda (cd)
      (and
       (if title    (equal (getf cd :title)  title)  t)
       (if artist   (equal (getf cd :artist) artist) t)
       (if rating   (equal (getf cd :rating) rating) t)
       (if ripped-p (equal (getf cd :ripped) ripped) t))))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;更新数据库记录&amp;mdash;&amp;mdash;再次使用WHERE&lt;/h2&gt;
&lt;p&gt;更新函数的原理：使用传入的选择器函数选出需要修改的数据库记录并使用keyword arguments指定要修改的值。主要不同的一点在于使用MAPCAR来操作list，并返回一个新的包含调用结构的list。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun update (selector-fn &amp;amp;key title artist rating (ripped nil ripped-p))
  (setf *db*
        (mapcar
         #'(lambda (row)
             (when (funcall selector-fn row)
               (if title    (setf (getf row :title) title))
               (if artist   (setf (getf row :artist) artist))
               (if rating   (setf (getf row :rating) rating))
               (if ripped-p (setf (getf row :ripped) ripped)))
             row) *db*)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里另一个不同之处在于将SETF用于了一个复杂的form，如(getf row :title)。后面将详细讨论SETF，这里只需要知道它是一个通用赋值操作符可以用于很多情况而不只是变量。这里在执行(setf (getf row :title) title)后，row变量保存的plist的:title属性值将被设置为title变量的值。&lt;/p&gt;
&lt;p&gt;更新函数的使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (update (where :artist "Dixie Chicks") :rating 11)
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们甚至可以为数据库添加一个简单的delete函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun delete-rows (selector-fn)
  (setf *db* (remove-if selector-fn *db*)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;REMOVE-IF与REMOVE-IF-NOT相反；它返回的list中，在原始list中与selector-fn匹配的元素已经被删除了。&lt;/p&gt;
&lt;h2&gt;移除重复代码获取更大胜利&lt;/h2&gt;
&lt;p&gt;到现在数据库已经支持insert，select，update和delete，并且还有一个用户界面供添加新记录，支持保存到文件和从文件加载。&lt;/p&gt;
&lt;p&gt;但是仍然存在一些重复代码。重复代码存在于where函数中。where函数中对每个字段都编写了类似的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(if title (equal (getf cd :title) title) t)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们改变CD的字段，就需要添加或删除where条件。update中也存在着类似的重复。&lt;/p&gt;
&lt;p&gt;如果我们需要优化代码想像一下每次都检查title或其它keyword parameter是否存在是否会消耗过多的资源？你需要返回的匿名函数只执行必须的计算。例如，下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(select (where :title "Give Us a Break" :ripped t))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应该修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(select
 #'(lambda (cd)
     (and (equal (getf cd :title) "Give Us a Break")
          (equal (getf cd :ripped) t))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这里仍然只能针对特定查询。&lt;/p&gt;
&lt;p&gt;使用Lisp的macro系统能轻松的满足上面的要求。Lisp中的macro与C/C++中的macro只是使用了相同的名称其本质是不同的。C预处理器根据文本进行替换，对于C/C++结构并不了解。Lisp macro本质上是一个代码生成器，由编译自动为你运行。当Lisp表达式包含了一个macro调用时，Lisp不会对表达式求值并将它传递函数。Lisp编译器将传递未求值的参数给macro代码，它将返回新的Lisp表达式，然后在macro被调用的地方被求值。&lt;/p&gt;
&lt;p&gt;为了编写一个简单的macro示例，需要先介绍一个新函数：REVERSE它接收list为参数并返回一个新的逆序的list。(reverse '(1 2 3))求值为(3 2 1)。现在定义一个macro：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro backwards (expr) (reverse expr))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语法上来看函数和宏的定义区别在于DEFMACRO和DEFUN，后面的名称、参数列表、body表达式都与函数类似。但宏与函数是完全不同的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (backwards ("hello, world" t format))
hello, world
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的macro是如何工作的呢？当REPL开始对backwards语句求值时，它识别出backwards是一个宏的名字。因此它不对表达式("hello, world" t format)求值，这很好因为它不是一个合法Lisp form。然后它将这个list传到backwards的代码中。backwards中的代码将这个list传递给REVERSE函数，它返回新的list (format t "hello, world")。backwards将这个值返回给REPL，然后它被进行求值。&lt;/p&gt;
&lt;p&gt;backwards macro定义了一个新的语言它与Lisp类似只是逆序的。对于一个已经编译过的Lisp程序，这个新语言效率上与原始的Lisp同样有效因为所有的macro代码&amp;mdash;&amp;mdash;用于生成新表达式的代码&amp;mdash;&amp;mdash;在编译时被执行。换言之，编译器将对(backwards ("hello, world" t format))和(format t "hello, world")生成相同的代码。&lt;/p&gt;
&lt;p&gt;在数据库示例的选择器函数生成器中。我们可以编写macro来根据特殊的参数生成所需要的函数。我们手工针对某个字段的优化代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(equal (getf cd field) value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以编写一个函数，给定字段名和值，返回类似上面的表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun make-comparison-expr (field value)    ; wrong
  (list equal (list getf cd field) value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有一个问题：Lisp遇到某个名称，比如field或value它不会将它们作为list中的第一个元素，它会认为它是一个变量名并查找它的值。这对于field和value不会有问题。但是你应该知道如何阻止Lisp进行求值：在名称前添加单引号（'）。因些，如下编写make-comparison-expr将是需要的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun make-comparison-expr (field value)
  (list 'equal (list 'getf 'cd field) value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有一个更好的方法来完成上面的函数。使用反单引号（`）使得列表中只有少数表达式被求值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; `(1 2 3)
(1 2 3)
CL-USER&amp;gt; '(1 2 3)
(1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过在前面添加逗号（,）对表达式进行求值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;`(1 2 (+ 1 2))        ==&amp;gt; (1 2 (+ 1 2))
`(1 2 ,(+ 1 2))       ==&amp;gt; (1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用反单引号可以将make-comparison-expr编写为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun make-comparison-expr (field value)
  `(equal (getf cd ,field) ,value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面的手工编写的选择器函数使用AND表达式将多个field/value封装。在这里可以将参数组织为where macro的一个参数，这个参数只是一个list。我们还需要一个函数从list中获取成对的参数并在每对参数上调用make-comparison-expr。为了实现个功能，我们可以使用LOOP macro。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun make-comparisons-list (fields)
  (loop while fields
     collecting (make-comparison-expr (pop fields) (pop fields))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面将详细讨论LOOP。这里只需要知道：如果list中还有元素它将一直循环，在每个周期中将popping两将并将值传递给make-comparison-expr，将结果收集起来直到循环结束后作为返回值。POP macro执行与PUSH macro相反的操作。&lt;/p&gt;
&lt;p&gt;现在只需要将make-comparison-list的结果用AND封装到匿名函数中，这可以在where macro中定义。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro where (&amp;amp;rest clauses)
  `#'(lambda (cd) (and ,@(make-comparisons-list clauses))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在调用make-comparisons-list前使用了逗号（,）的一个变种&amp;ldquo;接合&amp;rdquo;（,@）。它将一个list连接到外部的list中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;`(and ,(list 1 2 3))   ==&amp;gt; (AND (1 2 3))
`(and ,@(list 1 2 3))  ==&amp;gt; (AND 1 2 3)
`(and ,@(list 1 2 3) 4) ==&amp;gt; (AND 1 2 3 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where macro上另一个重要的功能是在参数列表中使用了&amp;amp;rest。与&amp;amp;key类似&amp;amp;rest将修改参数的解析方式。通过在参数列表中使用&amp;amp;rest，函数或宏可以接收任意数量的参数，这些参数被收集到一个list中，它被命名为&amp;amp;rest后面名称。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(where :title "Give Us a Break" :ripped t)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;产生的变量将包含下面的list。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(:title "Give Us a Break" :ripped t)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个list被传递到make-comparisons-list中，它返回包含比较表达式的list。可以使用函数MACROEXPAND-1来查看将产生什么样的调用。如果传递给MACROEXPAND-1的form是macro，它将使用适当的参数调用macro代码并返回展开的表达式。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (macroexpand-1 '(where :title "Give Us a Break" :ripped t))
#'(LAMBDA (CD)
    (AND (EQUAL (GETF CD :TITLE) "Give Us a Break")
         (EQUAL (GETF CD :RIPPED) T)))
T
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;语法和语义&lt;/h1&gt;
&lt;h2&gt;关于括号&lt;/h2&gt;
&lt;p&gt;历史原因：当John McCarthy首次发明Lisp时，他正致力于实现个更Algol-like的语法，他称之为M-expression。但是，他从来就没有达成。&lt;/p&gt;
&lt;p&gt;Lisp使用这种语法已经超过45年了你将发现它的强大之处。&lt;/p&gt;
&lt;h2&gt;黑盒子&lt;/h2&gt;
&lt;p&gt;计算机语言处理器&amp;mdash;&amp;mdash;解释器或编译器的操作都像一个黑盒。其中有一个子系统将程序转换为abstract syntax tree然后将语法树进行解释或编译。由于语言处理器是一个黑盒，通常只有语言的实现者才感兴趣。&lt;/p&gt;
&lt;p&gt;而Common Lisp定义了两个黑盒，一个负责将文本转换为Lisp对象，另一个处理这些对象的语义。第一个黑盒称为reader，第二个称为evaluator。&lt;/p&gt;
&lt;p&gt;定义字符串如何被解释为Lisp对象的是s-expression语法，它与非Lisp语言的解析器（parser）生成的抽像语法树类似，可以描述任意的树状表达式。&lt;/p&gt;
&lt;p&gt;Lisp reader懂得s-expression的语法而Lisp evaluator懂得Lisp forms的语法。&lt;/p&gt;
&lt;h2&gt;S-expressions&lt;/h2&gt;
&lt;p&gt;由lists和atoms构成。List由括号分隔可以包含任意数量的以空白分隔的元素。Atoms是除list之外的任何东西。Lists的元素也是s-expressions（atoms或lists）。注释以分号开头直至行尾。&lt;/p&gt;
&lt;p&gt;最常用的几种atoms：数字、字符串和名字。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数字：以+或-号开头，包含.或/，或以指数标识结尾的数字序列被读取为数字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串：以双引号包含。内部可以有以\开头的转义字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;名字：在Lisp程序中用于标识对象的符号。比如FORMAT、hello-world、&lt;em&gt;db&lt;/em&gt;等等。在读取名字时，reader将所有字符转换为大写。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为保证名字的唯一性，reader在读取名字并将它转为大写后将interns符号，reader从被称为package的table中查找是否存在同名的符号。如果未找到它就创建一个符，否则它将返回table中已经存在的符号。&lt;/p&gt;
&lt;h2&gt;S-expression作为Lisp Forms&lt;/h2&gt;
&lt;p&gt;最简单的Lisp forms是atoms，可以被分为两类：符号或其它。符号作为form被求值时它被当作变量名称并被求值为变量的当前值。&lt;/p&gt;
&lt;p&gt;数字和字符串被作为self-evaluating objects。&lt;/p&gt;
&lt;p&gt;符号本身也可以是self-evaluating的，它们的名字可以被赋给符号自身。&lt;/p&gt;
&lt;p&gt;另一类self-evaluating符号是keyword symbols&amp;mdash;&amp;mdash;以:开头的符号。&lt;/p&gt;
&lt;h2&gt;函数调用&lt;/h2&gt;
&lt;p&gt;函数调用forms的规则很简单：将list的剩余的元素作为Lisp forms进行求值并将结果传递给函数。&lt;/p&gt;
&lt;h2&gt;特殊操作符&lt;/h2&gt;
&lt;p&gt;当list中的第一个元素是一个特殊操作符时，表达式中的其它元素的求值是按这个操作符的规定来进行求值的。&lt;/p&gt;
&lt;h2&gt;宏&lt;/h2&gt;
&lt;p&gt;宏是一个接收s-expression作为参数并返回Lisp form然后对form求值的函数。求值过程分为两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;macro的form不会被求值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;macro函数返回的form（称为macro的expansion）将被按普通的求值规则被求值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;真值、假值和相等性&lt;/h2&gt;
&lt;p&gt;符号NIL是唯一的假值，其它为真值。符号T是经典的真值表示，用于需要返回non-NIL值时使用它。&lt;/p&gt;
&lt;p&gt;NIL的可以用nil,(),'nil,'()来表示。&lt;/p&gt;
&lt;p&gt;对t和't求值都将得到符号T。&lt;/p&gt;
&lt;p&gt;当使用&amp;ldquo;相同&amp;rdquo;这个词时它表示两个值是&amp;ldquo;同样的&amp;rdquo;（注：同一个东东）。&lt;/p&gt;
&lt;p&gt;四个常用的测试相等性的函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;EQ测试两个对象的&amp;ldquo;对象标识（object identity）&amp;rdquo;是否相等，对象标识的值有可能为数字或字符，这取决于你使用的Lisp实现。因此不应该使用EQ来比较可能是number或character的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EQL的行为类似EQ但它会对比参数是否为同样的类型并表达同样的值。比如，(eql 1 1)为true，而(eql 1 1.0)为false，因为1.0为浮点类型，1为整型属于不同类的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EQUAL的识别宽松一些，如果被比较的对象有相同的递归结构和内容则是相等的。EQUAL将包含相同字符的字符串当作相等。对于其它类型的对象，它将使用EQL的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EQUALP比EQUAL的识别更宽松一些。它在比较字符串时将忽略大小写。比较数字时，只需要它们表述的数学值是相同的即可。因此，(equalp 1 1.0)为true。对于List和Array将使用EQUALP测试其中的元素。对于其它数据类型EQUALP将使用EQL。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Lisp代码的格式&lt;/h2&gt;
&lt;p&gt;在SLIME中将光标停留在左括号上输入C-M-q，或在函数体的任意位置输入C-c M-q可以格式化整段代码。&lt;/p&gt;
&lt;h1&gt;函数&lt;/h1&gt;
&lt;h2&gt;定义新函数&lt;/h2&gt;
&lt;p&gt;使用DEFUN宏来定义函数。DEFUN的基本框架如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun name (parameter*)
  "Optional documentation string."
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;任何符号都可以作为函数名称。通常函数名只包括字母和连字符，其它字符允许在某些约定命名情况下出现。例如，将一个类型的值转换为另一类型通常使用&lt;code&gt;-&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果函数没有参数则使用空列表&lt;code&gt;()&lt;/code&gt;。参数关键字有reqiured，optional，multiple和keyword。&lt;/p&gt;
&lt;p&gt;参数列表后面的字符串被作为文档字符串，它用于说明函数。函数定义后可以使用DOCUMENTATION函数来访问文档字符串。&lt;/p&gt;
&lt;p&gt;DEFUN的body部分可以包含任意数量的Lisp表达式。最后一个表达式的值作为函数返回值。或使用RETURN-FROM操作符立即返回。&lt;/p&gt;
&lt;h2&gt;函数参数列表&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;&amp;amp;optional&lt;/code&gt;定义可选参数列表，下面的函数可以接收2-4个参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo(a b &amp;amp;optional c d) (list a b c d))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未传递参数时可选参数为Nil。&lt;/p&gt;
&lt;p&gt;可以指定可选参数的默认值和传值标识。下面的函数中参数c的默认值为3，可以使用c-supplied-p来检查是否传递了c参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (a b &amp;amp;optional (c 3 c-supplied-p))
  (list a b c c-supplied-p))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;&amp;amp;rest&lt;/code&gt;定义可变长度参数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun format (stream string &amp;amp;rest values) ...)
(defun + (&amp;amp;rest numbers) ...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;&amp;amp;key&lt;/code&gt;定义关键字参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (&amp;amp;key a b c) (list a b c))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用时使用符号指定要设置的参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo)                ==&amp;gt; (NIL NIL NIL)
(foo :a 1)           ==&amp;gt; (1 NIL NIL)
(foo :b 1)           ==&amp;gt; (NIL 1 NIL)
(foo :c 1)           ==&amp;gt; (NIL NIL 1)
(foo :a 1 :c 3)      ==&amp;gt; (1 NIL 3)
(foo :a 1 :b 2 :c 3) ==&amp;gt; (1 2 3)
(foo :a 1 :c 3 :b 2) ==&amp;gt; (1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键字参数也可以指定默认值和设置supplied-p变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (&amp;amp;key (a 0) (b 0 b-supplied-p) (c (+ a b)))
  (list a b c b-supplied-p))

(foo :a 1)           ==&amp;gt; (1 0 1 NIL)
(foo :b 1)           ==&amp;gt; (0 1 1 T)
(foo :b 1 :c 4)      ==&amp;gt; (0 1 4 T)
(foo :a 2 :b 1 :c 4) ==&amp;gt; (2 1 4 T)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;组合使用不同类型的参数时要按顺序来声明：首先是必须的参数，然后是可选参数，再接下来是可变长度的参数，最后使用关键字参数。通常会使用必须参数与其它参数类型组合，或者组合使用可选参数和可变长度参数。可选参数或可变长度参数与关键字参数组合使用时可能会引起奇怪的行为。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (x &amp;amp;optional y &amp;amp;key z) (list x y z))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以这样调用它：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo 1 2 :z 3) ==&amp;gt; (1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样调用也行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo 1)  ==&amp;gt; (1 nil nil)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这样调用时就会出错&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo 1 :z 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要组合使用可选参数和关键字参数时，应该转变为只使用关键字参数。&lt;/p&gt;
&lt;p&gt;可以安全的组合使用可变参数和关键字参数，但也仍然会导致奇怪的问题。参数既会被当作可变参数也会被作为关键字参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (&amp;amp;rest rest &amp;amp;key a b c) (list rest a b c))
(foo :a 1 :b 2 :c 3) ==&amp;gt; ((:A 1 :B 2 :C 3) 1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;函数返回值&lt;/h2&gt;
&lt;p&gt;所有函数都将最后一个表达式的值作为函数值。&lt;/p&gt;
&lt;p&gt;需要在函数中间就返回则要使用&lt;code&gt;RETURN-FROM&lt;/code&gt;操作符来立即从函数中返回值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RETURN-FROM&lt;/code&gt;其实与函数并没有任何联系；它是用于从操作符&lt;code&gt;BLOCK&lt;/code&gt;定义的代码块返回的。但是，由于&lt;code&gt;DEFUN&lt;/code&gt;会自动将整个函数体包裹为与函数名同名的代码块。因此，在函数中执行&lt;code&gt;RETURN-FROM&lt;/code&gt;也将会导致函数立即退出并返回值。&lt;code&gt;RETURN-FROM&lt;/code&gt;是一个特殊操作符，它的第一个&amp;ldquo;参数&amp;rdquo;是要返回的块名。这个名称不会被求值不需要使用引号。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;RETURN_FROM&lt;/code&gt;时的第一个参数为要返回的块名，如果修改了函数名称要记得修改这个参数。在Lisp中使用&lt;code&gt;RETURN_FROM&lt;/code&gt;的情况并不多见。&lt;/p&gt;
&lt;h2&gt;函数作为数据，也称为高阶函数&lt;/h2&gt;
&lt;p&gt;当在Lisp中使用DEFUN定义函数时实际上做了两件事：用给定的名称创建了一个函数对象。也可以使用LAMBDA表达式创建没有名称的函数对象。函数对象实际表述为编译后的代码，通常为机器码。一旦得到它只需要知道如何引用它和调用它。&lt;/p&gt;
&lt;p&gt;FUNCTION操作符提供了获取函数对象的机制。它接收函数名作为参数并返回对应的函数对象。名称前不加引号。它可以被写作&lt;code&gt;#'&lt;/code&gt;，与QUOTE写作&lt;code&gt;'&lt;/code&gt;写法类似。&lt;/p&gt;
&lt;p&gt;得到函数对象后有两个函数可以用来调用函数对象：FUNCALL和APPLY。它们的区别在于：&lt;/p&gt;
&lt;p&gt;FUNCALL是用于你要调用的函数的参数个数的情况下。它的第一个参数是要被调用的函数对象，其它参数被传递到函数中。&lt;/p&gt;
&lt;p&gt;APPLY的第一个参数是函数对象。函数对象后面的参数不是调用这个函数的参数而是一个包含参数的list。APPLY并不关心参数是可选参数、可变参数或关键字参数，组合参数到list中的元素必须是调用函数对象的合法参数。（通常只适用于关键字参数。）F&lt;/p&gt;
&lt;h2&gt;匿名函数&lt;/h2&gt;
&lt;p&gt;LAMBDA表达式。&lt;/p&gt;
&lt;h1&gt;变量&lt;/h1&gt;
&lt;p&gt;Common Lisp支持两种类型的变量：lexical和dynamic。这两种类型大体类似于其它语言中的&amp;ldquo;local&amp;rdquo;和&amp;ldquo;global&amp;rdquo;变量。但仅仅是大体类似。&lt;/p&gt;
&lt;h2&gt;变量基础知识&lt;/h2&gt;
&lt;p&gt;Common Lisp中变量类型是运行期检查的。变量可以带任何类型的数据，变量的值带有类型信息。Common Lisp是强类型语言，它将检查所有类型错误。&lt;/p&gt;
&lt;p&gt;Common Lisp中所有的值从概念上恶报是对象的引用。因此，对一个变量赋新值不会修改变量之前所引用的对象。但是，如果变量持有一个可变对象（mutable）的引用，则可以通过这个引用修改对象，修改将反应到所有引用了相同对象的代码中。&lt;/p&gt;
&lt;p&gt;定义新变量的其中一种方法就是定义函数参数。&lt;/p&gt;
&lt;p&gt;每次函数调用时，Lisp创建新的绑定来保存从调用者传递过来的参数。绑定是变量在运行时的表象。一个变量在程序运行中可以有许多不同的绑定。单个变量在同一时刻也可以用多个绑定；例如递归调用的参数，在每次函数调用时将被重新绑定。&lt;/p&gt;
&lt;p&gt;通过变量，函数参数保持对象的引用。因此，你可以在函数体中给函数参数重新赋值，这不会影响另一个对这个函数的调用的绑定。但是如果传递给函数的对象是可变对象，并在函数中修改了这个对象，则修改将会对调用者可见，因为调用者和被调用者引用了同一个对象。&lt;/p&gt;
&lt;p&gt;另一个定义新变量的方法是LET操作符。&lt;/p&gt;
&lt;p&gt;当LET被求值时，所有初始值被先求值。新的绑定被创建并在body部分为执行前被初始化。在LET的body部分中，变量名指向新创建的绑定。在LET语句之后，这个名称指向其它东西，如果它存在则它指向LET语句之前所指向的东西。&lt;/p&gt;
&lt;p&gt;LET语句的body部分的最后一个表达式被作为LET语句的返回值。与函数参数类似，变量在进入LET时被引入，在每次进入LET时重新绑定。&lt;/p&gt;
&lt;p&gt;两种类型的变量lexical和dynamic变量作用范围有不同的作用范围机制，但是这两种情况下都是由绑定 form来限定的。&lt;/p&gt;
&lt;p&gt;同名变量的嵌套引用时，内部的变量将屏蔽掉外部的绑定。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;defun&lt;/span&gt; &lt;span class="nt"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;format&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="s2"&gt;"Parameter: ~a~%"&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;      &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;------&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="nt"&gt;is&lt;/span&gt; &lt;span class="nt"&gt;argument&lt;/span&gt; 
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;let&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="nt"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;                        &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;format&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="s2"&gt;"Outer LET: ~a~%"&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;|&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;----&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="nt"&gt;is&lt;/span&gt; &lt;span class="nt"&gt;2&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;let&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;                      &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;format&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="s2"&gt;"Inner LET: ~a~%"&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;|&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;--&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="nt"&gt;is&lt;/span&gt; &lt;span class="nt"&gt;3&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;format&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="s2"&gt;"Outer LET: ~a~%"&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;   &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;format&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="s2"&gt;"Parameter: ~a~%"&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;     &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一个创建绑定的方式是LET*。后面定义的变量可以引用前面定义的变量的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let* ((x 10)
       (y (+ x 10)))
  (list x y))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Lexical变量和闭包&lt;/h2&gt;
&lt;p&gt;通常所有绑定都是lexically scoped变量。与C,Java中的local变量类似。&lt;/p&gt;
&lt;p&gt;Common Lisp的lexical变量存在一个不寻常的特点。在嵌套的函数和lexcial变量组合使用时将出现这个问题。通常lexical范围的变量，只存在于代码文本中绑定变量的范围才可以引用该变量。但当一个匿名函数在一个封闭范围内包含了lexical变量的引用时将发生什么呢？例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((count 0)) #'(lambda () (setf count (1+ count))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LAMBDA表达式内的count是lexical作用域的变量。但是匿名函数包含了对它的引用，匿名函数将作为let的返回值并能通过FUNCALL调用，能被那些不属于LET范围之内的代码调用。这个代码仍然能正常工作。count的绑定将在进入LET语句时被创建并将在需要它的期间一直存在下去。这种匿名函数被称为闭包，因为它&amp;ldquo;封闭（closes over）&amp;rdquo;了由LET创建的绑定。&lt;/p&gt;
&lt;p&gt;考虑闭包时要将它作为绑定来思考，不能把它当作变量。因为，闭包不仅仅能访问它封闭的变量的值也可以在不同的闭包调用时给变量赋新值，这个新值将能在不同的调用间被保留。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *fn* (let ((count 0)) #'(lambda () (setf count (1+ count)))))
CL-USER&amp;gt; (funcall *fn*)
1
CL-USER&amp;gt; (funcall *fn*)
2
CL-USER&amp;gt; (funcall *fn*)
3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;单个闭包通过引用变量可以封闭任意数量的变量绑定。多个闭包也可以共享相同的绑定。例如，下面的let返回的是一个闭包的列表，它们都引用了count的绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((count 0))
  (list
   #'(lambda () (incf count))
   #'(lambda () (decf count))
   #'(lambda () count)))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;动态变量，也称特殊变量&lt;/h2&gt;
&lt;p&gt;Common Lisp中创建全局变量的两个方法：DEFVAR和DEFPARAMETER。两个表达式都接收一个变量名和一个初始值，还有一个可选的字符串参数作为文档字符串。在使用DEFVAR和DEFPARAMETER后，全局变量的绑定可以在任何地方被使用。全局变量以&lt;code&gt;*&lt;/code&gt;开头和结尾。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defvar *count* 0
  "Count of widgets made so far.")

(defparameter *gap-tolerance* 0.001
  "Tolerance to be allowed in widget gaps.")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个定义方法的区别在于DEFPARAMETER在执行时总是会重新给变量赋值。DEFVAR只会在变量不存在时给它赋初值。DEFVAR也可以在定义全局变量时不赋初始值。这种变量被称为&amp;ldquo;未绑定（unbound）&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;全局变量的好处是不需要传递它们。多数语言都将标准输入和输出流作为全局变量。但是类似标准输出流这样的全局变量有时会需要通过修改这个变量来修改它们的行为。比如日志工具将它重定向到文件。有时在重定向到文件后时可能会忘记将它们重新定向到标准输出。&lt;/p&gt;
&lt;p&gt;解决这种问题的方法是使用动态变量。当你使用LET或函数参数绑定动态变量时，绑定将在进入绑定生存范围的时候被创建，这个绑定将在生存范围内替换全局绑定。这与Lexical绑定不同，它只在绑定生存周期内才能被引用，动态绑定可以任何代码的执行过程中被引用。所有全局变量都是动态变量。&lt;/p&gt;
&lt;p&gt;因此，你可以临时性的重新定义&lt;code&gt;*standard-output*&lt;/code&gt;，只需要使用LET重新绑定它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((*standard-output* *some-other-stream*))
  (stuff))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用stuff作为结果的任何代码在引用&lt;code&gt;*standard-output*&lt;/code&gt;时都将使用LET建立的绑定。当stuff返回执行过程离开LET范围时，&lt;code&gt;*standard-output*&lt;/code&gt;的绑定将被取消，随后的代码将看到执行LET之前的那个指向&lt;code&gt;*standard-output*&lt;/code&gt;的绑定。在任何时候，最近建立的绑定将屏蔽（shadows）掉之前的绑定。从概念上看，为动态变量创建的新绑定被压入那个变量对应的绑定堆栈中，引用那个变量时总是使用最近的绑定。当绑定范围结束时，前一个绑定再被弹出堆栈，如此继续。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defvar *x* 10)
(defun foo () (format t "X: ~d~%" *x*))

CL-USER&amp;gt; (foo)
X: 10
NIL

CL-USER&amp;gt; (let ((*x* 20)) (foo))
X: 20
NIL

CL-USER&amp;gt; (foo)
X: 10
NIL

(defun bar ()
  (foo)
  (let ((*x* 20)) (foo))
  (foo))

CL-USER&amp;gt; (bar)
X: 10
X: 20
X: 10
NIL

(defun foo ()
  (format t "Before assignment~18tX: ~d~%" *x*)
  (setf *x* (+ 1 *x*))
  (format t "After assignment~18tX: ~d~%" *x*))

CL-USER&amp;gt; (foo)
Before assignment X: 10
After assignment  X: 11
NIL

CL-USER&amp;gt; (bar)
Before assignment X: 11
After assignment  X: 12
Before assignment X: 20
After assignment  X: 21
Before assignment X: 12
After assignment  X: 13
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LET是如何知道绑定&lt;code&gt;*x*&lt;/code&gt;是一个动态绑定的呢？这是因为在申明&lt;code&gt;*x*&lt;/code&gt;是使用的是DEFVAR和DEFPARAMETER，它们会自动将变量申明为全局特殊变量。在任何时候在LET中或在函数参数中使用此变量的时候都将构造一个新的动态绑定。这也是为什么使用&lt;code&gt;*&lt;/code&gt;标识全局变量这个约定的非常重要的原因。&lt;/p&gt;
&lt;p&gt;也可以申明本地特殊变量。在binding form中，申明一个特殊变量，则将创建一个动态绑定的变量而不是lexical变量。其它代码可以在本地变量范围中申明一个特殊变量以便引用动态绑定。但是，本地特殊变量非常稀有，你不必考虑它们。&lt;/p&gt;
&lt;p&gt;动态绑定使得全局变量更加易于管理，绑定全局变量考虑它可能的两个影响：它将改变下游代码的行为，也可能出现下游代码给绑定赋新值断开了现有的绑定行为。只应该在需要的地方使用上面的这些特性。&lt;/p&gt;
&lt;h2&gt;常量&lt;/h2&gt;
&lt;p&gt;所有常量都是全局的，使用DEFCONSTANT定义。它的使用与DEFPARAMETER类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defconstant name initial-value-form [ documentation-string ])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常使用变量前后加&lt;code&gt;+&lt;/code&gt;作为全局变量的命名。另一种方式是使用前后添加&lt;code&gt;*-&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Lisp允许通过重新执行DEFCONSTANT并设置不同的初始值。, what exactly happens after the redefinition isn't defined。实际上，多数Lisp实现将会需要你重新对引用了这个常量的代码重新求值，以便应用新值，因为旧代码可能内联了旧的值。因此，最好只在真正的常量才使用DEFCONSTANT，例如NIL。&lt;/p&gt;
&lt;h2&gt;赋值&lt;/h2&gt;
&lt;p&gt;创建绑定后，你可以对它做两件事：得到当前值和给它设置一个新值。对符号求值时将得到符号对应的名字所指向的变量的值，因此你可以通过引用变量得到它的值。给绑定赋新值可以使用SETF宏，它是Common Lisp中的通用赋值操作符。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf place value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SETF是一个宏，它将被展开为低级操作，转变为对特殊操作符SETQ的调用，它可以操作lexical和动态绑定。&lt;/p&gt;
&lt;p&gt;前面讲过，给绑定赋新值不会影响其它绑定的值。例如；&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (x) (setf x 10))

(let ((y 20))
  (foo y)
  (print y))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将打印出20，而不是10。&lt;/p&gt;
&lt;p&gt;SETF可以给多个变量赋值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf x 1)
(setf y 2)

(setf x 1 y 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SETF将返回最后的赋值，因此可以嵌套使用SETF。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf x (setf y (random 10))) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;x和y将是同样的随机数值。&lt;/p&gt;
&lt;h2&gt;通用赋值&lt;/h2&gt;
&lt;p&gt;SETF可以对&amp;ldquo;SETFable places&amp;rdquo;的地方进行赋值操作，比如数组、变量、哈希表等等，甚至可以扩展SETF来允许它对用户定义的地方进行赋值操作，这里不作介绍。&lt;/p&gt;
&lt;p&gt;SETF的第一个参数是要赋值的位置，第二个参数是值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Simple variable:    (setf x 10) 
Array:              (setf (aref a 0) 10)
Hash table:         (setf (gethash 'key hash) 10)
Slot named 'field': (setf (field o) 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：SETF设置一个大对象的某个部分时不会影响到之前这个地方所存储的对象。这点上与Java，Perl和Python中的&lt;code&gt;=&lt;/code&gt;是相似的。&lt;/p&gt;
&lt;h2&gt;其它修改方式&lt;/h2&gt;
&lt;p&gt;通过INCF和DECF之类的modify macros来修改变量。使用这种宏不但看起来更加简明。并且，modify macros能安全的用于只允许对表达式进行一次求值的地方。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(incf (aref *array* (random (length *array*))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;转换为SETF表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf (aref *array* (random (length *array*)))
      (1+ (aref *array* (random (length *array*)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这两者是不同的，因为后者将会对RANDOM调用两次，这将返回不同的值。而INCF展开后将类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((tmp (random (length *array*))))
  (setf (aref *array* tmp) (1+ (aref *array* tmp))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常，modify macros将会对它的每个参数按从左至右的顺序求值一次。&lt;/p&gt;
&lt;p&gt;PUSH宏也是一个modify macro。&lt;/p&gt;
&lt;p&gt;两个神秘但非常有用的modify macro ROTATEF和SHIFTF。ROTATEF交换两个位置的值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(rotatef a b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;交换两个变量并返回NIL。由于a和b都是变量因此不需要担心side effects，前面的ROTATEF表达式类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((tmp a)) (setf a b b tmp) nil)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SHIFTF与之类似，但它不是交换，而是向左移动变量的值，下面的表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(shiftf a b 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((tmp a)) (setf a b b 10) tmp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ROTATEF和SHIFTF都可以用于任意数量的变量，与所有modify macros一样，都只对这些参数按从左至右的顺序求值一次。&lt;/p&gt;
&lt;h1&gt;宏：标准控制结构&lt;/h1&gt;
&lt;p&gt;通常高级语言在实现的时候总是采用一个很小的核心加标准库的方式来实现，这样比较易于学习和实现。人们通过编写新程序库或新类来扩展出自己的程序。&lt;/p&gt;
&lt;p&gt;Common Lisp也支持这些扩展方式，宏给Common Lisp提供了另一种扩展方式。前面讨论过每个宏都定义自己的语法，决定如何将s-expression转换为Lisp forms。通过macro我们可以构建新的类似WHEN，DOLIST和LOOP这样的控制结构，或者DEFUN和DEFPARAMETER这样的定义语句。这也是这门语言自己的实现方式。Lisp程序员通常更关心它提供了另一种方法来扩展这门语言，以便更好的解决编程中的特殊问题。&lt;/p&gt;
&lt;h2&gt;WHEN和UNLESS&lt;/h2&gt;
&lt;p&gt;if是一个特殊的操作符，基本语法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(if condition then-form [else-form])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;condition将被求值，如果它的值是非NIL值，则then-form将求值并作为结果返回。否则，如果else-form存在，则它将被求值并作为结果返回。&lt;/p&gt;
&lt;p&gt;IF只支持执行单个语句。在需要执行多个语句时不得不使用另一个操作符PROGN。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(if (spam-p current-message)
    (progn
      (file-in-spam-folder current-message)
      (update-spam-database current-message)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lisp提供了标准宏WHEN来执行这种任务：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(when (spam-p current-message)
  (file-in-spam-folder current-message)
  (update-spam-database current-message))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果它不存在于标准库中，你也可以自己来定义WHEN:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro when (condition &amp;amp;rest body)
  `(if ,condition (progn ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与WHEN宏相对的是UNLESS宏，它只在条件为非真时才执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro unless (condition &amp;amp;rest body)
  `(if (not ,condition) (progn ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面简单的例子包含了一个重要的内容：由于macro系统是构建于语言中的，因此你可以编写WHEN和UNLESS这样的宏来节约你的时间。&lt;/p&gt;
&lt;h2&gt;COND&lt;/h2&gt;
&lt;p&gt;另一种难看的使用IF表达式的情况是在多重选择的情况下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(if a
    (do-x)
    (if b
       (do-y)
       (do-z)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要执行更多语句可能还需要使用PROGN等等。因此，Common Lisp提供了COND宏。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(cond
  (test-1 form*)
      .
      .
      .
  (test-N form*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个情况下的分支上的元素可以包含零个或多个form，它们将在分支被选择的情况下被执行。所有的条件判断将按顺序被执行直到遇到一个为true的条件，这个分支上的语句将被执行，最后一个form的值作为整个COND的返回值。如果这个分支上的条件后面没有form，则将返回条件的值。习惯上将最后一个条件写为T，任何非NIL值都能工作，但T更能表明它的分界作用。因此可以将开头的IF表达式写为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(cond (a (do-x))
      (b (do-y))
      (t (do-z)))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;AND，OR和NOT&lt;/h2&gt;
&lt;p&gt;NOT不是宏而是一个操作符，它与AND和OR关系密切才放到这里来介绍。它接收单个参数并反转它的真假值，如果参数为NIL则返回T，否则返回NIL。&lt;/p&gt;
&lt;p&gt;AND和OR都是宏。它们实现了对任意数量的form的和逻辑与和或，由于它们是通过宏定义的，因此它们可以实现&amp;ldquo;短路&amp;rdquo;操作。它们按从左至右的顺序依次执行。当AND遇到某个form的求值结果为NIL时它返回NIL。如果所有form都返回非NIL值，则它返回最后一个form的值。对于OR它将在遇到第一个非NIL值时返回这个form的值。如果没有哪个form的返回值为真，则OR将返回NIL。&lt;/p&gt;
&lt;h2&gt;循环&lt;/h2&gt;
&lt;p&gt;Lisp中的25个特殊操作符都不直接支持循环结构。所有的循环控制结构都是基于两个特殊操作符（TAGBODY和GO）通过宏构造出来的。&lt;/p&gt;
&lt;p&gt;DO使用特殊操作符提供了基本的循环结构，DOLIST和DOTIMES提供两个易于使用的通用型的循环结构。当DOLIST和DOTIMES不够用时，你可以通过DO来定义自己的循环结构。&lt;/p&gt;
&lt;p&gt;LOOP宏提供了易于使用的English-like（或Algol-like）的non-Lispy的循环结构。&lt;/p&gt;
&lt;h2&gt;DOLIST和DOTIMES&lt;/h2&gt;
&lt;p&gt;DOLIST遍历list中的元素，并执行body中的语句。下面是它的基本结构（去掉了一些神秘选项）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(dolist (var list-form)
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (dolist (x '(1 2 3)) (print x))
1
2
3
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这种方法使用时DOLIST整个返回NIL。&lt;/p&gt;
&lt;p&gt;如果需要在中途中断循环可以使用RETURN。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (dolist (x '(1 2 3)) (print x) (if (evenp x) (return)))
1
2
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DOTIMES的基本结构与DOLIST类似。通常用于计数类的循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(dotimes (var count-form)
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;count-form的值必须是整数。每次执行body时var保留了从0至小于这个数的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (dotimes (i 4) (print i))
0
1
2
3
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与DOLIST一样，也可以使用RETURN中断循环。&lt;/p&gt;
&lt;h2&gt;DO&lt;/h2&gt;
&lt;p&gt;DOLIST和DOTIMES易于使用，但它并不能满足所有类型的循环的要求。DOLIST和DOTIMES只提供了一个循环变量，DO允许你绑定任意数量的变量并且你能够完全控制每个变量如何改变。并且也可以定义用于循环结束测试的代码，并能提供一个语句用于产生整个DO的返回值。DO的基本结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do (variable-definition*)
    (end-test-form result-form*)
  statement*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个variable-definition都引入了一个可以在循环体中访问的变量。单个变量定义的结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(var init-form step-form)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;init-form将在循环开始时被求值它的值将被绑定到var。在循环的每个迭代之前，step-form将被重新求值，并将结果赋给var。step-form是可选项，如果它不存在，则变量的值将一直保持不变，除非你在循环体中显式的给它赋值。与let中定义变量类似，如果init-form 指定，则变量将被绑定到NIL。你也可以像在LET中一样只是简单的在variable-definition中只定义变量名称。&lt;/p&gt;
&lt;p&gt;当end-test-form的求值结果为true时，result-form将被求值，它的结果将被作为DO表达式的返回值。&lt;/p&gt;
&lt;p&gt;在每次迭代前所有变量都会被求值。这意味着你可以在变量中引用其它变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do ((n 0 (1+ n))
     (cur 0 next)
     (next 1 (+ cur next)))
    ((= 10 n) cur))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这也揭示了DO的另一个特性&amp;mdash;&amp;mdash;因为你可以同时对多个变量进行操作，有时根本不会再需要循环体了。另外，你可以只保留result form，特别是如果你只需要使用循环控制结构时。&lt;/p&gt;
&lt;p&gt;记住DO语句基本结构中的6个括号：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do (variable-definition*)
    (end-test-form result-form*)
  statement*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在DO中即使你不需要使用循环变量，也仍然需要一个空的变量列表。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do ()
    ((&amp;gt; (get-universal-time) *some-future-date*))
  (format t "Waiting~%")
  (sleep 60)) 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;强大的LOOP&lt;/h2&gt;
&lt;p&gt;LOOP有两种风格。简单风格的不绑定任何变量，看起来像个无限循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(loop
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过RETURN才能跳出。&lt;/p&gt;
&lt;p&gt;另一种风格的LOOP。English风格，或者说un-Lispy风格。对于LOOP的这种风格存在一些争论，一些人喜欢，另一些人不喜欢这种风格认为它不那么Lispy。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(loop for i from 1 to 10 collecting i) ==&amp;gt; (1 2 3 4 5 6 7 8 9 10)
(loop for x from 1 to 10 summing (expt x 2)) ==&amp;gt; 385
(loop for x across "the quick brown fox jumps over the lazy dog"
      counting (find x "aeiou")) ==&amp;gt; 11
(loop for i below 10
      and a = 0 then b
      and b = 1 then (+ b a)
      finally (return  a))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;符号across,and,below,collecting,counting,finally,for,from,summing,then,和to都是LOOP循环的关键字。&lt;/p&gt;
&lt;h1&gt;宏：定义自己的宏&lt;/h1&gt;
&lt;p&gt;macro和函数操作于不同的层次。创建完全不同的抽像。&lt;/p&gt;
&lt;h2&gt;宏展开时与运行时&lt;/h2&gt;
&lt;p&gt;掌握宏的关键在于能清析的区分宏生成的代码和由这些代码构成的程序。当编写宏时，你是在编写由编译器运行的用于在编译时生成代码的程序。只有在所有宏被完全展开并且展开后的代码被编译后程序才被运行。宏被执行的时间被称为宏展开时，这与运行时（编写的代码和由宏生成的代码运行）是有区别的。&lt;/p&gt;
&lt;p&gt;宏展开时不能访问运行时的数据。即，宏展开时并不能执行程序，也不知道程序如何工作，宏展开时运行的代码只能处理程序代码中有的数据。比如，程序代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (x)
  (when (&amp;gt; x 10) (print 'big)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常你将会把x作为变量它保存了传递给foo的参数。但在宏展开时，比如编译器在运行WHEN宏时，可用的数据只有代码。因为程序还没有运行，没有调用foo因此也没有数值与x关联。编译器传递给WHEN的值是Lisp lists描述的程序代码。&lt;code&gt;(&amp;gt; x 10)&lt;/code&gt;和&lt;code&gt;(print 'big)&lt;/code&gt;作为参数传递给WHEN。它的定义类似下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro when (condition &amp;amp;rest body)
  `(if ,condition (progn ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当foo被编译时，WHEN宏将获得上面那两个参数并运行。condition参数被绑定到&lt;code&gt;(&amp;gt; x 10)&lt;/code&gt;，&lt;code&gt;(print 'big)&lt;/code&gt;被绑定到&lt;code&gt;&amp;amp;rest&lt;/code&gt;参数。而反引号内的表达式将生成代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(if (&amp;gt; x 10) (progn (print 'big)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当Lisp以解释方式执行时，宏展开时和运行时的区别就不那么明显了，因为他们是交叉的。语言标准中并未明确指定解释器应该怎样处理宏&amp;mdash;&amp;mdash;它可以展开所有宏代然后解释出结果，或者它只在遇到宏的时候才展开宏并使用它。在这两种情况下，宏总是传递未被求值的Lisp对象，宏的工作仍然是生成执行实际操作的代码，而不是由宏本身来执行实际操作。&lt;/p&gt;
&lt;h2&gt;DEFMACRO&lt;/h2&gt;
&lt;p&gt;基本结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro name (parameter*)
  "Optional documentation string."
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与函数结构类似，宏包括名称，参数列表，可选的文档字符串和body部分的Lisp表达式。&lt;/p&gt;
&lt;p&gt;一旦有了调用的示例代码和对应的展开代码，你就可以进行下一步：编写实际的宏代码。&lt;/p&gt;
&lt;p&gt;在编写完将示例代码正确展开的代码后，你需要确保宏没有漏洞（leak）。有漏洞的宏在某些参数下能工作得很好，但是对于另一些情况则不能正常工作。&lt;/p&gt;
&lt;p&gt;编写宏的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写调用宏的示例代码和这个代码应该展开的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写能根据示例代码参数生成代码的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确保宏抽像没有漏洞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;一个简单的宏：do-primes&lt;/h2&gt;
&lt;p&gt;这个宏提供类似DOTIMES和DOLIST的循环结构，它迭代连续的素数。&lt;/p&gt;
&lt;p&gt;首先，你需要两个工具函数，一个用于检测给定的数字是否为素数，另一个函数用于返回大于或等于它的参数的下一个素数。这两个函数都使用逼近法蛮力计算。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun primep (number)
  (when (&amp;gt; number 1)
    (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来编写调用宏的示例代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes (p 0 19)
  (format t "~d " p))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它表示对大于等于0小于等于19的素数执行body中的代码，变量p保存对应的素数。&lt;/p&gt;
&lt;p&gt;在没有do-primes宏时，需要使用下面的DO循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do ((p (next-prime 0) (next-prime (1+ p))))
    ((&amp;gt; p 19))
  (format t "~d " p))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来需要编写宏代码将前面的示例代码转换为上面的代码。&lt;/p&gt;
&lt;h2&gt;宏参数&lt;/h2&gt;
&lt;p&gt;由于传递给宏的都是Lisp对象描述的源代码，宏的第一步是解析出需要用于展开计算的那些对象。对于将参数插入模板的简单的宏来说，这个步骤微不足到：简单的定义右边的参数列表来接收各个参数。&lt;/p&gt;
&lt;p&gt;对于do-primes并不合适。它的第一个参数是包含了循环变量p，下限0和上限19。而在展开的代码中，这个list参数并不是整体出现在展开代码中的；它的三个元素是分开出现在不同位置的。&lt;/p&gt;
&lt;p&gt;你可以为do-primes定义两个参数，一个保存list另一个&lt;code&gt;&amp;amp;rest&lt;/code&gt;参数保存body部分。然后将list拆分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes (var-and-range &amp;amp;rest body)
  (let ((var (first var-and-range))
        (start (second var-and-range))
        (end (third var-and-range)))
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
         ((&amp;gt; ,var ,end))
       ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面将解释如何生成正确的展开代码；现在只需要注意变量var，start，end每个保存了一个从var-and-range中解析出的值，然后他们被加入反引号表达式用于生成do-primes的展开代码。&lt;/p&gt;
&lt;p&gt;然而并不需要像这样手工的拆分var-and-range因为宏参数列表被称为&lt;code&gt;destructuring&lt;/code&gt;参数列表。它将按列表的结构拆分传递给宏的参数。&lt;/p&gt;
&lt;p&gt;在destructuring参数列表中，简单的参数可以被替换为嵌套的参数列表。嵌套参数列表中的每个元素被绑定到参数列表的一部分。例如使用(var start end)替换var-and-range，则列表中的3个元素将自动对应到3个参数。&lt;/p&gt;
&lt;p&gt;宏参数的另一个特殊功能是你可以使用&lt;code&gt;&amp;amp;body&lt;/code&gt;作为&lt;code&gt;&amp;amp;rest&lt;/code&gt;的同义词。语义上两者是相等的，但很多开发环境将会使用&lt;code&gt;&amp;amp;body&lt;/code&gt;来决定如何缩进&amp;mdash;&amp;mdash;通常使用&lt;code&gt;&amp;amp;body&lt;/code&gt;接收宏的body部分。&lt;/p&gt;
&lt;p&gt;上面的宏可以修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes ((var start end) &amp;amp;body body)
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
       ((&amp;gt; ,var ,end))
     ,@body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，destructuring参数列表还将给予自动的错误检查，Lisp将会检查调用这个宏的第一个参数是否是一个包含3个元素的列表，如果不是则将给出错误信息。在像SLIME这样的开发环境中使用destructuring参数列表将能在输入函数或宏的名字时更快的得到参数的提示信息。对于原来的那种定义方式，SLIME中只会有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes var-and-range &amp;amp;rest body)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而使用新的定义将得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes (var start end) &amp;amp;body body)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Destructuring参数列表可以包含&lt;code&gt;&amp;amp;optional&lt;/code&gt;，&lt;code&gt;&amp;amp;key&lt;/code&gt;和&lt;code&gt;&amp;amp;rest&lt;/code&gt;参数，并可以包含嵌套destructuring列表。&lt;/p&gt;
&lt;h2&gt;生成展开代码&lt;/h2&gt;
&lt;p&gt;由于do-primes是个简单的宏，因此在使用destructured参数后，就只需要将它们插入到模板中生成展开代码了。&lt;/p&gt;
&lt;p&gt;回顾反引号&lt;/p&gt;
&lt;p&gt;+--------------------+----------------------------------------+--------------------+
|  Backquote Syntax  |     Equivalent List-Building Code      |       Result       |
+--------------------+----------------------------------------+--------------------+
|&lt;code&gt;(a (+ 1 2) c)      |(list 'a '(+ 1 2) 'c)                   |(a (+ 1 2) c)       |
+--------------------+----------------------------------------+--------------------+
|&lt;/code&gt;(a ,(+ 1 2) c)     |(list 'a (+ 1 2) 'c)                    |(a 3 c)             |
+--------------------+----------------------------------------+--------------------+
|&lt;code&gt;(a (list 1 2) c)   |(list 'a '(list 1 2) 'c)                |(a (list 1 2) c)    |
+--------------------+----------------------------------------+--------------------+
|&lt;/code&gt;(a ,(list 1 2) c)  |(list 'a (list 1 2) 'c)                 |(a (1 2) c)         |
+--------------------+----------------------------------------+--------------------+
|`(a ,@(list 1 2) c) |(append (list 'a) (list 1 2) (list 'c)) |(a 1 2 c)           |
+--------------------+----------------------------------------+--------------------+&lt;/p&gt;
&lt;p&gt;要注意反引号只是一个简略形式。但是这是一个很方便的书写方式。如果没有反引号，代码将会变成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes-a ((var start end) &amp;amp;body body)
  (append '(do)
          (list  (list (list var
                             (list 'next-prime start)
                             (list 'next-prime (list '1+ var)))))
          (list (list (list '&amp;gt; var end)))
          body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子也可以工作，或者你可以直接使用MACROEXPAND-1直接展开。&lt;/p&gt;
&lt;p&gt;在SLIME中你可以将光标停在宏调用的右括号后面使用C-c RET来调用Emacs的slime-macroexpand-1，它会调用MACROEXPAND-1并将展开的结果显示在临时缓冲区中。&lt;/p&gt;
&lt;h2&gt;堵塞漏洞&lt;/h2&gt;
&lt;p&gt;在Joel Spolsky的文章&amp;ldquo;The Law of Leaky Abstractions&amp;rdquo;中制造了一个词汇&amp;ldquo;leaky abstraction&amp;rdquo;来描述an abstraction that "leaks" details it's supposed to be abstracting away。&lt;/p&gt;
&lt;p&gt;它也指出，宏有3种情况将产生漏洞。&lt;/p&gt;
&lt;p&gt;当前的宏定义有其中的一种漏洞：命名漏洞，它对end表达式进行了多次求值。所设在调用do-primes时不直接使用数字而是使用(random 100)替代19：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes (p 0 (random 100))
  (format t "~d " p))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它展开后将变成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (macroexpand-1 '(do-primes (p 0 (random 100)) (format t "~d " p)))
(DO ((P (NEXT-PRIME 0) (NEXT-PRIME (1+ P))))
    ((&amp;gt; P (RANDOM 100)))
  (FORMAT T "~d " P))
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当这段展开的代码运行时，RANDOM将在每次循环时都被执行。这个循环将只会在随机数字恰好小于P时才会中止。迭代执行的次数也将是随机的。&lt;/p&gt;
&lt;p&gt;这是宏抽像中的漏洞。一个解决这个漏洞的办法是简单的说明do-primes的行为。但这不满足最小惊讶原则。程序员通常会认为他传递给宏的表达式只会被求值一次。而且，do-primes是构建在标准宏DOTIMES和DOLIST的模型的基础上，这两者都只对表达式求值一次，绝大多数程序员都会认为do-primes会有相似的行为。&lt;/p&gt;
&lt;p&gt;可以在生成的代码中对表达式求值并保存于变量中放在后面的DO循环中使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes ((var start end) &amp;amp;body body)
  `(do ((ending-value ,end)
        (,var (next-prime ,start) (next-prime (1+ ,var))))
       ((&amp;gt; ,var ending-value))
     ,@body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不幸的是，这个修改产生了两个新的漏洞：&lt;/p&gt;
&lt;p&gt;第一个新漏洞与刚才修复的多次求值的漏洞相似。因为DO循环中的初始化部分是按定义的顺序求值的，当宏的展开代码被求值时，后面传递的表达式end将会被选于start被求值，这与它们在宏调用中出现的顺序是相反的。这个漏洞在使用0和19来调用时不会导致问题。但当它们是有side effects的表达式时，求值顺序将再次与最小惊讶原则冲突。&lt;/p&gt;
&lt;p&gt;通过交换两个变量的定义顺序可以修补这个漏洞：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes ((var start end) &amp;amp;body body)
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
        (ending-value ,end))
       ((&amp;gt; ,var ending-value))
     ,@body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一个需要修补的漏洞是创建并使用了变量名ending-value。问题在于这个名字，它应该是宏实现的细节，与宏调用的环境相关。由于这个漏洞下面的调用将不会正确的工作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes (ending-value 0 10)
  (print ending-value))

(let ((ending-value 0))
  (do-primes (p 0 10)
    (incf ending-value p))
  ending-value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过MACROEXPAND-1可以看到这个问题。第一个调用将被展开为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do ((ending-value (next-prime 0) (next-prime (1+ ending-value)))
     (ending-value 10))
    ((&amp;gt; ending-value ending-value))
  (print ending-value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里DO循环中ending-value这下变量名被使用了两次。&lt;/p&gt;
&lt;p&gt;第二个代码展开为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((ending-value 0))
  (do ((p (next-prime 0) (next-prime (1+ p)))
       (ending-value 10))
      ((&amp;gt; p ending-value))
    (incf ending-value p))
  ending-value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种情况下的展开代码是合法的，但是它的行为并不是你所希望的。因为循环外部由LET建立的对ending-value的绑定被DO中的同名变量屏蔽（shadowed）了，表达式(incf ending-value p)对循环变量ending-value的修改不会影响循环外的同名变量，这将造成另一个无限循环。&lt;/p&gt;
&lt;p&gt;修补这个漏洞需要生成一个不会被外部代码引用的符号。你可以尝试使用一个不大可能被外部使用的名字，但这并不能保证不冲突。你也可以使用包来在某种程度上保护你的代码Chapter21。但这里有个更好的解决方法。&lt;/p&gt;
&lt;p&gt;函数GENSYM将在每次调用它时产生一个唯一的符号。这个符号从未被Lisp reader读取过并且它也从未被interned到任何包中。因此可以使用它替换ending-value，你可以在每次展开时生成一个新的符号。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes ((var start end) &amp;amp;body body)
  (let ((ending-value-name (gensym)))
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
          (,ending-value-name ,end))
         ((&amp;gt; ,var ,ending-value-name))
       ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意代码中的GENSYM并不是展开表达式中的一部分；它是作为宏展开器的一部分运行的，在每次宏展开时创建出一个新的符号。这初看起来可能有点奇怪ending-value-name是一个变量它的值是另一个变量的名字。但这实际上与参数var的值是变量名没有区别&amp;mdash;&amp;mdash;差异在于var的值是在macro语句被reader读取的时候创建的，ending-value-name的值是在宏代码运行时被创建的。&lt;/p&gt;
&lt;p&gt;使用这个方法定义后展开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes (ending-value 0 10)
  (print ending-value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将得到&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do ((ending-value (next-prime 0) (next-prime (1+ ending-value)))
     (#:g2141 10))
    ((&amp;gt; ending-value #:g2141))
  (print ending-value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在保存ending value的变量是生成的符号，&lt;code&gt;#:g2141&lt;/code&gt;。这个名字是由GENSYM生成的。生成的符号被打印为uninterned的符号的打工，前面带有&lt;code&gt;#:&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另一个调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((ending-value 0))
  (do-primes (p 0 10)
    (incf ending-value p))
  ending-value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将展开为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((ending-value 0))
  (do ((p (next-prime 0) (next-prime (1+ p)))
       (#:g2140 10))
      ((&amp;gt; p #:g2140))
    (incf ending-value p))
  ending-value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按下面的规则编写宏：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;除非有特殊原因，应该按subforms出现在宏调用上的顺序在展开代码中包含subforms。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除非有特殊原因，应该在展开代码中创建变量保存subforms的值，确保subforms只被求值一次，并在其它展开代码的其它地方使用这个变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用GENSYM在宏展开时创建变更名，并将它用于展开代码中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;宏编写宏&lt;/h2&gt;
&lt;p&gt;没有理由只有在编写函数时使用宏。宏的工作是抽像通用的句法模式，某些模式对于编写宏同样有益处。&lt;/p&gt;
&lt;p&gt;实际上，你已经看到这种模式，比如do-primes中以LET开头引入少量变量保存生成的符号名。&lt;/p&gt;
&lt;p&gt;这节里你将编写一个宏with-gensyms，它来完成上个版本中LET的工作。即，你将用宏来编写宏：一个宏生成代码来生成代码。你可以这样使用这个宏：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes ((var start end) &amp;amp;body body)
  (with-gensyms (ending-value-name)
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
          (,ending-value-name ,end))
         ((&amp;gt; ,var ,ending-value-name))
       ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它与上一版本中的do-primes相同。with-gensyms需要将每个变量名展开为LET。最简单的办法是编写一个反引号模板。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro with-gensyms ((&amp;amp;rest names) &amp;amp;body body)
  `(let ,(loop for n in names collect `(,n (gensym)))
     ,@body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用LOOP生成变量名。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (loop for n in '(a b c) collect `(,n (gensym)))
((A (GENSYM)) (B (GENSYM)) (C (GENSYM)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样在with-gensyms内部你可以直接引用变量名了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((ending-value-name (gensym)))
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
        (,ending-value-name ,end))
       ((&amp;gt; ,var ,ending-value-name))
     ,@body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来不错。但这个宏相当的锁碎，重点在于清析的知道什么时候这两个宏被展开：当编译do-primes的DEFMACRO，with-gensyms被展开到代码并编译。因此，编译后的do-primes与使用LET编写的是相同的。当编译使用do-primes的函数时，由with-gensyms生成的代码执行并生成do-primes的展开代码，但是with-gensyms它自己并不需要编译了，因为它在编译do-primes时已经被展开了。&lt;/p&gt;
&lt;h1&gt;实践：构建一个单元测试框架&lt;/h1&gt;
&lt;p&gt;这章将构建一个测试框架。其主要设计目标是尽可能容易的添加新测试、运行测试套件、跟踪错误。&lt;/p&gt;
&lt;p&gt;这个自动化测试框架的主要职责是告诉你是否所有测试都通过。所以，所以每个测试都必须是一个产生布尔类型结果的表达式。&lt;/p&gt;
&lt;h2&gt;两次尝试&lt;/h2&gt;
&lt;p&gt;如果是在做简单的测试可以在REPL中直接输入表达式然后检查返回值是否为T。最简单的开始这个测试框架的办法是编写一些测试用例然后用AND将结果连接起来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (and
    (= (+ 1 2) 3)
    (= (+ 1 2 3) 6)
    (= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在执行这个函数时它将返回T，因此你知道测试通过了。但是这里存在一些问题，如果某个测试用例失败了，你只能知道出了问题，返回了NIL，但是你不会知道具体是哪个测试用例出了问题。&lt;/p&gt;
&lt;p&gt;因此，需要改进一下。要能知道每个测试用例的执行情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (format t "~:[FAIL~;pass~] ... ~a~%" (= (+ 1 2) 3) '(= (+ 1 2) 3))
  (format t "~:[FAIL~;pass~] ... ~a~%" (= (+ 1 2 3) 6) '(= (+ 1 2 3) 6))
  (format t "~:[FAIL~;pass~] ... ~a~%" (= (+ -1 -3) -4) '(= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以看到每个测试的情况了。但是这里有很多重复的FORMAT调用，需要进行重构。&lt;/p&gt;
&lt;p&gt;另一个问题是对于整个测试过程没有返回一个标识来标识是否所有测试都通过。&lt;/p&gt;
&lt;h2&gt;重构&lt;/h2&gt;
&lt;p&gt;我们需要的结果是既能像最先一个版本那样对整个测试返回一个结果，但是也需要能像第二个版本那样报告单个用例的执行情况。由于第二个版本更接近需求，因此可以在第二个版本的基础上重构，你最先想要做的一定是去掉重复的代码。&lt;/p&gt;
&lt;p&gt;去掉重复的FORMAT调用的最简单的方法是定义一个新函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun report-result (result form)
  (format t "~:[FAIL~;pass~] ... ~a~%" result form))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新编写的test-+，提升并不大，但是至少可以方便的修改结果报告的格式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (report-result (= (+ 1 2) 3) '(= (+ 1 2) 3))
  (report-result (= (+ 1 2 3) 6) '(= (+ 1 2 3) 6))
  (report-result (= (+ -1 -3) -4) '(= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来你需要去掉重复的测试用例表达式。在这里需要的是将表达式既作为代码（用于计算结果）又作为数据（用于报告结果）。每当你需要将代码作为数据时，这就是你需要使用宏的明确信号。可以编写一个宏来改进&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro check (form)
  `(report-result ,form ',form))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;test-+将变成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (check (= (+ 1 2) 3))
  (check (= (+ 1 2 3) 6))
  (check (= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然是在去掉重复代码，何必不将多余的check调用也去掉？你可以将check定义为可以接收任意数量的语句，将每个都包装成对report-result的调用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro check (&amp;amp;body forms)
  `(progn
     ,@(loop for f in forms collect `(report-result ,f ',f))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最新版本的test-+将变成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (check
    (= (+ 1 2) 3)
    (= (+ 1 2 3) 6)
    (= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它与下面的代码是等效的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (progn
    (report-result (= (+ 1 2) 3) '(= (+ 1 2) 3))
    (report-result (= (+ 1 2 3) 6) '(= (+ 1 2 3) 6))
    (report-result (= (+ -1 -3) -4) '(= (+ -1 -3) -4))))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;修正返回值&lt;/h2&gt;
&lt;p&gt;我们还需要修正一下test-+的返回值以标识出所有用例是否都通过了。由于check负责来生成代码，因此只需要修改它生成的代码就可以了。&lt;/p&gt;
&lt;p&gt;首先，需要让report-result返回测试的结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun report-result (result form)
  (format t "~:[FAIL~;pass~] ... ~a~%" result form)
  result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，看起来似乎只需要将PROGN修改为AND就可以了。但是AND有个问题，因为它有短路行为。如果某个测试用例失败，后面的测试用例将不会被执行。Common Lisp也没有提供这样的控制结构。因此我们需要编写一个宏提供这样的功能。它的行为类似于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(combine-results
  (foo)
  (bar)
  (baz))

(let ((result t))
  (unless (foo) (setf result nil))
  (unless (bar) (setf result nil))
  (unless (baz) (setf result nil))
  result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是这里引入了变量result。根据前面章节的介绍，这里会产生一个漏洞。我们需要使用with-gensyms来给它生成唯一的名字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro combine-results (&amp;amp;body forms)
  (with-gensyms (result)
    `(let ((,result t))
      ,@(loop for f in forms collect `(unless ,f (setf ,result nil)))
      ,result)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以将check修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro check (&amp;amp;body forms)
  `(combine-results
    ,@(loop for f in forms collect `(report-result ,f ',f))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样修改后test-+将在所有测试用例都通过时返回T。&lt;/p&gt;
&lt;h2&gt;更好报告测试结果&lt;/h2&gt;
&lt;p&gt;当我们使用下面的方式来使用combine-results时，如果test-+或&lt;code&gt;test-*&lt;/code&gt;中某个用例出现错误时，我们将无法知道这个错误是在test-+中还是在&lt;code&gt;test-*&lt;/code&gt;中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-* ()
  (check
    (= (* 2 2) 4)
    (= (* 3 5) 15)))

(defun test-arithmetic ()
  (combine-results
   (test-+)
   (test-*)))

CL-USER&amp;gt; (test-arithmetic)
pass ... (= (+ 1 2) 3)
pass ... (= (+ 1 2 3) 6)
pass ... (= (+ -1 -3) -4)
pass ... (= (* 2 2) 4)
pass ... (= (* 3 5) 15)
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于打印结果的代码位于report-result中，因此需要传递信息告诉report-result当前运行的函数的信息。可以在report-result中添加一个参数来传递这个信息，但是由宏生成的代码调用report-result，并不知道当前运行的函数的信息。这意味着要修改调用check的方法，将函数信息传递给check然后由它传递给report-result吗？&lt;/p&gt;
&lt;p&gt;解决这种问题的方法是使用动态变量。创建一个动态变量，在调用每个测试函数之前，将测试函数名称绑定到这个动态变量中，report-result并不需要添加参数。&lt;/p&gt;
&lt;p&gt;在最外部申明这个变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defvar *test-name* nil)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在report-result的FORMAT中使用这个变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(format t "~:[FAIL~;pass~] ... ~a: ~a~%" result *test-name* form)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样修改后再运行test-arithmetic将变成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (test-arithmetic)
pass ... NIL: (= (+ 1 2) 3)
pass ... NIL: (= (+ 1 2 3) 6)
pass ... NIL: (= (+ -1 -3) -4)
pass ... NIL: (= (* 2 2) 4)
pass ... NIL: (= (* 3 5) 15)
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是由于动态变量没有绑定。因此还需要修改两个测试函数，让它们在执行check前先绑定动态变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (let ((*test-name* 'test-+))
    (check
      (= (+ 1 2) 3)
      (= (+ 1 2 3) 6)
      (= (+ -1 -3) -4))))

(defun test-* ()
  (let ((*test-name* 'test-*))
    (check
      (= (* 2 2) 4)
      (= (* 3 5) 15))))


CL-USER&amp;gt; (test-arithmetic)
pass ... TEST-+: (= (+ 1 2) 3)
pass ... TEST-+: (= (+ 1 2 3) 6)
pass ... TEST-+: (= (+ -1 -3) -4)
pass ... TEST-*: (= (* 2 2) 4)
pass ... TEST-*: (= (* 3 5) 15)
T
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;抽象概念的崛起&lt;/h2&gt;
&lt;p&gt;在修正测试函数的过程中，你又引入了一些重复。除函数包含了函数名两次之外&amp;mdash;&amp;mdash;一次是在defun中，另一次是将它绑定到&lt;code&gt;*test-name*&lt;/code&gt;变量上，还有两个测试函数的三行代码所使用的模式是一样的。你可以将这些重复简单的删除，理由是重复是不好的。但是如果你仔细观察产生重复的根源，你将学习到关于使用宏的重要的一课。&lt;/p&gt;
&lt;p&gt;这些函数以相同的方式开始是因为它们都是测试函数。产生重复的原因在于，在这时，测试函数还只是半抽象的。抽象只存在于你的意识中，但是代码里并没有方法表达&amp;ldquo;这是一个测试函数&amp;rdquo;，而是按某种特殊的模式在编写代码。&lt;/p&gt;
&lt;p&gt;不幸的是，局部抽象构建软件的低劣的工具。因为半抽象是由代码的模式来表达的，你需要保证大规模的重复代码，其后果就是可维护性差。由于抽象只存在于程序员的意识中，没有机制确保不同的程序员（甚至同一程序员在不同的工作时间里）都能以相同的方式理解这个抽象。为了完整的表达这个抽象，你需要一个方法来表达&amp;ldquo;这是一个测试函数&amp;rdquo;并且按某一模式生成需要的代码。换句话来说，你需要一个宏。&lt;/p&gt;
&lt;p&gt;你需要封装的是一个DEFUN加上一些样板式的代码，你需要编写一个宏能展开成DEFUN。然后使用这个宏，而不是DEFUN来定义测试函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro deftest (name parameters &amp;amp;body body)
  `(defun ,name ,parameters
    (let ((*test-name* ',name))
      ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用这个宏重写test-+：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(deftest test-+ ()
  (check
    (= (+ 1 2) 3)
    (= (+ 1 2 3) 6)
    (= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;测试的层次&lt;/h2&gt;
&lt;p&gt;现在你已经将测试函数变成了一等公民，新问题出现了，test-arithmetic是一个测试函数吗？如果用deftest定义它，则它的名字会被绑定到&lt;code&gt;*test-name*&lt;/code&gt;，但这将在显示测试结果时被&lt;code&gt;test-+&lt;/code&gt;和&lt;code&gt;test-*&lt;/code&gt;的绑定屏蔽掉。&lt;/p&gt;
&lt;p&gt;设想一下你有成千上万个测试用例需要整理。第一级被组织到类似&lt;code&gt;test-+&lt;/code&gt;和&lt;code&gt;test-*&lt;/code&gt;的测试函数中，它们直接调用check。但是针对成千上万的测试，你将会需要按层次来组织它们。类似test-arithmetic的函数可以将相关的测试函数组织到测试套件中。假设某些低层次的测试方法被多个不同的测试套件调用。没有信息能告诉你它是在哪个测试套件中出错的。&lt;/p&gt;
&lt;p&gt;针对test-arithmetic做一些小调整，你就能得到出错的测试用例的完整路径（包含测试套件的名称）。使得测试的输出类似下面的格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pass ... (TEST-ARITHMETIC TEST-+): (= (+ 1 2) 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这可以通过让&lt;code&gt;*test-name*&lt;/code&gt;保存测试函数的列表，而不是只保存最近一次定义中所使用的名称，只需要将下面的语句修改一下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((*test-name* ',name))
(let ((*test-name* (append *test-name* (list ',name))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改后需要用deftest重新定义test-arithmetic。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(deftest test-arithmetic ()
  (combine-results
   (test-+)
   (test-*)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样整个测试的结果将显示为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (test-arithmetic)
pass ... (TEST-ARITHMETIC TEST-+): (= (+ 1 2) 3)
pass ... (TEST-ARITHMETIC TEST-+): (= (+ 1 2 3) 6)
pass ... (TEST-ARITHMETIC TEST-+): (= (+ -1 -3) -4)
pass ... (TEST-ARITHMETIC TEST-*): (= (* 2 2) 4)
pass ... (TEST-ARITHMETIC TEST-*): (= (* 3 5) 15)
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样即使测试套件的层次增加，你在测试结果中仍然可以得到完整的路径：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(deftest test-math ()
  (test-arithmetic))

CL-USER&amp;gt; (test-math)
pass ... (TEST-MATH TEST-ARITHMETIC TEST-+): (= (+ 1 2) 3)
pass ... (TEST-MATH TEST-ARITHMETIC TEST-+): (= (+ 1 2 3) 6)
pass ... (TEST-MATH TEST-ARITHMETIC TEST-+): (= (+ -1 -3) -4)
pass ... (TEST-MATH TEST-ARITHMETIC TEST-*): (= (* 2 2) 4)
pass ... (TEST-MATH TEST-ARITHMETIC TEST-*): (= (* 3 5) 15)
T
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;上面测试框架的完整代码如下，只有26行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defvar *test-name* nil)

(defmacro deftest (name parameters &amp;amp;body body)
  "Define a test function. Within a test function we can call
   other test functions or use 'check' to run individual test
   cases."
  `(defun ,name ,parameters
    (let ((*test-name* (append *test-name* (list ',name))))
      ,@body)))

(defmacro check (&amp;amp;body forms)
  "Run each expression in 'forms' as a test case."
  `(combine-results
    ,@(loop for f in forms collect `(report-result ,f ',f))))

(defmacro combine-results (&amp;amp;body forms)
  "Combine the results (as booleans) of evaluating 'forms' in order."
  (with-gensyms (result)
    `(let ((,result t))
      ,@(loop for f in forms collect `(unless ,f (setf ,result nil)))
      ,result)))

(defun report-result (result form)
  "Report the results of a single test case. Called by 'check'."
  (format t "~:[FAIL~;pass~] ... ~a: ~a~%" result *test-name* form)
  result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;值得回顾一下得到上面的代码的整个过程，因为它描绘出了通常情况下怎样编写Lisp程序。&lt;/p&gt;
&lt;p&gt;我们开始于为这个问题定义一个简单的版本&amp;mdash;&amp;mdash;如何执行一堆布尔类型的表达式并检查它们是否都返回true。这只需要使用AND将它们连接起来，但是还需要更好的显示测试结果。所以我们又编写了一些充满重复和容易出错的代码能以我们需要的方式显示测试结果。&lt;/p&gt;
&lt;p&gt;下一步我们重构了第二个版本得到了简洁的代码。首先是使用标准的重构技术将一些代码放到了函数report-result中。不幸的是，我们发现使用report-result时仍然是乏味且容易出错的，因为需要传递两次测试表达式，一次用于得到表达式的值另一次是将表达式本身作为数据。因此我们又编写了check宏自动生成对report-result调用的细节。&lt;/p&gt;
&lt;p&gt;当编写check时，我们意识到可以在单次check调用中可以生成多次对report-result的调用，这让我们回到了最初的最精简的使用AND的版本。&lt;/p&gt;
&lt;p&gt;这时check API已经固定下来，因为你可以直接修改它的内部来影响它的工作方式。下一个任务是修正代码让它返回一个值来标识整个测试是否全部通过。我们没有立即来hacking check方法，而是幻想设计一个小型的语言。幻想有一个没有AND的短路行为的控制结构。但是我们意识到没有那样的结构，但是我们可以编写一个这样的结构。编写完combine-results后，才发现对check的修正确实是微不足道的。&lt;/p&gt;
&lt;p&gt;现在只需要提升显示测试结果了。开始修改test函数时，我们认识到这些函数代表了一个特殊的函数分类，它们应该要有自己的抽象。因此我们编写了deftest来抽象测试函数的编码模式。&lt;/p&gt;
&lt;p&gt;deftest提供了抽象测试定义和下层机构间的抽象屏障，我们可以提升测试结果的显示而不需要动测试函数。&lt;/p&gt;
&lt;h1&gt;数字、字符和字符串&lt;/h1&gt;
&lt;h1&gt;集合&lt;/h1&gt;
&lt;p&gt;Lisp不光只是提供了List类型，同样有类似其它语言中的arrays、vectors、maps等结构。&lt;/p&gt;
&lt;h2&gt;Vectors&lt;/h2&gt;
&lt;p&gt;Vector是Common Lisp中以整数作为索引的集合，有两种口味。固定长度的类似于其它语言中的数组：一块连续的内存保存了vector的元素。另一种是可变长度的vectors，它与Perl或Ruby中的数组或Java中的ArrayList类更接近：它们抽象了初建的存储，允许vector增长和收缩以增加或删除元素。&lt;/p&gt;
&lt;p&gt;可以向VECTOR函数传递任意数量的参数以构建固定长度的vector。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(vector)     ==&amp;gt; #()
(vector 1)   ==&amp;gt; #(1)
(vector 1 2) ==&amp;gt; #(1 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;#(...)&lt;/code&gt;标记法能被Lisp printer和reader使用。这种语法让你可以通过PRINTing输出和READing读入来保存和恢复vector。你也可以在代码中直接使用这种标记方法，但是你应该使用VECTOR或更为通用的函数MAKE_ARRAY来创建需要修改的vectors。&lt;/p&gt;
&lt;p&gt;MAKE-ARRAY是比VECTOR更通用是因为使用它可以创建任意维度的固定长度或可变长度的vector。MAKE-ARRAY需要一个list参数，它包含数组的维度。由于vector是一维数组，这个list将只包含一个数字，即vector的长度。为了方便使用，MAKE-ARRAY在接收单个元素的list参数的位置可以只接收一个数字作为参数。如果没有其它参数，MAKE-ARRAY将创建一个元素未初初始化的vector。为了将元素初始化为特定的值，你可以传递&lt;code&gt;:initial-element&lt;/code&gt;作为参数。例如，创建包含5个NIL元素的vector：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(make-array 5 :initial-element nil) ==&amp;gt; #(NIL NIL NIL NIL NIL)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MAKE-ARRAY也可以用于构建可变长度的vector。可变长度的vector比固定长度的vector稍复杂一些，它不仅需要跟踪用于保存实际使用了的元素的使用，还需要跟踪可用元素槽的数量。这个数字保存在vector的fill pointer里，这样称乎是因为它是下一次向vector中添加元素时将被填充的位置。&lt;/p&gt;
&lt;p&gt;为了构建一个带fill pointer的vector，你需要向MAKE-ARRAY中传递一个&lt;code&gt;:fill-pointer&lt;/code&gt;参数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(make-array 5 :fill-pointer 0) ==&amp;gt; #()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用VECTOR-PUSH函数向可变长度的vector尾部添加元素。它将元素添加到当前fill pointer指向的索引位置，并将fill pointer加1，并返回新添加的元素的索引位置。VECTOR-POP返回最近推入的元素，并将fill pointer的位置减1。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *x* (make-array 5 :fill-pointer 0))

(vector-push 'a *x*) ==&amp;gt; 0
*x*                  ==&amp;gt; #(A)
(vector-push 'b *x*) ==&amp;gt; 1
*x*                  ==&amp;gt; #(A B)
(vector-push 'c *x*) ==&amp;gt; 2
*x*                  ==&amp;gt; #(A B C)
(vector-pop *x*)     ==&amp;gt; C
*x*                  ==&amp;gt; #(A B)
(vector-pop *x*)     ==&amp;gt; B
*x*                  ==&amp;gt; #(A)
(vector-pop *x*)     ==&amp;gt; A
*x*                  ==&amp;gt; #()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，即使带fill pointer的vector也不完全是可变长度的。前面的&lt;code&gt;*x*&lt;/code&gt;最多只能保存5个元素。为了构建一个可变长度的vector，还需要向MAKE-ARRAY传递另一个关键字参数：&lt;code&gt;:adjustable&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(make-array 5 :fill-pointer 0 :adjustable t) ==&amp;gt; #()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样构建的可变长度的vector它的下层的内存可以按需要进行调整。使用VECTOR-PUSH-EXTEND向这种vector中添加元素，它与VECTOR-PUSH类似，但是它在向一个已经填满了的vector中推入新元素时它将自动扩展，它的fill pointer与下层存储的大小相同。&lt;/p&gt;
&lt;h2&gt;Vector的子类型&lt;/h2&gt;
&lt;p&gt;前面看到的vector是通用的可以保存任何类型的对象。可以创建某些特殊的vector限制它只能保存某些类型的元素。使用这种特殊的vector的原因是它们可以被存储者更紧凑可以比通用的vector提供更快的访问速度。&lt;/p&gt;
&lt;p&gt;字符串就是一种特殊的保存字符的vector。字符串的专用的操作函数。但是由于它们也是vector，因此下面讨论的接收vector参数的函数也可以用于字符串。&lt;/p&gt;
&lt;p&gt;字面量类型的字符串，例如&amp;ldquo;foo&amp;rdquo;，与字面量vector的&lt;code&gt;#()&lt;/code&gt;写法是一样的&amp;mdash;&amp;mdash;它的长度是固定的，并且不允许修改。但是，你可以向MAKE-ARRAY中传递关键字参数&lt;code&gt;:element-type&lt;/code&gt;构建可变长度的字符串。这个参数接收一个类型描述。这里不讨论它所有它可以接收的描述符；传递符号CHARACTER可以构建一个字符串。注意这个符号前要加引号以免它被当作变量名称。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(make-array 5 :fill-pointer 0 :adjustable t :element-type 'character)  ""
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bit vectors的元素都是零或一&amp;mdash;&amp;mdash;也得到了一些特殊的对待。它的read/print语法类似&lt;code&gt;#*00001111&lt;/code&gt;并且有相当多的函数可以使用。比如：对两个bit array执行&amp;ldquo;与&amp;rdquo;操作。创建bit vector时传递的&lt;code&gt;:element-type&lt;/code&gt;的符号为BIT。&lt;/p&gt;
&lt;h2&gt;Vector作为Sequence&lt;/h2&gt;
&lt;p&gt;Vector和list都是抽象类型sequence下的两个具体子类型。下面的章节所讨论的关于sequence的函数，都适用于普通或特殊类型的vector，也可以适用于list。&lt;/p&gt;
&lt;p&gt;LENGTH函数返回sequence的长度，ELT允许你根据整数索引访问序列中的元素。LENGTH只接收一个sequence参数并返回它包含的元素数量。对于fill pointer类型的vector，这个值将是fill pointer的值。ELT，是element的简写，接收一个sequence和整数索引号（零到sequence的长度之间）并返回相应位置的元素。如果索引越界，ELT将产生错误。与LENGTH类似ELT将带fill pointer的vector当作fill pointer指定长度的vector。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *x* (vector 1 2 3))

(length *x*) ==&amp;gt; 3
(elt *x* 0)  ==&amp;gt; 1
(elt *x* 1)  ==&amp;gt; 2
(elt *x* 2)  ==&amp;gt; 3
(elt *x* 3)  ==&amp;gt; error
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ELT也是一个SETFable的地方，因此你可以设置某个特定元素的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf (elt *x* 0) 10)

*x* ==&amp;gt; #(10 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Sequence迭代函数&lt;/h2&gt;
&lt;p&gt;理论上说对于sequence的操作将归结为LENGTH，ELT和对ELT的SETF操作的结合，Common Lisp提供了大量的用于sequence的函数库。&lt;/p&gt;
&lt;p&gt;每类函数允许你表达某一类sequence操作。例如不显式的编写循环来查找或过滤特定的元素。&lt;/p&gt;
&lt;p&gt;表11-1。基础sequence函数&lt;/p&gt;
&lt;p&gt;Name || Required Arguments || Returns
COUNT | Item and sequence | Number of times item appears in sequence
FIND | Item and sequence | Item or NIL
POSITION | Item and sequence | Index into sequence of NIL
REMOVE | Item and sequence | Sequence with instances of item removed
SUBSTITUTE | New item, item, and sequence | Sequence with instances of item replaced with new item&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(count 1 #(1 2 1 2 3 1 2 3 4))         ==&amp;gt; 3
(remove 1 #(1 2 1 2 3 1 2 3 4))        ==&amp;gt; #(2 2 3 2 3 4)
(remove 1 '(1 2 1 2 3 1 2 3 4))        ==&amp;gt; (2 2 3 2 3 4)
(remove #\a "foobarbaz")               ==&amp;gt; "foobrbz"
(substitute 10 1 #(1 2 1 2 3 1 2 3 4)) ==&amp;gt; #(10 2 10 2 3 10 2 3 4)
(substitute 10 1 '(1 2 1 2 3 1 2 3 4)) ==&amp;gt; (10 2 10 2 3 10 2 3 4)
(substitute #\x #\b "foobarbaz")       ==&amp;gt; "fooxarxaz"
(find 1 #(1 2 1 2 3 1 2 3 4))          ==&amp;gt; 1
(find 10 #(1 2 1 2 3 1 2 3 4))         ==&amp;gt; NIL
(position 1 #(1 2 1 2 3 1 2 3 4))      ==&amp;gt; 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意REMOVE和SUBSTITUTE总是返回与它的参数sequence类型一致的sequence。&lt;/p&gt;
&lt;h2&gt;高阶函数的变种&lt;/h2&gt;
&lt;p&gt;对于刚才讨论过的函数，Common Lisp提供了两个高阶函数变种，在接收的参数前添加一个函数参数，这个参数将对sequence的每个元素都调用一次。其中一套变种函数是在基础函数的后面添加&lt;code&gt;-IF&lt;/code&gt;后缀。这些函数将在作为参数的函数返回true时计数、查找、删除或者替换sequence中的元素。另一套变种函数是以&lt;code&gt;-IF-NOT&lt;/code&gt;结尾的，它将在参数函数不返回true时计数、查找、删除或者替换sequence中的元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(count-if #'evenp #(1 2 3 4 5))         ==&amp;gt; 2

(count-if-not #'evenp #(1 2 3 4 5))     ==&amp;gt; 3

(position-if #'digit-char-p "abcd0001") ==&amp;gt; 4

(remove-if-not #'(lambda (x) (char= (elt x 0) #\f))
  #("foo" "bar" "baz" "foom")) ==&amp;gt; #("foo" "foom")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;-IF&lt;/code&gt;和&lt;code&gt;-IF-NOT&lt;/code&gt;与前面讨论的那些不带后缀的函数接收相同的关键字参数除了：&lt;code&gt;:test&lt;/code&gt;参数不需要，因为带后缀的函数的第一个参数就是这个函数。&lt;code&gt;:key&lt;/code&gt;参数，它用于将从序列中得到的元素转换为传递给&lt;code&gt;:test&lt;/code&gt;函数的参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(count-if #'evenp #((1 a) (2 b) (3 c) (4 d) (5 e)) :key #'first)     ==&amp;gt; 2

(count-if-not #'evenp #((1 a) (2 b) (3 c) (4 d) (5 e)) :key #'first) ==&amp;gt; 3

(remove-if-not #'alpha-char-p
  #("foo" "bar" "1baz") :key #'(lambda (x) (elt x 0))) ==&amp;gt; #("foo" "bar")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;REMOVE族的函数还支持第四种变种，REMOVE-DUPLICATES，它只需要一个sequence参数，它会从中删除所有重复的元素。它与REMOVE函数接收相同的关键字参数，但是&lt;code&gt;:count&lt;/code&gt;除外，因为它总是会移除重复的元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(remove-duplicates #(1 2 1 2 3 1 2 3 4)) ==&amp;gt; #(1 2 3 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;处理整个Sequence&lt;/h2&gt;
&lt;p&gt;有少量函数可以在同一时间操作整个sequence（或多个sequence）。比如，COPY-SEQ和REVERSE都只接收一个sequence作为参数，并返回相同类型的sequence。OPY-SEQ返回的sequence包含它的参数相同的元素。REVERSE返回的sequence也包含与参数相同的元素但是元素顺序是相反的。注意，它们都复制元素&amp;mdash;&amp;mdash;返回的sequence是一个新的对象。&lt;/p&gt;
&lt;p&gt;CONCATENATE函数创建新的sequence，这个sequence包含所连接的任意数量的sequence。但是与REVERSE和COPY-SEQ不同，它们返回与参数类型相同的sequence。CONCATENATE必须显式的被告知在参数类型不同的情况下应该返回哪个类型的sequence。它的第一个参数是类型描述符，与MAKE-ARRAY的&lt;code&gt;:element-type&lt;/code&gt;参数类似。在这里，类型描述符通常是：VECTOR、LIST或STRING。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(concatenate 'vector #(1 2 3) '(4 5 6))    ==&amp;gt; #(1 2 3 4 5 6)
(concatenate 'list #(1 2 3) '(4 5 6))      ==&amp;gt; (1 2 3 4 5 6)
(concatenate 'string "abc" '(#\d #\e #\f)) ==&amp;gt; "abcdef"
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;排序和合并&lt;/h2&gt;
&lt;p&gt;SORT和STABLE-SORT函数提供了两个对sequence排序的方法。它们都接收一个sequence和一个predicate函数作为参数并返回排序后的sequence。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(sort (vector "foo" "bar" "baz") #'string&amp;lt;) ==&amp;gt; #("bar" "baz" "foo")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个函数不同之处在于STABLE-SORT保证不会重新排序相等的元素，而SORT有可能会对相等的元素重新排序。&lt;/p&gt;
&lt;p&gt;这些函数是&amp;ldquo;破坏性&amp;rdquo;函数的例子。破坏性函数允许&amp;mdash;&amp;mdash;通常是基于效率原因&amp;mdash;&amp;mdash;以任意方法或多或少的修改它们的参数。这有两个含义：其一，你总是应该对这些函数的返回值做某些处理（比如将它赋值给变量或将它传递到其它的函数），其二，除非你对将要传递给破坏性函数的参数已经操作完毕了，否则你应该传递它的拷贝。&lt;/p&gt;
&lt;p&gt;通常在排序后你不会关心未排序的版本，因此有意允许SORT和STABLE-SORT在排序过程中销毁sequence。这意味着你需要记得将代码写成下面的样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf my-sequence (sort my-sequence #'string&amp;lt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf my-sequence (sort my-sequence #'string&amp;lt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些函数也接收一个关键字参数，&lt;code&gt;:key&lt;/code&gt;，它与其它sequence函数中的&lt;code&gt;:key&lt;/code&gt;参数类似，它是一个可以将元素转换为传递给predicate函数作参数的函数。这个解析出来的key只是用于决定元素的排序；返回原sequence仍将包含参数sequence中的元素。&lt;/p&gt;
&lt;p&gt;MERGE函数接收两个sequence和一个predicate，并返回一个根据predicate由两个sequence合并而成的sequence。这与两个排序函数有关如果两个sequence都已经由相同的predicate排序过，则MERGE所返回的sequence将也被排序。与排序函数类似，MERGE也接收&lt;code&gt;:key&lt;/code&gt;关键字参数。与CONCATENATE函数类似，基于同样的原因，传递给MERGE的第一个参数用于指定要构造的sequence的类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(merge 'vector #(1 3 5) #(2 4 6) #'&amp;lt;) ==&amp;gt; #(1 2 3 4 5 6)
(merge 'list #(1 3 5) #(2 4 6) #'&amp;lt;)   ==&amp;gt; (1 2 3 4 5 6)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;subsequence处理&lt;/h2&gt;
&lt;p&gt;最基础的函数是SUBSEQ，它从一个sequence中从特定的开始位置到结束位置提取子sequence。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(subseq "foobarbaz" 3)   ==&amp;gt; "barbaz"
(subseq "foobarbaz" 3 6) ==&amp;gt; "bar"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SUBSEQ也是SETFable的，但是它不会扩展或缩短sequence；如果新值和将被替换的subsequence的长度不同，较短的那个将决定实际将替换多少个。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *x* (copy-seq "foobarbaz"))

(setf (subseq *x* 3 6) "xxx")  ; subsequence and new value are same length
*x* ==&amp;gt; "fooxxxbaz"

(setf (subseq *x* 3 6) "abcd") ; new value too long, extra character ignored.
*x* ==&amp;gt; "fooabcbaz"

(setf (subseq *x* 3 6) "xx")   ; new value too short, only two characters changed
*x* ==&amp;gt; "fooxxcbaz"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用FILL函数将sequence中的多个元素设置为同一个值。需要的参数是一个sequence和将被填充的值。默认情况下sequence的所有元素都会被设置为这个值；&lt;code&gt;:start&lt;/code&gt;和&lt;code&gt;:end&lt;/code&gt;关键字参数可以限制它所影响的subsequence。&lt;/p&gt;
&lt;p&gt;如果你需要在sequence中查找subsequence，可以像使用POSITION一样使用SEARCH函数，除了它的第一个参数是一个sequence而不是单个元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(position #\b "foobarbaz") ==&amp;gt; 3
(search "bar" "foobarbaz") ==&amp;gt; 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了查找出两个sequence是从哪里开始有不同元素的可以使用MISMATCH函数。它接收两个sequence并返回第一个不匹配的元素的索引。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(mismatch "foobarbaz" "foom") ==&amp;gt; 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果字符串匹配它将返回NIL。MISMATCH也可以接收许多标准的关键字参数&lt;code&gt;:key&lt;/code&gt;参数指定提取进行比较的值的函数；&lt;code&gt;:test&lt;/code&gt;参数指定比较函数；&lt;code&gt;:start1&lt;/code&gt;，&lt;code&gt;:end1&lt;/code&gt;，&lt;code&gt;:start2&lt;/code&gt;，&lt;code&gt;:end2&lt;/code&gt;用于指定两个sequence中的subsequence。&lt;code&gt;:from-end&lt;/code&gt;参数为T时表示应该从后面开始搜索，这时将返回从后面开始查找直到遇到不同元素时的在第一个sequence中的索引。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(mismatch "foobar" "bar" :from-end t) ==&amp;gt; 3
(mismatch "fooobar" "bar" :from-end t) ==&amp;gt; 4
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Sequence Predicates&lt;/h2&gt;
&lt;p&gt;有四个方便的函数EVERY、SOME、NOTANY和NOTEVERY，它们迭代整个sequence并使用predicate进行测试。它们的第一个参数是一个preicate函数，后面的参数是sequencesp。Predicate函数应该能接收sequence传递给它的所有参数。每次从sequence中取一个元素传递给predicate&amp;mdash;&amp;mdash;直到元素都处理完或者遇到终止测试：在遇到某个predicate失败时整个EVERY终上，并返回false。如果predicate总是成立，则它返回true。SOME返回第一个由predicate返回的非NIL值，或者在所有predicate都不成立时返回false。NOTANY在遇到某个predicate满足条件时返回true或者在所有predicate都不成立时返回false。NOTEVERY在predicate失败时返回true或者在所有predicate都成立时返回false。一些例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(every #'evenp #(1 2 3 4 5))    ==&amp;gt; NIL
(some #'evenp #(1 2 3 4 5))     ==&amp;gt; T
(notany #'evenp #(1 2 3 4 5))   ==&amp;gt; NIL
(notevery #'evenp #(1 2 3 4 5)) ==&amp;gt; T
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(every #'&amp;gt; #(1 2 3 4) #(5 4 3 2))    ==&amp;gt; NIL
(some #'&amp;gt; #(1 2 3 4) #(5 4 3 2))     ==&amp;gt; T
(notany #'&amp;gt; #(1 2 3 4) #(5 4 3 2))   ==&amp;gt; NIL
(notevery #'&amp;gt; #(1 2 3 4) #(5 4 3 2)) ==&amp;gt; T
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Sequence Mapping函数&lt;/h2&gt;
&lt;p&gt;MAP与predicate函数类似，接收一个n-argument函数和n个sequences。但是它不是返回boolean值，MAP返回新的sequence包含将函数应用到sequence元素的返回值。与CONCATENATE、MERGE类似，MAP也需要知道要构建出什么样的sequence。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(map 'vector #'* #(1 2 3 4 5) #(10 9 8 7 6)) ==&amp;gt; #(10 18 24 28 30)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MAP-INTO与MAP类似它不是构建一个给定类型的sequence，而是它将结果放到一个sequence并将它作为第一个参数传递。这个sequence可以是向函数提供值的sequence。例如，汇总多个vectors&amp;mdash;&amp;mdash;a、b和c，可以写成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(map-into a #'+ a b c)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果sequences的长度不相等，MAP-INTO只会影响最短的sequence那个长度的元素数量，包括将要mapped into的那个sequence。但是，如果将要mapped into的vector是fill pointer的，则受影响的元素个数不限制于fill pointer而是受限于vector实际的大小。在调用完MAP-INTO，fill pointer将被设置为mapped的元素的数量。但是，MAP-INTO不会扩展一个可扩展的vector。&lt;/p&gt;
&lt;p&gt;最后一个sequence函数是REDUCE，它执行另一类型的mapping：它遍历单个sequence，调用一个接收两个参数的函数，首先使用sequence的头两个元素作为参数，然后使用返回值和sequence中后面的元素作为参数。因此，下面的语句表达的是对1到10进行求和：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(reduce #'+ #(1 2 3 4 5 6 7 8 9 10)) ==&amp;gt; 55
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;REDUCE在当你需要将一个sequence处理为单一值时非常有用，当你使用它来表达时也非常的简洁。例如，查找sequence中的最大值，你可以写作&lt;code&gt;(reduce #'max numbers)&lt;/code&gt;。REDUCE也可以接收所有的关键字参数&lt;code&gt;(:key, :from-end, :start, :end)&lt;/code&gt;，并能接收一个独特的&lt;code&gt;(:initial-value)&lt;/code&gt;参数。它指定一个逻辑上放在sequence最前面的值（或者在你指定了&lt;code&gt;:from-end&lt;/code&gt;时放在sequence的最后面）。&lt;/p&gt;
&lt;h2&gt;Hash Tables&lt;/h2&gt;
&lt;p&gt;Common lisp提供的另一种通用集合是hash table。vector提供整型索引的数据结构，Hash table则允许你使用任意类型的对象作为索引，或keys。当你向hash table中添加新值时，你将它存储于一个特定的key下。后面你可以使用相同的key来访问这个值。或者你也可以使用相同的key来关联新值&amp;mdash;&amp;mdash;每个key对应于单个值。&lt;/p&gt;
&lt;p&gt;当使用无参数的MAKE-HASH-TABLE构建hash table时会使用EQL来判断两个key是否相等。这是一个很好的默认值，除非你需要使用字符串作为key，因为两个包含相同内容的字符串并不一定是EQL的。这种情况下你需要告诉hash table使用EQUAL来检查key是否相等，你可以向MAKE-HASH-TABLE函数传递一个关键字参数&lt;code&gt;:test&lt;/code&gt;，它的值为EQUAL符号。&lt;code&gt;:test&lt;/code&gt;的另外两个可能的值为符号EQ和EQUALP。这些是标准对象的比较函数的名称。与传递给sequence函数的&lt;code&gt;:test&lt;/code&gt;参数不同，MAKE-HASH-TABLE的&lt;code&gt;:test&lt;/code&gt;参数不允许传递任意的函数&amp;mdash;&amp;mdash;只允许EQ，EQL，EQUAL和EQUALP。这是因为hash table实际上需要两个函数，一个用于测试相等性，另一个hash函数用于从key计算出数值类型的hash code值，它能用于最终作为比较两个keys的值。尽管语言标准只允许使用标准的相等性测试函数，但是多数实现中都提供了某些机制自定义hash table。&lt;/p&gt;
&lt;p&gt;GETHASH函数提供了访问hash table元素的功能。它接收两个参数&amp;mdash;&amp;mdash;key和hash table&amp;mdash;&amp;mdash;并返回值，如果不存在则返回NIL。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *h* (make-hash-table))

(gethash 'foo *h*) ==&amp;gt; NIL

(setf (gethash 'foo *h*) 'quux)

(gethash 'foo *h*) ==&amp;gt; QUUX
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于GETHASH将在key不存在时返回NIL，因此没有办法从返回值知道hash table中是不存在那个key还是key所对应的值为NIL。GETHASH使用了一个我们还没有使用过的特性来解决这个问题&amp;mdash;&amp;mdash;多返回值。GETHASH实际上返回了两个值；主要的值是存储于key下的值或者NIL。次要的值是一个boolean类型的值标识key是否存在于hash table中。由于多返回值的工作方式，这个特殊的返回值被丢弃掉除非调用者显式的处理它才能&amp;ldquo;看到&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;后面的章节将讨论多返回值，但这里我们将了解一下如何使用MULTIPLE-VALUE-BIND宏来从GETHASH中得到特殊的返回值。MULTIPLE-VALUE-BIND将与LET类似创建一个变量，并使用多返回值来填充它们。&lt;/p&gt;
&lt;p&gt;下面的函数展示了你可以使用MULTIPLE-VALUE-BIND；变量将绑定到value和present：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun show-value (key hash-table)
  (multiple-value-bind (value present) (gethash key hash-table)
    (if present
      (format nil "Value ~a actually present." value)
      (format nil "Value ~a because key not found." value))))

(setf (gethash 'bar *h*) nil) ; provide an explicit value of NIL

(show-value 'foo *h*) ==&amp;gt; "Value QUUX actually present."
(show-value 'bar *h*) ==&amp;gt; "Value NIL actually present."
(show-value 'baz *h*) ==&amp;gt; "Value NIL because key not found."
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于设置某个key对应的值为NIL后，这个key仍然会存在于table中，因此你需要另一个函数将键值对完全从hash table中删除。REMHASH接收GETHASH相同的参数并将移除相应的键值对。你也可以使用CLRHASH来清空hash table中的所有键值对。&lt;/p&gt;
&lt;h2&gt;Hash Table迭代&lt;/h2&gt;
&lt;p&gt;Common Lisp提供了一些方法迭代hash table的所有entries。最简单的是通过MAPHASH函数。类似MAP函数，MAPHASH接收一个接收两个参数的函数和一个hash table并使用hash table中的键值对依次调用这个函数。例如，打印hash table中的所有键值对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(maphash #'(lambda (k v) (format t "~a =&amp;gt; ~a~%" k v)) *h*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在迭代过程中向hash table中添加或删除元素的结果不明确（通常会是不好的）：你可以使用SETF和GETHASH修改当前entry的值，使用REMHASH移除当前的entry。例如，移除所有值小于10的entries，可以写成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(maphash #'(lambda (k v) (when (&amp;lt; v 10) (remhash k *h*))) *h*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一迭代整个hash table的方法是使用扩展过的LOOP宏，下面的LOOP与第一个MAPHASH表达式是等效的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(loop for k being the hash-keys in *h* using (hash-value v)
  do (format t "~a =&amp;gt; ~a~%" k v))
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;叫作LISP的原因：List Processing&lt;/h1&gt;
&lt;p&gt;List在Lisp中扮演了一个重要的角色&amp;mdash;&amp;mdash;这是由于历史原因也是由于实际的需要。历史上，lists是Lisp原来的复合数据类型，尽管它已经存在十年了。现在，Common Lisp程序员可以使用vector、hash table或用户定义的类或结构而不只是使用list。&lt;/p&gt;
&lt;p&gt;从实际上来说，lists仍然存在于语言中因为它们对某些问题来说是优秀的解决方法。比如&amp;mdash;&amp;mdash;在使用宏时将代码当作数据来处理，这也可以解释为什么其它语言中不会觉得缺少Lisp风格的lists。更一般的来说，lists是一种用于描述混合的和/或有层次结构的数据优秀的结构。它也很轻量级并且支持函数式编程风格。&lt;/p&gt;
&lt;h2&gt;"There Is No List"&lt;/h2&gt;
&lt;p&gt;List的大部分特性是基于cons cells的，使用CONS函数可以构建它。&lt;/p&gt;
&lt;p&gt;CONS接收两个参数返回一个包含这两个值的cons cell。这两个值可以是指向任何对象。除非第二个值是NIL或另一个cons cell，cons总是被打印为括号中的以点号分开的两个值，因此也被称作dotted pair。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(cons 1 2) ==&amp;gt; (1 . 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cons cell的两个值被称作CAR和CDR，可以用同名的函数来访问它们。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(car (cons 1 2)) ==&amp;gt; 1
(cdr (cons 1 2)) ==&amp;gt; 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CAR和CDR都是SETFable的，例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *cons* (cons 1 2))
*cons*                 ==&amp;gt; (1 . 2)
(setf (car *cons*) 10) ==&amp;gt; 10
*cons*                 ==&amp;gt; (10 . 2)
(setf (cdr *cons*) 20) ==&amp;gt; 20
*cons*                 ==&amp;gt; (10 . 20)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于cons cell中的值可以指向任何类型的对象，因此可以通过将cons cells连接起来构建大型的数据结构。List是通过将cons cells链接成链。list中的元素保存在cons cell的CAR中，后面的subsequence保存在cons cell的CDR中。最后一个cell的CDR为NIL&amp;mdash;&amp;mdash;它表示空的list或boolean值false。&lt;/p&gt;
&lt;p&gt;单向链表。&lt;/p&gt;
&lt;p&gt;因此在讲到某个值为list时，它可能为NIL也可能指向一个cons cell。Lisp printer不会将lists打印成dotted pair格式，而是打印成括号包含的list格式。&lt;/p&gt;
&lt;p&gt;FIRST和REST是CAR和CDR的同义词。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *list* (list 1 2 3 4))
(first *list*)        ==&amp;gt; 1
(rest *list*)         ==&amp;gt; (2 3 4)
(first (rest *list*)) ==&amp;gt; 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为cons cells可以保存任意类型的值，因此单个list中可以包含不同类型的对象。&lt;/p&gt;
&lt;h2&gt;函数式编程和List&lt;/h2&gt;
&lt;p&gt;函数式编程的本质是构建不带副作用的函数，它只依赖于它的参数计算出结果。好处是让程序易于理解。消除副作用消除了所有可能的超距离作用。因为函数的结果只取决于它的参数，因此它的行为易于理解和测试。&lt;/p&gt;
&lt;p&gt;处理数字的函数自然就是函数式的因为数字本身就是不可变的。但是List则是可变的，比如在cons cell的CAR和CDR上使用SETF。但是list也可以被当作是函数式的数据类型，如果你将它们的值当作由它们所包含的元素来决定。因此(1 2 3 4)这个list与任何包含这4个数的list是函数性（functionally）相等的，而不管它们是否由相同的cons cells构成。接收这个list作为参数，并依照这个list的内容生成返回值的函数就被认为是函数式的。例如，REVERSE函数，给予参数(1 2 3 4)，后总是返回(4 3 2 1)。以不同的函数性相等的list参数调用REVERSE时得到的是函数性相等的list。函数式编程的另一方面是，使用高阶函数：函数将其它函数当作数据，将它们作为参数或返回值。&lt;/p&gt;
&lt;p&gt;多数list函数被编写为函数式是因为它们的返回值与它们的参数共享cons cells。比如APPEND接收任意数量的list参数并返回一个新的包含了所有参数中的元素的list。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(append (list 1 2) (list 3 4)) ==&amp;gt; (1 2 3 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从函数式的观点来看，APPEND的工作是返回list (1 2 3 4)而不修改list(1 2)和(3 4)中的任何cons cells。很显然达到这一目的的方法是构建一个包含4个新cons cells的全新的list。但这必然要做更多的工作。因此，APPEND实际上只创建了两个新的cons cells保存1和2，然后将它们与最后一个参数(3 4)的CDR连接起来。然后返回包含1的cons cell。原始的cons cells都没有改变，结果也是正确的list (1 2 3 4)。唯一的瑕疵是返回的list与list (3 4)共享了一些cons cells。&lt;/p&gt;
&lt;p&gt;按前面的办法APPEND必须复制所有它的参数，但它可以的返回值与最后一个参数共享了结构。&lt;/p&gt;
&lt;p&gt;其它函数也以类似的方式从共享结构中得到好处。APPEND总是返回共享结构。其它函数则依赖于具体的实现了。&lt;/p&gt;
&lt;h2&gt;"Destructive"操作&lt;/h2&gt;
&lt;p&gt;如果Common Lisp是一种纯函数式语言，那故事到此就结束了。但是它允许使用SETF修改CAR或CDR，我们要更多的考虑共享结构的副作用。&lt;/p&gt;
&lt;p&gt;因为Lisp的函数式传统，修改已有对象的操作被称为destructive，改变对象的状态&amp;ldquo;destroys&amp;rdquo;了它因为它不再表述与原值相同的值了。但是，使用相同术语描述所有状态改变的操作将导致某种困惑因此有两种不同类型的destructive操作，for-side-effect操作和recycling操作。&lt;/p&gt;
&lt;p&gt;For-side-effect操作是那些使用它们是因为需要它们的副作用。所有使用SETF都是这种情况，其它使用了SETF的函数也是这种情况，比如VECTOR-PUSH或VECTOR-POP。但是将这些操作当作destructive操作些不公平&amp;mdash;&amp;mdash;它们并不是在函数式风格的代码中故意被编写，因此它们不应该讨论它们是否使用函数式技术。但是，如果你混合了非函数式风格，for-side-effect操作的函数返回了共享结构的结果，则你要小心而不要去修改共享结构。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *list-1* (list 1 2))
(defparameter *list-2* (list 3 4))
(defparameter *list-3* (append *list-1* *list-2*))

*list-1*                  ==&amp;gt; (1 2)
*list-2*                  ==&amp;gt; (3 4)
*list-3*                  ==&amp;gt; (1 2 3 4)

(setf (first *list-2*) 0) ==&amp;gt; 0
*list-2*                  ==&amp;gt; (0 4)     ; as expected
*list-3*                  ==&amp;gt; (1 2 0 4) ; maybe not what you wanted
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种类型的destructive操作，recycling操作，是有意出现在函数式代码中的。它们的副作用是由于优化。特别是重用参数中的某些cons cells来构建结果。然而与APPEND之类的函数不同的是，在APPEND中是征用并包含cons cells，不修改参数的list，recycling函数会将cons cells作为原材料，修改CAR和CDR来构建想要的结果。因此，recycling函数只在原始的lists不再被需要时才能被安全的使用。&lt;/p&gt;
&lt;p&gt;为了解recycling函数如何工作，让我们比较一下REVERSE，它是nondestructive的，返回一个排过序的sequence，NREVERSE是这个函数的recycling版本。由于REVERSE不修改它的参数，它必须要给需要被排序的list中的每个元素都分配一个新的cons cell。但你可以会编写下面这样的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf *list* (reverse *list*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过将REVERSE的结果重新赋给&lt;code&gt;*list*&lt;/code&gt;，这将会移除&lt;code&gt;*list*&lt;/code&gt;原始指向的值的引用。list中原来的值将不再被引用，它们将有可能被垃圾收集器收集。但是，在许多Lisp实现中更有效的做法是立即使用已经存在的cons cells而不是重新分配一个新的而让原来的变成垃圾。&lt;/p&gt;
&lt;p&gt;NREVERSE允许你执行这样的操作。N表示non-consing，意味着你不需要分配任何新的cons cells。NREVERSE的副作用细节在这里不进行细究&amp;mdash;&amp;mdash;它允许修改list中任何cons cell的CAR和CDR&amp;mdash;&amp;mdash;但是通常的实现可能会遍历list来修改每个cons cell的CDR让它指向前一个cons cell，最后返回旧的list的最后一个cons cell，它现在变成了逆序后的list的头。这个过程没有必要分配新的cons cells，也没有产生垃圾。&lt;/p&gt;
&lt;p&gt;多数类似NREVERSE的recycling函数，都有nondestructive的对等的函数。通常recyling函数有non-destructive相同的名字除了它们前面以N开头。但是，并不全是这样的，这包含了一些常用的更常用的recyling函数，比如NCONC，它是APPEND的recyling版本，DELETE，DELETE-IF，DELETE-IF-NOT和DELETE-DUPLICATES，它是REMOVE族函数的recyling版本。&lt;/p&gt;
&lt;p&gt;通常，可以像使用nondestructive函数一样使用recyling函数但是你要知道函数返回后参数不再需要被作用。不要依赖于recyling函数的副作用。&lt;/p&gt;
&lt;p&gt;但是一小撮recyling函数的副作用却可以依赖。比如NCONC，APPEND的recyling版本，和NSUBSTITUTE和它的-IF和-IF-NOT变种，它们是SUBSTITUTE等的recyling版本。&lt;/p&gt;
&lt;p&gt;与APPEND一样，NCONC返回拼接了参数的list，但它以下面的方式构建返回值：对于每个非空list，NCONC将这个list的最后一个cons cell的CDR指向下一个非空list的第一个cons cell。它返回第一个list，这个list是整个结果的头部了。因此：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *x* (list 1 2 3))

(nconc *x* (list 4 5 6)) ==&amp;gt; (1 2 3 4 5 6)

*x* ==&amp;gt; (1 2 3 4 5 6)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NSUBSTITUTE及其变种也可以依赖，它遍历list结构将保存旧值的cons cells设置为新值或者让它保存不变。然后返回原始的list，它与SUBSTITUTE返回的值相同。&lt;/p&gt;
&lt;p&gt;关键是要记得对于不依赖于recyling函数的副作用这条规则来说&amp;mdash;&amp;mdash;NCONC和NSUBSTITUTE的是个例外。比较理想的办法是与其它recyling函数一样忽略它们的副作用，只使用它们的返回值。&lt;/p&gt;
&lt;h2&gt;组合recyling和共享结构&lt;/h2&gt;
&lt;p&gt;尽管你可以在调用完recycling函数后不再使用参数，但是值得注意的是每个recyling函数都是一把指向脚面的上了膛的枪：如果你不小心在后面使用了recyling函数的参数，你可能会丢掉几个脚趾。&lt;/p&gt;
&lt;p&gt;为了让事情变得更糟，共享结构和recyling函数通常是目的相反的。Nondestructive list函数返回共享结构的list符合cons cells没有被修改的意愿，但是recyling函数的工作方式则违背了这个意愿。或者，换一种说法，共享结构的前提是基于你不在意到底是哪些cons cells构成了list但使用recyling函数则需要你明确的知道cons cells指向了哪里。&lt;/p&gt;
&lt;p&gt;实际上，recyling函数往往使用在几个惯用的地方。最常见的情况是使用使用&amp;ldquo;consing&amp;rdquo;将元素加到list的前面构建一个list，通常是PUSH元素到list并保存于本地变量然后返回将它NREVERSE后的结果。&lt;/p&gt;
&lt;p&gt;这是一种高效的构建list的做法因为每次PUSH都只创建了一个cons cell修改了一个局部变量并且NREVERSE只是zip down the list并修改它的CDR。因为这个list只在函数内部被创建，因此对函数的外部对任何cons cells有引用的代码来说没有危险。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun upto (max)
  (let ((result nil))
    (dotimes (i max)
      (push i result))
    (nreverse result)))

(upto 10) ==&amp;gt; (0 1 2 3 4 5 6 7 8 9)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一个惯用的地方是立即重新赋值给潜在的将被回收的变量。比如DELETE函数，REMOVE的recyling版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf foo (delete nil foo))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将让foo指向它的旧值，只是所有的NIL都被删除了。但是，即使是这种用法也要小心&amp;mdash;&amp;mdash;如果foo与其它地方的list共享结构，使用DELETE替代REMOVE可能会破坏那些list结构。例如，假定&lt;code&gt;*list-2*&lt;/code&gt;和&lt;code&gt;*list-３*&lt;/code&gt;共享他们的最后两个cons cells。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*list-2* ==&amp;gt; (0 4)
*list-3* ==&amp;gt; (1 2 0 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下面的方法从&lt;code&gt;*list-3*&lt;/code&gt;中删除4：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf *list-3* (delete 4 *list-3*)) ==&amp;gt; (1 2 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DELETE将第三个cons cell的CDR设置为NIL，将它与第4个cons cell从list中断开。因为&lt;code&gt;*list-3*&lt;/code&gt;中的第3个cons cell也是&lt;code&gt;*list-2*&lt;/code&gt;中的第1个cons cell，&lt;code&gt;*list-2*&lt;/code&gt;将变为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*list-2* ==&amp;gt; (0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果使用REMOVE来代替DELETE，将构造出包含值1,2和0的list，创建新的cons cells而不会修改&lt;code&gt;*list-3*&lt;/code&gt;中的cons cells。这种情况下，&lt;code&gt;*list-2*&lt;/code&gt;将不会受影响。&lt;/p&gt;
&lt;p&gt;对于PUSH/NREVERSE和SETF/DELETE，80%的都习惯于使用recyling函数。其它的使用情况也是可能的，但是需要谨慎的跟踪哪个返回的是共享结构，哪个不是。&lt;/p&gt;
&lt;p&gt;通常，在处理list时，最好是用函数式风格编写你的代码&amp;mdash;&amp;mdash;你的函数应该只依赖于list参数的内容而不去修改它们。按这个规则，排除使用destructive函数，recyling或其它方式。一旦代码能工作后，如果profiling显示你需要进行优化，你可以将非destructive操作替换成recyling的版本。但是这只应该在你确信参数中的list不会被其它地方引用时。&lt;/p&gt;
&lt;p&gt;最后一个需要注意的是排序函数SORT，STABLE-SORT和MERGE也都是recyling函数。这些函数没有非destructive版本，因此如果你需要对list进行排序而不破坏它，你需要使用COPY-LIST复制一份需要排序的list，再传递给排序函数。在这两种情况下你都需要保证保留排序函数的结果因为原始的参数已经破损了。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (defparameter *list* (list 4 3 2 1))
*LIST*
CL-USER&amp;gt; (sort *list* #'&amp;lt;)
(1 2 3 4)                      ; looks good
CL-USER&amp;gt; *list*
(4)                            ; whoops!
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;List处理函数&lt;/h2&gt;
&lt;p&gt;FIRST和REST返回list中的第一个和其它元素。为了便于使用Common Lisp还提供了从SECOND到TENTH来返回list中相应的元素。还有更为通用的NTH函数，它接收两个参数，一个索引和一个list，返回list中索引（从0开始）对应的元素。类似的还有NTHCDR接收一个索引和一个list返回n次调用CDR的结果。（因此，(nthcdr 0 ...)将返回原始的list，而(nthcdr 1 ...)则相当于REST）。这些函数的操作只是FIRST和REST的组合。&lt;/p&gt;
&lt;p&gt;28个由CAR/CDR组合而成的函数是另一族函数。每个函数名都将多至4个的A和D放在C和R之间，每个A表示一个CAR每个D代表一次CDR。因此：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(caar list) === (car (car list))
(cadr list) === (car (cdr list))
(cadadr list) === (car (cdr (car (cdr list))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些函数都会认为它的list包含了其它list，如果参数不包含其它list元素，这些函数处理的是trees而不是lists：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(caar (list 1 2 3))                  ==&amp;gt; error
(caar (list (list 1 2) 3))           ==&amp;gt; 1
(cadr (list (list 1 2) (list 3 4)))  ==&amp;gt; (3 4)
(caadr (list (list 1 2) (list 3 4))) ==&amp;gt; 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些函数在现在已经用得较少了。即使是顽固派的Lisp hacker也会避免使用过长的这种组合。但是，这些组合可能会出现在旧的Lisp代码中。&lt;/p&gt;
&lt;p&gt;如果你以非函数式风格使用lists，FIRST-TENTH和CAR，CADR这些函数可以用于SETFable的地方。&lt;/p&gt;
&lt;p&gt;其它函数：
函数         || 描述
LAST         | 返回list的最后一个con cell。如果带有整型参数，则返回最后的第n个cons cells。
BUTLAST      | 返回除list中最后一个con cell的复制品。带有整数参数时则排除最后的第n个cells。
NBUTLAST     | BUTLAST的recyling版本；将会修改并返回参数list但是没有可靠的side effects。
LDIFF        | 返回到达给定cons cell的list的复制品。
TAILP        | 如果给定的对象是一个cons cell并且它属于list的结构的一部分则返回true。
LIST*        | 构建一个包含所有元素的list但是最后一个参数将作为最后一个cell的CDR。即对最后一个元素使用append。
MAKE-LISt    | 构建一个包含n个元素的list。这个list各元素的初始值是NIL或使用&lt;code&gt;:initial-element&lt;/code&gt;关键字参数指定的值。
REVAPPEND    | 合并REVERSE和APPEND；用REVERSE对第一个参数逆序然后append第二个参数。
NRECONC      | REVAPPEND的recyling版本；用NREVERSE对第一个参数逆序然后append第二个参数。
CONSP        | 判断某个对象是否为cons cell。
ATOM         | 判断某个对象是否不是cons cell。
LISTP        | 判断某个对象是否为cons cell或NIL。
NULL         | 判断某个对象是否为NIL。功能上等同于NOT，但最好的风格是在测试空的list而不是布尔值FALSE时使用。&lt;/p&gt;
&lt;h2&gt;Mapping&lt;/h2&gt;
&lt;p&gt;对高阶函数的使用是函数式编程风格的另一个重要方面，函数接收其它函数作为参数或者返回使用函数作为返回值。尽管MAP可以用于list和vector（任何sequence），Common Lisp也提供了六个专门处理list的mapping函数。这六个函数的不同之处在于如何构建返回值以及是否将函数应用于list元素或list结构中的cons cells。&lt;/p&gt;
&lt;p&gt;MAPCAR是最像MAP的。因为它总是返回一个list，它不像MAP需要result-type参数。它的第一个参数是将要应用到元素上的函数，其它参数是lists，它们中的元素作为参数提供给函数参数。在它方面，它与MAP类似：函数被应用到list参数的每个元素，每次从每个list中提取一个元素。每次函数调用的结果收集到一个新的list作为返回值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(mapcar #'(lambda (x) (* 2 x)) (list 1 2 3)) ==&amp;gt; (2 4 6)
(mapcar #'+ (list 1 2 3) (list 10 20 30)) ==&amp;gt; (11 22 33)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MAPLIST与MAPCAR类似只是每次传递的不是list中的元素。第一次执行时将整个list作为参数传递，然后是每个list的cdr，然后是cdr的cdr。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) 
==&amp;gt;  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MAPCAN和MAPCON与MAPCAR和MAPLIST类似，只是构建结果的方式不同。MAPCAR和MAPLIST将每次函数调用的结果保存到一个新的list里，类似于用LIST方法构建一个新的LiST，MAPCAN和MAPCON则是类似于使用NCONC来构建这个保存结果的list。MAPCAN与MAPCAR类似传递CAR给函数，MAPCON与MAPLIST类似传递cons cells（CDR）。&lt;/p&gt;
&lt;p&gt;利用NCONC的特性可以实现从LIST中REMOVE元素&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(mapcan #'(lambda (x) (if (= x 10) nil (list x)))  list) === (remove 10 list)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MAPC和MAPL是装扮为函数的控制结构&amp;mdash;&amp;mdash;它们是只简单的返回它们的第一个list参数，不收集函数结果，因此它们只用于有side effects的mapped函数。MAPC用于MAPCAR和MAPCAN，而MAPL用于MAPLIST和MAPCON。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;setq&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="n"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="n"&gt;NIL&lt;/span&gt; 
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mapc&lt;/span&gt; &lt;span class="c1"&gt;#'(lambda (&amp;amp;rest x) (setq dummy (append dummy x)))&lt;/span&gt;
        &lt;span class="s"&gt;'(1 2 3 4)&lt;/span&gt;
&lt;span class="s"&gt;        '&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
 &lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;其它结构&lt;/h2&gt;
&lt;p&gt;虽然cons cells和lists经常被当作同义词，但这并不完全正确&amp;mdash;&amp;mdash;正如前面提到的，你可以使用包含lists的lists构建树。与本章讨论过的函数允许你将cons cells构成的结构当作lists，其它函数允许你使用cons cells描述trees、sets和两种类型的key/value maps。下章讨论这些函数。&lt;/p&gt;
&lt;h1&gt;除了Lists：Cons Cells的其它用途&lt;/h1&gt;
&lt;p&gt;本章讨论由cons cells构成的trees，sets和lookup tables结构的处理函数。&lt;/p&gt;
&lt;h2&gt;Trees&lt;/h2&gt;
&lt;p&gt;包含list的list。&lt;code&gt;((1 2) (3 4) (5 6))&lt;/code&gt;的结构。&lt;/p&gt;
&lt;p&gt;&lt;img alt="list-or-tree" src="/practical_common_lisp/list-or-tree.png"/&gt;&lt;/p&gt;
&lt;p&gt;通过COPY-LIST和COPY-TREE来了解list函数和tree函数的区别。&lt;/p&gt;
&lt;p&gt;COPY-LIST只复制构造出list结构的cons cells。而不复制list中的子list。新创建的cons cells仍然指向原来的cons cells指向的list结构。对上面的结构COPY-LIST的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="copy-list-list-or-tree" src="/practical_common_lisp/copy-list-list-or-tree.png"/&gt;&lt;/p&gt;
&lt;p&gt;COPY-TREE复图中的每个cons cells并将它们连接为同样的结构。COPY-TREE的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="copy-tree-list-or-tree" src="/practical_common_lisp/copy-tree-list-or-tree.png"/&gt;&lt;/p&gt;
&lt;p&gt;原cons cells指向一个atomic值时，新建的cons cells将指向相同的值。比如数字5、6和符号NIL。&lt;/p&gt;
&lt;p&gt;另一个tree函数是TREE-EUQAL，它比较两个tree是否具有相同的结构并且叶节点都EQL（或者使用:test关键字指定的参数）。&lt;/p&gt;
&lt;p&gt;另一些处理tree的函数类似SUBSTITUTE和NSUBSTITUTE及其-IF和-IF-NOT变种。函数SUBST与SUBSTITUTE类似，它接收一个新项、一个旧项和一个tree，支持:key和:test关键字参数，返回一个新的tree，这个tree中的旧项被替换成了新的项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (subst 10 1 '(1 2 (3 2 1) ((1 1) (2 2))))
(10 2 (3 2 10) ((10 10) (2 2)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SUBST-IF与SUBSTITUTE-IF类似。只是在旧项参数处它接收一个接收单个参数的函数，这个函数将在tree的每个atomic值上调用，如果调用返回true，则在SUBST-IF所返回的新tree中相同的位置将会用新项代替。SUBST-IF-NOT与它相反，在函数返回NIL时进行替换。NSUBST，NSUBST-IF和NSUBST-IF-NOT是SUBST函数的recycling版本。&lt;/p&gt;
&lt;h2&gt;Sets&lt;/h2&gt;
&lt;p&gt;Sets也可以由cons cells来实现。实际上你可以将任何list当作set&amp;mdash;&amp;mdash;Common Lisp提供了好几个在list上执行set类操作的函数。但是，应该记住由于list的结构方式，与在大的sets上操作相比这些操作只能得到较差的效率。&lt;/p&gt;
&lt;p&gt;也就是说，使用内置的set函数很容易编写处理set的代码。相对于其它方法，对小型set的操作将更有效率。如果profiling显示这些函数操作是你的代码的瓶颈，你可以将这些list替换成构建于hash tables或bit vectors之上的sets。&lt;/p&gt;
&lt;p&gt;使用ADJOIN构造set。ADJOIN接收一个项和一个用于表示set的list，并返回一个包含这个项和参数list中的所有项的描述set的list。&lt;/p&gt;
&lt;p&gt;ADJOIN也接收:key和:test关键字参数，它们用于决定项是否存在于list中。与CONS类似，ADJOIN不影响原始的list&amp;mdash;&amp;mdash;如果你需要修改某个list你应该将ADJOIN的返回值赋给它。PUSHNEW宏会自动的完成这个操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (defparameter *set* ())
*SET*
CL-USER&amp;gt; (adjoin 1 *set*)
(1)
CL-USER&amp;gt; *set*
NIL
CL-USER&amp;gt; (setf *set* (adjoin 1 *set*))
(1)
CL-USER&amp;gt; (pushnew 2 *set*)
(2 1)
CL-USER&amp;gt; *set*
(2 1)
CL-USER&amp;gt; (pushnew 2 *set*)
(2 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以用MEMBER及MEMBER-IF和MEMBER-IF-NOT来检查某个项是否在set中。这些函数与sequence函数FIND，FIND-IF和FIND-IF-NOT类似，只是FIND函数只能用于lists。MEMBER函数不会在项存在时返回这个项而是返回包含这个项的cons cell&amp;mdash;&amp;mdash;即描述这个项的子元素。当希望得到的项不是描述为list时，所有这三个函数都返回NIL。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; cl hyper spec

(member 2 '(1 2 3)) =&amp;gt;  (2 3)                                 
 (member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) =&amp;gt;  ((3 . 4))
 (member 'e '(a b c d)) =&amp;gt;  NIL
 (member-if #'listp '(a b nil c d)) =&amp;gt;  (NIL C D)
 (member-if #'numberp '(a #\Space 5/3 foo)) =&amp;gt;  (5/3 FOO)
 (member-if-not #'zerop 
                 '(3 6 9 11 . 12)
                 :key #'(lambda (x) (mod x 3))) =&amp;gt;  (11 . 12)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它set类的函数提供了批量操作：INTERSECTION、UNION、SET-DIFFERENCE和SET-EXCLUSIVE-OR。这些函数都接收两个lists和:key、:test这两个关键字参数并返回一个新的描述结果set的list。INTERSECTION返回一个包含两个参数中所有元素的list。UNION包含两个参数中虽一元素的list。SET-DIFFERENCE返回的列表中包含第一个list中出现但没有出现在第二个参数中的元素。SET-EXCLUSIVE-OR返回的list包含仅在一个list中出现，或者在另一个list中出现但是未同时出现在两个list中的元素。这些函数也都有recycling版本，函数名为在这些函数前加N。&lt;/p&gt;
&lt;p&gt;函数SUBSETP接收两个list和:key、:test关键字参数。如果第一个list是第二个list的子集则返回true。只需要元素都出现，与元素出现的次序无关。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (subsetp '(3 2 1) '(1 2 3 4))
T
CL-USER&amp;gt; (subsetp '(1 2 3 4) '(3 2 1))
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Lookup Tables: Alists and Plists&lt;/h2&gt;
&lt;p&gt;Association lists即alists和property lists即plists。不应该在很大的table中使用它们&amp;mdash;&amp;mdash;应该使用hash table&amp;mdash;&amp;mdash;应当知道如何在小型table中使用它们，在小型的table中使用时它们会比hash tables更有效率，并且它们都有自己的特点。&lt;/p&gt;
&lt;p&gt;Alists是将keys映射到values的结构并且支持逆向查找，通过key查找value。Alists也支持添加key/value映射来屏蔽已经存在的映射。屏蔽key/value的映射被移除后原来的映射将重新呈现出来。&lt;/p&gt;
&lt;p&gt;在alist的内部它的元素也是由cons cells组成。可以把它的每个元素的CAR和CDR当作key/value对。例如&lt;code&gt;((A . 1) (B . 2) (C . 3))&lt;/code&gt;的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="alist-abc-123" src="/practical_common_lisp/alist-abc-123.png"/&gt;&lt;/p&gt;
&lt;p&gt;除非CDR部分是一个list，cons cells总是被表示为dotted pairs格式的s表达式来描述键值对。&lt;/p&gt;
&lt;p&gt;查找alist主要是使用ASSOC方法，它接收一个key和alist作为参数并返回第一个CAR与key匹配的cons cells，如果无key匹配则返回NIL。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (assoc 'a '((a . 1) (b . 2) (c . 3)))
(A . 1)
CL-USER&amp;gt; (assoc 'c '((a . 1) (b . 2) (c . 3)))
(C . 3)
CL-USER&amp;gt; (assoc 'd '((a . 1) (b . 2) (c . 3)))
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为获取到value只需要将ASSOC的结果传递给CDR。&lt;/p&gt;
&lt;p&gt;默认情况下使用EQL来比较key，如果你使用:key和:test关键字参数可以改变这个。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (assoc "a" '(("a" . 1) ("b" . 2) ("c" . 3)) :test #'string=)
("a" . 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为ASSOC是从头至尾搜索list的，因此一个key/value对可以屏蔽另一个拥有相同key的key/value对。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (assoc 'a '((a . 10) (a . 1) (b . 2) (c . 3)))
(A . 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用CONS将key/value对加到alist的前面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(cons (cons 'new-key 'new-value) alist)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Common Lisp也提供了ACONS函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(acons 'new-key 'new-value alist)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与CONS一样，ACONS函数不会修改这个alist。如果你需要修改它，则需要写成下面的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf alist (acons 'new-key 'new-value alist))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(push (cons 'new-key 'new-value) alist)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，使用ASSOC搜索所花的时间依赖于匹配的键值对在list中的深度。由于alist的机制是非常轻量级的，对于小的tablesalist可以用过hash table。在如何查找方面alist也提供了更多弹性。可以使用ASSOC-IF和ASSOC-IF-NOT函数来查找，它们返回第一个使用test函数与CAR匹配的键值对（ASSOC-IF-NOT表示不匹配）RASSOC、RASSOC-IF和RASSOC-IF-NOT与ASSOC类函数类似只是它们执行的是逆序的查找。&lt;/p&gt;
&lt;p&gt;COPY-ALIST与COPY-TREE类似，只是它不复制整个tree结构，它只复制构成list结构的cons cells和这些cons cells的CAR直接引用的cons cells。即原alist和复制的alist都包含相同的键值对象，即使这些键值刚好是由cons cells构成。&lt;/p&gt;
&lt;p&gt;你可以使用PAIRLIS函数将两个分别作为键和值的list构造成alist。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (pairlis '(a b c) '(1 2 3))
((C . 3) (B . 2) (A . 1))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可能得到&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (pairlis '(a b c) '(1 2 3))
((A . 1) (B . 2) (C . 3))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种look table是plist。结构上来讲plist只是标准的list。将A B和C映射为1 2 3的plist结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="plist-abc-123" src="/practical_common_lisp/plist-abc-123.png"/&gt;&lt;/p&gt;
&lt;p&gt;但是，plist的弹性比alist小些。实际上，plist只支持一个基础的GETF查找操作。GETF函数接收一个plist和key作为参数并返回相应的vaue或者在未找到时返回NIL。&lt;/p&gt;
&lt;p&gt;与ASSOC不同，GETF总是使用EQ比较key是否匹配。因此，你不应该使用数字或字符作为plist的key；这些类型的EQ行为是不确定的。实际上应该总是使用符号来作为plist的key。&lt;/p&gt;
&lt;p&gt;可以使用SETF和GETF来设置或取key相关的value。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (defparameter *plist* ())
*PLIST*
CL-USER&amp;gt; *plist*
NIL
CL-USER&amp;gt; (setf (getf *plist* :a) 1)
1
CL-USER&amp;gt; *plist*
(:A 1)
CL-USER&amp;gt; (setf (getf *plist* :a) 2)
2
CL-USER&amp;gt; *plist*
(:A 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用REMF宏从plist中移除键值对。如果找到了对应的key它返回true。&lt;/p&gt;
&lt;p&gt;与GETF类似REMF也是使用EQ来比较key的。&lt;/p&gt;
&lt;p&gt;由于plist经常用于从同一个plist中提取多个不同的属性，Common Lisp提供了GET-PROPERTIES函数，这使得它从单个plist中提取多个属性时更有效率。它接收一个plist和一个包含key的list作为参数搜索并返回多个值，它一次查找多个值，可以避免多次扫描plist。&lt;/p&gt;
&lt;p&gt;plist与符号的关系：每个符号对象都有与之相关联的plist可以用于保存与符号相关的信息。可以使用函数SYMBOL-PLIST获得这个plist。但我们通常很少关心整个plist，更常见的是使用GET函数，它接收一个符号和一个key，它等同于使用GETF和SYMBOL-PLIST。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(get 'symbol 'key) === (getf (symbol-plist 'symbol) 'key)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与GETF类似，GET也是SETFable的，因此你可以向符号添加任意信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf (get 'some-symbol 'my-key) "information")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用REMF和SYMBOL-PLIST来移除属性或者使用REMPROP。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(remprop 'symbol 'key) === (remf (symbol-plist 'symbol key))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;DESTRUCTURING-BIND&lt;/h2&gt;
&lt;p&gt;DESTRUCTURING-BIND宏是用于切割lists的。这个宏提供了一个方法destructure任意lists，类似于宏的参数列表可以接收它的list参数的一部分。它的基本结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(destructuring-bind (parameter*) list
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数parameter list可以包含任何类型的参数，例如：&amp;amp;optional，&amp;amp;rest和&amp;amp;key参数。在parameter lists中任何参数都可以被替换为嵌套的destructuring参数list，它接收list的一部分。list form将被求值一次并应该返回一个list，然后被destructured并将对应的值绑定到parameter指定的变量中。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(destructuring-bind (x y z) (list 1 2 3)
  (list :x x :y y :z z)) ==&amp;gt; (:X 1 :Y 2 :Z 3)

(destructuring-bind (x y z) (list 1 (list 2 20) 3)
  (list :x x :y y :z z)) ==&amp;gt; (:X 1 :Y (2 20) :Z 3)

(destructuring-bind (x (y1 y2) z) (list 1 (list 2 20) 3)
  (list :x x :y1 y1 :y2 y2 :z z)) ==&amp;gt; (:X 1 :Y1 2 :Y2 20 :Z 3)

(destructuring-bind (x (y1 &amp;amp;optional y2) z) (list 1 (list 2 20) 3)
  (list :x x :y1 y1 :y2 y2 :z z)) ==&amp;gt; (:X 1 :Y1 2 :Y2 20 :Z 3)

(destructuring-bind (x (y1 &amp;amp;optional y2) z) (list 1 (list 2) 3)
  (list :x x :y1 y1 :y2 y2 :z z)) ==&amp;gt; (:X 1 :Y1 2 :Y2 NIL :Z 3)

(destructuring-bind (&amp;amp;key x y z) (list :x 1 :y 2 :z 3)
  (list :x x :y y :z z)) ==&amp;gt; (:X 1 :Y 2 :Z 3)

(destructuring-bind (&amp;amp;key x y z) (list :z 1 :y 2 :x 3)
  (list :x x :y y :z z)) ==&amp;gt; (:X 3 :Y 2 :Z 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有一种类型的参数可以用于DESTRUCTURING-BIND也可以用于宏参数列表，即&amp;amp;whole参数。如果指定了这种类型的，则它必须是参数列表中的第一个，它将被绑定到整个list form。在&amp;amp;whole参数后面，其它参数可以按正常情况出现就像&amp;amp;whole参数不存在一样。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(destructuring-bind (&amp;amp;whole whole &amp;amp;key x y z) (list :z 1 :y 2 :x 3)
  (list :x x :y y :z z :whole whole))
==&amp;gt; (:X 3 :Y 2 :Z 1 :WHOLE (:Z 1 :Y 2 :X 3))
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;异常处理：conditions和restarts&lt;/h1&gt;
&lt;p&gt;多数语言中错误的处理方式是通过返回值和异常机制。&lt;/p&gt;
&lt;p&gt;这两种机制的缺点在于，当调用栈的底层出现问题，想要进行其进行修复时会由于堆栈已经被清除，用来恢复错误的代码将无法获得出问题之前的上下文环境而出现问题。&lt;/p&gt;
&lt;p&gt;例如，一个三层的调用，如果底层调用失败，中间层不能修复，控制权传到了高层代码。高层代码在处理错误时，它只能有两个项：在没有中层和底层协助的情况下来完成修复或者做出某种修改，以使得再次调用中层代码时能成功。第一个选项需要高层代码实现许多额外的工作&amp;mdash;&amp;mdash;实现整个中间层所做的操作。并且由于堆栈被恢复了，会有更多的工作需要做。第二个选项则需要进行某种修补和重新调用&amp;mdash;&amp;mdash;即改变某些东西使得再次调用底层代码时不会产生错误，这需要高层代码了解中间层和底层代码的工作方式，这与将函数当作黑盒处理的理念是相冲突的。&lt;/p&gt;
&lt;h2&gt;Lisp的处理方式&lt;/h2&gt;
&lt;p&gt;Common Lisp的处理方式是将恢复错误的代码与决定如何恢复的代码分离。可以将恢复错误的代码放在底层函数中而不执行任何实际的恢复策略，将这个决定权留给高层函数。&lt;/p&gt;
&lt;h2&gt;Conditions&lt;/h2&gt;
&lt;p&gt;类似于异常，可以用DEFINE-CONDITION宏来定义，与定义DEFCLASS类似，它默认的父类为CONDITION而不是STANDARD-OBJECT。Slots的指定与类定义相似。但是condition的slots不能使用SLOT-VALUE访问；必须为你需要使用的值指定:reader或:accessor。使用MAKE-CONDITION定义新的condition。使用参数:initargs来初始化slots，没有类似INITIALIZE-INSTANCE的机制来初始化。&lt;/p&gt;
&lt;p&gt;使用condition系统处理错误时，应该将condition定义为ERROR的子类，它是CONDITION的子类。&lt;/p&gt;</content><category term="lisp"></category></entry><entry><title>Programming in Scala 的读书笔记</title><link href="/programming-in-scala-de-du-shu-bi-ji.html" rel="alternate"></link><published>2010-12-27T00:00:00+08:00</published><updated>2010-12-27T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-12-27:/programming-in-scala-de-du-shu-bi-ji.html</id><summary type="html">&lt;h1&gt;语言基础&lt;/h1&gt;
&lt;h2&gt;变量定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scala的两种变量：val和var。val类似Java中的final变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scala中使用类型推断：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Hello, world"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;scala根据后面的字符串推断出msg是String类型的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在变量名后添加冒号和变量类型可以显式指定变量类型：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello, world"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;函数定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;例&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;括号外等号之前的类型为max的返回类型。这里可以不用显式的指定返回类型，编译器会推断出类型。但有时会需要显式的指定，比如函数是递归的时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果函数仅由一个句子组成，可以不写等号后的大括号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max2&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;else …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;语言基础&lt;/h1&gt;
&lt;h2&gt;变量定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scala的两种变量：val和var。val类似Java中的final变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scala中使用类型推断：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Hello, world"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;scala根据后面的字符串推断出msg是String类型的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在变量名后添加冒号和变量类型可以显式指定变量类型：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello, world"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;函数定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;例&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;括号外等号之前的类型为max的返回类型。这里可以不用显式的指定返回类型，编译器会推断出类型。但有时会需要显式的指定，比如函数是递归的时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果函数仅由一个句子组成，可以不写等号后的大括号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max2&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;不带参数也无返回值的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;greet&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释器回应&lt;code&gt;greet: ()Unit&lt;/code&gt;。空括号表示函数不带参数。Unit是greet的结果类型。相当于Java中的void。&lt;/p&gt;
&lt;h2&gt;Scala脚本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在脚本中使用args(0)来访问命令行参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;while循环&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scala默认的缩进风格是缩进2格。&lt;/li&gt;
&lt;li&gt;Java风格的i++和++i在Scala无效，自增必须写成&lt;code&gt;i = i + 1&lt;/code&gt;或&lt;code&gt;i += 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Scala和Java一样，while或if的布尔表达式要放在括号里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;foreach和for表达式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;foreach&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;foreach的参数被称作function literal。它的标准格式是&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子中arg的类型也可以去掉，因为编译器可以根据args的类型推断出arg的类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;foreach偏应用函数版本&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;for表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to是一个带Int参数的方法。&lt;code&gt;0 to 2&lt;/code&gt;被解释为&lt;code&gt;(0).to(2)&lt;/code&gt;。这里arg和i没有说明它是var还是val，但它总会是val，因为在循环体中不能修改它们的值。&lt;/p&gt;
&lt;h2&gt;类型参数化数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类型化参数类似Java中的泛型类型参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;greetStrings&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;](&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;greetStrings&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Hello"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scala里访问数组元素时是将索引放在圆括号里。从这里也可以看出来val的不可变。定义的val不能重新赋值，但并不代表val对象本身不可变。如上面给数组的第1个元素赋值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala没有操作符重载，都是方法调用。&lt;code&gt;+-*/&lt;/code&gt;都可以作为方法名称。包括对数组的访问也是使用()，而不是方括号，它实际上调用是是数组的apply方法，因为当在一个变量上使用括号时，默认将调用这个变量的apply方法。如&lt;code&gt;greetString(0)&lt;/code&gt;将被转化为&lt;code&gt;greetString.apply(0)&lt;/code&gt;。而当对带括号并包含一个到多个参数的变量赋值时，将调用变量的update方法。如&lt;code&gt;greetString(0)="Hello"&lt;/code&gt;将被转化为&lt;code&gt;greetString.update(0,"Hello")&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过伴生对象中的工厂方法创建数组：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;numNames&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"zero"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"one"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"two"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个代码调用了class Array的伴生对象object Array的apply方法，这个apply方法能接收可变数量的参数。&lt;/p&gt;
&lt;h2&gt;List&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scala.List不同于Java的List它是不可变的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用cons方法&lt;code&gt;::&lt;/code&gt;将元素添加到原来的List之前产生新的List。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;:::&lt;/code&gt;可以将两个List连接起来产生新的List。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义空类可以使用Nil，而定义新的List可以将所有元素用cons（即::）连接，最后再连接一个Nil。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;List不支持append，append将随列表长度变长耗时将线性增长。使用cons连接的耗时是常量时间。可以通过cons连接后再调用reverse，或使用ListBuffer，ListBuffer支持以append方式操作可变列表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Tuple&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;元组也不可变，它与List不同的时它可以保存不同类型的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Luftballons"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;元组的类型取决于它的元素数量。pair的类型是Tupe2[Int, String]。而('u','r','the',1,4,"me")则是Tupe6(Char,Char,String,Int,Int,String)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访元组元素问时从_1开始。当前版本的Scala只支持到_22。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元组没有使用括号来访问元素，因为apply方法返回的元素是同一类型的。而元组中访问不同元素时，返回类型是不同的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Set和Map&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala中有两套Set和Map，分别支持可变和不可变的方式使用Set和Map。不可变类型是默认的，不需要导入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两套Set特质都扩展了scala.collection.Set这个特质。分别是scala.collection.immutable.Set和scala.collection.mutable.Set。这两个特质都可以调用+方法添加元素，但两者的行为不同，可变集将会把元素添加到自身，而不可变集将会创建一个包含了新元素的新集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用可变集时变量可以是val，但变量内部的元素数量仍然可以改变。而使用不可变集添加元素时如果要将新集保存到原来的变量上，则要使用var，因为不可变集在添加新元素后将返回一个新的集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Set伴生对象定义了apply工厂方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个Map特质都扩展了scala.collection.Map这个特质。分别是scala.collection.immutable.Map和scala.collection.mutable.Map。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Map元素使用&lt;code&gt;-&amp;gt;&lt;/code&gt;方法来添加元素。在任何对象上调用&lt;code&gt;-&amp;gt;&lt;/code&gt;将产生一个包含键和值的二元元组，这个是通过隐式转换来实现的。Map的基本操作：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;scala.collection.mutable.Map&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;treasureMap&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;, &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]()&lt;/span&gt;
&lt;span class="n"&gt;treasureMap&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Go to island"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;treasureMap&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Find big X on ground"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;treasureMap&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Dig."&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用不可变Map，不需要导入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;romanNumeral&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;
 &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"I"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"II"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"III"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"IV"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"V"&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;romanNumeral&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;函数式风格&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;崇尚val，不可变对象和没有副作用的方法。只在特定情况下才使用var，可变对象和有副作用的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;从文件里读取行&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;List对象的reduceLeft方法接收的函数将会应用于List的头两个元素，然后再把函数应用于第一次计算的结果和第三个元素，依次下去，并返回最后一次的计算结果。例如，计算长度最长的行：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;longestLine&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduceLeft&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;类、字段和方法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类定义包含字段（val或var）和方法（用def定义）统称为：成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传递给方法的参数都是val，不能重新赋值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法最后的return语句是可选的，如果没有发现任何显式的返回语句，Scala方法将返回方法中最后一个计算得到的值。推荐的风格是避免显式的尤其是多个返回语句。代之以把每个方法当作是创建返回值的表达式。鼓励构建很小的方法，把大的方法分解成多个更小的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法如果仅计算单个结果表达式，可以去掉大括号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ChecksumAccumulator&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Byte&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;checksum&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;没有参数的方法很像是过程（procedure），是一种为了副作用而执行的方法。表示这种方法的另一种方式是去掉结果类型和等号。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ChecksumAccumulator&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Byte&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;checksum&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;去掉方法体前的等号后，方法的结果将注定是Unit。即使方法最后一行的结果不是Unit，仍然将返回Unit。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;public是Scala方法的默认访问级别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨行的表达式中，操作符要放在上一行的行末。或者将表达式包含在括号中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; 
&lt;span class="n"&gt;y&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;分号推断的规则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;疑问行由一个不能合法作为语句结尾的字结束，如句点或中缀操作符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下一行开始于不能作为语句开始的字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行结束于括号或方括号内部，因为这些符号不可能容纳多个语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Singletone对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala没有静态成员，而是提供了单例对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当单例对象与类同名时，被称作类的伴生对象。它们必须在同一个源文件里定义。类和它的伴生对象可以互相访问私有成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单例对象不带参数，而类可以，因为它不能用new来初始化。每个单例对象都被作为由一个静态变量指向的虚构类的一个实例来实现，因此它们与Java静态类有着相似的初始化语法。它会在第一次访问时初始化。虚构类的名称是对象名加一个美元符号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不与伴生类共享相同名称的单例对象被称为孤立对象。程序的入口main函数要求被定义在孤立对象中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Scala程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;要执行Scala程序，一定要提供一个main方法，它仅带一个参数，Array[String]，且结果类型为Unit的孤立单例对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala隐式的导入了java.lang和scala的成员，和名为Predef的单例对象中的成员到每个Scala源文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala里并不要求类名和文件名相同。如果不是脚本，推荐的风格是像Java那样按类名来命名文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Application特质&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大括号之间的代码被收集进了单例对象的主构造器，并在类被初始化时执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Application特质中不能访问传递给main的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为某些JVM线程模型的局限，如果程序是多线程的就需要显式的main方法。通常只在程序较简单和单线程的情况下才使用Application特质。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;基本类型的操作&lt;/h1&gt;
&lt;h2&gt;基本类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Byte，Short，Int，Long和Char被称为integral类型。Float和Double被称为numeric类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除String位于java.lang包外，其余所有基本类型都是scala的成员。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;文本表示&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;整数、浮点、字符、字符串的表示与Java类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;raw String用三引号包含，不需要转义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;符号文本写作&lt;code&gt;'标识符&lt;/code&gt;，这里标识符可以是任何字母或数字标识符。这种文本被映射成预定义类scala.Symbol的实例。;&lt;code&gt;'cymbal&lt;/code&gt;将被编译器扩展为工厂方法调用：Symbol("cymbal")。符号对象可以访问它的name属性。符号是被interned的，即把同一符号文本写两次时，两个表达式将指向同一个Symbol对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布尔类型只有true和false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;操作符和方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala中任何方法都可以当作操作符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中缀操作符前后带两个操作数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前缀操作符和后缀操作符都是unary的，它们仅有一个操作数。这些前缀操作符是在值类型对象上调用方法的简写方式。在这种情况下，方法名在操作符上前缀了&amp;ldquo;unary_&amp;rdquo;。例如Scala会把表达式&lt;code&gt;-2.0&lt;/code&gt;转换成方法调用&lt;code&gt;(2.0).unary_-&lt;/code&gt;。可以当作前缀操作符的标识符只有&lt;code&gt;+ - ! ~&lt;/code&gt;。如果使用其它其它符号，如&lt;code&gt;unary_*&lt;/code&gt;则不能像&lt;code&gt;*p&lt;/code&gt;这样调用，只能写作&lt;code&gt;p.unary_*&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后缀操作符是不用点或括号调用的不带任何参数的方法。Scala里可以省略方法调用的空括号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数学运算&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以通过中缀操作符，&lt;code&gt;+ - * / %&lt;/code&gt;在任何数字类型上调用数学方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字类型还提供了一元前缀操作符&lt;code&gt;+ -&lt;/code&gt;，即方法&lt;code&gt;unary_+&lt;/code&gt;和&lt;code&gt;unary_-&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关系和逻辑操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;与Java一样，逻辑与和逻辑或都有短路的概念。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala中短路机制是因为Scala方法都有延迟对参数求值甚至是取消求值的机制。这个机制被称作by-name parameter。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;位操作符&lt;/h2&gt;
&lt;h2&gt;对象相等性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相等性检测会处理null，它使用了一个简单的规则：首先检查左侧是否为null，如果不是，则调用equals方法。这种类型的比较对于不同的对象也会产生true，只要他们的内容相同并且它们的equals方法是基于内容编写的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala与Java里&lt;code&gt;==&lt;/code&gt;的区别。在Java里对于原始类型是直接比较值的相等性，与Scala一样。然而对于参考类型，Java是比较两个变量是否都指向JVM堆里的同一个对象。Scala也提供了这种机制，名字是eq。不过，eq和它的反义词ne，仅仅可以用于直接映射到Java的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;操作符优先级和关联性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无论如何，使用括号都是好的风格。或许唯一不用查书就可以知道的优先级关系就是乘除法操作比加减法操作的优先级要高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;富包装器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scala的基本类型上调用的方法多于之前所介绍的。很多方法是通过隐式转换（implicit conversion）来实现的。每个基本类型都有一个&amp;ldquo;富包装器&amp;rdquo;，要查看基本类型的所有方法时，还应该看下每个基本类型的富包装器的API文档。类名都是&amp;ldquo;Rich基本类型名&amp;rdquo;，位于scala.runtime包中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;函数式对象&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果类没有主体，就不一定需要一对空括号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据类参数Scala编译器会收集这类参数并创造一个带同样参数类型和数量的主构造器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可变对象有可能因为要复制很大的对象图而产生性能瓶颈。有时会需要提供可变对象的版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象构造的先决条件，在主构造器中使用require函数来检查条件是否都满足，当它返回false时将抛出IllegalArgumentException来阻止对象被构造。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在进行方法覆盖时override关键字是必须的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数化对象的参数只可以在对象内部访问。在对象外部只能访问对象的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this关键字指向当前执行方法被调用的对象实例，如果使用在构造器里就是指正被创建的对象实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala里主构造器之外的构造器称为从构造器。每个从构造器的第一个动作都是调用同一个类里其它的构造器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala编译器将按字段在源码中出现的次序进行初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标识符的约定：构成标识符的有字母数字式和操作符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字母数字标识符起始于一个字母或下划线，之后可以跟字母、数字或下划线。&amp;lsquo;$&amp;rsquo;字符也被当作字母，但是被保留作为编译器产生的标识符之用。Scala遵循Java驼峰式标识的习惯。不同的Java的在于常量命名，scala里constant并不同于val。Java常量命名通常都使用大写，Scala里常量命名习惯也是使用驼峰式风格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作符是如：+、:、?、~或#的可打印ASCII字符。这些标识字符将在转换为以&amp;lsquo;$&amp;rsquo;分隔的方法名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;混合标识符：由字母数字组成，后面跟前下划线和一个操作符标识符。如，unary_+被用于定义一元的&amp;lsquo;+&amp;rsquo;操作符的方法名。myvar_=被用于定义赋值操作符的方法名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文本标识符：是用反引号&lt;code&gt;...&lt;/code&gt;包含的任意字符串。例如yield是Scala保留字，如果我们要调用Java中Thread的静态方法yield就需要写作：Thread.&lt;code&gt;yield&lt;/code&gt;()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐式转换能在需要的时候自动把一种类型转换为另一种类型。隐匿转换要起作用需要定义在作用范围之内。它的转换是由编译器完成的，不会显式的出现在代码中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;内置控制结构&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;几乎所有Scala的控制结构都会产生值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala中所有赋值语句总是返回Unit。因此下面的代码将出问题：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;readLine&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//不起作用&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Read: "&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里用!=比较Unit和String将永远为true。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例1 :: 常见例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"."&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;listFiles&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例2 :: 不常见用法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filesHere&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例3 :: to（包含上限）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Iteration "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例4 :: until（不含上限）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;until&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Iteration "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例5 :: 过滤&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"."&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;listFiles&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例6 :: 多个过滤条件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"."&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;listFiles&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isFile&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例7 :: 嵌套枚举（多层嵌套循环）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;fileLines&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;java.io.File&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Source&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fromFile&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;getLines&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toList&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;grep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;fileLines&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;": "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;grep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".*gcd.*"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例8 :: mid-stream变量绑定，代替上例中两次调用trim。变量作为val引入和使用，但不带关键字val。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;grep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;fileLines&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;trimmed&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;": "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;grep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".*gcd.*"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例9 :: 使用yield创建新集合。格式&lt;code&gt;for {子名} yield {循环体}&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;scalaFiles&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;forLineLengths&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;fileLines&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;trimmed&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".*for.*"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;异常不需要申明在throws子名中。异常的catch子名中使用模式匹配来处理异常。try-catch-finally也可以产生值。应该避免在finally中返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;match表达式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala中没有break和continue语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量作用范围与Java区别在于Java不允许你在内部范围内创建与外部范围变量同名的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;函数和闭包&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地函数就像使用本地变量，它仅在包含它的代码块中可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以把函数写成函数文本（literal）并把它们像值（value）一样传递。函数文本被编译为类，类在运行期实例化的时候是一个函数值（function value）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数基础信息&lt;/h2&gt;
&lt;p&gt;完整的函数定义格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有时函数定义会要求显示定义返回类型。比如函数是递归的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果函数仅由一个句子组成，可以不写大括号。&lt;code&gt;def max2(x: Int, y: Int) = if (x&amp;gt;y) x else y&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数中可以定义函数，就像定义局部变量，称为本地函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数文本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数文本基本格式：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;括号里是参数，右箭头右边是函数体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数被编译成一个类，类在运行时是一个函数值：function value。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数文本（literal）也被编译为函数值，例&lt;code&gt;(x: Int) =&amp;gt; x + 1&lt;/code&gt;。函数文本中超过一个语句时，用大括号包住函数体。函数的返回值是最后一行的表达式的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数文本短格式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数文本的短格式，例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;someNumbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的someNumbers中的元素是整数类型的，因为类型推断系统可以得知x的类型，因此不需要说明x的类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;甚至可以进一步省去函数文本短格式中被推断的参数外的括号，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;someNumbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;占位符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果参数在函数文本内仅出现一次，则可以将参数省略为下划线。如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;someNumbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;当将下划线作为占位符时，编译器可能没有足够的信息推断缺失的参数类型。这时需要指定参数类型，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="k"&gt;_:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这里的多个下划线是指代不同的参数，每个参数在函数文本中只出现一次的情况下才能使用这种格式。多个下划线按顺序代表第一个参数，第二个....&lt;/p&gt;
&lt;h2&gt;偏应用函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用下划线代表全部或部分参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编译器根据这些信息产生一个新的函数类。新类的apply方法的参数个数和类型由占位符信息而决定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你写一个省略所有参数的偏应用程序表达式，而在代码的那个地方正需要一个函数，则你可以去掉下划线。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;someNumbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;someNumbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;闭包&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;名称来源：通过&amp;ldquo;捕获&amp;rdquo;自由变量的绑定对函数文本执行的&amp;ldquo;关闭&amp;rdquo;动作。不带自由变量的函数文本：&lt;code&gt;(x: Int) =&amp;gt; x + 1&lt;/code&gt;被称为closed term（小段源码），这在严格意义上讲不是闭包，因为这个代码在编写的时候就已经封闭了。但任何带自由变量的函数文本，如&lt;code&gt;(x: Int) =&amp;gt; x + more&lt;/code&gt;都是open term。因此任何类似&lt;code&gt;(x: Int) =&amp;gt; x + more&lt;/code&gt;需要在运行时创建的函数必须捕获自由变量more的绑定。由于这个函数值是关闭&lt;code&gt;(x: Int) =&amp;gt; x + more&lt;/code&gt;这个open term的行动的最终产物，得到的函数值将包含一个指向捕获的more变量的参考，因此被称为闭包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果more在闭包创建后改变了，闭包将看到这个变化。闭包对捕获变量的作出的改变在闭包外也可见。如果在闭包中修改了more，则more在闭包外也可见。Scala的闭包捕获了变量本身，而不是变量指向的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;addMore&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt;
&lt;span class="n"&gt;addMore&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//11&lt;/span&gt;
&lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9999&lt;/span&gt;
&lt;span class="n"&gt;addMore&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//10009&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果闭包访问了某些在程序运行时有若干不同备份的变量，例如，闭包使用了某个函数的本地变量，而这个函数又被调用了很多次。每次访问使用的将是闭包在被创建的时候活跃的变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;makeIncreaser&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;more&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;inc1&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;makeIncreaser&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;inc9999&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;makeIncreaser&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9999&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;inc1&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//11&lt;/span&gt;
&lt;span class="n"&gt;inc9999&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//10009&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;上例中Scala编译器重新安排了makeIncreaser的参数使得捕获的参数继续存在于堆中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;重复参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数的最后一个参数可以是重复的，用于支持可变长度参数列表。通过在参数类型后放一个星号来标明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数内部，重复参数的类型是声明参数类型的数组。但是你不能直接使用数组作为重复参数传入，这在编译时将出错。如果需要这样做，则要在调用时在数组参数后面添加一个冒号和一个_*符号。&lt;code&gt;echo(arr: _*)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;尾递归&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala编译器检测到尾递归时将使用新值更新函数参数，然后把它替换成一个回到开头的跳转。（类似while，但更代码更优美和简明）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于JVM的约束，在两个函数间相间的进行递归调用将得到到优化。如果递归中的最后一个调用是函数值也不能获得优化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isEven&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Boolean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;isOdd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isOdd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Boolean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;isEven&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;funValue&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nestedFun&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;nestedFun&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="n"&gt;funValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;控制抽象&lt;/h1&gt;
&lt;h2&gt;减少重复代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;matcher&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;matcher&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
    &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesEnding&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesContaining&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesRegex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;FileMatcher&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"."&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;listFiles&lt;/span&gt; 
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matcher&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;matcher&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
      &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; 
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesEnding&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesContaining&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesRegex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;简化客户代码&lt;/h2&gt;
&lt;h2&gt;Curry化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过Curry化我们可以创建&amp;ldquo;感觉像是原生语言支持&amp;rdquo;的控制抽象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原始的例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;plainOldSum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="n"&gt;plainOldSum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;curry化后&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;curriedSum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="n"&gt;curriedSum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里实际相当于下面的调用过程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;编写新的控制结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以通过创建以函数作为参数的方法来定义新的控制结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;twice&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;twice&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//7.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;自定义控制结构版本1&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;withPrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;File&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;PrintWriter&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;PrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;finally&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;withPrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; 
  &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"date.txt"&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; 
  &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果方法调用只传入一个参数，可以使用大括号替代小括号包围的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;withPrintWriter带两个参数，因此不能使用大括号。我们可以curry化第一个参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;withPrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;File&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;PrintWriter&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;PrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;finally&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"date.txt"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;withPrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;by-name参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用by-name参数可以实现像if或while那样的控制结构。没有参数传入大括号之间的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原始的例子，需要使用参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;assertionsEnabled&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;myAssert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assertionsEnabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;AssertionError&lt;/span&gt;

&lt;span class="c1"&gt;//使用它有点难看&lt;/span&gt;
&lt;span class="n"&gt;myAssert&lt;/span&gt;&lt;span class="o"&gt;(()&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用by-name参数修改。by-name参数在定义参数类型的时候使用&lt;code&gt;=&amp;gt;&lt;/code&gt;而不是&lt;code&gt;() =&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;byNameAssert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assertionsEnabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;AssertionError&lt;/span&gt;

&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;byNameAssert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例3&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;boolAssert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assertionsEnabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;AssertionError&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子与byNameAssert存在重要的区别。由于boolAssert的参数是Boolean，括号中的表达式将先于boolAssert的调用被执行。当assertionEnabled为false时，boolAssert仍将产生副作用，而byNameAssert不会。&lt;/p&gt;
&lt;h1&gt;组合与继承&lt;/h1&gt;
&lt;h2&gt;抽象类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;抽象成员的类本身必须被声明为抽象，抽象成员本身不需要添加abstract关键字。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定义无参数方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无参数方法在Scala中是非常普通的。带有空括号的方法定义，被称为空括号方法。推荐的习惯是在没有参数并且方法仅通过读含的方式访问可变状态（不改变可变状态）时，使用无参数方法。这个惯例支持统一访问原则，即客户代码不应受通过字段还是方法实现属性的决定的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面两组不同的定义对于用户来讲并没有区别。区别在于方法调用可能要稍慢一些，而属性访问则在初始化的时候已经计算了。其重点在于Element类的客户不应在其内部实现发生改变的时候受影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala中可以使用空括号方法重载无参数方法，反之亦可。可以在调用任何不带参数的方法时省略空的括号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原则上Scala上的函数调用中可以省略所有空括号。但在调用的方法存在副作用时，推荐仍然写一对空括号。例如，方法执行了I/O，或写入了var变量，或读取了不属于接收参数内的var变量，直接或间接的使用了可变对象。这种情况下括号作为线索说明了这个调用触发了一些计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总的来说，Scala里定义不带参数也没有副使用的方法为无参数方法，省略空的括号是鼓励的风格，另一方面不要定义没有括号的带副作用的方法，因为那样的话方法调用看上去会像选择一个字段，这样客户在看到副作用时会觉得奇怪。同样的，当你调用带副使用的函数时请添加上空括号。另一种考虑这个问题方法是：如果你调用的函数执行了操作就使用括号，如果仅提供了对某个属性的访问就省略括号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;扩展类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;extends子句有两个效果：使子类从父类继承所有非私有的成员，使子类成为父类的子类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果忽略extends子句，Scala编译器隐式的假设你的类从scala.AnyRef继承。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;重载方法和字段&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala中字段和方法属于相同的命名空间。这使得字段重载无参数方法成为可能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala里禁止在同一个类里有同样的名称定义字段和方法。而在Java中方法名可以与字段同名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala仅为定义准备了两个命名空间（值（字段、方法、包、单例对象）、类型（类、特质）），而Java有四个（字段、方法、类型、包）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定义参数化字段&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在定义中组合参数和字段避免同时编写参数和赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;调用超类构造器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在定义子类时，直接将父类的构造器的参数放在父类名后面的括号里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;使用override修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala里所有重载了父类具体成员的成员都需要这个修饰符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译器根据这个信息，可以避免不安全的方法覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;多态和动态绑定&lt;/h2&gt;
&lt;h2&gt;定义final成员&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当要确保成员不被子类重载时，使用final修饰符。&lt;/li&gt;
&lt;li&gt;要确保类不被重载时，在类上使用final修饰符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;使用组合与继承&lt;/h2&gt;
&lt;h2&gt;实现above，beside和toString&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scala里的数组表示为Java数组，但支持更多的方法。特别是Scala里的数组继承自类scala.Seq，能够表现象序列这样的结构并包含许多访问的转换序列的方法。&lt;/li&gt;
&lt;li&gt;zip操作符可以将两个参数变成Tuple2。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;zip&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"a"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"b"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res1&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;, &lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;)]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面可以看出如果两个操作数组的其中一个比另一个长，zip将舍弃余下的元素。
 - for循环中将this.contents和that.contents两个数组的元素zip到line1和line2，然后使用for表达式的yield部分来产生结果。结果类型的枚举遍历的表达式类型一致。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;line1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;line2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;zip&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"a"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"b"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;line1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;line2&lt;/span&gt;
&lt;span class="n"&gt;res0&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;序列中定义了mkString方法，它能返回序列中所有元素组成的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;mkString&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt;
&lt;span class="n"&gt;res4&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;定义工厂对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以在基类的伴生对象中定义多个工厂方法来产生不同子类型的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;ArrayElements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;UniformElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;LineElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;伴生类里可以直接调用伴生对象中的方法，可以缩短代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Element.elem&lt;/span&gt; 
&lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;above&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;beside&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; 
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; 
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="n"&gt;zip&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt; 
&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;line1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;line2&lt;/span&gt; 
&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="n"&gt;mkString&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;使用工厂方法后，使得子类型可以是私有的。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ArrayElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; 
    &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; 
  &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; 
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LineElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
    &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; 
    &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt; 
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UniformElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; 
    &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; 
  &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt; 
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt; 

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;ArrayElements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;UniformElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;LineElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Scala的类层级&lt;/h1&gt;
&lt;p&gt;-　每个类都继承自Any类。Scala还在类层级的底端定义了Null和Nothing，主要都扮演通用的子类。Nothing是所有类的子类。&lt;/p&gt;
&lt;h2&gt;Scala类层级&lt;/h2&gt;
&lt;p&gt;-　Any中定义了&lt;code&gt;==,!=,equals&lt;/code&gt;，还有&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;toString&lt;/code&gt;。Any中的&lt;code&gt;==,!=&lt;/code&gt;方法，被声明为final，因此它们不能在子类里重载。实际上&lt;code&gt;==&lt;/code&gt;总与equals相同，&lt;code&gt;!=&lt;/code&gt;总是于equals相反。
　-　Any有两个子类：AnyVal和AnyRef。
　-　AnyVal是九个内建值类（Byte、Short、Char、Int、Long、Float、Double、Boolean、Unit）的父类。内建值类除Unit外，其它的都对应于Java原始类型。Scala里这些类的实例都写成文本。不能用new创建这些类的实例，因为这些值类都被定义成既是抽象的又是final的。Unit大约对应于Java中的void；被用途不返回任何有效结果的方法的结果类型。Unit只有一个实例值，写作()。所有值类都是scala.AnyVal的子类型，它们之间互相没有继承关系。值类之间可以进行隐式转换。隐匿转换还为值类增加了功能，如min,max,until,to和abs都是定义在类scala.runtime.RichInt里的，并且有一个从类Int到RichInt的隐式转换。
 - AnyRef是Scala里所有引用类的基类。在Java里AnyRef实际上就是类java.lang.Object的别名。Scala类与Java类不同在于它们还继承自ScalaObject物特别的标记特质。ScalaObject包含了scala编译器定义和实现的方法，作用是让Scala程序执行更有效。到现在为止，ScalaObject只包含了单个方法&lt;code&gt;$tag&lt;/code&gt;，用于内部以提高模式匹配的速度。&lt;/p&gt;
&lt;h2&gt;原生类型是如何实现的&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当数据需要被当作对象看侍时，Scala使用对象类型，如java.lang.Integer。它与Java5的自动装箱机制差异在于Scala里的装箱比Java里的更少见。&lt;/li&gt;
&lt;li&gt;AnyRef类型定义了eq方法，它不能被重载且实现为对比对象的引用（类似Java里的&lt;code&gt;==&lt;/code&gt;）。它的反义方法为ne。&lt;/li&gt;
&lt;li&gt;Scala中的&lt;code&gt;==&lt;/code&gt;被设计为透明的参考类型代表的东西。对值类型来说，就是自然（数学或自然）相等。对引用类型，&lt;code&gt;==&lt;/code&gt;被视为继承自Object的equals方法的别名。这个方法被初始地定义为引用相等，但被许多子类重载实现它们的相等概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;底层类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;scala.Null和scala.Nothing是用于统一方式处理某些&amp;ldquo;边界情况&amp;rdquo;的特殊类型。&lt;/li&gt;
&lt;li&gt;Null是null类型的引用；它是每个引用类的子类。Null不能赋值给值类型。&lt;/li&gt;
&lt;li&gt;Nothing是Scala类层级中最底端；它是任何类型的子类型。没有这个类型的值。Nothing的一个用处是标明不正常的终止。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;RuntimeException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;divide&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; 
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"can't divide by zero"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;特质&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;物质是Scala中代码复用的基础单元。特质封装了方法和字段定义，并且可以通过混入到类中重用它们。类可以混入任意个特质。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;特质如何工作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;特质的定义使用关键字trait，其它与类定义无异。&lt;/li&gt;
&lt;li&gt;特质与类一样会有默认超类AnyRef。&lt;/li&gt;
&lt;li&gt;可以使用extends或with关键字把特质混入到类中。Scala&amp;ldquo;混入&amp;rdquo;特质而不是继承，特质的混入与其它语言中的多继承有重要的差别。&lt;/li&gt;
&lt;li&gt;使用extends关键字混入特质时，隐式地继承了特质的超类。例如下例中，Frog是AnyRef（Philosophical的超类）的子类并混入了Philosophical。从特质继承的方法可以像从超类继承的方法那样使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Frog&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Philosophical&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"green"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果想把特质混入到扩展自超类的类里，可以用extends指明父类，用with混入特质。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Animal&lt;/span&gt; 
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;HasLegs&lt;/span&gt; 
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Frog&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Animal&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;Philosophical&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;HasLegs&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"green"&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;特质就像是带有具体方法的Java接口，不过它可以做得更多。比如，它可以声明字段和维持状态值。实际上，可以用特质定义任何用类定义做的事，并且语法也一样，除了两点：第一，特质不能有任何&amp;ldquo;类&amp;rdquo;参数，也就是说传递给类的主构造器的参数。另一个差别在于不论在类的哪个角落，super调用都是静态绑定的，在特质中，它们是动态绑定的。调用的实现将在每一次特质被混入到具体类的时候才被决定。这种处理super的行为使得特质能以可堆叠的改变方式：stackable modifications工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;瘦接口对阵胖接口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;要使用特质丰满接口，只要简单地定义一个具有少量抽象方法的特质&amp;mdash;&amp;mdash;特质接口的瘦部分&amp;mdash;&amp;mdash;和潜在的大量具体方法，所有的都实现在抽象方法上。然后你就可以把丰满了的特质混入到类中，实现接口的瘦部分，并最终得到具有全部胖接口内容的类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;特质用来做可堆叠的改变&lt;/h2&gt;
&lt;p&gt;下面部分用FreeMind写的
[[scala-tip/Programming In Scala.png]]&lt;/p&gt;
&lt;h1&gt;Case Class和模式匹配&lt;/h1&gt;
&lt;p&gt;Case Class是Scala中用于匹配对象的一种方法。通常情况下只要在需要使用模式匹配的类的class关键字前添加case关键字就可以了。&lt;/p&gt;
&lt;h2&gt;Case Class的例子&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上例也可以看出Scala中class定义时类体部分可以为空。&lt;/p&gt;
&lt;h3 id="case-classes"&gt;Case classes&lt;/h3&gt;
&lt;p&gt;每个Expr的子类都有一个case修饰符。有这个修饰符的类被称为Case class。使用这个修饰符后Scala编译器将会为这个类添加特殊的语法效果。&lt;/p&gt;
&lt;p&gt;首先，它会给这个类添加一个工厂方法。比如使用Var("x")来构造对象而不需要new Var("x")。这个工厂方法在嵌套使用这个类时更显方便。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个语法效果是所有参数列表中的参数被隐式的添加了val前缀，因此它们被当作了类的字段。&lt;/p&gt;
&lt;p&gt;第三，编译器将为Case class添加toString，hashCode和equals方法。它们可用于打印，计算hash值或递归的按对象结构中的字段进行对比。由于Scala中==总是会使用equals，这意味case class中的元素也将会按结构进行对比。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(+,&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res3&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="mo-shi-pi-pei"&gt;模式匹配&lt;/h3&gt;
&lt;p&gt;Case class的另一个好处是支持模式匹配。例如要实现下面的规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Doublenegation&lt;/span&gt;
&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Addingzero&lt;/span&gt;
&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Multiplyingbyone&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用模式匹配来实现这些规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;simplifyTop&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;))))&lt;/span&gt;
&lt;span class="n"&gt;res4&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;simplifyTop&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Doublenegation&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Addingzero&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Multiplyingbyone&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例中的simplifyTop包含匹配表达式。匹配表达类似于Java中的switch，但它通常出现在selector表达式的后面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;alternatives&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;switch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;alternatives&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模式匹配包含于一个alternatives序列中，每个匹配都以关键字case开头。每个alternative包含了一个模式和一个以上的表达式，它将在匹配时被执行。箭头符号=&amp;gt;将模式和表达式分开。&lt;/p&gt;
&lt;p&gt;匹配表达式将按模式匹配的书写顺序执行。当=&amp;gt;左边的模式匹配上时，=&amp;gt;右边的表达式将被执行。&lt;/p&gt;
&lt;p&gt;常量匹配比如"+"或1的匹配与使用==是等效的。类似e这样的变量匹配将匹配所的值。然后变量指向case语句右边的值。在这个例子中，前三个例子中，在匹配范围内，e变量都绑定到了变量上。通配符匹配s模式（_）也匹配所有值，但它不会绑定变量值。在例中的最后是默认匹配，它只是返回expr，不对表达式做任何操作。&lt;/p&gt;
&lt;p&gt;构造器模式如UnOp("-",e)。这个模式匹配所有第一个参数匹配"-"第二个参数匹配e且类型为UnOp的值。构造器的参数自身也是匹配模式。这允许我们使用简单的标记写出深度匹配。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="mo-shi-pi-pei-yu-switchde-bi-jiao"&gt;模式匹配与switch的比较&lt;/h4&gt;
&lt;p&gt;匹配表达式可以被看作Java风格的switch。Java风格的switch可以很自然的用匹配表达式来表示，每个模式都是常量最后的模式可以是一个通配符（它用于表示switch中的default）。switch与模式匹配有三处不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala中的匹配是表达式，它总会产生一个值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala的alternative表达式不会&amp;ldquo;fall through&amp;rdquo;到下一个匹配情况（不需要break）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有任何模式匹配，将会抛出MatchError异常。这意味着你总会需要有一个默认的匹配，即使它什么也不做。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;"isabinaryoperation"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子中的第二种情况没有代码，因此它不会执行任何操作。这个例子中的两种情况都会返回空值&amp;lsquo;()&amp;rsquo;，这也是整个匹配表达式的结果。&lt;/p&gt;
&lt;h2&gt;模式类型&lt;/h2&gt;
&lt;h3 id="tong-pei-fu-pi-pei-mo-shi_1"&gt;通配符匹配模式&lt;/h3&gt;
&lt;p&gt;通配符模式（_）匹配所有对象。常用于作为默认值，捕获所有的情况，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;"isabinaryoperation"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通配符也可用于忽略对象的某些部分。比如，在前面的例子中并不需要关心BinOp的元素。只需要检查它是不是BinOp。因此可以使用通配符匹配：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;"isabinaryoperation"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"It'ssomethingelse"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="chang-liang-pi-pei-mo-shi"&gt;常量匹配模式&lt;/h3&gt;
&lt;p&gt;常量模式只匹配自身。任何字面量（literal）都可以用于常量模式。比如，5，true和"hello"都是常量模式。任何val或singleton对象也可以用作常量模式。比如，Nil是一个singleton对象，它可以用于匹配空列表（empty list）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"five"&lt;/span&gt;
  &lt;span class="n"&gt;casetrue&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"truth"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"hi!"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Nil&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"theemptylist"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"somethingelse"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res5&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;five&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res6&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;truth&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res7&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Nil&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res8&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;theemptylist&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res9&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;somethingelse&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bian-liang-pi-pei-mo-shi"&gt;变量匹配模式&lt;/h3&gt;
&lt;p&gt;变量模式匹配任何对象，与通配符模式类似。与通配符不同之处在于，Scala将会绑定对象到变量。你可以在后面使用这个变量来操作匹配的对象。比如下例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"zero"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;somethingElse&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"notzero:"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;somethingElse&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量还是常量？&lt;/p&gt;
&lt;p&gt;常量模式可以有符号名称。比如前面以经看到的使用Nil作为模式。下例中，模式匹配常量E(2.71828...)和Pi(3.14159...)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Math.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Pi&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;importMath&lt;/span&gt;&lt;span class="o"&gt;.{&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Pi&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"strange math? Pi = "&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nc"&gt;Pi&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"OK"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;res10&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;E不会匹配Pi，因此&amp;ldquo;strange math"的情况不会发生。&lt;/p&gt;
&lt;p&gt;Scala编译器如何知道Pi是从java.lang.Math对象中导入的常量，而不是一个变量呢？Scala使用了一个简单的规则来区分：以小写字母开头的名称将作为模式变量；其它情况将作为常量。上例如果改为小写的pi将出现不同的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;
&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;3.141592653589793&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"strangemath?Pi="&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;res11&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;strangemath&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;2.7182818&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种情况下编译器将不会允许你添加default case。因为pi是变量模式，它将匹配所有输入，因此它后面的情况将不可达：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"strangemath?Pi="&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"OK"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;error:unreachablecode&lt;/span&gt;
    &lt;span class="n"&gt;case_=&amp;gt;&lt;/span&gt;&lt;span class="s"&gt;"OK"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如有必要通过使用两个反单引号（~上的那个）你仍然可以使用小写的名称作为常量模式。比如常量是某些对象的字段时。例如，pi是一个变量模式，但是this.pi或obj.pi是常量。我们可以使用反单引号解决这个问题，通过使用&lt;code&gt;pi&lt;/code&gt;，pi将被作为常量模式，而不是变量模式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;`pi`&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"strangemath?Pi="&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;
      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"OK"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;res13&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;反单引号在Scala中被用于两种不同目的。前面已经介绍过使用它可以将关键字作为普通的标识符。比如&lt;code&gt;yield&lt;/code&gt;()会将yield作为标识符而不是关键字。&lt;/p&gt;
&lt;h3 id="gou-zao-qi-pi-pei-mo-shi"&gt;构造器匹配模式&lt;/h3&gt;
&lt;p&gt;构造器匹配模式使得模式匹配变得真正强大。例如&amp;ldquo;BinOp("+", e, Number(0))&amp;rdquo;。这个匹配选检查Case class的名称是否为BinOp然后检查它的构造器参数是否匹配额外的模式。&lt;/p&gt;
&lt;p&gt;这些额外的模式意味着Scala的模式支持深度匹配。这些模式不只是检查最顶级的对象，也检查这个对象的内容是否匹配额外的模式。由于这些额外的模式也可以是构造器模式，你可以使用它检查任意深度的对象。比如上面提到的例子先检查顶层的对象是否为BinOp，它的第三个构造器参数是否为Number，value字段是否为数字0。这个模式在一行中检查了三级深度的数据。&lt;/p&gt;
&lt;h3 id="xu-lie-pi-pei-mo-shi"&gt;序列匹配模式&lt;/h3&gt;
&lt;p&gt;可以像匹配case class那样使用序列匹配模式来匹配List或Array这样的序列类型。使用的是同样的语法，但你可以在模式中指定任意数量的元素。比如，下例显示了如何匹配以0开头的含有3个元素的list：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foundit"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要匹配不指定长度的序列模式，可以在模式的最后一个元素使用&lt;code&gt;_*&lt;/code&gt;。这个模式匹配序列中任意数量的元素，包括0个元素。下例将匹配任何以0开头的list，不管list有多长。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foundit"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="yuan-zu-pi-pei-mo-shi"&gt;元组匹配模式&lt;/h3&gt;
&lt;p&gt;也可以匹配元组。例如(a,b,c)匹配任意3元素的元组。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;tupleDemo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"matched"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="lei-xing-pi-pei-mo-shi"&gt;类型匹配模式&lt;/h3&gt;
&lt;p&gt;可以使用类型匹配模式来代替类型测试和类型转换。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;generalSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;,&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是使用generalSize的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;generalSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res14&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;generalSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="sc"&gt;'a'&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="sc"&gt;'b'&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res15&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;generalSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res16&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里要注意，尽管s和x指的是同一个值，x的类型是Any，但是s的类型是具体类型。因此在调用具体类型的方法时不能直接使用x.method，而是要使用s.method。&lt;/p&gt;
&lt;p&gt;如果不使用模式匹配，Scala中使用了不同于Java的方式进行进行类型测试和类型转换。例如测试expr是否为String：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isInstanceOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将expr转换为String，使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;asInstanceOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作符isInstanceOf和asInstanceOf是作为Any类的预定义函数，它们在方括号中接收一个类型参数。实际上，x.asInstanceOf[String]是参数String的隐式类型参数的方法调用的一个特殊情况。&lt;/p&gt;
&lt;p&gt;从这里可以看出在Scala中进行类型测试和类型转换更繁锁。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isInstanceOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]){&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;asInstanceOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种类型匹配模式：&amp;ldquo;m: Map[&lt;em&gt;, &lt;/em&gt;]&amp;rdquo;。这个匹配模式匹配任意Map类型的值，这个Map的key和value可以是任意类型的，m指向这个Map。因此，m.size将返回map的size。下划线与其它匹配模式中一样。&lt;/p&gt;
&lt;h3 id="lei-xing-ca-chu"&gt;类型擦除&lt;/h3&gt;
&lt;p&gt;能测试Map元素的类型吗？例如测试map的key和value是否都为Int：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isIntIntMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;,&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;therewereuncheckedwarnings&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;runwith&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;uncheckedfordetails&lt;/span&gt;
&lt;span class="n"&gt;isIntIntMap&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释器给出了&amp;ldquo;unchecked warning.&amp;rdquo;。可以在启动解释器时添加-unchecked参数来了解详细信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="n"&gt;quit&lt;/span&gt;
&lt;span class="nc"&gt;$scala&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;unchecked&lt;/span&gt;
&lt;span class="nc"&gt;WelcometoScalaversion2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mf"&gt;7.2&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;JavaHotSpot&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;TM&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nc"&gt;ClientVM&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nc"&gt;Java1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="n"&gt;_13&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;
&lt;span class="nc"&gt;Typeinexpressionstohavethemevaluated&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;helpformoreinformation.&lt;/span&gt;
&lt;span class="kt"&gt;scala&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;def&lt;/span&gt; &lt;span class="kt"&gt;isIntIntMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;x:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;,&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;warning:non&lt;/span&gt; &lt;span class="kt"&gt;variable&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="kt"&gt;-argument&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;in&lt;/span&gt;
&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;pattern&lt;/span&gt; &lt;span class="kt"&gt;is&lt;/span&gt; &lt;span class="kt"&gt;unchecked&lt;/span&gt; &lt;span class="kt"&gt;since&lt;/span&gt; &lt;span class="kt"&gt;it&lt;/span&gt; &lt;span class="kt"&gt;is&lt;/span&gt; &lt;span class="kt"&gt;eliminated&lt;/span&gt; &lt;span class="kt"&gt;by&lt;/span&gt; &lt;span class="kt"&gt;erasure&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;,&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;
       &lt;span class="o"&gt;^&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与Java泛型类型Scala使用了擦除模式。这意味着在运行时不会维护类型参数。因此，没有办法在运行时决定map对象在构建时是否使用了两个Int类型参数。系统可以做的只是检查值是否匹配带任意类型参数的Map。可以使用不同类型的参数调用isIntIntMap来验证这个问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isIntIntMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res17&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isIntIntMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc"&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"abc"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res18&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;唯一的例外是数组，因为与Java中一样Scala对数组作了特殊处理。数组元素的类型被保存在数组中，因此可以进行模式匹配。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isStringArray&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"yes"&lt;/span&gt;
      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"no"&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;isStringArray&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isStringArray&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res19&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;yes&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;ai&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;ai&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isStringArray&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ai&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res20&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;no&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bian-liang-bang-ding"&gt;变量绑定&lt;/h3&gt;
&lt;p&gt;对于变量匹配模式，你可以向任何匹配模式添加变量。只需要在匹配模式前添加@符号。这将会将匹配成功的变量绑定到变量上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abs"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;@&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abs"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量e被绑定到&lt;code&gt;UnOp("abs", _)&lt;/code&gt;这个匹配模式上。如果整个模式匹配成功，则整个匹配的&lt;code&gt;UnOp("abs", _)&lt;/code&gt;部分将被作为变量e。&lt;/p&gt;
&lt;h3 id="pattern-guard"&gt;Pattern guard&lt;/h3&gt;
&lt;p&gt;有些情况下，句法上的匹配并不够精确。比如，给你一个任务将&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;转换为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可能会写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;simplifyAdd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;error:x&lt;/span&gt; &lt;span class="kt"&gt;is&lt;/span&gt; &lt;span class="kt"&gt;already&lt;/span&gt; &lt;span class="kt"&gt;defined&lt;/span&gt; &lt;span class="kt"&gt;as&lt;/span&gt; &lt;span class="kt"&gt;value&lt;/span&gt; &lt;span class="kt"&gt;x&lt;/span&gt;
         &lt;span class="n"&gt;caseBinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将会失败，因为Scala约束了模式匹配为线性的：模式变量在同一个匹配模式中只允许出现一次。但，你可以使用pattern guard重写为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;simplifyAdd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
       &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;simplifyAdd&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pattern guard是在匹配模式后添加if。Guard可以是任意类型的boolean表达式，它通常会引用模式变量。如果pattern guard存在，则匹配只在guard的if条件满足时才会成功。使用pattern guard的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//match only positive integers&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;if&lt;/span&gt; &lt;span class="err"&gt;0&lt;/span&gt; &lt;span class="kt"&gt;&amp;lt;n&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;...&lt;/span&gt;

&lt;span class="c1"&gt;//match only strings starting with the letter 'a'&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="kt"&gt;if&lt;/span&gt; &lt;span class="kt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)=&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'a'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;匹配模式重叠&lt;/h2&gt;
&lt;p&gt;匹配模式将按书写次序依次尝试。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//&amp;lsquo;-&amp;rsquo;isitsowninverse&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//&amp;lsquo;0&amp;rsquo;isaneutralelementfor&amp;lsquo;+&amp;rsquo;&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//&amp;lsquo;1&amp;rsquo;isaneutralelementfor&amp;lsquo;*&amp;rsquo;&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个版本的simplify会将规则应用到表达式的任何位置，不管它是否是顶层对象。在这个例子中要注意catch-all的情况应该放在最后。否则下面的匹配模式将不可达，编译时将出现unreachable code错误。&lt;/p&gt;
&lt;h2&gt;Sealed classes&lt;/h2&gt;
&lt;p&gt;在编写模式匹配时，必要要保证能覆盖所有可能的情况。有些时候我们可以末尾处添加默认情况的匹配，但这只在存在合理的默认匹配的情况下才适合。如果没有默认匹配？你还会认为你安全的覆盖了所有可能的情况吗？&lt;/p&gt;
&lt;p&gt;实际上，你可以从Scala编译器来获得支持来检测缺失的匹配模式。为了达到这个目的，编译器需要知道会有哪些可能的匹配。通常情况下这在Scala中是不可能的，因为我们可以任意的定义新的case class。比如，我们可以一个编译单元中在Expr的类继承结构中随意的定义5个case class，而在另一个编译单元中只定义4个。&lt;/p&gt;
&lt;p&gt;可取的方法是使case class的超类为sealed class。Sealed class不允许在定义sealed class的文件之外定义新的子类。这对于使用模式匹配是非常重要的，因为这意味着你不需要考虑子类的问题，因为所有的子类类型你都已经知道了。sealed关键字通常用于模式匹配。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;sealed&lt;/span&gt; &lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在定义模式匹配&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"anumber"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"avariable"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在编译时Scala将检查缺失的匹配情况并给出警告信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;match&lt;/span&gt; &lt;span class="kt"&gt;is&lt;/span&gt; &lt;span class="kt"&gt;not&lt;/span&gt; &lt;span class="kt"&gt;exhaustive!&lt;/span&gt;
&lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;combination&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;
&lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;combination&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时我们可能会遇到编译器发邮过多的这种警告。例于，你可以确保在某个环境下某些情况不可能会发生。我们能确保不会发生MatchError。为了避免出现这些警告，我们可以添加catch-all case：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"anumber"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"avariable"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;RuntimeException&lt;/span&gt; &lt;span class="c1"&gt;//Shouldnothappen&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种修改方式能工作，但未必是你所满意的，因为你被迫添加了不可能被执行的代码，我们也可以直接让编译器闭嘴。&lt;/p&gt;
&lt;p&gt;即在模式匹配的selector上添加@unchecked注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;:@&lt;/span&gt;&lt;span class="n"&gt;unchecked&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"anumber"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"avariable"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常你可以使用给添加注释的方式给selector表达式添加注释：在表达式后面加上冒号和注释。如上面的e:@unchecked。@unchecked对于模式匹配有特殊含义。如果selector表达式带有这个注释，则编译器将不会检查匹配模式是否覆盖所有可能。&lt;/p&gt;
&lt;h2&gt;Option&lt;/h2&gt;
&lt;p&gt;对于可选值Scala有一个标准类型Option。它的值只有两种情况。一种为Some(x)，x是实际的值。另一种为None对象，它表示没有值。&lt;/p&gt;
&lt;p&gt;在对Scala的集合类型的一些操作会生成可选值。比如，Scala的Map的get方法将在key对应的值存在时将生成Some(value)，如果key对应的值不存在则返回None。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;capitals&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;
         &lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"France"&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Paris"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Japan"&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Tokyo"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;capitals&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;
  &lt;span class="kt"&gt;scala.collection.immutable.Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;,
  &lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;France&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Paris&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nc"&gt;Japan&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Tokyo&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;capitalsget&lt;/span&gt; &lt;span class="s"&gt;"France"&lt;/span&gt;
&lt;span class="n"&gt;res21&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Paris&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;capitalsget&lt;/span&gt; &lt;span class="s"&gt;"NorthPole"&lt;/span&gt;
&lt;span class="n"&gt;res22&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最常见的获取可选值的方式是使用模式匹配。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"?"&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="nc"&gt;String&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;capitalsget&lt;/span&gt; &lt;span class="s"&gt;"Japan"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res23&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Tokyo&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;capitalsget&lt;/span&gt; &lt;span class="s"&gt;"France"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res24&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Paris&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;capitalsget&lt;/span&gt; &lt;span class="s"&gt;"NorthPole"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res25&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;=?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Option类型在Scala程序中很常见。比较它与Java中使用null标识没有值。例如，java.util.HashMap的get方法将返回存储于HashMap中的值，在未找到值是返回null。这种方式使得HashMap中不能保存null值。如果某个变量允许为null，则你总是需要在使用它时检查它是否为null。如果你忘记检查就可能在运行时产生NullPointerException。由于这种异常并不是总会发生，因此难于发现和调试。而对于Scala而言则不会发生这种情况，因为它允许在hash map上存储值的类型，而null不是合法的类型。例如，HashMap[Int, Int]不能返回null来表示&amp;ldquo;没有这个元素&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;Scala鼓励使用Option来标识可选值。这与Java中直接使用类型有很多好处。首先，增加了可读性，Option[String]标明了变量可能为null的字符串。更重要的是，使用未检查的空值变量在Scala中变成了类型错误。如果将类型为Option[String]的变量用于String则编译将不能通过。&lt;/p&gt;
&lt;h2&gt;无处不在的匹配模式&lt;/h2&gt;
&lt;p&gt;匹配模式被用于Scala中的很多地方，而不仅仅是用于匹配表达式。&lt;/p&gt;
&lt;h3 id="mo-shi-yong-yu-bian-liang-ding-yi"&gt;模式用于变量定义&lt;/h3&gt;
&lt;p&gt;当定义val或var时，你可以使用模式来代替标识符。例如，你可以使用下面的例子来提取元组中的数据，将元组的不同部分赋给不同的变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"abc"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;)=(&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;myTuple&lt;/span&gt;
&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;
&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使用case class时，如果你明确的了解这个case class，则你可以使用模式来析构对象。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(*,&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;exp&lt;/span&gt;
&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="casexu-lie-zuo-wei-pian-ying-yong-han-shu"&gt;Case序列作为偏应用函数&lt;/h3&gt;
&lt;p&gt;大括号中的case序列可以用于任何允许使用function literal的地方。与只有一个入口点和参数列表的函数不同，case序列可以有多个入口，每个入口有自己的参数列表。每个case都有进入函数的入口，参数由模式来指定。函数在每个入口点case的右边。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;withDefault&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;={&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数休有两个case。第一个匹配Some，并返回Some内部的数值。第二个case匹配None，返回数值0。下面是使用这个函数的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;withDefault&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res25&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;withDefault&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;None&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res26&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种机制对于actor库非常有用。下面是一些典型的actor的代码。它传递模式匹配到react方法中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;actor&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Actor&lt;/span&gt;&lt;span class="o"&gt;)=&amp;gt;{&lt;/span&gt;
    &lt;span class="n"&gt;actor&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;getip&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;act&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;{&lt;/span&gt;
    &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Unhandledmessage:"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;act&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Case序列的另一个应用是偏应用函数（partial function）。如果你将这个函数应用到一个值它将产生运行时错误。例如，下面是一个返回list中第二个元素中的整数的偏应用函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;={&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当编译时这个函数时，编译器将产生下面的警告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;warning:&lt;/span&gt; &lt;span class="kt"&gt;match&lt;/span&gt; &lt;span class="kt"&gt;is&lt;/span&gt; &lt;span class="kt"&gt;not&lt;/span&gt; &lt;span class="kt"&gt;exhaustive!&lt;/span&gt;
 &lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;combination&lt;/span&gt; &lt;span class="nc"&gt;Nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果传递空的list给它，它将产生错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res24&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;MatchError&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
      &lt;span class="kt"&gt;at$anonfun$1.apply&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;&amp;lt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="err"&gt;17&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="kt"&gt;at$anonfun$1.apply&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;&amp;lt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="err"&gt;17&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你需要检查某个偏应用函数是否定义，你必须先告诉编译器你需要使用偏应用函数。类型说明&lt;code&gt;List[Int] =&amp;gt; Int&lt;/code&gt;包含了整型List的所有函数，无论它是否是偏应用函数。只包含整型List的所有偏应用函数应该写作&lt;code&gt;PartialFunction[List[Int],Int]&lt;/code&gt;。下面是新编写的函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;PartialFunction&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;,&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用偏应用函数的isDefinedAt测试是否定义了函数。在这里，可以测试到接收两个以上元素的List作为参数的second函数被定义了，而接收空List的second函数不存在：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isDefinedAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res27&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isDefinedAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;res28&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上，上面的表达式被Scala编译器编译为偏应用函数是通过将模式进行了两次转换&amp;mdash;&amp;mdash;一次是为了实现匹配函数，另一次是实现&lt;code&gt;isDefinedAt&lt;/code&gt;函数。例如，&lt;code&gt;{case x :: y :: _ =&amp;gt; y}&lt;/code&gt;将被翻译为下面的偏应用函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;PartialFunction&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;,&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]{&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isDefinedAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当function literal被申明为PartialFunction时这个转换就产生。如果申明的类型为Function1，或未申明则将被转换为完整的函数。&lt;/p&gt;
&lt;p&gt;通常，如果可能应该尽可能的使用完整的函数，因为使用偏应用函数时允许运行时错误，编译器无法给予帮助。尽管如此，但在有些时候偏应用函数确实有用。你可能确保不提供未被处理的值。其中一个办法是可以使用检查偏应用函数的框架，总是在调用函数前使用isDefinedAt进行检查。例如，上面的react中，参数是一个偏应用，它精确定义了调用都要处理的消息。&lt;/p&gt;
&lt;h3 id="forbiao-da-shi-zhong-de-pi-pei-mo-shi"&gt;for表达式中的匹配模式&lt;/h3&gt;
&lt;p&gt;你也可以在for表达式中使用模式匹配。下例中的表达式遍历capitals map中的键/值对。每个键值对匹配(country, city)模式，这将会定义两个变量country和city。&lt;/p&gt;
&lt;p&gt;键值对匹配模式在匹配时是一种特殊的模式，它永远不会失败。capitals是map它的的键值对总会匹配键值对模式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;country&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;city&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="n"&gt;capitals&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The capital of"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;country&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;"is"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;city&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nc"&gt;The&lt;/span&gt; &lt;span class="n"&gt;capital&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;Franceis&lt;/span&gt; &lt;span class="nc"&gt;Paris&lt;/span&gt;
&lt;span class="nc"&gt;The&lt;/span&gt; &lt;span class="n"&gt;capital&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;Japanis&lt;/span&gt; &lt;span class="nc"&gt;Tokyo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是生成的数据也有可能不能匹配。例如下面的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"apple"&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
           &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"orange"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;apple&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;
     &lt;span class="nc"&gt;None&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;orange&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fruit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fruit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;apple&lt;/span&gt;
&lt;span class="n"&gt;orange&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子中None元素不会匹配Some(fruit)，因此它不会显示出来。&lt;/p&gt;
&lt;h2&gt;一个大型的示例&lt;/h2&gt;</content><category term="scala"></category></entry><entry><title>OAF开发笔记</title><link href="/oafkai-fa-bi-ji.html" rel="alternate"></link><published>2010-12-09T00:00:00+08:00</published><updated>2010-12-09T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-12-09:/oafkai-fa-bi-ji.html</id><summary type="html">&lt;h1&gt;开发advancedTable in advancedTable&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置两个VO，建立两个VO之间的View Link对象。在页面中以两个VO中的主VO创建outerTable，在outerTable上创建detail，在这个detail中再以主从关系中的从VO创建innerTable。outerTable和inerTable都为advancedTable类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从关系中主VO需要增加一个属性用于标识下innerTable是否展开，它的值为字符串Y或N。将outerTable的Detail View Attribute设置为这个属性的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将outterTable的Child View Attribute设置为关联字段的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将outterTable的View Link Instance设置为主从关系的View Link实例名（不是类名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将innerTable和Detail View Attribute设置为对应的属性（如果有）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将innerTable的View Link Instance设置为主从关系的View Link实例名（不是类名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些设置与OAF Guide中下面这段代码起的作用是一样的，这样设置以后下面CO中的代码就不需要了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(...)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;outerTable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAWebBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"outerTable"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;innerTable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAWebBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"innerTable …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;开发advancedTable in advancedTable&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置两个VO，建立两个VO之间的View Link对象。在页面中以两个VO中的主VO创建outerTable，在outerTable上创建detail，在这个detail中再以主从关系中的从VO创建innerTable。outerTable和inerTable都为advancedTable类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从关系中主VO需要增加一个属性用于标识下innerTable是否展开，它的值为字符串Y或N。将outerTable的Detail View Attribute设置为这个属性的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将outterTable的Child View Attribute设置为关联字段的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将outterTable的View Link Instance设置为主从关系的View Link实例名（不是类名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将innerTable和Detail View Attribute设置为对应的属性（如果有）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将innerTable的View Link Instance设置为主从关系的View Link实例名（不是类名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些设置与OAF Guide中下面这段代码起的作用是一样的，这样设置以后下面CO中的代码就不需要了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(...)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;outerTable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAWebBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"outerTable"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;innerTable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAWebBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"innerTable"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outerTable&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;outerTable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CHILD_VIEW_ATTRIBUTE_NAME&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"Deptno"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;outerTable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;VIEW_LINK_NAME&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"DeptEmpVL"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;innerTable&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;innerTable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CHILD_VIEW_ATTRIBUTE_NAME&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"Deptno"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;innerTable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;VIEW_LINK_NAME&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"DeptEmpVL"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;开发HGrid和Tree组件&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;以自关联的VO为例，添加一个VL以关联自身。但并不要求必须是自关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建一个hGrid区域，在其中添加tree和其它的项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在tree的nodeDef中设置好View Instance和View Attribute以作为节点的标题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在tree和childNode中设置Ancestor Node为需要递归显示的区域，例如：/dtxxsoft/oracle/apps/cux/dpt/task/webui/DptTaskMainPG.TreeColumnRN。不要使用View Link Instance，它已经deprecated，只需要设置View Link Accessor，它的值为VL的定义中Destination一方的Accessor Name。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HGrid的查询。多次尝试未成功。替代的方法是另做一个列表页面进行查询，在列表中选中节点后，计算出该节点在树中的路径，再转到HGrid页面，并Focus到这个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HGrid的初始焦点路径，例如设置到根节点的第5个子节点下的第2个节点上。查询时也是通过设置该属性来定位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;focusRootPath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;setInitialFocusPath&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;focusRootPath&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HGrid列表在数据库中的新数据时不能刷新，即使将HGrid对应的vo缓存清空也无效。只能在页面跳转时不保存am，或者手工调用pageContext.releaseRootApplicationModule方法让页面的AM失效，这样HGrid界面才能刷新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果设置焦点路径要注意HGrid根节点有多个节点和只有一个节点时的区别，如果只有一个节点则它将是根节点。如果有多个根极节点，则HGrid将自动产生一个根节点。如果只有一个根级节点，则计算路径时，不要将根节点自身计算进去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;关于RetainAM&lt;/h1&gt;
&lt;p&gt;开发手册中所说的RetainAM的情况必须是在两个页面使用相同类型的根应用模块时才能使用。而在实际使用过程中，我发现两个页面使用了不同的AM，在使用RetainAM=Y时同样有效。例如，从A页面Forward到B页面时RetainAM=Y，然后在B页面进行一些操作，此过程中总是使用RetainAM=Y，当从B页面回到A页面时仍然使用RetainAM=Y，这样A页面的AM的状态仍然能够保留。即使我在B页面中使用pageContext.releaseRootApplicationModule()，这时失效的也只是B页面自己的AM，回到A页面时，A页面的AM仍然有效。&lt;/p&gt;
&lt;h1&gt;基于SQL的只读VO的一个Bug&lt;/h1&gt;
&lt;p&gt;如果使用&lt;code&gt;select t.* from aaa t&lt;/code&gt;之类的SQL来创建VO，当aaa表中添加了新的字段后，VO不能自动同步，页面中的项有可能出现与VO的属性不匹配的情况。&lt;/p&gt;
&lt;h1&gt;取库存组织&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;select oav.organization_id org_id,
       oav.organization_code org_code,
       oav.organization_name org_name,
       oav.responsibility_id resp_id,
       oav.resp_application_id resp_app_id
from   org_access_view oav,
       mtl_parameters mp,
       wip_eam_parameters wep
where  oav.organization_id = mp.organization_id
and    NVL(mp.eam_enabled_flag,'N') = 'Y'
and    oav.organization_id = wep.organization_id
order by org_code
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;日志&lt;/h1&gt;
&lt;p&gt;OAF日志不支持日志级别的处理。没有日志的优先级。日志级别的有效值是OAFwkConstant中的UNEXPECTED, ERROR, EXCEPTION, EVENT, ROCEDURE, STATEMENT, PERFORMANCE。&lt;/p&gt;
&lt;h1&gt;开发包含train的多步处理页面&lt;/h1&gt;
&lt;p&gt;开发文档中有个错误：&lt;/p&gt;
&lt;p&gt;Step CE-5.3 Add Links to the navigationBar中Destination URI /&lt;yourname&gt;/oracle/apps/ak/employee/webui/ EmpUpdatePG的Destination URI的值应该与应该包含OA.jsp?page=。该值应该与Step CE-4.2 Add Three Train Nodes to the EmpTrainRN Region中设置的Destination URI的值保持一致。&lt;/yourname&gt;&lt;/p&gt;
&lt;p&gt;该错误将导致点击&amp;ldquo;下一步&amp;rdquo;时train最多只能到第二步，NavButtonBar中的下拉列表中的当前步骤始终显示为第一步。&lt;/p&gt;
&lt;h1&gt;OAF页面缓存&lt;/h1&gt;
&lt;h2&gt;清除高速缓存&lt;/h2&gt;
&lt;p&gt;页面缓存将被清理
Functional Adminstrator &amp;gt; Core services &amp;gt; Caching Framework &amp;gt; Clear cache.&lt;/p&gt;
&lt;h2&gt;开发中的页面缓存&lt;/h2&gt;
&lt;p&gt;在JSP页面中使用oracle.apps.jtf.cache.CacheManager.invalidate()方法可以清空页面缓存。&lt;/p&gt;
&lt;h1&gt;由链接弹出的页面&lt;/h1&gt;
&lt;p&gt;将链接的target属性为_blank时页面将在弹出窗口中打开。这时要注意，链接上要加上retainAM=Y否则在窗口弹出后，在原页面中进行操作时将出错。&lt;/p&gt;
&lt;p&gt;有可能是因为oaf中的am实际是与用户session关联的，当与服务器有交互时，如果没有retainAM则上一个am将丢失。ebs中除了lov之类的弹出页面外，也没有其它的弹出页面。估计也是因为这个原因，oaf不能维护在同一个http session中进行两个AM相关的操作。这是根据以下分析得来的：&lt;/p&gt;
&lt;p&gt;在弹出的窗口中，如果所有操作都是post或retainAM=Y的操作，则原窗口中仍可继续操作。如果在弹出窗口中点击了&amp;ldquo;主页&amp;rdquo;等会让AM失效的链接时，则父窗口的AM也将失效。&lt;/p&gt;
&lt;h1&gt;JSP相关&lt;/h1&gt;
&lt;h2&gt;在JSP中获取JDBC连接&lt;/h2&gt;
&lt;p&gt;来源：http://www.itjaj.com/thread-3994-1-1.html&lt;/p&gt;
&lt;p&gt;方法一：使用FWAppsContext获取连接&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"java.sql.Connection"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.jtf.base.session.FWAppsContext"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.jtf.base.session.ServletSessionManager"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.jtf.base.session.FWSession"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;

&lt;span class="x"&gt;String appName = request.getParameter("appName");&lt;/span&gt;
&lt;span class="x"&gt;String stateless = request.getParameter("stateless");&lt;/span&gt;

&lt;span class="x"&gt;if (appName == null) appName = "JTF";&lt;/span&gt;
&lt;span class="x"&gt;if (stateless == null) stateless = "T";&lt;/span&gt;

&lt;span class="x"&gt;FWSession _fwSession;&lt;/span&gt;
&lt;span class="x"&gt;try {&lt;/span&gt;
&lt;span class="x"&gt;  _fwSession = oracle.apps.jtf.base.session.ServletSessionManager.startRequest(request,response,appName,statelessB);&lt;/span&gt;
&lt;span class="x"&gt;} catch(oracle.apps.jtf.base.session.ServletSessionManagerException e) {&lt;/span&gt;
&lt;span class="x"&gt;  throw e;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="x"&gt;FWAppsContext cont = _fwSession.getFWAppsContext();&lt;/span&gt;
&lt;span class="x"&gt;Connection conn = cont.getJDBCConnection();&lt;/span&gt;

&lt;span class="x"&gt;try {&lt;/span&gt;
&lt;span class="x"&gt;  // 程序代码逻辑&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="x"&gt;finally {&lt;/span&gt;
&lt;span class="x"&gt;  if (conn != null)&lt;/span&gt;
&lt;span class="x"&gt;    conn.close();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;/**** End Request ****/&lt;/span&gt;
&lt;span class="x"&gt;try {&lt;/span&gt;
&lt;span class="x"&gt;  oracle.apps.jtf.base.session.ServletSessionManager.endRequest(request, false);&lt;/span&gt;
&lt;span class="x"&gt;} catch(oracle.apps.jtf.base.session.ServletSessionManagerException e) {&lt;/span&gt;
&lt;span class="x"&gt;  throw e;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FWAppsContext可以获取很多环境数据，如UserID、RespId、RespApplId等，还可以设置和获取Session值。&lt;/p&gt;
&lt;p&gt;方法二：使用EBS的SSO类库获取数据库连接&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.fnd.common.WebAppsContext"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.fnd.common.ProfileStore"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="n"&gt;page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.fnd.sso.*"&lt;/span&gt; &lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;

&lt;span class="x"&gt;boolean isCtxAvailable = false;&lt;/span&gt;
&lt;span class="x"&gt;WebAppsContext wctx = null;&lt;/span&gt;

&lt;span class="x"&gt;if (Utils.isAppsContextAvailable())&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;  isCtxAvailable = true;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="x"&gt;wctx = Utils.getAppsContext();&lt;/span&gt;
&lt;span class="x"&gt;Connection conn = Utils.getConnection();&lt;/span&gt;
&lt;span class="x"&gt;ProfileStore profilestore = wctx.getProfileStore();&lt;/span&gt;

&lt;span class="x"&gt;try&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;  // 程序代码逻辑&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="x"&gt;finally&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;  conn.close();&lt;/span&gt;
&lt;span class="x"&gt;  if (!isCtxAvailable)&lt;/span&gt;
&lt;span class="x"&gt;  {&lt;/span&gt;
&lt;span class="x"&gt;    Utils.releaseAppsContext();&lt;/span&gt;
&lt;span class="x"&gt;  }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法三：其它方法
上面两种方法是我常用的方法，除此之外，还可以使用以下任一种方法来获取连接，其实每种方式最终都是调用AppsContext来获取数据库连接的
1、调用oracle.apps.jtf.aom.transaction.TransactionScope.getConnection();&lt;/p&gt;
&lt;p&gt;2、使用WebRequestUtil来获取WebAppsContext，并最终获取数据库连接&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="n"&gt;page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.fnd.common.WebAppsContext"&lt;/span&gt; &lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="n"&gt;page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.fnd.common.WebRequestUtil"&lt;/span&gt; &lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;
&lt;span class="no"&gt;WebAppsContext&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;WebRequestUtil&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;validateContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="no"&gt;WebRequestUtil&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setClientEncoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="no"&gt;Connection&lt;/span&gt; &lt;span class="n"&gt;conn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getJDBCConnection&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;JSP文件编译&lt;/h2&gt;
&lt;p&gt;相关环境变量：
 - $FND_TOP/patch/115/bin/ojspCompile.pl JSP编译脚本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$OA_HTML JSP保存目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$OAD_TOP/_pages JSP编译为class后的保存目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强制重新编译所有JSP文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ojspCompile.pl &amp;ndash;compile &amp;ndash;flush -p
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;编译单个文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ojspCompile.pl --compile -s a.jsp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a.jsp为文件名匹配表达式。&lt;/p&gt;
&lt;h1&gt;设置表格中汇总数据的值&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OAMessageStyledTextBean&lt;/span&gt; &lt;span class="n"&gt;salaryBean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAMessageStyledTextBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"item1"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;salaryBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TABULAR_FUNCTION_VALUE_ATTR&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例中iem1为，设置了Total Value为True的列。&lt;/p&gt;
&lt;h1&gt;UI控制&lt;/h1&gt;
&lt;h2&gt;不同UI效果的例子&lt;/h2&gt;
&lt;p&gt;对于不同的UI效果可以参考范例包oracle.apps.fnd.framework.toolbox.samplelib中的例子。&lt;/p&gt;
&lt;h2&gt;自定义xss文件来设置CSS定义&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="nt"&gt;&amp;lt;style&lt;/span&gt; &lt;span class="na"&gt;selector=&lt;/span&gt;&lt;span class="s"&gt;".CuxIssueLevel02"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"color"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;#ff6600&lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改OA_HTML/cabo/custom.xss或者添加新的xss文件然后在custom.xss中引用。然后通过设置WebBean的CSSClass属性来使用所定义的样式。&lt;/p&gt;
&lt;p&gt;使用中发现有bug，在其中定义颜色使用"orange"时不能正确生成到css文件中去，而使用rgb方法来表示则正常。&lt;/p&gt;
&lt;h2&gt;使用UrlInclude引入CSS定义&lt;/h2&gt;
&lt;p&gt;使用UrlInclude组件包含CSS文件或包含带样式定义的文件。然后通过设置WebBean的CSSClass属性来使用所定义的样式。&lt;/p&gt;
&lt;h2&gt;设置内联样式&lt;/h2&gt;
&lt;p&gt;直接设置WebBean的InlineStyle来设置内联样式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;CSSStyle&lt;/span&gt; &lt;span class="n"&gt;cellStyle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;CSSStyle&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;cellStyle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setProperty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"border"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"#cc0000 solid"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;cellStyle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setProperty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"border-width"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"0 1 1 0"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;cellFormatBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setInlineStyle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cellStyle&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;编程方式实现动态绑定属性&lt;/h2&gt;
&lt;p&gt;默认情况下Required, Rendered, Disabled, and Read Only的值可以设置为SPEL表达式。如果有其它属性需要动态绑定则要使用动态绑定技术。OAF提供了三种类型的绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fnd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;framework&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;webui&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;OADataBoundValueViewObject&lt;/span&gt;
&lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fnd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;framework&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;webui&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;OADataBoundValueAppModule&lt;/span&gt;
&lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fnd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;framework&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;webui&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;OAFunctionSecurityBoundValue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;使用动态绑定控制组件样式&lt;/h2&gt;
&lt;p&gt;通过使用OADataBoundValueViewObject将组件的style Class绑定到VO属性上来控制颜色。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;bean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"bean"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bean&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;bean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAMessageStyledTextBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STYLE_CLASS_ATTR&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
                           &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OADataBoundValueViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bean&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
                                                          &lt;span class="s"&gt;"ViewAttrName"&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;样式可以使用上节中介绍的方法进行定义。&lt;/p&gt;
&lt;h1&gt;新建记录后在保存后，部分LOV带出来的只读字段丢失&lt;/h1&gt;
&lt;p&gt;这是因为只读字段的数据不会被保存到VO中，因此需要在保存完后刷新一次当前的VO，让数据重新加载一次，这通常可以调用AM中编辑记录的方法，让它重新执行一次查询，使VO中的只读字段重新从数据库加载。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>汇编语言（王爽）读书笔记</title><link href="/hui-bian-yu-yan-wang-shuang-du-shu-bi-ji.html" rel="alternate"></link><published>2010-09-01T00:00:00+08:00</published><updated>2010-09-01T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-09-01:/hui-bian-yu-yan-wang-shuang-du-shu-bi-ji.html</id><summary type="html">&lt;h1&gt;基础知识&lt;/h1&gt;
&lt;h2&gt;存储单元&lt;/h2&gt;
&lt;p&gt;最小信息单位是bit（比特、二进制位），8bit为1Byte（字节）。存储单元以字节为单位计。128个存储单元的存储器可以存储128字节。&lt;/p&gt;
&lt;h2&gt;CPU对存储器的读写&lt;/h2&gt;
&lt;h3 id="du-xie-shi-cpuyu-wai-bu-qi-jian-jin-xing-3lei-xin-xi-jiao-hu"&gt;读写时CPU与外部器件进行3类信息交互：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;存储单元的地址（地址信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;器件的选择，读或写的命令（控制信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读或写的数据（数据信息）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="du-xie-guo-cheng"&gt;读写过程&lt;/h3&gt;
&lt;h4 id="cpucong-3hao-dan-yuan-zhong-du-qu-shu-ju-guo-cheng"&gt;CPU从3号单元中读取数据过程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU通过地址线将地址信息3发出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过控制线发出内存读取命令，选中存储芯片，并通知它，将要从中读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储器将3号单元中的数据通过数据线送入CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="cpuxiang-3hao-dan-yuan-xie-ru-shu-ju"&gt;CPU向3号单元写入数据&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU通过地址线将地址信息3发出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过数据线将数据送入内存的3号单元中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="di-zhi-zong-xian_1"&gt;地址总线&lt;/h3&gt;
&lt;p&gt;一个CPU有N根地址线，则可以立这个CPU的地址总线宽度为N。这样CPU可以最多寻找2的N次方个内存单元。&lt;/p&gt;
&lt;h3 id="shu-ju-zong-xian"&gt;数据总线&lt;/h3&gt;
&lt;p&gt;CPU与内存或其它器件之间的数据传递是通过数据总线进行的。数据总线宽度决定了CPU和外界的数据传送速度（宽度不足时将需要进行多次传送）。8088CPU数据总线宽度为8，8086CPU的数据总线宽度为16。&lt;/p&gt;
&lt;h3 id="kong-zhi-zong-xian"&gt;控制总线&lt;/h3&gt;
&lt;p&gt;控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。它决定了CPU对外部器件的控制能力。&lt;/p&gt;
&lt;h3 id="di-zhi-kong-jian-gai-shu"&gt;地址空间概述&lt;/h3&gt;
&lt;p&gt;主板上的核心器件通过总线 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;基础知识&lt;/h1&gt;
&lt;h2&gt;存储单元&lt;/h2&gt;
&lt;p&gt;最小信息单位是bit（比特、二进制位），8bit为1Byte（字节）。存储单元以字节为单位计。128个存储单元的存储器可以存储128字节。&lt;/p&gt;
&lt;h2&gt;CPU对存储器的读写&lt;/h2&gt;
&lt;h3 id="du-xie-shi-cpuyu-wai-bu-qi-jian-jin-xing-3lei-xin-xi-jiao-hu"&gt;读写时CPU与外部器件进行3类信息交互：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;存储单元的地址（地址信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;器件的选择，读或写的命令（控制信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读或写的数据（数据信息）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="du-xie-guo-cheng"&gt;读写过程&lt;/h3&gt;
&lt;h4 id="cpucong-3hao-dan-yuan-zhong-du-qu-shu-ju-guo-cheng"&gt;CPU从3号单元中读取数据过程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU通过地址线将地址信息3发出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过控制线发出内存读取命令，选中存储芯片，并通知它，将要从中读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储器将3号单元中的数据通过数据线送入CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="cpuxiang-3hao-dan-yuan-xie-ru-shu-ju"&gt;CPU向3号单元写入数据&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU通过地址线将地址信息3发出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过数据线将数据送入内存的3号单元中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="di-zhi-zong-xian_1"&gt;地址总线&lt;/h3&gt;
&lt;p&gt;一个CPU有N根地址线，则可以立这个CPU的地址总线宽度为N。这样CPU可以最多寻找2的N次方个内存单元。&lt;/p&gt;
&lt;h3 id="shu-ju-zong-xian"&gt;数据总线&lt;/h3&gt;
&lt;p&gt;CPU与内存或其它器件之间的数据传递是通过数据总线进行的。数据总线宽度决定了CPU和外界的数据传送速度（宽度不足时将需要进行多次传送）。8088CPU数据总线宽度为8，8086CPU的数据总线宽度为16。&lt;/p&gt;
&lt;h3 id="kong-zhi-zong-xian"&gt;控制总线&lt;/h3&gt;
&lt;p&gt;控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。它决定了CPU对外部器件的控制能力。&lt;/p&gt;
&lt;h3 id="di-zhi-kong-jian-gai-shu"&gt;地址空间概述&lt;/h3&gt;
&lt;p&gt;主板上的核心器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有：CPU、存储器、外围芯片组、扩展插槽（插有RAM内存条和各类接口卡）等。&lt;/p&gt;
&lt;p&gt;PC上的存储器芯片从读写属性上分为两类：RAM和ROM。从功能和连接上分为：RAM、BIOS及接口卡上的RAM（例如：显存）。&lt;/p&gt;
&lt;p&gt;这些存储器在物理上是独立的器件，但它们都和CPU的总线相连；CPU对它们进行读或写的时候都通过控制线发出内存读写命令。即CPU在操纵和控制它们的时候，把它们都当作内存来对侍，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。&lt;/p&gt;
&lt;p&gt;所有物理存储器被看作由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段。CPU在这段地址空间中读写数据，实际上就是在对相应的物理存储器中读写数据。&lt;/p&gt;
&lt;p&gt;内存地址空间的大小受CPU地址总线宽度的限制。8086CPU的地址总线宽度为20,可以传送2的20次方个不同的地址信息（内存单元），地址空间大小为1MB。80386CPU的地址总线宽度为32,则内在地址空间最大约为4GB。&lt;/p&gt;
&lt;h1&gt;寄存器（CPU工作原理）&lt;/h1&gt;
&lt;p&gt;CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章所说的总线相对于CPU内部来说是外部总线。在CPU中：运算器进行信息处理；寄存器进行信息存储；控制器控制各种器件进行工作；内部总线连接各种器件，在它们之间进行数据的传送。&lt;/p&gt;
&lt;p&gt;对于汇编程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。程序员通过改变各种上寄存器中的内容来实现对CPU的控制。&lt;/p&gt;
&lt;p&gt;8086CPU中有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。&lt;/p&gt;
&lt;h2&gt;通用寄存器&lt;/h2&gt;
&lt;p&gt;8086CPU的所有寄存器都是16位的，可以存储两个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性的数据，被称为通用寄存器。&lt;/p&gt;
&lt;p&gt;8086CPU的上代CPU中寄存器是8位的，为保证兼容性，8086CPU中的AX、BX、CX、DX四个寄存器都可以分为两个独立的8位寄存器来使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AX可分为AH和AL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BX可分为BH和BL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CX可分为CH和CL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DX可分为DH和DL&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;8086CPU可以一次性处理两种尺寸的数据：byte（字节，8位），可存在8位寄存器中，word（字，16位），可存在16位寄存器中。&lt;/p&gt;
&lt;h2&gt;物理地址&lt;/h2&gt;
&lt;p&gt;CPU访问内存单元时，要给出内存单元的地址。所有内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有惟一的地址，这个地址被称为物理地址。&lt;/p&gt;
&lt;p&gt;CPU通过地址总线卷入存储器的必须是一个内在单元的物理地址。在CPU向地址总线上发出物理地址之前，必须在内部先形成这个物理地址。&lt;/p&gt;
&lt;h2&gt;16位结构的CPU&lt;/h2&gt;
&lt;p&gt;16位结构的CPU有下面几方面的结构特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运算器一次最多可以处理16位的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存器的最大宽度为16位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存器和运算器之间的通路为16位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次处理、传输、暂存16位地址。&lt;/p&gt;
&lt;h2&gt;8086CPU给出物理地址的方法&lt;/h2&gt;
&lt;p&gt;8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂存的地址为16位。如果将地址从内部简单的发出，那就只能送出16位地址，表现出的寻址能力只有64KB。&lt;/p&gt;
&lt;p&gt;8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。&lt;/p&gt;
&lt;p&gt;当8086CPU要读写内存时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段地址和偏移地址通过内部总线送入一个称为地址加法器的部件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址加法器将两个16位地址合并成为一个20位的物理地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址加法器通过内部总线将20位物理地址送入输入输出控制电路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入输出控制电路将20位物理地址送上地址总线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;20位物理地址被地址总线传送到存储器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址加法器采用 &lt;em&gt;物理地址＝段地址X16+偏移地址&lt;/em&gt; 的方法用段地址和偏移地址合成物理地址。&lt;/p&gt;
&lt;h2&gt;段的概念&lt;/h2&gt;
&lt;p&gt;将若干地址连续内在单元看作一个段，用段地址X16的起始地址（基础地址），用领衔地址定位段中的内在单元。有两点需要注意：段地址X16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位的寻址能力为64KB，所以一个段的长度最大为64KB。&lt;/p&gt;
&lt;h2&gt;段寄存器&lt;/h2&gt;
&lt;p&gt;8086CPU有4个段寄存器：CS、DS、SS、ES。&lt;/p&gt;
&lt;h2&gt;CS和IP&lt;/h2&gt;
&lt;p&gt;CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS主代码段寄存器，IP为指令指针寄存器。&lt;/p&gt;
&lt;p&gt;在8086CPU中，任意时刻，设CS中内容为M，IP中的内容为N，8086CPU将从内存MX16+N单元开始，读取下一条指令并执行。&lt;/p&gt;
&lt;p&gt;8086CPU加电启动或复位后CS和IP被设置为CS=F000H，IP=FFF0H，CPU从内存FFFF0H单元中读取指令执行。&lt;/p&gt;
&lt;h2&gt;修改CS、IP的指令&lt;/h2&gt;
&lt;p&gt;大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。&lt;/p&gt;
&lt;p&gt;但是mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。8086CPU提供了jmp指令来改变CS、IP的内容。&lt;/p&gt;
&lt;p&gt;若想同时修改CS、IP的内容，可用指令&amp;ldquo;jmp 段地址: 偏移地址&amp;rdquo;完成，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;jmp&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="no"&gt;AE3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="nf"&gt;jmp&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="no"&gt;B16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若想仅修改IP的内容，可以用指令&amp;ldquo;jmp 某一合法寄存器&amp;rdquo;完成，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;jmp&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;代码段&lt;/h2&gt;
&lt;p&gt;在编程时，可根据需要，将一组内存单元定义为一个段。长度为&lt;code&gt;N(N&amp;lt;=64KB)&lt;/code&gt;的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。&lt;/p&gt;
&lt;p&gt;将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS:IP指向的内存单元中的内容为指令。&lt;/p&gt;
&lt;h3 id="debugcheng-xu"&gt;Debug程序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;R命令查看、改变CPU寄存器的内容，&amp;ldquo;r&amp;rdquo;查看，&amp;ldquo;r ax&amp;rdquo;修改ax的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;D命令查看内存中的内容，&amp;ldquo;d 段地址:偏移地址&amp;rdquo;将显示指定的内存单元开始的128个内存单元的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;E命令改写内存中的内容，&amp;ldquo;e 起始地址 数据 数据 数据......&amp;rdquo;，实际上也可以用它来直接写入机器码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;T指令逐条执行代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P执行中断调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A命令以汇编指令的形式在内存中写入机器指令。简单的A命令从一个预设的地址开始输入指令。&amp;ldquo;A 1000:0&amp;rdquo;从1000:0开始的内存中写入指令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;寄存器（内存访问）&lt;/h1&gt;
&lt;h2&gt;内存中字的存储&lt;/h2&gt;
&lt;p&gt;CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元，则一个字要用两个地址连续的内存单元来存放，这个字的低位字节放在低地址单元中，高位字节存放在高地址单元中。&lt;/p&gt;
&lt;p&gt;字单元，即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。&lt;/p&gt;
&lt;h2&gt;DS和[address]&lt;/h2&gt;
&lt;p&gt;CPu要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。8086中有一个DS寄存器，通常用来存放要访问数据的段地址。&lt;/p&gt;
&lt;p&gt;前面使用mov指令，可以完成两种传送：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将数据直接送入寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将一个寄存器中的内容送入另一个寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也可以使用mov将一个内存单元中的内容送入一个寄存器中。格式：mov 寄存器名，内在单元地址。&lt;/p&gt;
&lt;p&gt;内存单元偏移地址放在[]中。段地址由CPU自动取ds中的数据。&lt;/p&gt;
&lt;p&gt;不能使用类似mov ds, 1000h来将1000h送入ds。只能通过寄存器中转。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从寄存器送入内存单元。例如，使用mov [0],al可以将al的数据传送到当前数据段中偏移地址为0的内存单元里。&lt;/p&gt;
&lt;h2&gt;字的传送&lt;/h2&gt;
&lt;p&gt;我们只要在mov指令中给出16位寄存器就可以进行16位数据的传送了。&lt;/p&gt;
&lt;h2&gt;mov、add、sub指令&lt;/h2&gt;
&lt;p&gt;mov指令形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mov 寄存器, 数据     如：mov ax, 8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 寄存器, 寄存器   如：mov ax,bx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 寄存器, 内存单元   如：mov ax,[0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 内存单元, 寄存器   如：mov [0],bx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 段寄存器, 寄存器   如：mov ds,bx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 寄存器, 段寄存器   如：mov bx,ds&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 内存单元, 段寄存器 如：mov [0],cs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 段寄存器, 内存单元 如：mov ds,[0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能使用 mov 段寄存器, 数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;add和sub指令同mov一样，都操作两个对象。它们可以有以下几种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;add 寄存器, 数据     如：add ax,8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;add 寄存器, 寄存器   如：add ax,bx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;add 寄存器, 内存单元  如：add ax, [0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;add 内存单元, 寄存器  如：add [0],ax&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sub 寄存器, 数据     如：sub ax,8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sub 寄存器, 寄存器   如：sub ax,bx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sub 寄存器, 内存单元  如：sub ax, [0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sub 内在单元, 寄存器  如：sub [0],ax&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据段&lt;/h2&gt;
&lt;p&gt;将一段内存将作数据段，是编程时的一种安排，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。&lt;/p&gt;
&lt;h2&gt;栈&lt;/h2&gt;
&lt;p&gt;栈是一种具有特殊的访问方式的存储空间。栈的操作规则为LIFO（Last In First Out），先进先出。&lt;/p&gt;
&lt;h2&gt;CPU提供的栈机制&lt;/h2&gt;
&lt;p&gt;8086CPU提供的入栈和出栈指令为PUSH和POP。&lt;/p&gt;
&lt;p&gt;8086CPU中有两个寄存器来存放栈顶的地址，段寄存器SS和寄存器SP，栈顶的段地址放在SS中，偏移地址放在SP中。栈为空时，栈中没有元素，也就不存在栈顶的元素，所以SS:SP只指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2。栈操作时变化的是SP的值，内存中的数据不会被清空，只会被覆盖。&lt;/p&gt;
&lt;h2&gt;栈顶超界的问题&lt;/h2&gt;
&lt;p&gt;当栈满时再使用push指令，或栈空时再使用pop指令都将发生栈顶超界的问题，这将覆盖栈空间外的数据。&lt;/p&gt;
&lt;p&gt;8086CPU不保证对栈的操作不会超界。&lt;/p&gt;
&lt;p&gt;在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，执行出入栈的时候要注意防止超界。&lt;/p&gt;
&lt;h2&gt;push和pop指令&lt;/h2&gt;
&lt;p&gt;指令格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;push 寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pop 寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push 段寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pop 段寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push 内存单元&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pop 内存单元&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令执行时，可以只给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中取得。&lt;/p&gt;
&lt;p&gt;push和pop指令同mov指令不同，CPU执行mov指令时只需要一步操作，就是传送，而执行push、pop指令时需要两步操作。执行push时，先改变SP，然后向SS:SP处传送。执行pop时，先读取SS:SP的数据，然后改变SP。&lt;/p&gt;
&lt;h2&gt;栈段&lt;/h2&gt;
&lt;p&gt;栈段也仅仅是编程时的一种安排。我们可以将长度为&lt;code&gt;N(N&amp;lt;=64K)&lt;/code&gt;的组地址连续，起始地址为16的倍数的内存单元当作栈空间来使用。&lt;/p&gt;
&lt;h1&gt;第一个程序&lt;/h1&gt;
&lt;h2&gt;源程序&lt;/h2&gt;
&lt;h3 id="wei-zhi-ling"&gt;伪指令&lt;/h3&gt;
&lt;p&gt;汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译的机器指令，是终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行。伪指令由编译器来执行，编译器根据伪指令来进行相关的编译工作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;segment和ends是一对成对使用的伪指令，这是在写可被编译的汇编程序时，必须要用到的一对伪指令。它的功能是定义一个段，segment说明段开始，ends说明段结束。使用格式为：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;段名&lt;/span&gt; &lt;span class="nf"&gt;segment&lt;/span&gt;
&lt;span class="err"&gt;.&lt;/span&gt;
&lt;span class="err"&gt;.&lt;/span&gt;
&lt;span class="err"&gt;段名&lt;/span&gt; &lt;span class="nf"&gt;ends&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个汇编程序由多个段组成，这些段被用来存放代码、数据或当作栈空间来使用。&lt;/p&gt;
&lt;p&gt;一个有意义的汇编程序中至少有一个段，这个段用来存放代码。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;end是一个汇编程序的结束标记，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;assume这条伪指令的含义为&amp;ldquo;假设&amp;rdquo;。它假设某一段寄存器和程序中的某一个用segments...ends定义的段相关联。通过assume说明这种关联，在情况下，编译程序可以将段寄存器和某一个具体的段联系。assume并不是一条非要深入理解不可的伪指令，以后我们编程时，记着用assume将有特定用途的段和相关的段寄存器关联起来即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如我们用codes segment ... codesg ends定义了名为codseg的段。我们在程序开头，用assume cs:codeseg将用作代码段的段codesg和CPU中的段寄存器cs联系起来。&lt;/p&gt;
&lt;h3 id="yuan-cheng-xu-zhong-de-cheng-xu"&gt;源程序中的&amp;ldquo;程序&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;汇编语言写的源程序，包括伪指令和汇编指令，伪指令由编译器来处理，它们并不实现我们编程的最终目的。我们这里所说的程序是指源程序中最终由计算机执行、处理的指令或数据。&lt;/p&gt;
&lt;h3 id="biao-hao"&gt;标号&lt;/h3&gt;
&lt;p&gt;汇编源程序中，除了汇编指令和伪指令外，还有一些标号，如&amp;ldquo;codesg&amp;rdquo;。一个标号指代了一个地址。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。&lt;/p&gt;
&lt;h3 id="cheng-xu-de-jie-gou"&gt;程序的结构&lt;/h3&gt;
&lt;p&gt;源程序由一些段构成。我们可以在这些段中存放代码、数据、或将某个段当作栈空间。基本要素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;assume&lt;/span&gt; &lt;span class="no"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="no"&gt;abc&lt;/span&gt;
&lt;span class="nf"&gt;abc&lt;/span&gt; &lt;span class="no"&gt;segment&lt;/span&gt;
  &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ax&lt;/span&gt;
  &lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ax&lt;/span&gt;

&lt;span class="nf"&gt;abc&lt;/span&gt; &lt;span class="no"&gt;ends&lt;/span&gt;

&lt;span class="nf"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="cheng-xu-fan-hui"&gt;程序返回&lt;/h3&gt;
&lt;p&gt;通过下面的两条指令返回：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="no"&gt;c00H&lt;/span&gt;
&lt;span class="nf"&gt;int&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="yu-fa-cuo-wu-he-luo-ji-cuo-wu"&gt;语法错误和逻辑错误&lt;/h3&gt;
&lt;h2&gt;编译源程序&lt;/h2&gt;
&lt;p&gt;编译过程中将得到3个输出文件：目标文件（.obj）、列表文件（.lst）、交叉引用文件（.crf）。目标文件是我们最终要得到的结果，另外两个只是中间结果。&lt;/p&gt;
&lt;h2&gt;连接器的简单解释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个源文件编译后，得到了存有机器码的目标文件，目标文件中有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="yi-jian-hua-de-fang-shi-jin-xing-bian-yi-he-lian-jie"&gt;以简化的方式进行编译和连接&lt;/h3&gt;
&lt;p&gt;编译和连接1.asm&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;masm&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="c"&gt;;&lt;/span&gt;
&lt;span class="no"&gt;link&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="c"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;可执行文件中的程序将入内存并运行的原理&lt;/h2&gt;
&lt;p&gt;DOS中如果用户要执行一个程序，则输入该程序的可执行文件名，command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS:IP指向程序的入口，此后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，command再次显示当前盘符和当前路径组成的提示符，等侍用户的输入。&lt;/p&gt;
&lt;h2&gt;程序执行过程的跟踪&lt;/h2&gt;
&lt;p&gt;用Debug将程序加载入内存。&lt;/p&gt;
&lt;p&gt;DOS中EXE加载的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;找到一段起始地址为SA:0000的容量足够的空闲内存区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这段内存区的前256字节中，创建一个称为程序段的前缀 （PSP）的数据区，DOS要利用PSP来和被加载的程序进行通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从PSP的后面将程序装入，程序的地址被设置为SA+10H:0；（空闲的内存区从SA:0开始，0-255字节为PSP，从256字节处开始存放程序，为更好地区分PSP和程序。DOS一般将它们划分到不同的段中，所以，有了这样的地址安排：空闲内存区：SA:0，PSP区：SA:0，程序区SA+10H:0。注意：PSP区和程序区虽然物理地址连接，却有不同的段地址。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将内存区的段地址存入DS中，初始化其它相关寄存器后，设置CS:IP指向程序入口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为9，则程序所在的内存区的地址为ds:0&lt;/p&gt;
&lt;p&gt;这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信。从256字节处向后的空间存放的是程序。&lt;/p&gt;
&lt;h1&gt;[bx]和loop指令&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;[bx]和内存单元的描述&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[bx]同样表示一个内存单元，它的偏移地址在bx中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;loop&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;循环指令&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们定义的描述性的符号&amp;ldquo;()&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在下面的内容中，将使用&amp;ldquo;()&amp;rdquo;来表示一个寄存器或内存单元中的内容。它所表示的内容有两种类型：字节或字。是哪种类型将由寄存器名或具体的运算决定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;约定符号idata表示常量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后面，将使用idata表示常量。&lt;/p&gt;
&lt;h2&gt;[bx]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;mov ax,[bx]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mov [bx],ax&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bx中存放的数据作为一个偏移地址，段地址SA默认在ds中，将ax中的数据送入SA:EA处。&lt;/p&gt;
&lt;h2&gt;Loop指令&lt;/h2&gt;
&lt;p&gt;指令格式是：loop 标号。CPU执行loop指令时，要进行两步操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;(cx)=(cx)-1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;在Debug中跟踪用loop指令实现的循环程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在汇编程序中数据不能以字母开头。所以A000h要写为0A000h。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Debug中使用G来继续执行程序。或者g 0012之类的指令转到cs:0012处开始跟踪。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Debug和汇编编译器Masm对指令的不同处理&lt;/h2&gt;
&lt;p&gt;Debug和编译器masm对形如&amp;ldquo;mov ax,[0]&amp;rdquo;这类的指令在解释上不同。Debug会将[0]解释为一个内存单元。而0是内存单元的偏移地址；而编译器将[0]就解释为了0。&lt;/p&gt;
&lt;p&gt;当前我们将偏移地址送入bx寄存器，用[bx]的方式来访问内存单元。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ax&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;al&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果希望像在Debug中那样，在&amp;ldquo;[]&amp;rdquo;中直接给出内存单元的偏移地址。只需要在&amp;ldquo;[]&amp;rdquo;的前面显式的给出段地址所在的寄存器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ax&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;al&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;段前缀&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;mov ax,ds:[bx]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov ax,cs:[bx]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov ax,ss:[bx]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov as,es:[bx]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov ax,ss:[0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov ax,cs:[0]&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的&amp;ldquo;ds:&amp;rdquo;、&amp;ldquo;cs&amp;rdquo;、&amp;ldquo;ss&amp;rdquo;或&amp;ldquo;es&amp;rdquo;，称为段前缀。&lt;/p&gt;
&lt;h2&gt;一段安全的空间&lt;/h2&gt;
&lt;p&gt;在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。&lt;/p&gt;
&lt;p&gt;一般在PC机中，DOS和其他合法程序一般都不会使用0:200~0:300的256个字节的空间。所以我们使用这段空间是安全的。&lt;/p&gt;
&lt;h1&gt;包含多个段的程序&lt;/h1&gt;
&lt;p&gt;程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行过程中间向操作系统申请。&lt;/p&gt;
&lt;p&gt;若要一个程序在加载的时候取得所需的空间，则必须要在源程序中做出说明。我们通过在源程序中定义段来进行内存空间的获取。&lt;/p&gt;
&lt;h2&gt;在代码段中使用数据&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;assume&lt;/span&gt; &lt;span class="no"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="no"&gt;code&lt;/span&gt;
&lt;span class="nf"&gt;code&lt;/span&gt; &lt;span class="no"&gt;segment&lt;/span&gt;
  &lt;span class="nf"&gt;dw&lt;/span&gt; &lt;span class="mi"&gt;0123&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0456&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0789&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="no"&gt;abcH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="no"&gt;defH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="no"&gt;fedH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="no"&gt;cbaH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0987&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
  &lt;span class="nl"&gt;start:&lt;/span&gt;    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
            &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
            &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;cx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
      &lt;span class="nl"&gt;s:&lt;/span&gt;    &lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
           &lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
           &lt;span class="nf"&gt;loop&lt;/span&gt; &lt;span class="no"&gt;s&lt;/span&gt;
  &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="no"&gt;c00h&lt;/span&gt;
  &lt;span class="nf"&gt;int&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
&lt;span class="nf"&gt;code&lt;/span&gt; &lt;span class="no"&gt;ends&lt;/span&gt;
&lt;span class="nf"&gt;end&lt;/span&gt; &lt;span class="no"&gt;start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里代码段定义了一些字型数据。因此代码段的起始位置不再是代码，代码的起始位置由start来标明，代码结束由end start来标明。&lt;/p&gt;
&lt;h2&gt;在代码段中使用栈&lt;/h2&gt;
&lt;h2&gt;将数据、代码、栈放入不同的段&lt;/h2&gt;
&lt;h1&gt;更灵活的定位内存地址的方法&lt;/h1&gt;
&lt;h2&gt;and和or指令&lt;/h2&gt;
&lt;h2&gt;以字符形式给出数据&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;db&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="no"&gt;unIX&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;   &lt;span class="err"&gt;相当于&lt;/span&gt; &lt;span class="no"&gt;db&lt;/span&gt; &lt;span class="mi"&gt;75&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="no"&gt;EH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;49&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;58&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;al&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="no"&gt;a&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt; &lt;span class="err"&gt;相当于&lt;/span&gt; &lt;span class="no"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;al&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;61&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[bx+idata]&lt;/h2&gt;
&lt;p&gt;它的偏移地址为(bx)+idata（bx中的数值加上idata）。也可以写作idata[bx]。&lt;/p&gt;
&lt;h2&gt;SI和DI&lt;/h2&gt;
&lt;p&gt;SI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8位寄存器来使用。&lt;/p&gt;
&lt;h2&gt;[bx+si]和[bx+di]&lt;/h2&gt;
&lt;p&gt;这两者的含义相似。表示一个内存单元，它的偏移地址为(bx)+(si)，即bx中的数值加上si中的数值。&lt;/p&gt;
&lt;h2&gt;[bx+si+idata]和[bx+di+idata]&lt;/h2&gt;
&lt;p&gt;这两者的含义相似。表示一个内存单元，它的偏移地址为(bx)+(si)+idata，即bx中的数值加上si中的数值再加上idata。&lt;/p&gt;
&lt;h2&gt;不同的寻址方式的灵活应用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;[idata]用一个常量来表示地址，可用于直接定位一个内存单元；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[bx+si]用两个变量表示地址；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[bx+si+idata]用两个变量和一个常量表示地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，在需要暂存数据的时候，我们都应该使用栈。&lt;/p&gt;
&lt;h1&gt;数据处理的两个基本问题&lt;/h1&gt;
&lt;p&gt;下面将使用reg来表示寄存器，sreg表示段寄存器。&lt;/p&gt;
&lt;p&gt;reg包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di&lt;/p&gt;
&lt;p&gt;sreg包括：ds,ss,cs,es&lt;/p&gt;
&lt;h2&gt;bx、si、di、bp&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在8086CPU中，只有这4个寄存器可以用在&amp;ldquo;[...]&amp;rdquo;中来进行内存单元的寻址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在[...]中，这4个寄存器可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只要在[...]中使用寄存器bp，而指令没有显式的给出段地址，段地址默认在ss中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;机器指令处理的数据所在位置&lt;/h2&gt;
&lt;p&gt;绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类：读取、写入、运算。在机器指令这一层来讲，关不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。&lt;/p&gt;
&lt;h2&gt;汇编语言中数据位置的表达&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;立即数（idata）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于直接包含在机器指令中的数据，在汇编指令中直接给出，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
&lt;span class="nf"&gt;or&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;00010000&lt;/span&gt;&lt;span class="no"&gt;b&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;al&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="no"&gt;a&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段地址（SA）和偏移地址（EA）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。存放段寄存器可以是默认的，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;di&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等指令，段地址默认在ds中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等指令，段地址默认在ss中。&lt;/p&gt;
&lt;p&gt;存放段地址的寄存器也可以显性的给出，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="no"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;es&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;寻址方式&lt;/h2&gt;
&lt;p&gt;当数据存放在内在中的时候，我们可以用多种方式来给定这个内存单元的偏移地
址，这种定位内存单元的方法一般被称为寻址方式。
&lt;table class="table table table-condensed table-bordered table-hover"&gt;
&lt;tr&gt;
&lt;td&gt;寻址方式&lt;/td&gt;
&lt;td&gt;含义&lt;/td&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;常用格式举例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[idata]&lt;/td&gt;
&lt;td&gt;EA=idata;SA=(ds)&lt;/td&gt;
&lt;td&gt;直接寻址&lt;/td&gt;
&lt;td&gt;[idata]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
     [bx]&lt;br/&gt;
     [si]&lt;br/&gt;
     [di]&lt;br/&gt;
     [bp]&lt;br/&gt;
&lt;/td&gt;
&lt;td&gt;
     EA=(bx);SA=(ds)&lt;br/&gt;
     EA=(si);SA=(ds)&lt;br/&gt;
     EA=(di);SA=(ds)&lt;br/&gt;
     EA=(bp);SA=(ss)&lt;br/&gt;
&lt;/td&gt;
&lt;td&gt;寄存器相对寻址&lt;/td&gt;
&lt;td&gt;
     用于结构体：         &lt;br/&gt; 
     [bx].idata          &lt;br/&gt;
     用于数组：           &lt;br/&gt;
     idata[si],idata[di] &lt;br/&gt;
     用于二维数组         &lt;br/&gt;
     [bx][idata]         &lt;br/&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;</content><category term="asm"></category></entry><entry><title>SICP读书笔记</title><link href="/sicpdu-shu-bi-ji.html" rel="alternate"></link><published>2010-08-31T00:00:00+08:00</published><updated>2010-08-31T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-08-31:/sicpdu-shu-bi-ji.html</id><summary type="html">&lt;h1&gt;Chap.1 Building Abstractions with Procedures&lt;/h1&gt;
&lt;p&gt;在思考活动中通过简单的想法尽力实现强大能量，首要有三： 1. 将多个简单的想法组合成单个的复杂的想法，因而可以完成所有复杂的想法。2. 将两个想法，不论它们是简单或复杂，放到一起，将他们彼此设置并立即观察他们，而不将它们组织成一个想法，通过这种方法可以得到想法之间的关系。3. 将他们从现实的已经存在的其它想法中分离出来：这称为抽象，这样可以构成这些想法的通用想法。&lt;/p&gt;
&lt;p&gt;计算机语言完成任务的三个机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原生表达式，它描述了语言所关心的最简单的实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合的方法，复合元素是从简单元素构成的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象的方法，通过抽象复合元素可以被命名和作为单元被处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编程过程中，我们处理两种类型的元素：过程和数据。数据是要处理的&amp;ldquo;原材料&amp;rdquo;，而过程是处理数据的规则的描述。因此，任何一门强大的编程语言应该能够 描述原生数据类型和原生过程，应该有组合和抽象过程和数据的方法。&lt;/p&gt;
&lt;h2&gt;Exercise 1.2 将下面的表达式转换为form&lt;/h2&gt;
&lt;p&gt;&lt;img alt="ch1-z-g-3" src="/SICP/ch1-z-g-3.gif"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Chap.1 Building Abstractions with Procedures&lt;/h1&gt;
&lt;p&gt;在思考活动中通过简单的想法尽力实现强大能量，首要有三： 1. 将多个简单的想法组合成单个的复杂的想法，因而可以完成所有复杂的想法。2. 将两个想法，不论它们是简单或复杂，放到一起，将他们彼此设置并立即观察他们，而不将它们组织成一个想法，通过这种方法可以得到想法之间的关系。3. 将他们从现实的已经存在的其它想法中分离出来：这称为抽象，这样可以构成这些想法的通用想法。&lt;/p&gt;
&lt;p&gt;计算机语言完成任务的三个机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原生表达式，它描述了语言所关心的最简单的实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合的方法，复合元素是从简单元素构成的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象的方法，通过抽象复合元素可以被命名和作为单元被处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编程过程中，我们处理两种类型的元素：过程和数据。数据是要处理的&amp;ldquo;原材料&amp;rdquo;，而过程是处理数据的规则的描述。因此，任何一门强大的编程语言应该能够 描述原生数据类型和原生过程，应该有组合和抽象过程和数据的方法。&lt;/p&gt;
&lt;h2&gt;Exercise 1.2 将下面的表达式转换为form&lt;/h2&gt;
&lt;p&gt;&lt;img alt="ch1-z-g-3" src="/SICP/ch1-z-g-3.gif"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Exercise 1.3 定义一个过程接收3个参数返回最大的两个参数的平方和&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sum-max-square&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Exercise 1.4 观察下面的求值模型它整合了操作符和表达式。&lt;/h2&gt;
&lt;p&gt;这个例子体现了 scheme 与 common lisp 的区别。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a-plus-abs-b&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它将根据 b 是否大于 0 来决定对 a 和 b 进行加或减操作。&lt;/p&gt;
&lt;h2&gt;Exercise 1.5 应用序或正则序测试&lt;/h2&gt;
&lt;p&gt;Ben Bitdiddle 发明了一种检测解释器是应用序还是正则序的方法。先定义两个过程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;0&lt;/span&gt;
      &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后对下面的表达式求值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然 p 的定义是不正确的，当解释器是应用序的时候会先对参数求值。因此对 (p) 求值时程序将出错。如果程序是正则序则 (p) 不会被立即求值，因为 (= x 0) 将返回真值，整个 test 表达式将返回 0 。&lt;/p&gt;
&lt;h2&gt;Section 1.17 牛顿法求平方根&lt;/h2&gt;
&lt;p&gt;如果猜想y是x的平方，则下一个更接近x平方根的值是((y+x/y))/2&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mf"&gt;0.001&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;guess&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"第一种平方根算法："&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="mf"&gt;21.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Exercise 1.6 能否通过 cond 来定义 if&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;new-if&lt;/span&gt; &lt;span class="nv"&gt;predicate&lt;/span&gt; &lt;span class="nv"&gt;then-clause&lt;/span&gt; &lt;span class="nv"&gt;else-clause&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;predicate&lt;/span&gt; &lt;span class="nv"&gt;then-clause&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="nv"&gt;else-clause&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当测试用 new-if 来实现 Section 1.17 中的求平方根的方法时有可能会出现错误。因为通常 if 是一个特殊的 form 。它只会在条件为真时才对 then 子句求值。而 new-if 只是一个函数，它有可能会对所有参数都求值（比如解释器使用应用序）。在这用于 1.17 中的 sqrt-iter 中时将导致无限循环。&lt;/p&gt;
&lt;h2&gt;Exercise 1.7&lt;/h2&gt;
&lt;p&gt;原来的 section 1.17 中的 good-enough? 是比较猜测值的平方与被开方数的差的绝对值小于某个值。这种方法在对那些很小的数求平方根时并不是很有效。一个更好的办法是将它改进成比较两次猜测值之差是否小于某个给定的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;last-value&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;last-guess表示上一次猜测的值&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mf"&gt;0.000001&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;修改了这个递归计算过程的参数，添加了上次猜测结果&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;guess&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;保证将猜测值设置为与上个猜测值之差的绝对值大于那个比较值0.000001&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"第二种平方根算法："&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="mf"&gt;9.0&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="mf"&gt;21.0&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Exercise 1.8 牛顿法求立方根&lt;/h2&gt;
&lt;p&gt;如果 y 接近 x 的立方根，那么更接近的值是 (x/y*y+2y)/3 。对应的求立方根的程序为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;逼近算法&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;;精度检查&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mf"&gt;0.000001&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;;迭代过程&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cube-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;guess&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cube-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"求立方根算法求27的立方根:"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cube-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="mi"&gt;27&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只是在 exercise 1.7 的基础上替换了 improve 方法。&lt;/p&gt;
&lt;h2&gt;Section 1.2 过程和它们所产生的计算&lt;/h2&gt;
&lt;h3 id="section-122-xian-xing-di-gui-he-die-dai"&gt;Section 1.2.2 线性递归和迭代&lt;/h3&gt;
&lt;h4 id="exercise-19-miao-hui-xian-xing-die-dai-he-xian-xing-di-gui-de-ji-suan-guo-cheng"&gt;Exercise 1.9 描绘线性迭代和线性递归的计算过程&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-rec&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;b&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-rec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;dec&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="c1"&gt;;(add-rec 4 5)&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (add-rec 3 5))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (add-rec 2 5)))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (inc (add-rec 1 5))))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (inc (inc (add-rec 0 5)))))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (inc (inc 5))))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (inc 6)))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (7)))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc 8)&lt;/span&gt;
&lt;span class="c1"&gt;;9&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-iter&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;b&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;dec&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="c1"&gt;;(add-iter 4 5)&lt;/span&gt;
&lt;span class="c1"&gt;;(add-iter 3 6)&lt;/span&gt;
&lt;span class="c1"&gt;;(add-iter 2 7)&lt;/span&gt;
&lt;span class="c1"&gt;;(add-iter 1 8)&lt;/span&gt;
&lt;span class="c1"&gt;;(add-iter 0 9)&lt;/span&gt;
&lt;span class="c1"&gt;;9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="exercise-110-a-ke-man-han-shu"&gt;Exercise 1.10 阿克曼函数&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;g&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;h&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;k&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过使用 f,g,h 和正整数 n ，给出计算 5 乘以 n 的 2 次方的函数 &lt;code&gt;(k n)&lt;/code&gt; 的定义。
 - TODO:&lt;/p&gt;
&lt;h3 id="section-122-shu-xing-di-gui_1"&gt;Section 1.2.2 树形递归&lt;/h3&gt;
&lt;p&gt;树形递归也是一种常见的计算模式。例如Fibonacci数的计算。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Fib(n) = 0                   if n = 0
Fib(n) = 1                   if n = 1
Fib(n) = Fib(n-1) + Fib(n-2) otherwise
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它所产生的计算过程是树状的。会随着n的变大计算规模也逐渐变大。并且在计算过程中间会产生许多重复的计算。例如，计算Fib(3)和Fib(4)时都会需要计算Fib(2)和Fib(1)，这样随着n变大会产生许多重复的计算。&lt;/p&gt;
&lt;p&gt;如果将它转换成递归方式计算规模就不会随n变大而变大。计算的方法是引入两个中间变量a和b，将它们初始化为Fib(0)和Fib(1)，然后a=a+b，b=a，进而计算出Fib(2)，如此递归直至计算出Fib(n)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib-iter&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib_iter&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;b&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;TODO:找零钱的算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="exercise-111-fen-bie-yi-di-gui-he-die-dai-de-fang-shi-bian-xie-fn"&gt;Exercise 1.11 分别以递归和迭代的方式编写f(n)&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f(n)=n if n&amp;lt;3 and f(n) = f(n-1)+2f(n-2)+3f(n-3) if n &amp;gt;=3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归方式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
      &lt;span class="nv"&gt;n&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; 
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;迭代方式。这里我引入了3个变量a、b和c分别代表f(n-1)、f(n-2)和f(n-3)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f1&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f1-iter&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f1-iter&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
      &lt;span class="nv"&gt;c&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f1-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="exercise-112-pa-si-qia-san-jiao"&gt;Exercise 1.12 帕斯卡三角&lt;/h4&gt;
&lt;p&gt;编写递归过程计算帕斯卡三角的元素。&lt;/p&gt;
&lt;p&gt;我首先归纳帕斯卡三角的元素的计算方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f(n,level) = 1                              如果n=1或n=level
f(n,level) = 0                              如果n&amp;lt;1或n&amp;gt;level则元素不存在
f(n,level) = f(n,level-1) + f(n-1,level-1)  otherswise
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中level为层次，n为在某层中的位置。&lt;/p&gt;
&lt;p&gt;转换成函数定义&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;pascal-triangle&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nv"&gt;level&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nv"&gt;level&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;or &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nv"&gt;level&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;pascal-triangle&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;level&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;pascal-triangle&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;level&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="exercise-113-zheng-ming-fibnshi-zui-jie-jin-mou-shu-de-zheng-shu"&gt;Exercise 1.13 证明Fib(n)是最接近某数的整数&lt;/h4&gt;
&lt;p&gt;&lt;literal style="html"&gt;HTML&lt;/literal&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TODO:&lt;/li&gt;
&lt;/ul&gt;</content><category term="lisp"></category><category term="scheme"></category></entry><entry><title>OA Framework Page解析</title><link href="/oa-framework-pagejie-xi.html" rel="alternate"></link><published>2010-07-27T00:00:00+08:00</published><updated>2010-07-27T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-07-27:/oa-framework-pagejie-xi.html</id><summary type="html">&lt;h1&gt;Page基础&lt;/h1&gt;
&lt;p&gt;在浏览器看来，OA Framework页面与其它web页面一样，被渲染为HTML。&lt;/p&gt;
&lt;p&gt;在中间层中，页面是由内存中层级分布的Javabeans组成&amp;mdash;&amp;mdash;非常像传统的Java客户端UI。每个UI构件，比如按钮、表格、tab、商标图像等，被渲染为页面中对应的构件。&lt;/p&gt;
&lt;p&gt;浏览器向一个页面发出请求时，OA Framework读取页面定义的元数据创建web bean结构。每个bean与一个UI控制器关联，OA Framework调用你编写的代码初始化页面。页面处理完成后，OA Framework将web bean结构交给UIX框架处理以生成发送给浏览器的HTML。&lt;/p&gt;
&lt;p&gt;当浏览器发出一个表单提请求时，OA Framework重新创建bean及其层次结构（只在必要的时候才重新创建，通常这些bean是被缓存的，只在特定的情况下才重新创建），然后调用为page bean编写的事件处理代码。当页面处理完成后，页面HTML重新生成并发送给浏览器。&lt;/p&gt;
&lt;p&gt;OA Framework MVC架构：&lt;/p&gt;
&lt;p&gt;&lt;img alt="anatomy" src="/oaf_page/anatomy.gif"/&gt;&lt;/p&gt;
&lt;h1&gt;模型Model&lt;/h1&gt;
&lt;p&gt;模型包括下层的数据和应用业务逻辑。它也提花了现实世界对象和应用服务间的抽像层。&lt;/p&gt;
&lt;h2&gt;应用模块Application Modules&lt;/h2&gt;
&lt;p&gt;BC4j应用模块本质上是一个容器，它管理和提供对&amp;ldquo;相关&amp;ldquo;BC4J模型对象的访问。这里的&amp;ldquo;相关&amp;rdquo;指的是同一个任务中的参与者 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Page基础&lt;/h1&gt;
&lt;p&gt;在浏览器看来，OA Framework页面与其它web页面一样，被渲染为HTML。&lt;/p&gt;
&lt;p&gt;在中间层中，页面是由内存中层级分布的Javabeans组成&amp;mdash;&amp;mdash;非常像传统的Java客户端UI。每个UI构件，比如按钮、表格、tab、商标图像等，被渲染为页面中对应的构件。&lt;/p&gt;
&lt;p&gt;浏览器向一个页面发出请求时，OA Framework读取页面定义的元数据创建web bean结构。每个bean与一个UI控制器关联，OA Framework调用你编写的代码初始化页面。页面处理完成后，OA Framework将web bean结构交给UIX框架处理以生成发送给浏览器的HTML。&lt;/p&gt;
&lt;p&gt;当浏览器发出一个表单提请求时，OA Framework重新创建bean及其层次结构（只在必要的时候才重新创建，通常这些bean是被缓存的，只在特定的情况下才重新创建），然后调用为page bean编写的事件处理代码。当页面处理完成后，页面HTML重新生成并发送给浏览器。&lt;/p&gt;
&lt;p&gt;OA Framework MVC架构：&lt;/p&gt;
&lt;p&gt;&lt;img alt="anatomy" src="/oaf_page/anatomy.gif"/&gt;&lt;/p&gt;
&lt;h1&gt;模型Model&lt;/h1&gt;
&lt;p&gt;模型包括下层的数据和应用业务逻辑。它也提花了现实世界对象和应用服务间的抽像层。&lt;/p&gt;
&lt;h2&gt;应用模块Application Modules&lt;/h2&gt;
&lt;p&gt;BC4j应用模块本质上是一个容器，它管理和提供对&amp;ldquo;相关&amp;ldquo;BC4J模型对象的访问。这里的&amp;ldquo;相关&amp;rdquo;指的是同一个任务中的参与者。比如所有的BC4J对象在同一个任务中参与同一个事务&amp;mdash;&amp;mdash;即使对应的用户界面需要用户访问多个页面。&lt;/p&gt;
&lt;p&gt;应用模块：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ess_model_arch_am" src="/oaf_page/ess_model_arch_am.gif"/&gt;&lt;/p&gt;
&lt;p&gt;应用模块是oracle.apps.fnd.framework.server.OAApplicationModuleImpl类的子类。&lt;/p&gt;
&lt;p&gt;每个OAFramework 页都有一个根（root）应用模块，它与最顶层的页面区域（page region）关联。根应用模块提供事务环境和连接数据库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果多个页面参与同一个物理或虚拟事务，它们应该共享相同的根应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个页面功能不依赖于其它东西，它需要拥有自己的应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 一个根应用模块可能包含一个或多个嵌套的应用模块，可以嵌套任意多的层次。这种情况下，根应用模块可以访问它包含的子对象的数据和对象，所有子对象共享根应用模块的事务。你可以在创建需要重用的与数据库操作相关的UI区域时使用这个功能。&lt;/p&gt;
&lt;h2&gt;实体对象（Entity Objects）和关联对象（Association Objects）&lt;/h2&gt;
&lt;p&gt;BC4J实体对象包含了业务规则（校验、动作等）与数据库表中的一行关联。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 实体也可以基于视图、同义词、快照而定义。&lt;/p&gt;
&lt;p&gt;OA Framework支持Java和PL/SQL实体。&lt;/p&gt;
&lt;p&gt;实体对象：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ess_model_arch_eo" src="/oaf_page/ess_model_arch_eo.gif"/&gt;&lt;/p&gt;
&lt;p&gt;多数实体是oracle.aps.fnd.framework.server.OAEntityImpl的子类（PL/SQL继承于特殊版本的OAEntityImpl）。&lt;/p&gt;
&lt;p&gt;表和实体对象一一对象，所有实体应该包含与之关联的表的所有列。实体对象使用映射了它的属性和数据库列，并自动实现了查询、插入、更新、删除等操作。多数情况下，我们只需要添加校验逻辑。&lt;/p&gt;
&lt;p&gt;实体对象可以用于任何程序（不限于OA Framework）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关联对象Association Objects&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于定义实体间的关系。&lt;/p&gt;
&lt;h2&gt;视图对象（View Objects）和视图链接（View Links）&lt;/h2&gt;
&lt;p&gt;BC4J视图对象处理数据库查询。查询执行后，视图对象提供了访问它的结果集的功能。结果集包含了一个或多个视图行，视图行与数据库查询的行相对应。&lt;/p&gt;
&lt;p&gt;视图对象：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ess_model_arch_vo" src="/oaf_page/ess_model_arch_vo.gif"/&gt;&lt;/p&gt;
&lt;p&gt;所有的视图对象都是oracle.apps.fnd.framework.server.OAViewObjectImpl类的子类。&lt;/p&gt;
&lt;p&gt;视图对象可以配置为使用下面的策略查询数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它的属性映射到简单的SQL语句的列（通常用于小的只读的视图对象）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它的属性映射到实体对象的属性（用于插入、更新和删除实体）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些属性映射到实体对象，一些直接映射到SQL（用于增加实体临时数据，这些数据不能通过实体获得，比如计算值或用于UI显示需要）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在OA Framework应用中，将在下面情况下使用视图对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;呈现用于优化用户界面细节的数据。如果用户界面支持实体的插入、更新、删除，你将通过视图对象执行这些操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为poplists、lists of values和其它UI组件创建简单的查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为业务逻辑创建有效的&amp;ldquo;校验查询（validation queries）&amp;rdquo;。比如，在定单处理时使用一个校验视图对象获得最大可以购买的商品数量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以为视图对象编写代码用于实现复合查询或查询时的数据绑定（以便视图对象知道怎样&amp;ldquo;查询&amp;rdquo;自己）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视图链接View Links&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与实体对象类似，也可以为视图对象建立关联，称为视图链接（view links）。比如可以在定单头视图对象和定单内容间建立视图链接对象。这可以用于在运行时访问定单头时自动查询定单内容。&lt;/p&gt;
&lt;h2&gt;OADBTransaction&lt;/h2&gt;
&lt;p&gt;OADBTransaction：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ess_model_arch_tran" src="/oaf_page/ess_model_arch_tran.gif"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 准备的来说这个图应该要包含实现类oracle.apps.fnd.framework.server.OADBTransactionImpl替代oracle.apps.fnd.framework.OADBTransaction接口。&lt;/p&gt;
&lt;p&gt;如图所示，OADBTransaction扮演的是模型中的中心角色，因为它与一个根应用模块关联，管理JDBC连接/数据库会话，直接拥有你创建的任何实体（根应用模块拥有的视图对象中的行指向实体对象）。可以使用OADBTransaction在模型代码中完成下面的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建一个语句执行PL/SQL函数和存储过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问应用会话级环境信息（session-level Application context information），比如：用户名、id、当前责任（resposibility）等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问一个oracle.apps.fnd.framework.OANLSServices对象，如果你需要执行NLS操作，比如转换服务器时间到用户日期/时间等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过根应用模块访问OADBTransaction。&lt;/p&gt;
&lt;h1&gt;视图&lt;/h1&gt;
&lt;p&gt;视图格式化当前模型数据给用户。&lt;/p&gt;
&lt;h2&gt;定义页面&lt;/h2&gt;
&lt;p&gt;在Oracle Applications开发时，将使用XML页面定义文件。当产品发布后，OA Framework从数据库获取页面定义。&lt;/p&gt;
&lt;p&gt;使用JDeveloper定义的页面（pages）由区域（regions）和条目（items）组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;条目是简单的构件，比如按钮、输入域、图像等，它不包含子构件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区域是容器对象它可以包含条目和其它区域。比如区域包含文件头（headers）、表格和特别的布局组件（layout components）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义的每个区域和条目都有style属性，它告诉OA Framework使用哪个web bean对象来描述它。比如，如果你定义区域的style属性为&amp;ldquo;table&amp;rdquo;，OA Framework将使用oracle.apps.fnd.framework.webui.beans.table.OATableBean。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有页面必须有一个单一的top-level region（通常称为&amp;ldquo;root region&amp;rdquo;）它的style为pageLayout。它将使用oracle.apps.fnd.framework.webui.beans.layout.OAPageLayoutBean。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;regions和items显示在JDeveloper page tree中的顺序告诉了Framework将这些对象添加在什么位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;属性集Attribute Sets&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个region或item通过使用attribute sets可以继承一组属性集合。attribute sets是一个被命名的属性的集合，可重用于任何UI对象，包括：regions，items和其它属性集。当使用attributes set创建UI时，你可以覆盖所继承的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件重用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果需要在页面使用共同对象，可以简单的从它继承。&lt;/p&gt;
&lt;p&gt;比如，可以创建一个通用的region。新建region时，将新region的Extends属性设置为通用region的命名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 共享的通用region在引用它的page中是不可编辑的，属于它的选项目在JDeveloper中将显示为灰色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据源绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于需要与数据库交互的bean，你需要指定数据源，将它绑定到View Instance Name，并关联好View Attribute Name。这个绑定是至关重要的，因为OA Framework使用它获取数据，并将用户输入的数据写入下面的视图对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;View Instance Name指向当前上下文环境中包含应用模块中的视图对象（所有视图对象&amp;ldquo;生活&amp;ldquo;于一个应用模块中，在包含它的容器对象中有一个实例变量名）。比如，如果SuppliersVO视图对象，在页面的根应用模块中有一个实例变量&amp;ldquo;MySupVO&amp;rdquo;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;View Attribute Name指向视图对象中映射到数据库列的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定义菜单&lt;/h2&gt;
&lt;h2&gt;定义页面流&lt;/h2&gt;
&lt;h2&gt;个性化页面&lt;/h2&gt;
&lt;h1&gt;控制器&lt;/h1&gt;
&lt;p&gt;控制器响应用户动作控制应用流转。&lt;/p&gt;
&lt;p&gt;控制器可以与视图中的region级的对象关联（任何实现oracle.apps.fnd.framework.webui.beans.OAWebBeanContainer的OA Framework web bean都可以与控制器关联）。&lt;/p&gt;
&lt;p&gt;控制器是oracle.apps.fnd.framework.webui.OAControllerImpl的子类。&lt;/p&gt;
&lt;p&gt;控制器代码的行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;生成/初始化UI&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中途截取或处理用户事件，比如按钮按下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;请求处理&lt;/h2&gt;
&lt;p&gt;当浏览器向OA.jsp请求一个页面时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.OAPageBean（OA Framework主页面处理类）根据请求的页面名称检查需要哪个根应用模块，并从应用模块池（application module pool）中取出。这个应用模块将为页面从JDBC连接池中获取连接和事务上下文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户会话校验；如果无效，将显示登录页面（这里是简化的说法，具体细节在Developer's Guid中有说明）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果用户有效，OAPageBean根据请求参数处理HTTP POST或GET。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;处理GET请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当浏览器发起GET请求一个page时（或你手工forward时），OA Framework使用描述的UI定义构建web bean层级结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;OAPageBean调用页面的top-level pageLayout bean的processRequest()方法，然后进入web bean层级结构中继续递归调用来初始化web beans（包括任何相关的模型组件）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个web bean可以有自己的控制器，如果有就调用控制器的processRequest(OAPageContext pageContext, OAWebBean webBean)方法。这个方法可以用于构件或修改页面布局，设置web bean属性和执行任何手工的数据初始化工作（比如，打开页面时自动执行查询）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些复杂的web beans（比如：oracle.apps.fnd.framework.webui.beans.table.OATableBean和oracle.apps.fnd.framework.webui.beans.layout.OAPageLayoutBean）通过调用它们的prepareForRendering()（这个方法在JavaDoc中的说明）方法执行post-controller处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个web bean调用它的子对象的processRequest()方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.OAPageBean将web bean结构传递给UIX渲染并发送给浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;处理POST请求&lt;/p&gt;
&lt;p&gt;当浏览器向服务器页面发出POST请求时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;OAPageBean检查web bean层级结构是否在内存中。如果没有它就像在GET请求中一样创建一个web bean层级结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAPageBean调用整个层级结构中的web bean的processFormData(OAPageContext pageContext, OAWebBean webBean)方法，并将form中的数据写入模型（它在pageLayout region上调用processFormData()，然后在它的子对象上递归的调用processFormData()方法）。将form数据写入模型时将自动调用属性和实体级别（attribute and entity-level validations）的校验，如果抛出了任何校验异常，处理将停止，错误信息将显示给用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在执行processFormData()期间没有异常抛出，OAPageBean将使用与上面相同的方法在层级结构中的所有web bean上调用processFormRequest(OAPageContext pageContext, OAWebBean webBean)方法。这里给了你的控制器响应用户动作的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有JSP forward或redirect发出，或在执行processFormRequest()方法时没有异常被抛出。则页面刷新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;OAPageContext&lt;/h2&gt;
&lt;p&gt;当OA Framework收到一个OA.jsp请求时，OAPageBean创建一个oracle.apps.fnd.framework.webui.OAPageContext，这个类仅在页面处理过程中存在。上面描述的三个方法（processRequest()，processFormData()，processFormRequest()）都有一个OAPageContext参数，任何将要编写的控制器代码都使用了这个至关重要的类。&lt;/p&gt;
&lt;p&gt;&lt;img alt="pagecontext_arch" src="/oaf_page/pagecontext_arch.gif"/&gt;&lt;/p&gt;
&lt;p&gt;如上图所描述的，OAPageContext有指向request和根应用模块的引用。根据这个关系，OAPageContext被传递到每个控制器的响应处理方法中，你将看到如何在下面的通用任务中使用OAPageContext：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问请求参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用getParameter(String name)方法读取请求参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;页面上的每个web bean（buttons，fields等等）传递给getParameter()的是你定义在页面上的唯一ID属性。比如，使用下面的代码可以得到用户是否按下了名为&amp;ldquo;GoButton&amp;rdquo;的按钮：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"GoButton"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// The user pressed the "Go" button, do something...&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;访问根应用模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OAPageContext缓存了根应用模块的引用，它可以访问视图对象和事务。如果需要访问应用模块，可以通过OAPageContext：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAApplicationModule&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRootApplicationModule&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;发出导航指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用方法告诉OA Framework执行JSP forward或客户端重定向。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"CreateButton"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// The user pressed the "Create Supplier" button, now perform a JSP forward to&lt;/span&gt;
    &lt;span class="c1"&gt;// the "Create Supplier" page.&lt;/span&gt;

    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setForwardURL&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OA.jsp?page=/oracle/apps/dem/employee/webui/EmpDetailsPG"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                               &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;                               &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;KEEP_MENU_CONTEXT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;                                                           &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;                                                           &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;                                                           &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Retain AM                                                      OAWebBeanConstants.ADD_BREAD_CRUMB_YES, // Show breadcrumbs                                                     OAWebBeanConstants.IGNORE_MESSAGES);&lt;/span&gt;

  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;访问应用上下文信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与模型中的OADBTransaction类似，OAPageContext可以访问servlet session级的Oracle Application上下文信息，如：用户名，ID，当前职责等。比如，下面的片段用于获取用户名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getUserName&lt;/span&gt;&lt;span class="o"&gt;();}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Web Bean架构&lt;/h1&gt;
&lt;p&gt;所有OA Framework web beans都与UIX framework中的bean对应。比如，OATableBean继承自oracle.cabo.ui.beans.table.TableBean（&amp;ldquo;cabo"是UIX framework早期的名字，包定义仍然使用了旧名）。&lt;/p&gt;
&lt;p&gt;每个OA Framework web bean都实现了一组接口，这些接口实现了OA Framework添加到基础的UIX beans上的行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.beans.OAWebBean定义了所有web beans的通用行为（比如，其中在这里定义的关键的行为有processRequest，processFormData，processFormRequest方法，一些beans自己实现了这些方法）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.OAWebBeanConstants用于视图和控制器的常量集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.beans.OAWebBeanData定义通用的个性化定义和数据源管理行为&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.beans.OAWebBeanContainer定义所有可以作为其它web beans容器的web beans的特性。比如，所有layout web beans都实现了这个接口。只有实现了这个接口的beans才可以与控制器关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAWebBean&lt;type&gt;定义了bean在OA Framework上下文环境中的内在特性。比如，OATableBean实现的oracle.apps.fnd.framework.webui.beans.OAWebBeanTable接口。&lt;/type&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;web bean例子（OATableBean）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="bean_arch" src="/oaf_page/bean_arch.gif"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内部Bean结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个web bean自己包含了下列的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;_indexedChildren子web beans&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;_namedChildren子web beans特殊行为的UIX标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;_attributes web bean的特性（属性描述），下表的图表描述&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;描述web bean使用Dictionary保存键值对属性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="bean_internals_attr" src="/oaf_page/bean_internals_attr.gif"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据绑定值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与上面的图表描述的情况不同，OA Framework web bean的attributes实际上是用数据绑定值实现的，这意味着它是由下层的数据源提供的，在组件被渲染时才被获取。后面将看到如何定义用户自定义绑定值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在页面渲染时，UIX framework处理web bean层级对象产生页面的HTML代码。&lt;/p&gt;
&lt;p&gt;对于每个web bean属性，UIX调用它的getAttributeValue()方法。并传递给它一个渲染上下文（rendering context），rendering context是UIX决定绑定值的全部基础。对于给出的属性，比如，rendering context知道下层的视图对象实例，视图属性和当前的行。数据绑定使用rendering context通过查询它的数据源所提供的返回值传递给UIX以产正确的HTML。&lt;/p&gt;
&lt;h1&gt;OA Framework Javadoc手册&lt;/h1&gt;
&lt;p&gt;每个OA Framework包的描述：&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework&lt;/h2&gt;
&lt;p&gt;包含的类和接口可以安全的从模型（server）和用户界面控制器或视图（client）访问。比如，需要在页面中访问根应用模块，应该使用oracle.apps.fnd.framework.OAApplicationModule接口（不应该在客户端访问它的实现）。&lt;/p&gt;
&lt;p&gt;这个包也包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有OA Framework异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OANLSServices类用于执行国际化操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;oracle.apps.fnd.framework.server&lt;/h2&gt;
&lt;p&gt;包含了OA Framework Model-View-Controller中用于实现model的类和接口。&lt;/p&gt;
&lt;p&gt;这些类规定用于任何客户端用户界面（不仅仅是OA Framework HTML pages）[译注：根据后面的意思，这里似乎应该是不能用于！]，并且不允许被任何oracle.apps.fnd.framework.webui包和其子包中的类和接口引用，也不允许应用中的webui包和其子包引用。&lt;/p&gt;
&lt;p&gt;当建造OA Framework应用模型时，应该使用这个包中的类替代BC4J中继承的类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要从控制器或视图代码中调用这个包中的类。&lt;/p&gt;
&lt;h2&gt;oracle.app.fnd.framework.webui&lt;/h2&gt;
&lt;p&gt;包括了构造OA Framework HTML用户界面的核心类。&lt;/p&gt;
&lt;p&gt;一些这个包中最常用的类和接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OAController&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAPageContext&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何下面所描述的beans子包中的类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要从模型代码中调用这个包中的类。&lt;/p&gt;
&lt;h2&gt;oracle.app.fnd.framework.webui.beans&lt;/h2&gt;
&lt;p&gt;包含用于用户界面组件的web bean。你将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;这个包和其子包中的类与UIX组件对应，它们继承关系如下。当构造OA Framework应用页面时，应该使用OA Framework类，除非你要使用一个已经介绍给UIX的新的功能，但目前这还不被支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework类是在JDeveloper中描述的MDS页面中使用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;UIX Package&lt;/th&gt;
&lt;th align="left"&gt;OA Package&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cable.ui.beans&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cable.ui.beans.form&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.form&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cabo.ui.beans.include&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.include&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cabo.ui.beans.layout&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.layout&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cabo.ui.beans.message&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.message&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cabo.ui.beans.nav&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.nav&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cabo.ui.beans.table&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.table&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.beans.form&lt;/h2&gt;
&lt;p&gt;包含了HTML form组件相关的web bean类。包括了提交按钮和各种数据入口／特定的控件（checkbox,radio,group,shuttle,text input field等）。可以在编写用户界面控制器时使用这些类，需要用编程的方式处理web beans。&lt;/p&gt;
&lt;p&gt;与这个包中其它的web beans不同的是oracle.apps.fnd.framework.webui.beans.message包（message web beans可以显示错误，信息，带警告图标的说明信息）。当在JDeveloper中创建页面时，OA Framework为同一个包中的这些组件自动显示消息。应该只在下面的情况下使用这个包中的这个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类没有message bean供选择。（比如，这个包中唯一的类OASubmitButtonBean）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能使用message bean替换的时候。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.bean.include&lt;/h2&gt;
&lt;p&gt;包含了用于将外部资源（servlet,JSP,HTML）中包含到用户界面的web bean类。将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.beans.layout&lt;/h2&gt;
&lt;p&gt;包含了OA Framework程序中页面布局的web bean类，包括特殊的layout组件，比如，hide/show，content container，bulleted lists，headers，standardized templates等等。将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.beans.message&lt;/h2&gt;
&lt;p&gt;包含了HTMl form数据相关组件具有显示相关错误，警告信息或带信息图标的说明性消息的web bean类（比如，如果用户在文本框中输入了错误的值，下次渲染这个页面时，这个文本框前将显示一个表示出错的图标）。将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;这个包中的许多web bean也包含在oracle.apps.fnd.framework.webui.bean.form包中，没有显示额外的消息文本和图标文本的能力。当在JDeveloper中创建页面时，OA Framework自动将message bean添加这两个包中的组件。应该只在不能使用包含message bean的页面上使用不带消息显示能力的类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.bean.nav&lt;/h2&gt;
&lt;p&gt;包含了用户界面导航的组件（links,trees,menu elements,quick links,breadcrumbs等）。将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.beans.table&lt;/h2&gt;
&lt;p&gt;包含显示table和HGrid组件的web bean类。将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.laf&lt;/h2&gt;
&lt;p&gt;包含用于控制HTML渲染特性，包括页面观感和上下文细节（比如，内容能为打印效果而优化显示在浏览器中或用于e-mail）的工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>SOA Suite培训</title><link href="/soa-suitepei-xun.html" rel="alternate"></link><published>2010-07-13T00:00:00+08:00</published><updated>2010-07-13T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-07-13:/soa-suitepei-xun.html</id><summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;配置EBS启用SOA Suite&lt;/li&gt;
&lt;li&gt;Native interface开放为WebService接口&lt;/li&gt;
&lt;li&gt;通过ISG调用外部系统提供的WebService&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;EBS的配置&lt;/h1&gt;
&lt;p&gt;Native Service Enablement Of EBS&lt;/p&gt;
&lt;p&gt;参考Metalink Note:556540.1&lt;/p&gt;
&lt;h1&gt;ISG的设置&lt;/h1&gt;
&lt;h1&gt;Native Interface开放为WebService&lt;/h1&gt;
&lt;h2&gt;开放系统标准接口为WebService&lt;/h2&gt;
&lt;p&gt;通过&amp;ldquo;集成SOA网关&amp;rdquo;这个职责为标准接口授权、生成WSDL、部署或卸载WebService&lt;/p&gt;
&lt;h2&gt;开放自己开发的接口为WebService&lt;/h2&gt;
&lt;p&gt;通过Perl工具程序将自己的接口注册到Repository里&lt;/p&gt;
&lt;h2&gt;外部系统异步调用EBS发布的WebService&lt;/h2&gt;
&lt;h1&gt;ISG调用外部的WebService&lt;/h1&gt;
&lt;p&gt;不支持RPC格式的SOAP消息，只支持Document格式的。&lt;/p&gt;
&lt;h2&gt;Business Event驱动对外部系统WebService的调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Create/Use Invoker Event&lt;/li&gt;
&lt;li&gt;选Workflow Administrator WebApplications职责&lt;/li&gt;
&lt;li&gt;点击&amp;ldquo;Business Events&amp;rdquo;&lt;/li&gt;
&lt;li&gt;点击&amp;ldquo;Create Event&amp;rdquo;&lt;/li&gt;
&lt;li&gt;填写Name，Display Name和Description选择状态为&amp;ldquo;Enabled …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;配置EBS启用SOA Suite&lt;/li&gt;
&lt;li&gt;Native interface开放为WebService接口&lt;/li&gt;
&lt;li&gt;通过ISG调用外部系统提供的WebService&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;EBS的配置&lt;/h1&gt;
&lt;p&gt;Native Service Enablement Of EBS&lt;/p&gt;
&lt;p&gt;参考Metalink Note:556540.1&lt;/p&gt;
&lt;h1&gt;ISG的设置&lt;/h1&gt;
&lt;h1&gt;Native Interface开放为WebService&lt;/h1&gt;
&lt;h2&gt;开放系统标准接口为WebService&lt;/h2&gt;
&lt;p&gt;通过&amp;ldquo;集成SOA网关&amp;rdquo;这个职责为标准接口授权、生成WSDL、部署或卸载WebService&lt;/p&gt;
&lt;h2&gt;开放自己开发的接口为WebService&lt;/h2&gt;
&lt;p&gt;通过Perl工具程序将自己的接口注册到Repository里&lt;/p&gt;
&lt;h2&gt;外部系统异步调用EBS发布的WebService&lt;/h2&gt;
&lt;h1&gt;ISG调用外部的WebService&lt;/h1&gt;
&lt;p&gt;不支持RPC格式的SOAP消息，只支持Document格式的。&lt;/p&gt;
&lt;h2&gt;Business Event驱动对外部系统WebService的调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Create/Use Invoker Event&lt;/li&gt;
&lt;li&gt;选Workflow Administrator WebApplications职责&lt;/li&gt;
&lt;li&gt;点击&amp;ldquo;Business Events&amp;rdquo;&lt;/li&gt;
&lt;li&gt;点击&amp;ldquo;Create Event&amp;rdquo;&lt;/li&gt;
&lt;li&gt;填写Name，Display Name和Description选择状态为&amp;ldquo;Enabled&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输入Owner Name和Tag（通常都填FND/FND）&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击&amp;ldquo;Apply&amp;rdquo;保存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Native Service Invocation Process&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Search Invoker Business Event.&lt;/li&gt;
&lt;li&gt;Select to view its subscriptions&lt;/li&gt;
&lt;li&gt;Click "Create Subscription"&lt;/li&gt;
&lt;li&gt;Enter local Subscriber System,Phase(&amp;lt;100 for synchronous response).&lt;/li&gt;
&lt;li&gt;Select Rule Data as "Message".&lt;/li&gt;
&lt;li&gt;Select Action Type "Invoke Web Service".&lt;/li&gt;
&lt;li&gt;Click "Next".&lt;/li&gt;
&lt;li&gt;Follow wizard based WSDL parser UI:&lt;/li&gt;
&lt;li&gt;Enter WSDL URL and click "Next".&lt;/li&gt;
&lt;li&gt;Select Service and click "Next".&lt;/li&gt;
&lt;li&gt;Select Service Port and click "Next".&lt;/li&gt;
&lt;li&gt;Select Service Operation and click "Next".&lt;/li&gt;
&lt;li&gt;Use seeded Java Rule Function - oracle.apps.fnd.wf.bes.WebServiceInvokerSubscription or custom extended class.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Optionally enter WS Security parameters:WFBES_SOAP_USERNAME,WEBES_SOAP_PASSWORD_MOD,WEBES_SOAP_PASSWORD_KEY as &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create Receive Event&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;navigate to "Events" tab in Workflow &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自定义的Business Event驱动对外部系统的WebService的调用&lt;/h2&gt;
&lt;h2&gt;直接调用外部的WebService&lt;/h2&gt;
&lt;h2&gt;异步调用外部的WebService&lt;/h2&gt;
&lt;p&gt;由Create Subscription时的Phase决定，大于100时为异步调用&lt;/p&gt;
&lt;h1&gt;问题&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何开放自己开发的接口为WebService&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与其它系统集成时如何解决人员、权限、登录等方面的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有BPEL的情况下（不能通过接口表和多次WebService调用处理）如何处理大数据量的问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过接口表的方式，多次调用方法写入数据到接口表，再调用其它方法进行验证，然后再调用方法提交请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SOAP头的问题，如何在SOAP头设置相关的用户、职责等信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AQ自动触发对外部系统WebService的调用，还是需要轮询AQ&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异步调用时需要运行工作流background engine 的请求&lt;/p&gt;
&lt;p&gt;测试WebService
http://www.ignyte.com/webservices/ignyte.whatsshowing.webservice/moviefunctions.asmx?wsdl
参数 88052 18&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category></entry><entry><title>Better Builds With Maven 学习笔记</title><link href="/better-builds-with-maven-xue-xi-bi-ji.html" rel="alternate"></link><published>2009-09-21T00:00:00+08:00</published><updated>2009-09-21T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2009-09-21:/better-builds-with-maven-xue-xi-bi-ji.html</id><summary type="html">&lt;h1&gt;开始&lt;/h1&gt;
&lt;h2&gt;准备使用Maven&lt;/h2&gt;
&lt;p&gt;Maven默认读取&lt;user_home&gt;/.m2/settings.xml，通过proxy段的配置设置代理信息。通过mirror段设置镜像服务器。这两个配置在M2_HOME/conf/settings.xml中都有范例。将M2_HOME/bin添加到环境变量。运行&lt;/user_home&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn -version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看使用的Maven版本信息。&lt;/p&gt;
&lt;h3 id="zhao-dao-de-xiang-guan-zi-liao"&gt;找到的相关资料&lt;/h3&gt;
&lt;p&gt;配置环境变量M2_HOME为Maven2的安装目录，这样即使是在使用maven-ant-tasks时也读取M2_HOME/conf/settings.xml。&lt;/p&gt;
&lt;p&gt;在mirrors段添加镜像配置，当前比较快的国内镜像是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;mirror&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;redv.com&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://mirrors.redv.com/maven2&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;mirrorOf&amp;gt;&lt;/span&gt;central&lt;span class="nt"&gt;&amp;lt;/mirrorOf&amp;gt;&lt;/span&gt;
      &lt;span class="c"&gt;&amp;lt;!-- Shanghai, China --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/mirror&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建第一个Maven工程&lt;/h2&gt;
&lt;p&gt;使用Maven的&lt;code&gt;Archetype&lt;/code&gt;机制创建第一个工程。Archetype被定义为原始的模式或模型，从它可以生成同一类型的东西 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;开始&lt;/h1&gt;
&lt;h2&gt;准备使用Maven&lt;/h2&gt;
&lt;p&gt;Maven默认读取&lt;user_home&gt;/.m2/settings.xml，通过proxy段的配置设置代理信息。通过mirror段设置镜像服务器。这两个配置在M2_HOME/conf/settings.xml中都有范例。将M2_HOME/bin添加到环境变量。运行&lt;/user_home&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn -version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看使用的Maven版本信息。&lt;/p&gt;
&lt;h3 id="zhao-dao-de-xiang-guan-zi-liao"&gt;找到的相关资料&lt;/h3&gt;
&lt;p&gt;配置环境变量M2_HOME为Maven2的安装目录，这样即使是在使用maven-ant-tasks时也读取M2_HOME/conf/settings.xml。&lt;/p&gt;
&lt;p&gt;在mirrors段添加镜像配置，当前比较快的国内镜像是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;mirror&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;redv.com&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://mirrors.redv.com/maven2&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;mirrorOf&amp;gt;&lt;/span&gt;central&lt;span class="nt"&gt;&amp;lt;/mirrorOf&amp;gt;&lt;/span&gt;
      &lt;span class="c"&gt;&amp;lt;!-- Shanghai, China --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/mirror&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建第一个Maven工程&lt;/h2&gt;
&lt;p&gt;使用Maven的&lt;code&gt;Archetype&lt;/code&gt;机制创建第一个工程。Archetype被定义为原始的模式或模型，从它可以生成同一类型的东西。在Maven中，Archetype是工程的模板，它与用户输入的一些信息组合起来生成一个全功能的Maven工程。&lt;/p&gt;
&lt;p&gt;创建工程&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn archetype:create -DgroupId=com.mycompany.app -DartifactId=my-app
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将创建一个my-app目录，目录中包含了一个pom.xml文件，它的内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;"http://maven.apache.org/POM/4.0.0"&lt;/span&gt; &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;"http://www.w3.org/2001/XMLSchema-instance"&lt;/span&gt;
  &lt;span class="na"&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class="s"&gt;"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.mycompany.app&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mvn-app&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;mvn-app&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.8.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;src目录包含了构建、测试、创建文档、部署工程所需的输入信息。&lt;/p&gt;
&lt;h2&gt;编译应用程序源码&lt;/h2&gt;
&lt;p&gt;进入&lt;my-app&gt;目录，执行：&lt;/my-app&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn compile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将编译源码。Maven遵循&amp;ldquo;约定优于配置&amp;rdquo;的原则，这是Maven的第一个原则。默认情况下，源码放在src/main/java中。这个默认值并不会出现在POM文件中，实际上，它是从父级（根级）POM继承过来的。编译后的classes保存目录也是同样的方式处理的，默认它放在target/classes目录下。&lt;/p&gt;
&lt;p&gt;是什么编译了应用程序源码？这是Maven的第二个原则&amp;ldquo;重用构建逻辑&amp;rdquo;。默认配置中配置了标准编译插件，它用于编译应用程序源码。同样的编译逻辑可以重用于其它的工程中。&lt;/p&gt;
&lt;p&gt;上面了解了Maven如何找到应用程序源码，Maven怎样来编译应用源码，怎样调用编译插件。接下来的问题是，Maven如何能获取编译器插件？在Maven的标准安装中，找不到编译插件，因为它不是与Maven发布版一起发布的。Maven将在需要插件时自动下载插件。&lt;/p&gt;
&lt;p&gt;当第一次执行编译命令（或其它任何命令），Mave将下载这个命令需要的插件及其依赖的其它插件。下次再执行同样的命令时，Maven将不再下载它，命令执行将快很多。&lt;/p&gt;
&lt;h2&gt;编译测试源码执行单元测试&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将进行单元测试。这时Maven将下载更多需要的插件。在执行单元测试前，Maven将编译主代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn test-compile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译测试代码。但是当执行mvn test时总是会先执行compile和test-compile。&lt;/p&gt;
&lt;h2&gt;打包并安装到本地仓库&lt;/h2&gt;
&lt;p&gt;生成jar包执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn package
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看工程的POM文件可以看到packaging元素被设置为jar。Maven通过这个设置了解到需要生成一个JAR文件。&lt;/p&gt;
&lt;p&gt;安装到本地仓库&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以通过修改settings.xml的localRepository设置仓库的位置。&lt;/p&gt;
&lt;p&gt;注意：Surefire插件（它执行test）将按特定的命名约定查看测试代码。默认情况下，下面的测试将被包含：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;**/*Test.java
**/Test*.java
**/*TestCase.java
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的将不被包含：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;**Abstract*Test.java
**/Abstract*TestCase.java
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Maven的重用构建逻辑使得即使是使用默认的POM文件也可以执行大量基础构建操作，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn site
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以为工程生成一个简单网站。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn clean
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将清除target目录下旧的构建数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn idea:idea
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以产生一个IDEA工程。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn eclipse:eclipse
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成一个eclipse工程。&lt;/p&gt;
&lt;h2&gt;处理Classpath资源&lt;/h2&gt;
&lt;p&gt;src/main/resources是Maven推荐的保存资源文件的目录。可以将需要打包到JAR文件的资源放到这个目录。Maven使用的规则是所有放在src/main/resources目录下的文件和目录都将打包到JAR中。&lt;/p&gt;
&lt;p&gt;默认生成的JAR文件中包含了META-INF目录。在这个目录下可以找到MANIFEST.MF和pom.xml和pom.properties。你可以创建自己的mainfest文件，如果不创建Maven将自动生成一个。也可以包含自己的资源文件，例如在src/main/resources目录下添加一个application.properties文件，重新打包则资源文件也将也现在JAR包中。&lt;/p&gt;
&lt;p&gt;pom.xml和pom.properties文件被打包到JAR以便由Maven的每个artifact生成的JAR包都是自描述的，并且允许你包含自己的应用中的原数据。最简单的应用可能就是用于获取应用的版本号。操作POM文件需要使用Maven的工具，但是propertiest文件却可以使用标准Java API。&lt;/p&gt;
&lt;h3 id="chu-li-ce-shi-yong-classpathde-zi-yuan"&gt;处理测试用Classpath的资源&lt;/h3&gt;
&lt;p&gt;添加资源到单元测试classpath，可以将资源添加到src/test/resources目录。在单元测试中，使用下面的代码片段在测试阶段访问资源：
&lt;src lang="java"&gt;
// Retrieve resource
InputStream is = getClass().getResourceAsStream( "/test.properties" );
// Do something with the resource
&lt;/src&gt;&lt;/p&gt;
&lt;p&gt;可以使用下面的配置覆盖maven-jar-plugin的默认配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-jar-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;archive&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;manifestFile&amp;gt;&lt;/span&gt;META-INF/MANIFEST.MF&lt;span class="nt"&gt;&amp;lt;/manifestFile&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/archive&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="guo-lu-classpathzi-yuan"&gt;过滤Classpath资源&lt;/h3&gt;
&lt;p&gt;有时资源文件中包含的一些值在构建时才能提供。Maven中可以使用资源过滤，动态的将资源属性值设置到资源文件中。将资源文件中的属性值设置为${&lt;property name=""&gt;}，这个属性可以是pom.xml或用户的settings.xml中定义的属性，或定义在外部properties文件，或都是系统属性。&lt;/property&gt;&lt;/p&gt;
&lt;p&gt;需要将pom.xml中将需要进行过滤处理的资源目录的filtering属性设置为true。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.mycompany.app&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;my-app&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Maven Quick Start Archetype&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.8.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;resources&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filtering&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/filtering&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/resources&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用资源过滤的举例：创建src/main/resources/META-INF/application.properties，内容设置为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# application.properties
application.name=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
application.version=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn process-resources
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;target/classes目录下的application.properties文件内容将变为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# application.properties
application.name=Maven Quick Start Archetype
application.version=1.0-SNAPSHOT
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要引用外部propertiest文件中的属性值，需要在pom.xml中添加对外部文件的引用。例如，创建一个外部资源文件src/main/filters/filter.properties：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# filter.properties
my.filter.value=hello!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将对它的引用添加到pom.xml中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;filters&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;filter&amp;gt;&lt;/span&gt;src/main/filters/filter.properties&lt;span class="nt"&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/filters&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;resources&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;filtering&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/filtering&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/resources&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在application.propertiest文件中引用对应的属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# application.properties
application.name=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
application.version=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
message=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行mvn process-resources命令时会将message替换为外部文件中my.filter.value属性对应的值。&lt;/p&gt;
&lt;p&gt;也可以在pom文件的properties段定义这些属性值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.mycompany.app&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;my-app&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Maven Quick Start Archetype&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.8.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;resources&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filtering&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/filtering&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/resources&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;my.filter.value&amp;gt;&lt;/span&gt;hello&lt;span class="nt"&gt;&amp;lt;/my.filter.value&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;资源过滤也可以获取系统属性，也可以是编译到Java中的（java.version或user.home），或使用Java -D参数在命令行指定的属性。例如将application.propertiest文件设置为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# application.properties
java.version=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
command.line.prop=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prop&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后执行下面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn process-resources "-Dcommand.line.prop=hello again"
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="fang-zhi-guo-lu-er-jin-zhi-zi-yuan"&gt;防止过滤二进制资源&lt;/h3&gt;
&lt;p&gt;某些情况下我们不希望属性过滤处理某些资源文件。比如图像文件。&lt;/p&gt;
&lt;p&gt;比如src/main/resources/images不希望被过滤，这时应该排除这些资源。pom.xml设置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;resources&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filtering&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/filtering&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;excludes&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;exclude&amp;gt;&lt;/span&gt;images/**&lt;span class="nt"&gt;&amp;lt;/exclude&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/excludes&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;includes&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;include&amp;gt;&lt;/span&gt;images/**&lt;span class="nt"&gt;&amp;lt;/include&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/includes&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/resources&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;使用Maven插件&lt;/h2&gt;
&lt;p&gt;配置Maven插件的参数。&lt;/p&gt;
&lt;p&gt;例如，指定Java编译器只允许编译JDK 5.0的源码。可以在POM中添加设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;source&amp;gt;&lt;/span&gt;1.5&lt;span class="nt"&gt;&amp;lt;/source&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;target&amp;gt;&lt;/span&gt;1.5&lt;span class="nt"&gt;&amp;lt;/target&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Maven 2的插件和工程的依赖很相似，在某种程度上它们确实如此。如果在本地找不到插件，则将自动下载插件，这更是与依赖关系的处理相同。插件与依赖同相样有groupId和version元素，但多数情况下这些元素不需要。&lt;/p&gt;
&lt;p&gt;如果不指定groupId，则Maven将搜索org.apache.maven.plugins或org.codehause.mojo这两个groupId。你也可以在POM或settings.xml中指定goupId。&lt;/p&gt;
&lt;p&gt;如果不指定版本Maven将尝试获取指定插件的最新版本。&lt;/p&gt;
&lt;p&gt;通过mvn help:describe命令可以找到插件可选配置项。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn help:describe -DgroupId=org.apache.maven.plugins \
 -DartifactId=maven-compiler-plugin -Dfull=true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以在 http://maven.apache.org/plugins/ 使用Maven Plugin Reference找到相关插件的配置信息。&lt;/p&gt;
&lt;h1&gt;使用Maven创建应用&lt;/h1&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;将要创建的应用名叫Proficio，拉丁语的"help"。&lt;/p&gt;
&lt;h2&gt;设置应用程序的目录结构&lt;/h2&gt;
&lt;p&gt;在设置Proficio的目录结构时，注意Maven强调的实践标准化和构建模块化构建是很重要的。&lt;/p&gt;
&lt;p&gt;这种实践自然将产生分离的可重用的开发工程。决定如何最优化的分解应用的原则叫做&amp;ldquo;分离关注点（Separation of Concerns）&amp;rdquo;原则，即SoC原则。&lt;/p&gt;
&lt;p&gt;SoC有助于识别、封装、操作于有相关特殊概念、目标、任务或目的的软件片段。关注点是组织和分解软件的动力，更多的易于管理和理解的部分，每个都用于说明一个或多个特定关注点。&lt;/p&gt;
&lt;p&gt;如上所述，Proficio样例工程将被设置为多个Maven模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Proficio API：Proficio的应用编程接口，它包含了一套接口。这些接口是主要组件（例如store）的API。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proficio CLI：提供Proficio的命令行接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proficio Core：API的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proficio Model：Proficio应用的数据模型，它包含了将被整个Proficio工程所使用的所有的类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proficio Stores：这个模块处理包含所有的存储模块。Proficio有一个简单的memory-based和XStream-based存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Proficio的顶层POM中，可以看到所有子模块元素。一个模块指向另一个Maven工程，实际上它是指向另一个POM。Proficio的顶层POM文件如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;pom&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Maven Proficio&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;modules&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;proficio-model&lt;span class="nt"&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;proficio-api&lt;span class="nt"&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;proficio-core&lt;span class="nt"&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;proficio-stores&lt;span class="nt"&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;proficio-cli&lt;span class="nt"&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/modules&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的版本号1.0-SNAPSHOT。对于一个有多模块的应用，通常将所有模块一起发布，所有模块使用一个公共的版本号。这是推荐的一种方式。&lt;/p&gt;
&lt;p&gt;注意上面的packaging元素，这里它被设置为pom。对于包含模块的POM文件，packaging必须设置为pom：这告诉Maven你准备创建一个模块集。&lt;/p&gt;
&lt;p&gt;Proficio应用的模块打包类型：
模块 || 打包类型
proficio-api | jar
proficio-cli | jar
proficio-core | jar
proficio-module | jar
proficio-stores | pom&lt;/p&gt;
&lt;p&gt;proficio-stores模块有两个子模块。&lt;/p&gt;
&lt;h2&gt;使用工程继承&lt;/h2&gt;
&lt;p&gt;Maven最重要的功能之一就是工程继承。使用工程继承允许你在一个地方规定组织机构信息，规定部署信息，或规定通用的依赖。由Proficio工程产生的每个工程的POM文件，每个的顶部都有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[...]&lt;/span&gt;
&lt;span class="na"&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;
  &lt;span class="na"&gt;&amp;lt;groupId&amp;gt;com.devzuz.mvnbook.proficio&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="na"&gt;&amp;lt;artifactId&amp;gt;proficio&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="na"&gt;&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class="na"&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个片段允许你从指定的顶层的POM继承。顶层POM中指定了依赖JUnit 3.8.1。在这种情况下子工程中不再申明这个依赖也可以使用这个包。&lt;/p&gt;
&lt;p&gt;为了了解在继承处理时发生的东西可以执行mvn help:effective-pom命令。这个命令将显示出最终的POM。在proficio的子工程中执行这个命令时可以看到依赖中出现了JUnit 3.8.1。&lt;/p&gt;
&lt;h2&gt;管理依赖关系&lt;/h2&gt;
&lt;p&gt;Maven可以让不同的工程共享程序包。&lt;/p&gt;
&lt;p&gt;可以在顶层的POM中描述所有子工程共享的依赖。&lt;/p&gt;
&lt;p&gt;例如Proficio的顶层POM：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-model&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-api&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-store-memory&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-store-xstream&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-core&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-container-default&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-9&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意${project.version}指定了版本，它与应用的版本对应。&lt;/p&gt;
&lt;p&gt;在dependencyManagement一节，有多个Proficio依赖并且还依赖于Plexus IoC container。dependencyManagment元素与顶层POM的dependencies有重要区别。&lt;/p&gt;
&lt;p&gt;dependencyManagement元素中包括的dependencies元素仅用于说明引用的版本号，对并不影响工程的依赖关系图，然而顶层的dependencies元素将影响依赖关系图。查看proficio-api模块的POM将只看到引用而没有指定版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-model&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个依赖的版本号是从Proficio的顶层POM文件的dependencyManagement继承过来的。dependencyManagement指定了引用proficio-model的版本号为1.0-SNAPSHOT（被设置为${project.version}）这个版本号将注入到上面的依赖中。dependencyManagement中说明的dependencies只用于当某个依赖没有版本号的情况。&lt;/p&gt;
&lt;h2&gt;使用快照&lt;/h2&gt;
&lt;p&gt;当开发的应用具有多个模块时，通常每个模块的版本都在变更。API可能正在经历变迁或你的实现正在发生改变，或者在进行重构。你在构建时需要非常容易的实时获取最新版本，这是Maven的快照（snapshot）的概念。快照是Maven的一个artifact。查看Proficio的顶层POM可以看到指定了快照版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-model&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-api&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-container-default&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-9&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;指定快照版本作为依赖时Maven将会查找新版本而不像手工指定版本时那样操作。快照依赖假定总是在变更，因此Maven将尝试更新它们。默认情况下Maven将以天为单位查找新版本，但你可以使用命令行参数-U来强制它查找新版本。当指定非快照的依赖时Maven将下载依赖并且不会进行重试。
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;解决依赖冲突和使用版本号范围&lt;/h2&gt;
&lt;p&gt;在Maven 2.0中通过引入依赖传递，使得可以在简单的POM文件中只指定你直接需要的依赖，并且Maven可以计算出完整的依赖关系图。但是，随着图的增涨，不可避免的将产生一个或多个artifacts需要依赖的不同版本。这种情况下，Maven必须选择使用哪个版本。&lt;/p&gt;
&lt;p&gt;Maven通常选择这个关系树中顶层的&amp;ldquo;最接近的版本（nearest）&amp;rdquo;，Maven选择版本号跨度最小的版本。如果在POM中指定了版本，则将被使用而不管其它的原因。但这种方式也有下面的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;选择的版本可能没有某个依赖的组件所需要的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在相同的级别先择了多个不同的版本，则结果将是不明确的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;手工解决冲突，可以从依赖树中移除不正确的版本，或者可以用正确的版本来覆盖掉树中的版本。移除不正确的版本需要在运行Maven时指定-X标识来找出不正确的版本。例如，如果在proficio-core模块运行mvn -X test将输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;proficio-core&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;0-SNAPSHOT&lt;/span&gt;
  &lt;span class="nt"&gt;junit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;1&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;test&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="nt"&gt;plexus-container-default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;0-alpha-9&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nt"&gt;plexus-utils&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;4&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nt"&gt;classworlds&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;1-alpha-2&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nt"&gt;junit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;1&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;not&lt;/span&gt; &lt;span class="nt"&gt;setting&lt;/span&gt; &lt;span class="nt"&gt;scope&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;local&lt;/span&gt; &lt;span class="nt"&gt;scope&lt;/span&gt; &lt;span class="nt"&gt;test&lt;/span&gt; &lt;span class="nt"&gt;wins&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="nt"&gt;proficio-api&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;0-SNAPSHOT&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nt"&gt;proficio-model&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;0-SNAPSHOT&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nt"&gt;plexus-utils&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;1&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样可以找出当前操作所使用的详细版本信息，一旦找出了不正确的版本，你可以将它从依赖关系图中移除。例如，这个例子中，plexus-utils出现了两次，Proficio需要1.1版。为确保这个依赖，可以修改plexus-container-default的依赖，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-container-default&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-9&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;exclusions&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;exclusion&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-utils&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/exclusion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/exclusions&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这保证了Maven将忽略1.04版的plexus-utils，而使用1.1版。&lt;/p&gt;
&lt;p&gt;另一种方法确保在依赖中使用特定版本，是将它直接包含在POM中，例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-utils&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;runtime&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这种方式是不被推荐的除非你是在制作一个绑定了自己的依赖的artifact，并且它自身不会作为一个依赖（例如，是一个WAR文件）。原因是这种做法歪曲了真实的依赖关系图，在工程自身作为依赖被重用时将导致问题。&lt;/p&gt;
&lt;p&gt;在这里指定了runtime作用范围。这是因为，在这种情况下，依赖只是用于打包而不是编译。实际上，如果依赖是在编译时需要，它应该总是出现在当前POM的依赖中&amp;mdash;&amp;mdash;而不管另一个依赖是否使用了它。&lt;/p&gt;
&lt;p&gt;上面的这些解决都只是理想化的，但它可以提高你自己的依赖的质量，避免你在构建自己的产品时的风险。这一点在构建一个应用程序框架时是非常重要的，因为它将广泛的被其它人使用。为达到这个目标，可以使用版本范围来替代这种方式。&lt;/p&gt;
&lt;p&gt;当上面的plexus-utils的版本被设置为1.1时，标明首选依赖的是1.1版，但其它版本可能也能够接受。Maven并不知道哪个版本可以工作，因此当与其它依赖冲突时，Maven确保所有的版本使用前面描述的&amp;ldquo;最近依赖（nearest dependency）&amp;rdquo;技术来决定使用哪个版本。&lt;/p&gt;
&lt;p&gt;但是，你可能需要一个plexus-utils 1.1版中的功能。这时，依赖应该指定为下面的形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-utils&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;[1.1,)&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表示在版本冲突时仍将使用nearest dependency技术，但是版本号必须符合给定的范围。如果版本不匹配，则下一个最接近的版本将被测试，如此继续。最后，如果没有匹配的版本，或本来就没有冲突，则使用指定的版本[1.1,)。这表示将从仓库中获取最小的版本号大于或等于1.1的版本。&lt;/p&gt;
&lt;p&gt;版本范围范例表：&lt;/p&gt;
&lt;p&gt;范围 || 含义
(,1.0] | 小于或等于1.0
[1.2,1.3] | 处于1.2和1.3之间（含1.3）
[1.0,2.0) | 大于或等于1.0，但小于2.0
[1.5,) | 大于或等于1.5
(,1.1),(1.1,) | 除1.1外的任何版本&lt;/p&gt;
&lt;p&gt;通过指定使用的版本范围，使得构建时依赖管理机制更加可靠并且减少异常的情况。但应该避免过度的详细。例如，如果两个版本范围依赖图不交叉，那么构建将失败。&lt;/p&gt;
&lt;p&gt;为了解版本范围是如何工作的，需要了解版本是怎样进行比较的。下面展示了Maven是如何分割版本号的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1.0.1-20060211.131141-1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从左至右依次为：&lt;/p&gt;
&lt;p&gt;1为主版本号&lt;/p&gt;
&lt;p&gt;0为次版本号&lt;/p&gt;
&lt;p&gt;1为Bug修正号&lt;/p&gt;
&lt;p&gt;20060211.131141为限定版本号&lt;/p&gt;
&lt;p&gt;1为构建号&lt;/p&gt;
&lt;p&gt;在目前的版本方案中，快照版本是一种特殊的情况，在这种情况下限定号和构建号可以同时存在。在正式版本中，可以只提供限定号或只提供构建号。有意设置的限定号标识出了一个较优先的版本（例如：alpha-1，beta-1，rc1）。对于快照版本，限定号必须是文本&amp;ldquo;snapshot&amp;rdquo;或时间戳。构建号是一个自增号在发布时标明是补丁构建。&lt;/p&gt;
&lt;p&gt;版本中的元素依次决定哪个版本较新&amp;mdash;&amp;mdash;首先是主版本号，如果主版本号相等，则比较次版本号，接下来是Bug修正号，限定号，最后比较构建号。带限定号的版本比不带限定号的版本要旧；比如1.2-beta比1.2旧。包含了构建号的版本比不带构建号的版本新；比如1.2-beta-1比1.2-beta新。某些情况下，版本可能会不匹配这个语法。在这些情况下，两个版本号将作为字符串进行比较。&lt;/p&gt;
&lt;p&gt;当使用快照版本测试编译发布版本或自己测试发布测试版本时应该将它们部署到快照仓库，这将在第七章讨论。这保证了在版本范围中的beta版本才会使用，除非工程显式的申明了使用快照版本。&lt;/p&gt;
&lt;p&gt;最后要注意的是当使用版本范围时版本更新是如何被决定的。这个机制与前面介绍的快照版本更新机制是相同的，即每天从版本库中更新一次版本。但是，这可以通过配置每个仓库来设置更新的频率，或在命令行使用-U参数强制Maven执行更新。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;releases&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;updatePolicy&amp;gt;&lt;/span&gt;interval:60&lt;span class="nt"&gt;&amp;lt;/updatePolicy&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/releases&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;利用构建生命周期&lt;/h2&gt;
&lt;p&gt;第二章中将Maven描述为一个正确调整插件执行方式或顺序的应用框架，这实际上就是Maven的默认构建生命周期。Maven默认的构建生命周期对于大多数工程来说不需要增加任何内容就可以满足了&amp;mdash;&amp;mdash;当然，有时工程需要增加不同的内容到Maven的默认构生命周期来满足构建的需求。&lt;/p&gt;
&lt;p&gt;例如，Proficio需要从model生成Java源码。Maven通过允许申明插件来满足这个需求，将它绑定到Maven默认生命周期的一个标准阶段&amp;mdash;&amp;mdash;generate-sources阶段。&lt;/p&gt;
&lt;p&gt;Maven的插件是为特定任务而创建的，这意味着插件将被绑定到默认的生命周期的一个特定阶段。在Proficio中，Modello插件被用于生成Proficio的数据模型的Java源码。查看proficio-model的POM可以看到plugins元素配置了Modello插件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-model&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Model&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.modello&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;modello-maven-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-5&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;java&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;packageWithVersion&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/packageWithVersion&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;model&amp;gt;&lt;/span&gt;src/main/mdo/proficio.mdo&lt;span class="nt"&gt;&amp;lt;/model&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这与第二章中maven-compiler-plugin的申明非常相似，但这里可以看到额外的execution元素。Maven中的插件可以有多个goal，因此你需要指定你希望运行插件的哪个goal，这可以通过在execution中的goal元素来指定。&lt;/p&gt;
&lt;h2&gt;使用Profiles&lt;/h2&gt;
&lt;p&gt;Profile是Maven提供的用于创建构建生命周期中的不同环境变量、不同的平台、不同JVM、不同的测试数据库、或引用不同的本地文件系统的方法。通常你可以在POM中封装，以保证构建的可移植性，但有时你需要考虑变化的交叉系统的情况，这也是Maven中引入profile的原因。&lt;/p&gt;
&lt;p&gt;Profile使用POM中的一个子集元素来指定，可以用多种方式来启用。Profile在构建时修改POM，意味着它将用于给不同的目标环境中的参数集（比如，在开发环境、测试环境、产品环境下应用服务器根路径）不同参数值。&lt;/p&gt;
&lt;p&gt;Profile也可以很容易的实现团队中不同成员生成不同的构建结果。也可以通过profile阻止构建的移植性。Profile可以定义在下面三个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Maven的配置文件（通常是&lt;user_home&gt;/.m2/settings.xml）&lt;/user_home&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与POM同一目录下的名为profiles.xml的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POM文件中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优先级依次为POM文件、profiles.xml、settings.xml。这也是Maven中的基本原则。&lt;/p&gt;
&lt;p&gt;settings.xml中设置profile会影响所有的构建，因此它适合&amp;ldquo;全局&amp;rdquo;的profiles。profiles.xml允许设置单个工程的构建而不用修改POM。基于POM的profiles是首选方式，因为这样更具有移植性（它们将在布署时发布到仓库，对于源于仓库的子构建或依赖来说也同样有效）。&lt;/p&gt;
&lt;p&gt;因为移植性的原因，那些不会发布到仓库中的文件不允许修改任何基础构建。因此，profiles.xml和settings.xml只允许定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;仓库repositories&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件仓库pluginRepositories&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性properties&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其它的信息必须在POM的profile中指定或在POM自身指定。例如，如果settings.xml中有一个profile它可以注入一个依赖，你的工程运行需要settings注入的依赖，一旦这个工程部部署到仓库中它将不能解决它的依赖。因为其中一个依赖设置在settings.xml的profile中了。&lt;/p&gt;
&lt;p&gt;注意：respositories、pluginRepositories和properties也可以在POM内部的profiles指定。因此，在POM外部指定的profiles只允许使用POM内部指定的profiles选项的一个小的子集。&lt;/p&gt;
&lt;p&gt;可以在POM中定义的profile：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;repositories&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pluginRepositories&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dependencies&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;plugins&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;properties(not actually available in the main POM, but used behind the scenes)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;modules&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reporting&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dependencyManagement&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;distributionManagement&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构建元素的子集，由下面组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;defaultGoal&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;resources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;testResources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;finalName&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有多种方法启用profiles：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在命令行上使用-P选项。这个选项接收以逗号名分隔的profile的id列表。当指定这个选项时，这些指定在参数中的profiles将被激活。例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn -Pprofile1,profile2 install
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Profiles可以在Maven settings文件通过activeProfiles段中激活。这段接收activeProfile元素的列表，每个都包括了一个profile-id。注意你必须在settings.xml文件中定义了这些profiles。例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;settings&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;profiles&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;profile1&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      [...]
    &lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/profiles&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;activeProfiles&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;activeProfile&amp;gt;&lt;/span&gt;profile1&lt;span class="nt"&gt;&amp;lt;/activeProfile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/activeProfiles&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/settings&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Profiles可以在检测到构建环境时自动触发。这些在profile的activation段设置。目前这种检测仅限于匹配JDK版本号的前缀、当前系统属性或系统属性的值。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;profile1&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;activation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;jdk&amp;gt;&lt;/span&gt;1.4&lt;span class="nt"&gt;&amp;lt;/jdk&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/activation&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个激器将在JDK的版本以1.4开始时被触发。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;profile1&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;activation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;debug&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/activation&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的profile将在系统属性debug被指定时被触发。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;profile1&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;activation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;environment&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/activation&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的这个例子将在系统属性environment属性设置为true时激活。&lt;/p&gt;
&lt;p&gt;在熟悉profiles后，可以使用它组装不同的Proficio系统：一个配置方案是memory-base存储，另一个是XStream-based存储。这些将在proficio-cli模块中使用。proficio-cli模块的profile定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
 [...]
 &lt;span class="c"&gt;&amp;lt;!-- Profiles for the two assemblies to create for deployment --&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;profiles&amp;gt;&lt;/span&gt;
  &lt;span class="c"&gt;&amp;lt;!-- Profile which creates an assembly using the memory based store --&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;memory&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-assembly-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;descriptors&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;descriptor&amp;gt;&lt;/span&gt;src/main/assembly/assembly-store-memory.xml&lt;span class="nt"&gt;&amp;lt;/descriptor&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;/descriptors&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;activation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;memory&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/activation&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
  &lt;span class="c"&gt;&amp;lt;!-- Profile which creates an assembly using the xstream based store --&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;xstream&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-assembly-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;descriptors&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;descriptor&amp;gt;&lt;/span&gt;src/main/assembly/assembly-store-xstream.xml&lt;span class="nt"&gt;&amp;lt;/descriptor&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;/descriptors&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;activation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;xstream&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/activation&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/profiles&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到两个profiles：一个id为memory另一个id为xstream。在每个profile中你可以配置插件。也可以看到profile通过一个系统属性进行激活。这个例子依赖于前面已经执行过的一些构建步骤，因此应该先在工程的顶级目录执行mvn install确保需要的组件被安装到本地仓库。&lt;/p&gt;
&lt;p&gt;如果想基于memory-based存储进行构建，可以执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn -Dmemory clean assembly:assembly
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想基于XStream-based存储进行，可以执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn -Dxstream clean assembly:assembly
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种方式构建的结果都保存在target目录中，如果对输出使用jar tvf命令，可以看到memory-base方式构建时只包含了proficio-store-memory-1.0-SNAPSHOT.jar，当使用XStream-based方式时，只包含了proficio-store-xstream-1.0-SNAPSHOT.jar。&lt;/p&gt;
&lt;h2&gt;部署应用&lt;/h2&gt;
&lt;p&gt;当前Maven支持多种部署方式包括文件系统部署、SSH2部署、SFTP部署、FTP部署和外部SSH部署。为了进行部署，需要正确的配置POM中的distributionManagement元素，通常是在顶级POM中，因为子POM可以继承这些信息。&lt;/p&gt;
&lt;h3 id="wen-jian-xi-tong-bu-shu"&gt;文件系统部署&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;proficio-repository&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Repository&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;file://&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;basedir&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/target/deploy&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ssh2bu-shu"&gt;SSH2部署&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;proficio-repository&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Repository&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;scp://sshserver.yourcompany.com/deploy&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="sftpbu-shu"&gt;SFTP部署&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;proficio-repository&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Repository&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;sftp://ftpserver.yourcompany.com/deploy&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="wai-bu-sshbu-shu"&gt;外部SSH部署&lt;/h3&gt;
&lt;p&gt;前面三个部署方式是包含在Maven内部的，因此只需要distributionMangement元素，但使用外部SSH命令部署则还要使用一个构建扩展。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;proficio-repository&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Repository&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;scpexe://sshserver.yourcompany.com/deploy&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;extensions&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;extension&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.wagon&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;wagon-ssh-external&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-6&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/extension&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/extensions&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个构建扩展指定使用Wagon外部SSH提供都，它将你的文件移动到远程服务器上。Wagon是Maven中通用的用于传送的机制。&lt;/p&gt;
&lt;h3 id="ftpbu-shu"&gt;FTP部署&lt;/h3&gt;
&lt;p&gt;FTP部署也必须指定一个构建扩展。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;proficio-repository&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Repository&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;ftp://ftpserver.yourcompany.com/deploy&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;extensions&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;extension&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.wagon&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;wagon-ftp&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-6&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/extension&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/extensions&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦配置完POM后，可以执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn deploy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进行部署。&lt;/p&gt;
&lt;h2&gt;为应用程序创建Web站点&lt;/h2&gt;
&lt;p&gt;前面已经完成了Proficio的构建、测试、部署，现在可以为这个应用创建一个标准的Web站点。对于Procio这样的应，推荐在顶级目录创建用于生成站点的资源目录。&lt;/p&gt;
&lt;p&gt;所有用于生成站点的文件保存在src/site目录。src/site目录中也有子目录保存支持文档。Maven支持大量同的文件格式。&lt;/p&gt;
&lt;p&gt;当前支持得最好的格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;XDOC格式，它是一个被Apache广泛使用的简单的XML格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;APT（Almost Plain Text）,与wiki格式类似的格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FML格式，FAQ格式。一个简单的XML格式管理FAQ。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DocBook Simple格式，它是一个比完整的DocBook格式简单一些的格式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Maven也有限的支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Twiki格式，这是一种流行的Wiki格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confluence格式，这是另一种流行的Wiki格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DocBook格式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在后面的章节将了解支持较好的那些格式，但你应该熟悉下面的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;配置banner的外观。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置站点的皮肤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置发布数据的格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置banner下显示的链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置放入生成的页面的&lt;head&gt;&lt;/head&gt;元素中的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置显示在导航栏中的菜单项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置项目报表的外观。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看Proficio应用的src/site可以看到站点的描述：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Proficio"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;bannerLeft&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;href&amp;gt;&lt;/span&gt;http://maven.apache.org/&lt;span class="nt"&gt;&amp;lt;/href&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/bannerLeft&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;bannerRight&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;src&amp;gt;&lt;/span&gt;http://maven.apache.org/images/apache-maven project.png&lt;span class="nt"&gt;&amp;lt;/src&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/bannerRight&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;skin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.skins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-default-skin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/skin&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;publishDate&lt;/span&gt; &lt;span class="na"&gt;format=&lt;/span&gt;&lt;span class="s"&gt;"dd MMM yyyy"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;links&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;item&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Apache"&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://www.apache.org/"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;item&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Maven"&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://maven.apache.org/"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;item&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Continuum"&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://maven.apache.org/continuum"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/links&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&amp;lt;meta&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"faq"&lt;/span&gt; &lt;span class="na"&gt;content=&lt;/span&gt;&lt;span class="s"&gt;"proficio"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;menu&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Quick Links"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;item&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Features"&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"/maven-features.html"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/menu&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;menu&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"About Proficio"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;item&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"What is Proficio?"&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"/what-is-maven.html"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/menu&amp;gt;&lt;/span&gt;
    &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;reports&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个相当标准的Web站点描述，每个元素的说明如下：&lt;/p&gt;
&lt;p&gt;站点描述元素 || 说明
bannerLeft and bannerRight | 这些元素包括名称、href和可选的src元素，可以用于图像。
skin | 这个元素看起来像是依赖的描述（使用了相同的机制来获取皮肤）控制站点使用的皮肤。
publishDate | 发布日期的格式，使用的Java类中的SimpleDateFormat。
body/links | 控制banner下的链接引用只需要name和href。
body/head | head元素允许你插入任何信息到生成的页面。可以加metadata、script（如Google Analytics）。&lt;/p&gt;
&lt;p&gt;Maven中最流行的功能之一就是花较少的功夫就可以生成标准的报表。只要简单的在站点描述中包含${reports}引用，默认情况下是包含的，工程信息报表将自动生成的被添加上来。标准的工程信息报表包含下面的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;依赖关系报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;邮件列表报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持续集成报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源码仓库报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发行版本跟踪报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工程团队报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;版权&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管标准报表很有用，通常你需要自定义工程的报表。报表的创建和显示控制是在POM的build/reports元素中。你可以选择生成报表的信息，只要列举出需要包含在站点中的报表即可。这个插件的配置方式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;reporting&amp;gt;&lt;/span&gt;
    [...]
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-project-info-reports-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;reportSets&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;reportSet&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;reports&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;dependencies&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;project-team&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;mailing-list&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;cim&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
              &lt;span class="c"&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class="c"&gt;              Issue tracking report will be omitted&lt;/span&gt;
&lt;span class="c"&gt;              &amp;lt;report&amp;gt;issue-tracking&amp;lt;/report&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;              --&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;license&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;scm&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/reports&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/reportSet&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/reportSets&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
    [...]
  &lt;span class="nt"&gt;&amp;lt;/reporting&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn site
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成站点。&lt;/p&gt;
&lt;p&gt;生成的站点放在target目录下。如果有其它的资源，如图片、PDF等可以存放在src/site/resources。当站点被生成时src/site/resources将被复制到站点的顶级目录。&lt;/p&gt;
&lt;h1&gt;构建J2EE应用程序&lt;/h1&gt;
&lt;h1&gt;开发Maven插件&lt;/h1&gt;
&lt;p&gt;如第二章所述，Maven实际上是一个平台，它在构建生命周期中执行插件来执行构建一个项目时需要进行的任务。Maven核心API处理与POM定义相关操作，解决工程的依赖关系，组织和运行插件。实际执行任务或工作是由一套与工程的构建生命周期相关联的插件集来完成的。这使得Maven的插件框架极其重要，不光是在构建工程的过种中，在对工程的功能进行扩展，如集成外部工具和系统时也同样重要。&lt;/p&gt;
&lt;p&gt;多数工程中Maven提供的插件足够满足多数构建过程的需要。即使要执行一些特殊的任务，也可能已经存在了这样的插件。可以在Apache Maven project和CodeHaus Mojo project或其它第三方网站找到与Maven集成的插件。如果找不到合适的插件，可能就需要编写客户化插件将这些任务集成到构建生命周期中。&lt;/p&gt;
&lt;h2&gt;回顾插件技术&lt;/h2&gt;
&lt;p&gt;Mojo是Maven应用的基本工作单元。它执行原子性的构建任务，用于描述构建过程中的单个步骤。一些mojo结合起来完成相关的任务，它们被打包到plugin中。&lt;/p&gt;
&lt;p&gt;与Java中的包一样，plugin提供了分组的机制，将在构建生命周期中提供类似功能的多个mojo进行分组。比如，maven-compiler-plugin包含两个mojo：compile和testCompile。在这里，它们的任务都是编译代码。对这些mojo进行打包向用户提供了一致的访问机制，允许共享POM中添加的单个段的配置。另外，它也使mojo之间共享代码更方便。&lt;/p&gt;
&lt;p&gt;Mojo描述了构建过程中的单个任务。工程的构建过程包含了一套mojo的集合，它们按定义好的特定顺序执行。这个顺序被称为&amp;ldquo;构建生命周期&amp;rdquo;，它被定义为一套任务分类的集合，称为&amp;ldquo;构建阶段&amp;rdquo;。当Maven执行构建时，它按生命周期顺序执行每个阶段相关的mojo。&lt;/p&gt;
&lt;p&gt;mojo与构建阶段的关系被称为&amp;ldquo;构建building&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;Maven实际上定义了三个不同的构建周期，这章讨论默认的构建生命周期，它用于主要的构建活动（其它两个处理清理工作目录和生成Web站点）。&lt;/p&gt;
&lt;p&gt;多数mojo被分为不同的分类，对应于构建生命周期的阶段。因此，mojo自然的与一个阶段绑定，这决定了在这个周期中的某个任务该在何时执行。由于阶段绑定提供了mojo在生命周期中的分组机制，通过连续的各个阶段可以决定前一个价码应该做什么。因此，为确保与其它插件的兼容，为你的插件提供恰当的阶段绑定是很重要的。&lt;/p&gt;
&lt;p&gt;mojo通常指定了一个默认的阶段绑定，它们可以被绑定到构建过程的任何阶段。甚至，一个mojo可以通过配置工程POM文件的executions段被绑定到同一构建生命周期的多个位置。每个excution可以为它申明的mojo集合指定一个单独的构建阶段。但是，在mojo执行前，它可能需要某些活动先被执行完成，因此应该在重新绑定mojo之前检查文档以了解它。&lt;/p&gt;
&lt;p&gt;某些情况下，mojo可以被设计为独立于构建生命周期之外。比如mojo可能从版本库中检出代码，或为一个新的工程创建目录结构。这些mojo通常是被直接调用的，它们不会与构建生命周期的某个阶段绑定，因为他们不能被自动划分到典型的构建过程中。讨论这些mojo与Maven构建过程本身有些跑题了，因为它们通常是由POM的维护者执行的任务，或通过集成外部开发工具来完成。&lt;/p&gt;
&lt;h2&gt;开始插件开发&lt;/h2&gt;
&lt;p&gt;为了了解Maven插件开发技术，你需要较好的了解插件是如何构建的以及它们如何与他们的环境进行交互。作为插件开发都，你必须了解构建生命周期阶段的绑定和参数的注入。了解这个框架使你了解每个mojo都需要的Maven构建状态信息，并决定将mojo绑定到哪个构建阶段。&lt;/p&gt;
&lt;h3 id="cha-jian-kuang-jia"&gt;插件框架&lt;/h3&gt;
&lt;p&gt;Maven提为插件供了强大的框架，包括较好的生命周期定义，依赖关系管理，参数解析和注入。通过生命周期，Maven也较好的定义了生成工程发布包等等。将mojo绑定到构建生命周期使得mojo可以知道哪些处理阶段已经完成了。使用Maven的参数注入，使mojo可以获取构建的状态。参数注入和生命周期绑定是所有mojo开发的基础。&lt;/p&gt;
&lt;h4 id="can-yu-gou-jian-sheng-ming-zhou-qi"&gt;参与构建生命周期&lt;/h4&gt;
&lt;p&gt;大多数插件完全由mojo组成并根据它们的功能被绑定到构建生命周期的各个阶段。例如，某个工程的源码需要被编译并被打包到一个jar文件中以便发布。在这个构建过程中，Maven将为生成&amp;lsquo;jar&amp;rsquo;包执行一个默认的生命周期。&amp;lsquo;jar&amp;rsquo;包过程的定义被绑定到下面的生命周期阶段：&lt;/p&gt;
&lt;p&gt;生命周期阶段 || mojo || 插件
process-resources | resources | maven-resources-plugin
compile | compile | maven-compiler-plugin
process-test-resources | testResources | maven-resources-plugin
test-compile | testCompile | maven-compiler-plugin
test | test | maven-surefire-plugin
package | jar | maven-jar-plugin
install | install | maven-install-plugin
deploy | deploy | maven-deploy-plugin&lt;/p&gt;
&lt;p&gt;当命令Maven执行生命周期中的打包阶段时，上面至少有两个mojo将被执行。首先，maven-compile-plugin中的compile mojo将源代码编译到output目录。然后，maven-jar-plugin中的jar mojo将收集到的class文件打包到jar文件中。&lt;/p&gt;
&lt;p&gt;在这个例子的构建过程中仅仅只有这些mojo将被执行。因为这个假想的工程没有&amp;ldquo;非代码&amp;rdquo;资源，因此maven-resources-plugin中没有mojo会被执行。每个与资源相关的mojo将发现没有非代码资源的这个问题，它们将不会修改构建过程。这不是Maven框架的功能，而是mojo设计中的一个需要。好的mojo设计能决定什么时候不执行，它通常与执行时做出的修改一样重要。&lt;/p&gt;
&lt;p&gt;如果Maven工程中也包含了单元测试源码，则另外两个mojo将被触发处理单元测试。maven-compiler-plugin中的testCompile mojo编译测试代码，然后maven-surefire-plugin中的test mojo将执行这些编译过的测试。这些mojo总是被定义在生命周期中，但现在它们什么也不做。&lt;/p&gt;
&lt;p&gt;根据具体的工程，许多插件可以增加到默认的生命周期定义中来，提供各种各样的功能，例如部署到资源仓库、校验工程的内容、生成工程的Web站点，等等。Maven的插件框架确保几乎所有的东西都可以被集成到构建生命周期。这种扩展性也是使得Maven如此强大的部分原因。&lt;/p&gt;
&lt;h4 id="fang-wen-gou-jian-xin-xi"&gt;访问构建信息&lt;/h4&gt;
&lt;p&gt;为了使mojo能有效的执行，它需要获取当前构建的状态信息。这些信息来自于两方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;工程信息&amp;mdash;&amp;mdash;来自于工程的POM，或来自于前面的mojo执行时通过编程的方式所做的修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环境信息&amp;mdash;&amp;mdash;这些更加静态，包括用户、机器、Maven设置、系统属性、执行Maven时指定的系统属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了访问当前构建的状态，Maven允许mojo使用表达式设置参数值。在运行时，与参数关联的表达式将在当前的构建状态中被解析，并将结果注入mojo。通过正确的使用参数表达式，mojo可以保持它的依赖的最小化，从而避免了遍历整个构建状态对象图。&lt;/p&gt;
&lt;p&gt;例如，一个给源码打补丁的mojo需要找到工程的源码和补丁文件。这个可以使用下面的表达式mojo从当前的构建信息中获取源码目录列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compileSourceRoots&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设补丁文件的保存目录是作为mojo的配置在POM中设置的，这个表达式可以使用类似下面的表达式获取这个信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;patchDirectory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="cha-jian-miao-shu"&gt;插件描述&lt;/h4&gt;
&lt;p&gt;Maven的插件描述是一个嵌入到插件的jar包中的描述文件，存放在/META-INF/maven/plugin.xml。描述文件XML格式的，它告诉Maven在这个插件包中包含的mojo集。包含的信息有：mojo实现类（或它在插件jar包中的路径）的信息，各个mojo应该被绑定到生命周期的哪个阶段，mojo申明的参数集和其它信息。&lt;/p&gt;
&lt;p&gt;在这个描述中，每个申明的mojo参数信息中都描述了多种用于获取参数值的表达式，描述了它是否可编辑，是否是mojo执行所必需的，以及参数值被注入到mojo实例的机制。&lt;/p&gt;
&lt;p&gt;插件描述非常强大足够满足各种pojo的需要。但这种弹性是要付出代价的。为了获得这种弹性，它使用了复杂的语法。手工编写插件描述需要插件开发者了解Maven插件框架的底层细节&amp;mdash;&amp;mdash;那些开发者不使用的细节，除非在配置描述时。这也是Maven插件开发工具出现的原因。通过从插件开发抽象许多细节，Maven的插件开发工具只暴露那些与插件实现语言相关的规范。（Maven's development tools expose only relevant specifications in a format convenient for a given plugin's implementation language）&lt;/p&gt;
&lt;h3 id="cha-jian-kai-fa-gong-ju_1"&gt;插件开发工具&lt;/h3&gt;
&lt;p&gt;为了创建插件描述，Maven提供了插件工具从多种不同格式中分析mojo的元数据。元数据被直接嵌入到源码中，它的格式与mojo的实现语言关。简言之，Maven的插件开发工具解除了手工维护mojo元数据的负担。插件开发工具分为下面两个分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;插件解析框架&amp;mdash;&amp;mdash;它知道如何从Maven支持的语言中解析出格式化的元数据。这个框架生成插件的文档和插件的描述；它包括一个应用框架的库，这些库提供了一套程序库（通常是每种mojo支持的语言都有一个）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;maven-plugin-plugin&amp;mdash;&amp;mdash;它使用插件解析框架，从mojo实现中解析出元数据，加上从插件自己的配置文件（插件工程POM）中获取的其它插件级元数据；maven-plugin-plugin简单的将插件作为前面所述的resource-generating step对标准的jar生命周期进行增强。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，用户编写mojo的元数据的格式依赖于用于实现该mojo的语言。使用Java时，最简单的方式是提供javadoc注释来标明mojo的属性和参数。例如，maven-clean-plugin中的clean mojo提供了下面的类级的javadoc注入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * @goal clean&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;CleanMojo&lt;span class="w"&gt; &lt;/span&gt;extends&lt;span class="w"&gt; &lt;/span&gt;AbstractMojo&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个注释告诉插件开发工具mojo的名称，以便它可以在生命周期中被引用，比如在POM配置文件中，或直接调用（比如从命令行）。clean mojo也定义了下面的内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/**
 * Be verbose in the debug log-level?
 *
 * @parameter expression="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;clean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;verbose&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" default-value="false"
 */
private boolean verbose;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个注释标明了这个字段是一个mojo参数。这个参数注释也指定了两个属性，表达式和默认值。首先指定参数的默认值应该被设置为false。第二个指定这个参数可以在命令行进行配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-Dclean.verbose=false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，也可以在POM中配置这个参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;verbose&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/verbose&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面可以看到参数名没有的显式的通过注释来指定；当使用@parameter注释时这是隐式指定的。&lt;/p&gt;
&lt;p&gt;我们可以直接申明字段而不是使用javadoc注释来初始化这个默认值，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;private boolean verbose = false;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但如果你需要注入的默认值包含了一个参数表达式时的情况。例如，下面是maven-resources-plugin中的resources mojo使用字段注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/**
 * Directory containing the classes.
 *
 * @parameter default-value="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;outputDirectory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"
 */
private File classesDirectory;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种情况下，不可能用需要的值来初始化这个java.io.File类型的字段，它指向当前工程的输出目录。当这个mojo被实例化后，这个值是从POM中获取并被注入的。由于插件工具也可以基于这些注释生成文档，因此通过元数据指定默认值是一个较好的方法，而不是在Java字段中初始化字段。&lt;/p&gt;
&lt;p&gt;上面这些注释是适应于用Java编写的mojo。如果你用其它语言mojo，比如Ant，这时指定元数据的定义将不同。但它们的原理是一样的。&lt;/p&gt;
&lt;h4 id="xuan-ze-mojode-shi-xian-yu-yan"&gt;选择mojo的实现语言&lt;/h4&gt;
&lt;h3 id="shi-yong-ben-zhang-fan-li-de-ti-shi_1"&gt;使用本章范例的提示&lt;/h3&gt;
&lt;p&gt;保持例子的简单。以便于理解。&lt;/p&gt;
&lt;p&gt;新建一个名为buildinfo的工程，它使用这个插件。&lt;/p&gt;
&lt;h2&gt;开发第一个Mojo&lt;/h2&gt;
&lt;p&gt;本章的开发目标是围绕一个称为Guniea Pig的简单工程。开发的成果将能获取构建信息并将被部署Maven开发仓库。&lt;/p&gt;
&lt;h3 id="buildinfode-yi-ge-li-zi-shi-yong-yi-ge-javabian-xie-de-mojohuo-qu-xin-xi"&gt;BuildInfo的一个例子：使用一个Java编写的Mojo获取信息&lt;/h3&gt;
&lt;p&gt;试想POM包含了这样一个profile，它将在系统属性os.name的值为Linux时被触发。当被触发时，这个profile将添加一个Linux下特定的新的依赖到工程中，有这个依赖的情况下在Linux下才能构建成功。当这个profile没有被触发时，一个默认的依赖将被注入，这个依赖是windows下的一个库。而这个依赖只在测试时需要而不会传递到依赖于本工程的其它工程。&lt;/p&gt;
&lt;p&gt;由于这个值非常重要。如果测试的依赖包含于这样一个profile中，当这个profile被触发时它能决定构建的成功或失败。因此，应该在构建信息文件中包含这个系统属性的说明以便他人能理解环境对这个构建的影响。&lt;/p&gt;
&lt;h4 id="xian-jue-tiao-jian-gou-jian-sheng-cheng-buildinfosheng-cheng-qi-gong-cheng"&gt;先决条件：构建生成buildinfo生成器工程&lt;/h4&gt;
&lt;p&gt;在编写buildinfo插件之前，你必须先将buildinfo生成器库安装到Maven本地仓库中。Buildinfo插件是对这个生成器的简单封装，它提供了一个很薄的适配层以便从Maven构建中运行生成器。这种方式也给出了一个重要的实践提示；通过将生成器从Maven构建代码中分离，你可以编写任何类型的适配器或前端代码，在不同的场景下使用用可重用的工具。&lt;/p&gt;
&lt;p&gt;构建buildinfo生成器类，执行下面的步骤：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd buildinfo
mvn install
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="shi-yong-archetypecha-jian-sheng-cheng-cha-jian-gong-cheng-de-ji-chu-dai-ma"&gt;使用archetype插件生成插件工程的基础代码&lt;/h4&gt;
&lt;p&gt;现在buildinfo生成器的类库已经被安装到Maven仓库，有助于我们使用Maven的archetype插件从标准插件工程模板中创建一个简单的基础工程从而转到插件编写过程。一旦插件工程结构就绪，编写pojo就简单了。为了生成基础的buildinfo插件，只要执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn archetype:create -DgroupId=com.devzuz.mvnbook.plugins \
-DartifactId=maven-buildinfo-plugin \
-DarchetypeArtifactId=maven-archetype-mojo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当运行这个命令时将看到警告信息&amp;ldquo;${project.build.directory} is not a valid reference&amp;rdquo;这是用于生成插件代码的Velocity模板产生的，不影响工程的正常使用。&lt;/p&gt;
&lt;p&gt;上面的命令在maven-buildinfo-plugin下创建了一个标准结构的工程。这个目录下包含了一个基础的POM和一个示例pojo。为完成这个插件，你对POM进行修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改name元素为Maven BuildInfo Plugin。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移除url元素，因为这个插件现在没有与Web站点关联。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以后还需要修改POM，比如修改mojo的依赖关系。&lt;/p&gt;
&lt;p&gt;由于你需要创建自己的mojo，因此应该删除示例mojo。示例保存在：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;src\main\java\com\devzuz\mvnbook\plugins\MyMojo.java
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="mojo"&gt;mojo&lt;/h4&gt;
&lt;p&gt;一个简单的Java编写的mojo：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/**
 * Write the environment information for the current build execution
 * to an XML file.
 * @goal extract
 * @phase package
 * @requiresDependencyResolution test
 *
 */
public class WriteBuildInfoMojo extends AbstractMojo {
    /**
     * Determines which system properties are added to the buildinfo file.
     * @parameter
     */
 private String systemProperties;
    /**
     * The location to write the buildinfo file. Used to attach the buildinfo
     * to the project jar for installation and deployment.
     * @parameter expression="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;buildinfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;outputFile&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" default- \
value="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;directory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;artifactId&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;- \
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;-buildinfo.xml"
     * @required
     */
    private File outputFile;
    public void execute() throws MojoExecutionException {
        BuildInfo buildInfo = new BuildInfo();
        addSystemProperties( buildInfo );
        try {
            BuildInfoUtils.writeXml( buildInfo, outputFile );
        } catch ( IOException e ) {
            throw new MojoExecutionException( "Error writing buildinfo \
XML file. Reason: " + e.getMessage(), e );
        }
    }
    private void addSystemProperties( BuildInfo buildInfo ) {
        Properties sysprops = System.getProperties();
        if ( systemProperties != null ) {
            String[] keys = systemProperties.split( "," );
            for ( int i = 0; i &lt;span class="nt"&gt;&amp;lt; keys.length&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt; &lt;span class="err"&gt;i++&lt;/span&gt; &lt;span class="err"&gt;)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
                &lt;span class="err"&gt;String&lt;/span&gt; &lt;span class="na"&gt;key =&lt;/span&gt; &lt;span class="err"&gt;keys[i].trim();&lt;/span&gt;
                &lt;span class="err"&gt;String&lt;/span&gt; &lt;span class="na"&gt;value =&lt;/span&gt; &lt;span class="err"&gt;sysprops.getProperty(&lt;/span&gt; &lt;span class="err"&gt;key,&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;
&lt;span class="err"&gt;BuildInfoConstants.MISSING_INFO_PLACEHOLDER&lt;/span&gt; &lt;span class="err"&gt;);&lt;/span&gt;
                &lt;span class="err"&gt;buildInfo.addSystemProperty(&lt;/span&gt; &lt;span class="err"&gt;key,&lt;/span&gt; &lt;span class="err"&gt;value&lt;/span&gt; &lt;span class="err"&gt;);&lt;/span&gt;
            &lt;span class="err"&gt;}&lt;/span&gt;
        &lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个mojo的代码部分比较简单，值得关注的是javadoc注释。在类级的javadoc注释中，有两个特殊的注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * @goal extract&lt;/span&gt;
&lt;span class="cm"&gt; * @phase package&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个注释@goal，告诉插件工具将这个类当作mojo。当调用这个mojo时，你将使用这个名称。第二个注释告诉Maven这个mojo应该在构建生命周期的哪个阶段被执行。在这里，你从环境中收集信息并将它同工程产品一起发布到maven仓库中。因此，应该在package阶段执行这个mojo，以便它被添加到工程产品中。通常，打包阶段也是获取信息并添加到构建结果中的最佳阶段。&lt;/p&gt;
&lt;p&gt;类级注释的下面是字段级的javadoc注释，它用于指定mojo的参数。每个都指向一个特定参数，以便可以独立的设置。systemProperties参数变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/**
 * @parameter expression="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;buildinfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;systemProperties&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"
 */
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一种最为简单的指定参数的情况。使用@parameter注释，没有属性，将允许在POM中插件配置中指定这个mojo字段。你可能想要允许用户指定哪些系统属性应该被包含到构建信息文件中，使用expression属性，你可以指定参数从命令行引用的名称。在这种情况下，expression属性可以被设置为系统属性的列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;localhost $ mvn buildinfo:extract \
-Dbuildinfo.systemProperties=java.version,user.dir
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行这个命令的模块应该使用buildinfo前缀。在这里，guinea-pig模块应该使用buildinfo这个goal前缀来绑定到maven-buildinfo-plugin，以便在guinea-pig目录下执行上面的命令。&lt;/p&gt;
&lt;p&gt;最后，outputFile参数出现在一个更加复杂的参数注释例子中。由于你对这个参数有更加复杂的要求，这个复杂性是合理的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/**
* The location to write the buildinfo file. Used to attach the buildinfo
* for installation and deployment.
*
* @parameter expression="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;buildinfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;outputFile&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" default- \
value="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;directory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;artifactId&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;- \
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;-buildinfo.xml"
*
* @required
*/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，mojo不运行除非它知道将构建信息写到哪个文件。为确保这个参数有一个值，mojo使用了@required注释。如果在配置mojo时这个参数没有值，这个构建将产生错误。另外，你可能需要让mojo从工程中计算出这个值作为这个参数的默认值。在这里注释中使用几个表达式来指定默认输出路径。&lt;/p&gt;
&lt;h4 id="cha-jian-de-pom"&gt;插件的POM&lt;/h4&gt;
&lt;p&gt;Mojo编写完后，你可以构建一个简单POM文件以便你构建这个插件，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-buildinfo-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;maven-plugin&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;

  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-plugin-api&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.shared&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;buildinfo&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
[...]
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个POM申明了工程的标识和它的两个依赖。&lt;/p&gt;
&lt;p&gt;注意依赖中的buildinfo，它提供了解析和格式化构建信息文件的工具。依赖中也指定了maven-plugin，这表示这个插件将遵循构建生命周期映射。&lt;/p&gt;
&lt;h4 id="bang-ding-dao-gou-jian-sheng-ming-zhou-qi"&gt;绑定到构建生命周期&lt;/h4&gt;
&lt;p&gt;现在已经有了方法来获取构建时的环境信息，你需要确保每个构建都能得到这个信息。最简单的保证方法就是将extract mojo绑定到构建生命周期，让它在每次构建时都被触发。这包括了修改标准的jar生命周期。可以通过向Guinea Pig的POM中配置新的插件，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-buildinfo-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;extract&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;systemProperties&amp;gt;&lt;/span&gt;os.name,java.version&lt;span class="nt"&gt;&amp;lt;/systemProperties&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;extract&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    [...]
  &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的绑定将在构建生命周期的package阶段执行maven-buildinfo-plugin的extract mojo，并获取系统的os.name属性。&lt;/p&gt;
&lt;h4 id="shu-chu"&gt;输出&lt;/h4&gt;
&lt;p&gt;现在你有了一个mojo和一个POM，你可以构建这个插件并试用！首先，使用下面的命令构建buildinfo插件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd C:\book-projects\maven-buildinfo-plugin
mvn clean install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，通过将buildinfo插件绑定到Guinea Pig工程来测试插件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd C:\book-projects\guinea-pig
mvn package
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当执行Guinea Pig的构建时，你可以看到类似下面的输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[...]&lt;/span&gt;
&lt;span class="k"&gt;[INFO] [buildinfo:extract {execution: extract}]&lt;/span&gt;
&lt;span class="k"&gt;[INFO]&lt;/span&gt;
&lt;span class="k"&gt;[INFO]&lt;/span&gt;
&lt;span class="na"&gt;[INFO] ------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="na"&gt;[INFO] Reactor Summary:&lt;/span&gt;
&lt;span class="na"&gt;[INFO] ------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="k"&gt;[INFO] Guinea Pig Sample Application ......................... SUCCESS [6.468s]&lt;/span&gt;
&lt;span class="k"&gt;[INFO] Guinea Pig API ........................................ SUCCESS [2.359s]&lt;/span&gt;
&lt;span class="k"&gt;[INFO] Guinea Pig Core ....................................... SUCCESS [0.469s]&lt;/span&gt;
&lt;span class="na"&gt;[INFO] ------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="na"&gt;[INFO] BUILD SUCCESSFUL&lt;/span&gt;
&lt;span class="na"&gt;[INFO] ------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="k"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在target目录下，应该有一个新的文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;guinea-pig-1.0-SNAPSHOT-buildinfo.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个文件中，可以看到类似下面的信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;buildinfo&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;systemProperties&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;java.version&amp;gt;&lt;/span&gt;1.5.0_06&lt;span class="nt"&gt;&amp;lt;/java.version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;os.name&amp;gt;&lt;/span&gt;Windows XP&lt;span class="nt"&gt;&amp;lt;/os.name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/systemProperties&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;sourceRoots&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;sourceRoot&amp;gt;&lt;/span&gt;src\main\java&lt;span class="nt"&gt;&amp;lt;/sourceRoot&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/sourceRoots&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;resourceRoots&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;resourceRoot&amp;gt;&lt;/span&gt;src\main\resources&lt;span class="nt"&gt;&amp;lt;/resourceRoot&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/resourceRoots&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/buildinfo&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然OS的名称和java的版本可能会不同。&lt;/p&gt;
&lt;h3 id="buildinfode-li-zi-shi-yong-ant-mojotong-zhi-qi-ta-kai-fa-zhe_1"&gt;BuildInfo的例子：使用Ant Mojo通知其它开发者&lt;/h3&gt;
&lt;p&gt;现在一些重要信息已经被获取，你需要在这个工程的产品被部署时与团队中的其它人分享这些信息。在Maven的世界中要记住&amp;ldquo;部署deployement&amp;rdquo;表示将工程产品注入到Maven仓库系统。现在，需要发送一个通知邮件到工程开发的邮件列表，以便其它团队成员来访问。&lt;/p&gt;
&lt;p&gt;当然，这样的任务可以使用基于Java的mojo通过JavaMail API来处理。但这需要写大量的代码和测试，更简单的办法是使用Ant。&lt;/p&gt;
&lt;p&gt;在编写完发送通知邮件的Ant target后，你只需要编写一个mojo来将这个target封装到Maven构建过程中。&lt;/p&gt;
&lt;h4 id="ant-target"&gt;Ant target&lt;/h4&gt;
&lt;p&gt;新的mojo保存在notify.build.xml中，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;target&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"notify-target"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;mail&lt;/span&gt; &lt;span class="na"&gt;from=&lt;/span&gt;&lt;span class="s"&gt;"maven@localhost"&lt;/span&gt; &lt;span class="na"&gt;replyto=&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;listAddr&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;
      &lt;span class="na"&gt;subject=&lt;/span&gt;&lt;span class="s"&gt;"Build Info for Deployment of &lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;
       &lt;span class="na"&gt;mailhost=&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;mailHost&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt; &lt;span class="na"&gt;mailport=&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;mailPort&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;
       &lt;span class="na"&gt;messagefile=&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;buildinfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;outputFile&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

      &lt;span class="nt"&gt;&amp;lt;to&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;listAddr&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/to&amp;gt;&lt;/span&gt;

    &lt;span class="nt"&gt;&amp;lt;/mail&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/target&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="mojo-metadatawen-jian"&gt;Mojo Metadata文件&lt;/h4&gt;
&lt;p&gt;不同于之前的例子，Ant mojo的metadata是保存在单独的文件中的，它使用命名约定与构建脚本关联。在这个例子中，构建脚本被命名为notify.build.xml。对应的metadata文件名为notify.mojos.xml，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;pluginMetadata&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;mojos&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;mojo&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;call&amp;gt;&lt;/span&gt;notify-target&lt;span class="nt"&gt;&amp;lt;/call&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;notify&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;phase&amp;gt;&lt;/span&gt;deploy&lt;span class="nt"&gt;&amp;lt;/phase&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;description&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;![CDATA[&lt;/span&gt;
&lt;span class="cp"&gt;        Email environment information from the current build to the&lt;/span&gt;
&lt;span class="cp"&gt;        development mailing list when the artifact is deployed.&lt;/span&gt;
&lt;span class="cp"&gt;      ]]&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;parameters&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;parameter&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;buildinfo.outputFile&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;defaultValue&amp;gt;&lt;/span&gt;
              &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;directory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;artifactId&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;- \
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;-buildinfo.xml
            &lt;span class="nt"&gt;&amp;lt;/defaultValue&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;required&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;readonly&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/readonly&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/parameter&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;parameter&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;listAddr&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;required&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/parameter&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;parameter&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;project.name&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;defaultValue&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/defaultValue&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;required&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;readonly&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/readonly&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/parameter&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;parameter&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;mailHost&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;expression&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;mailHost&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/expression&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;defaultValue&amp;gt;&lt;/span&gt;localhost&lt;span class="nt"&gt;&amp;lt;/defaultValue&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;required&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/parameter&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;parameter&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;mailPort&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;expression&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;mailPort&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/expression&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;defaultValue&amp;gt;&lt;/span&gt;25&lt;span class="nt"&gt;&amp;lt;/defaultValue&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;required&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/parameter&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/parameters&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/mojo&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/mojos&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/pluginMetadata&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初看起来，文件内容与Java编写的mojo包含的metadata是不同的；但细看就可以发现有许多相似的地方。&lt;/p&gt;
&lt;p&gt;首先，由于现在你对于用来描述mojo的metadata类型已经有一个较好的概念，总体结构应该比较熟悉。与Java的例子中一样，mojo级的metadata描述绑定的阶段和mojo的名称等细节。&lt;/p&gt;
&lt;p&gt;metadata指定mojo的参数列表，每个都有自己的信息，如名字、表达式、默认值和其它信息。表达式的语法用于从构建状态解析信息，参数标识如required仍然存在，但是是通过XML表达的。&lt;/p&gt;
&lt;p&gt;当这个mojo被执行时，Maven仍然将解析并注入这些参数到mojo中；不同之处在于用来注入的方式。在Java中，参数注入通过直接注入到字段或通过JavaBean风格的setXXX()方法进行。在基于Ant的mojo中，参数注入是作为属性被Ant工程实例引用的。&lt;/p&gt;
&lt;p&gt;Ant参数注入应遵循下面的原则：如果参数类型是java.lang.String（默认），则它的值是作为属性被注入的；其它的值将作为工程的属性引用被注入。在这个例子中，所有mojo参数类型都为java.lang.String。如果某个参数是其它类型的，你需要在&lt;name&gt;元素中添加&lt;type&gt;元素来描述参数的类型。&lt;/type&gt;&lt;/name&gt;&lt;/p&gt;
&lt;p&gt;最后，注意这个mojo被绑定到生命周期的deploy阶段。这是这个mojo中一个重要的地方，因为你准备在这时发送邮件到开发邮件列表。如果绑定在其它阶段，它将产生大量垃圾邮件。而放在deploy阶段，则只在新的工程产品被部署到远程仓库中时才会发送邮件。&lt;/p&gt;
&lt;h4 id="wei-ant-mojosxiu-gai-cha-jian-pom"&gt;为Ant Mojos修改插件POM&lt;/h4&gt;
&lt;p&gt;由于Maven 2.0不支持基于Ant的mojo（将在2.0.2中支持Ant），需要一些特殊的配置来让maven-plugin-plugin识别Ant mojos。幸运的是，Maven允许POM-specific注入插件级的依赖，以便插件使用框架提供的功能。（in order to accommodate plugins that take a framework approach to providing their functionality. ）&lt;/p&gt;
&lt;p&gt;maven-plugin-plugin是一个完善的例子，它通过使用maven-plugin-tools-api库中的MojoDescriptorExtractor接口。这个库定义了一套从原生格式（Java或其它语言编写的pojo）解析并生成mojo描述信息的接口集，这些描述信息包括了插件描述文件。maven-plugin-plugin的Java和BeanShell版中提供了上述接口的实现库。&lt;/p&gt;
&lt;p&gt;这允许开发者不需要额外的配置就可以在基于Java或BeanShell的mojo中生成描述信息。为了开发基于Ant的mojo，你需要使用maven-plugin-plugin来支持Ant mojo。&lt;/p&gt;
&lt;p&gt;为达到这个目的，你需要在POM配置中将maven-plugin-tools-ant库添加到maven-plguin-plugin的依赖中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-plugin-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-plugin-tools-ant&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.0.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，由于插件现在包括了一个基于Ant的mojo，它需要一些新的依赖，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-script-ant&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.0.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;ant&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;ant&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.6.5&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个新依赖是用于封装Ant构建脚本的mojo API，它们对于在Maven构建过程中将Ant脚本作为mojo总是需要的。第二个新的依赖，是对Ant库的依赖。&lt;/p&gt;
&lt;h4 id="jiang-notify-mojobang-ding-dao-sheng-ming-zhou-qi"&gt;将Notify Mojo绑定到生命周期&lt;/h4&gt;
&lt;p&gt;Ant mojo插件的描述生成完后，它与Maven中其它类型的mojo一样。甚至配置都是一样的。在Guinea PIG POM中添加Ant mojo：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-buildinfo-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;extract&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
          [...]
        &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;notify&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;notify&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;listAddr&amp;gt;&lt;/span&gt;dev@guineapig.codehaus.org&lt;span class="nt"&gt;&amp;lt;/listAddr&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    [...]
  &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;execution&gt;&amp;mdash;&amp;mdash;它将extract mojo绑定到构建中。notify mojo放在另一个&lt;execution&gt;中。这是因为一个execution只能包含构建生命周期中的一个阶段，并且这两个mojo不应该在同一个构建阶段执行。&lt;/execution&gt;&lt;/execution&gt;&lt;/p&gt;
&lt;p&gt;为了告诉notify mojo将邮件发送到里，还应该在configuration一节中配置listAddr参数值。&lt;/p&gt;
&lt;p&gt;现在执行下面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn deploy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构建过程将执行构建步骤并部署jar&amp;mdash;&amp;mdash;，它也将在打包阶段获取环境信息，并在部署阶段发送邮件到Guinea Pig开发者邮件列表。&lt;/p&gt;
&lt;p&gt;注意：应该配置distributionManagement和scm以便能成功的执行mvn deploy。&lt;/p&gt;
&lt;h2&gt;高级Mojo开发&lt;/h2&gt;
&lt;p&gt;前面的例子展示了如何申明简单的mojo参数，如何使用名称和绑定阶段来注释mojo。下面的例子将包含更多与mojo开发相关的高级主题。下面的章节互相没有依赖，对于开发基本的mojo来说并不是必须的。但如果你想知道如何开发插件来管理依赖、工程源码和资源、产品附件，那么准备开始吧！&lt;/p&gt;
&lt;h1&gt;评估工程的健康度&lt;/h1&gt;
&lt;h1&gt;使用Maven进行团队协作&lt;/h1&gt;
&lt;h1&gt;迁移到Maven&lt;/h1&gt;</content><category term="maven"></category></entry><entry><title>Maven2 Tips</title><link href="/maven2-tips.html" rel="alternate"></link><published>2009-09-21T00:00:00+08:00</published><updated>2009-09-21T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2009-09-21:/maven2-tips.html</id><summary type="html">&lt;h1&gt;mvn命令行&lt;/h1&gt;
&lt;h2&gt;执行Java程序&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn exec:java -Dexec.mainClass=org.jamsa.scalademo.FunctionValue
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;运行单个单元测试&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn test -Dtest=AppTest
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;安装包和源码包&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn install:install-file -Dfile=target/jsonplugin-0.34.jar -Dsources=target/jsonplugin-0.34-sources.jar -DartifactId=jsonplugin -DgroupId=com.googlecode -Dversion=0.34 -Dclassifier=sources -Dpackaging=jar
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成lift应用&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn.bat archetype:generate -U -DarchetypeGroupId=net …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;mvn命令行&lt;/h1&gt;
&lt;h2&gt;执行Java程序&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn exec:java -Dexec.mainClass=org.jamsa.scalademo.FunctionValue
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;运行单个单元测试&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn test -Dtest=AppTest
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;安装包和源码包&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn install:install-file -Dfile=target/jsonplugin-0.34.jar -Dsources=target/jsonplugin-0.34-sources.jar -DartifactId=jsonplugin -DgroupId=com.googlecode -Dversion=0.34 -Dclassifier=sources -Dpackaging=jar
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成lift应用&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn.bat archetype:generate -U -DarchetypeGroupId=net.liftweb -DarchetypeArtifactId=lift-archetype-blank -DremoteRepositories=http://scala-tools.org/repo-releases -DgroupId=demo.helloworld -DartifactId=helloworld -Dversion=1.0-SNAPSHOT
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;pom.xml配置&lt;/h1&gt;
&lt;h2&gt;dependency的scope&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.8.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!-- 使ide能找到c标签库的tld文件 --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;taglibs&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;standard&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;provided&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的test表示在测试时才需要该依赖。而provided则表示发布后的环境中将提供这个包。&lt;/p&gt;
&lt;h2&gt;scala插件配置&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.scala-tools&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-scala-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;compile&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;testCompile&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;scalaVersion&amp;gt;&lt;/span&gt;${scala.version}&lt;span class="nt"&gt;&amp;lt;/scalaVersion&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;args&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;arg&amp;gt;&lt;/span&gt;-target:jvm-1.5&lt;span class="nt"&gt;&amp;lt;/arg&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;arg&amp;gt;&lt;/span&gt;-encoding&lt;span class="nt"&gt;&amp;lt;/arg&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;arg&amp;gt;&lt;/span&gt;GBK&lt;span class="nt"&gt;&amp;lt;/arg&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/args&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过args可指定-encoding参数，可以避免出现scalac识别源码字符集错误的问题。&lt;/p&gt;
&lt;h2&gt;指定所使用的依赖的编译版本&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.json&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;json&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;20090211&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;classifier&amp;gt;&lt;/span&gt;jdk1.5&lt;span class="nt"&gt;&amp;lt;/classifier&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;jetty插件的配置&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.mortbay.jetty&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-jetty-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;stopPort&amp;gt;&lt;/span&gt;9966&lt;span class="nt"&gt;&amp;lt;/stopPort&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;stopKey&amp;gt;&lt;/span&gt;foo&lt;span class="nt"&gt;&amp;lt;/stopKey&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;webAppConfig&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;contextPath&amp;gt;&lt;/span&gt;/budget&lt;span class="nt"&gt;&amp;lt;/contextPath&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;defaultsDescriptor&amp;gt;&lt;/span&gt;src/main/resources/webdefault.xml
                &lt;span class="nt"&gt;&amp;lt;/defaultsDescriptor&amp;gt;&lt;/span&gt;
                &lt;span class="c"&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class="c"&gt;                    &amp;lt;overrideDescriptor&amp;gt;src/main/resources/override-web.xml&amp;lt;/overrideDescriptor&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;                --&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/webAppConfig&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有一个样例 &lt;a href="webdefault.xml"&gt;webdefault.xml&lt;/a&gt; 。webdefault.xml可以解决执行jetty:run时静态文件不能修改的问题。&lt;/p&gt;
&lt;h2&gt;一个简单的Profile&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;&amp;lt;profiles&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;oc4j&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;xerces&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;xercesImpl&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.6.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;javax.servlet&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;jstl&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;taglibs&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;standard&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-war-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;webResources&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/oc4j&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;/webResources&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/profiles&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="maven"></category></entry><entry><title>JBoss Seam 学习笔记</title><link href="/jboss-seam-xue-xi-bi-ji.html" rel="alternate"></link><published>2009-01-15T00:00:00+08:00</published><updated>2009-01-15T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2009-01-15:/jboss-seam-xue-xi-bi-ji.html</id><summary type="html">&lt;h1&gt;JBoss Seam介绍&lt;/h1&gt;
&lt;p&gt;Seam是一个for Java EE5的应用框架。它是从下面的规则得到灵感的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集成JSF和EJB3.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集成AJAX。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Seam支持两个开源的JSF AJAX解决方案：ICEFaces和Ajax4JSF。这些解决方案让你可以在应用中添加AJAX支持而不需要编写JS代码。&lt;/p&gt;
&lt;p&gt;Seam也支持内置EJB3组件的的JavaScript远程调用。AJAX客户端可以很容易的调用服务端组件和JMS主题，而不需要中间动作层。&lt;/p&gt;
&lt;p&gt;这两种办法都工作得比较好，如果不是有Seam内置的并发和状态管理，它确保了许多并发和异步的AJAX请求被安全高效的在服务端被处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集成业务流程作为一流的构件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集成了jBPM，并允许定义会话层。JSF为这个会话层提供了强大的事件模型。Seam通过暴露jBPM的业务流程相关的事件，使用同样的事件处理机制，为所有Seam的组件模型提供了统一的事件模型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种&amp;ldquo;填充&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申明性状态管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作区管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到处都是带注释的POJO&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;易测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Seam可以工作于任何支持EJB3的应用服务器中。通过使用Jboss嵌入式EJB3容器，甚至可以在Servlet容器中使用Seam，比如Tomcat或任何J2EE应用服务器。&lt;/p&gt;
&lt;p&gt;在现在并不是所有的人都准备迁移到EJB3。因此，在这期间可以把Seam作为一种框架来使用，使用JSF作展现，Hibernate作持久层，JavaBean处理应用逻辑。当准备迁移到EJB3.0时，迁移将比较直接。&lt;/p&gt;
&lt;h1&gt;Chapter 1. Seam教程 …&lt;/h1&gt;</summary><content type="html">&lt;h1&gt;JBoss Seam介绍&lt;/h1&gt;
&lt;p&gt;Seam是一个for Java EE5的应用框架。它是从下面的规则得到灵感的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集成JSF和EJB3.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集成AJAX。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Seam支持两个开源的JSF AJAX解决方案：ICEFaces和Ajax4JSF。这些解决方案让你可以在应用中添加AJAX支持而不需要编写JS代码。&lt;/p&gt;
&lt;p&gt;Seam也支持内置EJB3组件的的JavaScript远程调用。AJAX客户端可以很容易的调用服务端组件和JMS主题，而不需要中间动作层。&lt;/p&gt;
&lt;p&gt;这两种办法都工作得比较好，如果不是有Seam内置的并发和状态管理，它确保了许多并发和异步的AJAX请求被安全高效的在服务端被处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集成业务流程作为一流的构件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集成了jBPM，并允许定义会话层。JSF为这个会话层提供了强大的事件模型。Seam通过暴露jBPM的业务流程相关的事件，使用同样的事件处理机制，为所有Seam的组件模型提供了统一的事件模型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种&amp;ldquo;填充&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申明性状态管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作区管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到处都是带注释的POJO&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;易测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Seam可以工作于任何支持EJB3的应用服务器中。通过使用Jboss嵌入式EJB3容器，甚至可以在Servlet容器中使用Seam，比如Tomcat或任何J2EE应用服务器。&lt;/p&gt;
&lt;p&gt;在现在并不是所有的人都准备迁移到EJB3。因此，在这期间可以把Seam作为一种框架来使用，使用JSF作展现，Hibernate作持久层，JavaBean处理应用逻辑。当准备迁移到EJB3.0时，迁移将比较直接。&lt;/p&gt;
&lt;h1&gt;Chapter 1. Seam教程&lt;/h1&gt;
&lt;h1&gt;Chapter 2. 使用seam-gen开始Seam&lt;/h1&gt;
&lt;h2&gt;2.1 开始之前&lt;/h2&gt;
&lt;p&gt;确保你有JDK 5或JDK 6，JBoss AS 4.0.5和Ant 1.6。&lt;/p&gt;
&lt;p&gt;JBoss有完善的热部署和重新部署WAR和EAR的功能。但不幸的是，由于JVM的Bug，重新部署一个EAR&amp;mdash;&amp;mdash;通常是在开发阶段&amp;mdash;&amp;mdash;最终将导致JVM Perm Gen溢出。因此，我们推荐在开发阶段调整JVM参数。推荐的参数为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-Xms512m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=512
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你没有足够的内存，推荐使用下面的参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-Xms256m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=256
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你从命令行运行JBoss，则可以修改bin/conf下的配置来配置JVM参数。&lt;/p&gt;
&lt;h2&gt;2.2 设置一个新的Eclipse工程&lt;/h2&gt;
&lt;p&gt;首先我们需要配置一个seam-gen环境：JBoss AS安装路径、Eclipse工作空间、数据库连接：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd jboss-seam-home
seam setup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据提示输入相关的信息。其中重要的选项是选择EAR和WAR部署。EAR工程支持EJB 3.0需要Java EE 5。WAR工程不支持EJB 3.0，但可以部署到J2EE环境中。WAR包简单易懂。如果安装了支持EJB 3.0的JBoss，选择ear。否则，选择war。&lt;/p&gt;
&lt;p&gt;如果数据模型已经存在，请确保告诉了seam-gen数据库表已经存在于数据库。&lt;/p&gt;
&lt;p&gt;设置保存在seam-gen/build.properties，但你可以再次运行seam set来修改。&lt;/p&gt;
&lt;p&gt;进入Eclipse工作空间，执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;seam new-project
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它将复制Seam需要的jar文件，需要的JDBC驱动包到新的Eclipse工程中，并生成所有需要的资源和配置文件，facelets模板文件和样式，Eclipse元数据和Ant脚本。这个Eclipse工程将自动部署到JBoss中一个展开的目录中。在Eclipse中点击New -&amp;gt; Project... -&amp;gt; General -&amp;gt; Project -&amp;gt; Next，不要选择Java Project。&lt;/p&gt;
&lt;p&gt;如果Eclipse中默认的JDK不是Java SE 5或Java SE 6，你需要设置工程的默认编译器。&lt;/p&gt;
&lt;p&gt;你也可以在Eclipse外部，使用seam explode。&lt;/p&gt;
&lt;p&gt;转到&lt;code&gt;http://localhost:8080/helloworld&lt;/code&gt;查看欢迎页面。这是一个facelet页面，vew/home/xhtml，使用的模板为&lt;code&gt;view/layout/template.xhtml&lt;/code&gt;可以修改这个页面或模板，修改将立即生效。&lt;/p&gt;
&lt;p&gt;不要害怕生成的工程目录中的XML配置文档。它们中多数是标准的Java EE原料，这些原料只要创建一次就不再需要查看，在所有Seam工程中它们有90%是相同的。&lt;/p&gt;
&lt;p&gt;生成的工程包括三个数据库和持久化配置。jboss-beans.xml，persistence-test.xml和import-test.sql文件用于基于HSQLDB做TestNG单元测试。测试用的数据库数据存储在import-test.sql中,它们在运行测试前被导出到数据库。project-dev-ds.xml，persistence-dev.xml和import-dev.sql用于部署到开发数据库。这个数据库配置是否自动导出到数据库取决于你使用seam-gen是否告诉它你工作于已经存在的数据库上。myproject-prod-ds.xml，persistence-prod.xml和import-prod.sql文件用于部署到产品数据库。这个数据库配置不会自动导出和部署。&lt;/p&gt;
&lt;h2&gt;2.3 创建一个新的action&lt;/h2&gt;
&lt;p&gt;如果你使用传递的action风格的web应用框架，你可以使用下面的方法创建一个无状态的action方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;seam new-action
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Seam将提示一些信息，并生成新的facelet页面和Seam组件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;C:\Projects\jboss-seam&amp;gt;seam new-action ping
Buildfile: C:\Projects\jboss-seam\seam-gen\build.xml

validate-workspace:

validate-project:

action-input:
    [input] Enter the Seam component name
ping
    [input] Enter the local interface name [Ping]

    [input] Enter the bean class name [PingBean]

    [input] Enter the action method name [ping]

    [input] Enter the page name [ping]


setup-filters:

new-action:
     [echo] Creating a new stateless session bean component with an action method
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello\test
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello\test
     [copy] Copying 1 file to C:\Projects\hello\view
     [echo] Type 'seam restart' and go to http://localhost:8080/helloworld/ping.seam

BUILD SUCCESSFUL
Total time: 13 seconds
C:\Projects\jboss-seam&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我们添加了新的Seam组件，我们需要重新部署。你可以使用seam restart，或运行build.xml中的restart任务。另一种方法是编辑&lt;code&gt;resources/META-INF/application&lt;/code&gt;文件来重启。不需要每次都重启JBoss。&lt;/p&gt;
&lt;p&gt;现在转到&lt;code&gt;http://localhost:8080/helloworld/ping.seam&lt;/code&gt;然后点击按钮。你将看到执行了src中的action中的代码。可以在ping()方法中设置断点，然后再次点击。&lt;/p&gt;
&lt;p&gt;最后，在测试包中找到PingTest.xml文件并使用Eclipse的TestNG插件来执行集中测试。也可以使用seam tesst或build.xml中的test任务。&lt;/p&gt;
&lt;h2&gt;2.4 创建一个带action的form&lt;/h2&gt;
&lt;p&gt;创建form的步骤：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;seam new-form
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;C:\Projects\jboss-seam&amp;gt;seam new-form
Buildfile: C:\Projects\jboss-seam\seam-gen\build.xml

validate-workspace:

validate-project:

action-input:
    [input] Enter the Seam component name
hello
    [input] Enter the local interface name [Hello]

    [input] Enter the bean class name [HelloBean]

    [input] Enter the action method name [hello]

    [input] Enter the page name [hello]


setup-filters:

new-form:
     [echo] Creating a new stateful session bean component with an action method
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello\test
     [copy] Copying 1 file to C:\Projects\hello\view
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello\test
     [echo] Type 'seam restart' and go to http://localhost:8080/hello/hello.seam

BUILD SUCCESSFUL
Total time: 5 seconds
C:\Projects\jboss-seam&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启应用，转到&lt;code&gt;http://localhost:8080/helloworld/hello.seam&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;2.5 从已存的数据库生成一个应用&lt;/h2&gt;
&lt;p&gt;在数据库中手工创建一些表.输入:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;seam generate-entities
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启应用,转到&lt;code&gt;http://localhost:8080/helloworld&lt;/code&gt;。你可以浏览数据库，编辑已经存在的对象，创建新对象。如果你查看生成的代码，你将对它的简单感到吃惊！Seam被设置为易于访问数据，即不想使用seam-gen的用户。&lt;/p&gt;
&lt;h2&gt;2.6 使用EAR部署应用&lt;/h2&gt;
&lt;p&gt;最后，我们需要能将应用打包成标准的Java EE 5 的包。首先，我们需要运行&lt;code&gt;seam unexplode&lt;/code&gt;移除wxploded目录。输入&lt;code&gt;seam deploy&lt;/code&gt;命令部署EAR，或运行生成的工程中的&lt;code&gt;deploy&lt;/code&gt;任务。也可以使用&lt;code&gt;seam undeploy&lt;/code&gt;取消部署。&lt;/p&gt;
&lt;p&gt;默认情况下，将使用&lt;code&gt;dev&lt;/code&gt;配置来部署应用。EAR将包含persistence-dev.xml和import-dev.sql和myproject-dev-ds.xml。可以使用&lt;code&gt;prod&lt;/code&gt;配置文件来部署，输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;seam -Dprofile=prod deploy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以定义自己的应用部署配置文件。只需要添加适当的文件&amp;mdash;&amp;mdash;比如，persistence-staging.xml、import-staging.sql和myproject-staging-ds.xml并使用&lt;code&gt;-Dprofile=staging&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;2.7 Seam和增量热部署&lt;/h2&gt;
&lt;p&gt;当使用解压后的目录（exploded directory）部署Seam应用时，你将在开发时获得增量热部署的支持。也可以在components.xml中启动debug模式来启动Seam和Facelets的调试模式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;core:init debug="true"/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，下面的文件可以重新部署而不需要重启web应用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 任何facelets页面
 任何pages.xml文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但如果你修改了Java代码，我们仍然需要重启应用。（在Jboss中可以通过修改EAR部署中的顶级部署描述application.xml，或WAR部署中的web.xml的时间戳。）&lt;/p&gt;
&lt;p&gt;但如果你想快速进行编辑/编译/测试周期，Seam支持JavaBean组件的增量部署。为使用这个功能，你必须将JavaBean组件部署到WEB-INF/dev目录，以便被特殊的Seam classloader加载，而不是被WAR或EAR的classloader加载。&lt;/p&gt;
&lt;p&gt;你需要知道有下面的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;组件必须是JavaBean组件，不能是EJB3 Bean（我们正在修正这个限制）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实例不能被热部署&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过components.xml部署的组件不可以被热部署&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;热部署的组件对于WEB-INF/dev之外的class loader是不可见的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Seam debug模式必须被启用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你使用seam-gen生成了一个WAR工程，增量热部署对于src/action源码目录下的类都是可用的。但是，seam-gen不支持EAR工程的热部署。&lt;/p&gt;
&lt;h1&gt;3 上下文组件模型&lt;/h1&gt;
&lt;p&gt;Seam中两个核心的概念是上下文（context）的概念和组件（component）概念。组件是有状态对象，使用EJB，组件的实例与一个上下文关联，在上下文中被命名，Seam允许组件树被动态装配和重新装配。&lt;/p&gt;
&lt;h2&gt;3.1 Seam上下文&lt;/h2&gt;
&lt;p&gt;Seam上下文是被框架创建和销毁的。应用不显示的使用Java API控制上下文的界限。上下文通常是隐式的。有些情况下，上下文界限通过注释来设置。&lt;/p&gt;
&lt;p&gt;基本的Seam上下文是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有状态上下文（Stateless context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件（或请求）上下文（Event(or request) context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面上下文（Page context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对话上下文（Conversation context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会话上下文（Session context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务流程上下文（Business process context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用上下文（Application context）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你能从servlet和相关规范中识别出其中一些上下文。但其中两个可能是新的概念：对话上下文和业务流上下文。在web应用中状态管理比较脆弱和易于出的一个原因在于三个内置上下文（request，session和application）从业务逻辑的观点来看没有特别的含义。一个用户登录session，比如，任意构建的实际应用工作流。因此，多数Seam组件处于对话上下文或业务流程上下文中，因为它们对于应用是有含义的。&lt;/p&gt;
&lt;h3 id="311-you-zhuang-tai-shang-xia-wen"&gt;3.1.1 有状态上下文&lt;/h3&gt;
&lt;p&gt;真正有状态的组件（有状态session bean）总是存在于有状态上下文中。有状态组件并不是很有趣，可以证明不是很面向对象。但它仍然是很重要的且经常使用。&lt;/p&gt;
&lt;h3 id="312-shi-jian-shang-xia-wen"&gt;3.1.2 事件上下文&lt;/h3&gt;
&lt;p&gt;事件上下文是&amp;ldquo;窄&amp;rdquo;的有状态上下文，它是对web request上下文的封装。但是事件上下文与JSF请求的生命周期相关是事件上下文最重要的一个例子，它是你最常用的。与事件上下文关联的组件将在请求结束时被销毁，但它们的状态在请求周期中是有效的。&lt;/p&gt;
&lt;p&gt;当你通过RMI或Seam Remoting调用Seam组件，事件环境的创建和销毁仅在调用的期间。&lt;/p&gt;
&lt;h3 id="313-ye-mian-shang-xia-wen"&gt;3.1.3 页面上下文&lt;/h3&gt;
&lt;p&gt;页面组件允许你关联状态到一个被渲染的页面实例。你可以在你的事件监听中初始化状态，或当实际渲染页面时，然后可以从任何发源于这个页面的事件中访问它。这对于类似可选项列表这类的功能非常有用，这种情况下列表可能通过修改服务端修改数据而改变。状态实际上被序列化到客户端，因此这个机构对于多窗口操作和后退按钮来说非常健壮。&lt;/p&gt;
&lt;h3 id="314-dui-hua-shang-xia-wen"&gt;3.1.4 对话上下文&lt;/h3&gt;
&lt;p&gt;对话上下文是Seam中的一个中心概念。一个对话上下文对于用户来说是一组功能的集合。它可能处于多个用户交互，多个请求和多次数据库事务之间。但对于用户，一个对话只解决一个单一的问题。比如，&amp;ldquo;旅馆登记&amp;rdquo;，&amp;ldquo;批准合同&amp;rdquo;，&amp;ldquo;创建定单&amp;ldquo;都是对话。你可以把一个对话当作一个单一的&amp;rdquo;用例&amp;ldquo;，但这不是很准确。&lt;/p&gt;
&lt;p&gt;一个对话保持了关于&amp;ldquo;用户在这个窗口中正在做什么&amp;rdquo;的状态。在一个时间点上一个单一用户可以使用多个窗口拥有有多个对话。对话上下文允许我们确保多个不同的对话间不产生冲突。&lt;/p&gt;
&lt;p&gt;你可能需要花一些时间了解对话在应用中的作用。但一旦你使用它，你将喜欢上这个概念。&lt;/p&gt;
&lt;p&gt;一些对话只是简单的一个请求。对话跨多个请求可以使用Seam提供的注释来划分。&lt;/p&gt;
&lt;p&gt;一些对话也是任务。一个任务是一个长时间的业务处理，当它成功时可能触发业务流程状态的变迁。Seam为任务的划分提供了一套特殊的注释。&lt;/p&gt;
&lt;p&gt;对话可以嵌套，这是一个高级功能。&lt;/p&gt;
&lt;p&gt;通常，对话状态由Seam保持在请求之间的servlet session中。Seam实现可配置的对话超时，自动清除无效的对话，这确保单个用户的session状态不会过度增长。&lt;/p&gt;
&lt;p&gt;在同一个进程中Seam串行处理同一个长时间运行的对话上下文。&lt;/p&gt;
&lt;p&gt;Seam也可以配置为在客户端浏览器中保持对话状态。&lt;/p&gt;
&lt;h3 id="315-sessionshang-xia-wen"&gt;3.1.5 Session上下文&lt;/h3&gt;
&lt;p&gt;Session上下文保持登录用户session相关的状态。某些情况下这对于在多个对话间共享状态很有用，我们通常不赞成在session上下文中保持除登录用户全局信息外的其它组件。&lt;/p&gt;
&lt;p&gt;在JSR-168 portal环境，session上下文代表portlet session。&lt;/p&gt;
&lt;h3 id="316-ye-wu-liu-shang-xia-wen"&gt;3.1.6 业务流上下文&lt;/h3&gt;
&lt;h1&gt;Chapter 3. 上下文组件模型&lt;/h1&gt;
&lt;p&gt;（未完成）&lt;/p&gt;
&lt;h1&gt;环境配置&lt;/h1&gt;
&lt;p&gt;直接运行setup.bat按提示操作。&lt;/p&gt;
&lt;p&gt;要注意的一些问题：
 1. seam必须要在相匹配的JBoss版本上才能运行。我的机器上安装的JBoss为4.2.0GA，开始的时候试了一下运行jboss-seam-2.0.0.CR2，maven提示安装jboss-seam-gen这个包，手工下载了这个包，然后在jboss-seam-2.0.0.CR2/build/maven2/bin下的mvn命令来安装这个包。（注：在2.0.0.CR3中已经没有这个问题了）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;jboss-seam-1.x版本在JBoss-4.2.0GA上运行出错。jboss-seam-1.x需要JBoss-4.0.5x。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署jboss-seam-2.0.0.CR2/examples下的例子时需要先修改jboss-seam-2.0.0.CR2/build.properties添加一行指定jboss的路径，jboss.home=d:\jboss-4.2.0.GA。注意：即使在seam.bat setup时指定了正确的JBoss的路径，这里也必须要设置，这好像是jboss-seam-2.0.0.CR2的一个BUG。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;创建一个简单的例子&lt;/h1&gt;
&lt;h2&gt;seam create-project&lt;/h2&gt;
&lt;p&gt;创建一个项目&lt;/p&gt;
&lt;h2&gt;seam create-action&lt;/h2&gt;
&lt;p&gt;创建一个action类&lt;/p&gt;
&lt;h2&gt;seam create-form&lt;/h2&gt;
&lt;p&gt;创建一个表单&lt;/p&gt;
&lt;h2&gt;seam generate-entities&lt;/h2&gt;
&lt;p&gt;基于数据库生成CRUD代码（没有D）。
测试这个例子时不应该使用hsqldb，除非写了import.sql文件。在hsqldb启动后创建了表，否则在创建实体重启后会找不到表。&lt;/p&gt;
&lt;h1&gt;components.xml文件&lt;/h1&gt;
&lt;h2&gt;分页&lt;/h2&gt;
&lt;p&gt;可以通过在components.xml中注入每页最多显式的记录数，也可以修改XxxList类的getMaxResults的返回值。&lt;/p&gt;</content><category term="seam"></category><category term="jsf"></category></entry><entry><title>OA Framework应用构建之——实现控制器</title><link href="/build_control.html" rel="alternate"></link><published>2008-08-06T00:00:00+08:00</published><updated>2008-08-06T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-08-06:/build_control.html</id><summary type="html">&lt;h1&gt;设计一个OA Controller&lt;/h1&gt;
&lt;p&gt;如&lt;a href="/oa-framework-pagejie-xi.html"&gt;OA Framework Page解析&lt;/a&gt;中所描述的，OA Controller定义了web beans的行为。具体来说，编写控制器代码的目的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在运行时处理／初始化UI（包含那些通过编程方式添加的layout）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拦截或响应按钮按下之类的用户事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制器不应该包含任何业务逻辑；这应该属于模型类。&lt;/p&gt;
&lt;h2&gt;必备知识&lt;/h2&gt;
&lt;p&gt;通常来说，在提出如何设计控制器之前，应该思考一下是否需要创建控制器。&lt;/p&gt;
&lt;p&gt;作为一条规则，应该只在绝对必要的情况下才编写控制器。如果可以通过设计的方式创建页面，就不要通过编程的方式实现region和item。编程方式创建的web beans不能被个性化，重用或继承。而且，一些硬编码的layouts可能会丢失BLAF UI样式。&lt;/p&gt;
&lt;p&gt;在&lt;a href="/build_view.html"&gt;实现视图&lt;/a&gt;中说过，所有位于共同组件中的顶级regions必须与一个控制器关联。&lt;/p&gt;
&lt;h2&gt;粒度&lt;/h2&gt;
&lt;p&gt;OA Controllers可以与任何region关联（任何实现oracle.apps.fnd.framework.webui.beans.OAWebBeanContainer接口的web beans）；不能将控制器与items关联。&lt;/p&gt;
&lt;p&gt;许多OA Framework新手都想知道控制器应该是 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;设计一个OA Controller&lt;/h1&gt;
&lt;p&gt;如&lt;a href="/oa-framework-pagejie-xi.html"&gt;OA Framework Page解析&lt;/a&gt;中所描述的，OA Controller定义了web beans的行为。具体来说，编写控制器代码的目的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在运行时处理／初始化UI（包含那些通过编程方式添加的layout）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拦截或响应按钮按下之类的用户事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制器不应该包含任何业务逻辑；这应该属于模型类。&lt;/p&gt;
&lt;h2&gt;必备知识&lt;/h2&gt;
&lt;p&gt;通常来说，在提出如何设计控制器之前，应该思考一下是否需要创建控制器。&lt;/p&gt;
&lt;p&gt;作为一条规则，应该只在绝对必要的情况下才编写控制器。如果可以通过设计的方式创建页面，就不要通过编程的方式实现region和item。编程方式创建的web beans不能被个性化，重用或继承。而且，一些硬编码的layouts可能会丢失BLAF UI样式。&lt;/p&gt;
&lt;p&gt;在&lt;a href="/build_view.html"&gt;实现视图&lt;/a&gt;中说过，所有位于共同组件中的顶级regions必须与一个控制器关联。&lt;/p&gt;
&lt;h2&gt;粒度&lt;/h2&gt;
&lt;p&gt;OA Controllers可以与任何region关联（任何实现oracle.apps.fnd.framework.webui.beans.OAWebBeanContainer接口的web beans）；不能将控制器与items关联。&lt;/p&gt;
&lt;p&gt;许多OA Framework新手都想知道控制器应该是&amp;rdquo;多大&amp;ldquo;。应该一个页面一个，或一个功能region一个（比如&amp;ldquo;Search&amp;rdquo; region），或一个复合web bean（比如一个table）一个，或者？答案是要看情况。&lt;/p&gt;
&lt;p&gt;最初，在一个非常简单的页面，你可能不需要任何控制器（如果没有工作要作就不需要创建控制器）。如果需要编写代码，你需要根据下面的条件决定创建什么样的控制器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利于封装，一个web bean实现了它自己的行为&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件重用，如果组件被设置为重用，它必须是自包含，自已自足。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码实用性，尽管页面包含了8个regions时可以很容易的添加8个控制器（每个包含少量的代码），这种&amp;ldquo;纯&amp;rdquo;OO的观念可以导致代码维护困难，可能导致产品代码文件膨胀。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一些方法可以帮助决定如何处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;永远不要从child bean中设置parent/grandparent web bean的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为相关联的region定义控制器来设置region和它的子孙region的属性。如果需要主控制器管理多个子／孙web bean，控制器应该与适当的父／祖父bean相关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于复杂的beans（比如OATableBean）应该将控制器关联到bean自身，或关联到一个简单的容器bean中（如果它实现功能逻辑单元）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，应该为页面创建少于满足上面规则和考虑数量的控制器。对于非常简单的页面，通常是为pageLayout区域关联单个的控制器。对于更复杂的页面，应该为各个功能组件（比如，查询页面中典型的&amp;ldquo;Search&amp;rdquo;区域控制器和&amp;ldquo;Results&amp;rdquo;区域控制器）创建少量不同的控制器。共享区域应该拥有自己的适当的控制器。&lt;/p&gt;
&lt;h2&gt;模型性／重用&lt;/h2&gt;
&lt;p&gt;在同一组相关联的页面中，你有时将找到可以重用代码的机会。下面是创建模块性更强的控制器代码的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在控制器中添加私自己的私有方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个公用的控制器类（它是oracle.apps.fnd.framework.webui.OAControllerImpl），然后为有需要的页面／区域继承这个类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建辅助的实用工具类，控制器中可以根据需要代理。这些类不需要实现任何OA Framework类或接口，应该被包含在与它们所辅助的控制器类所在的包中。注意，静态方法适合于在这些类中使用，当使用静态方法时，应该考虑下面的问题：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能影响子类中的静态方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;封装相关常量和静态方法。（There are packaging implications related to the use of constants and static methods ）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;线程安全&lt;/h2&gt;
&lt;p&gt;OA Framework被设计为支持多线程web bean访问（尽管还没有实现）。大部分对于你的代码来说是透明的，只有少量规则必须在控制器代码中遵守：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果在控制器或辅助类中使用静态方法，则永远不要包含状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总是将页面的OAPageContext传递给任何web bean存储器（如果需要可以带OAPageContext）。比如，使用setText(OAPageContext pageContext, String text)代替setText(String text)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;状态管理&lt;/h2&gt;
&lt;p&gt;不要在控制器中或你实例化的辅助类中添加非易失性成员变量。OA Framework不会钝化成员变量，因此一旦虚拟机失效被支持后将不能恢复这些值。可以添加static final成员变量。&lt;/p&gt;
&lt;h2&gt;编码规则&lt;/h2&gt;
&lt;h1&gt;创建一个控制器&lt;/h1&gt;
&lt;p&gt;为一个区域创建控制器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在JDeveloper Structure页面中选择区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右键选择Set New Controller...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在New Controller对话框中，输入包和类名。选择OK创建与选择区域关联的控制器。注意Inspector中的Controller Class属性值是类的全名，如：oracle.apps.fnd.framework.toolbox.tutorial.webui.HomeSearchCO。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JDeveloper将创建控制器模板。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*===========================================================================+&lt;/span&gt;
&lt;span class="cm"&gt; | Copyright (c) 2001, 2003 Oracle Corporation, Redwood Shores, CA, USA      |&lt;/span&gt;
&lt;span class="cm"&gt; | All rights reserved.                                                      |&lt;/span&gt;
&lt;span class="cm"&gt; +===========================================================================+&lt;/span&gt;
&lt;span class="cm"&gt; | HISTORY                                                                   |&lt;/span&gt;
&lt;span class="cm"&gt; +===========================================================================*/&lt;/span&gt;
&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.toolbox.tutorial.webui&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.common.VersionInfo&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.webui.OAControllerImpl&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.webui.OAPageContext&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.webui.beans.OAWebBean&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * Controller for ...&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OrderSummaryCO&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;OAControllerImpl&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;RCS_ID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"$Header$"&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;RCS_ID_RECORDED&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
   &lt;span class="n"&gt;VersionInfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;recordClassVersion&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RCS_ID&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"%packagename%"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

 &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Layout and page setup logic for a region.&lt;/span&gt;
&lt;span class="cm"&gt;   * @param pageContext the current OA page context&lt;/span&gt;
&lt;span class="cm"&gt;   * @param webBean the web bean corresponding to the region&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;

 &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Procedure to handle form submissions for form elements in&lt;/span&gt;
&lt;span class="cm"&gt;   * a region.&lt;/span&gt;
&lt;span class="cm"&gt;   * @param pageContext the current OA page context&lt;/span&gt;
&lt;span class="cm"&gt;   * @param webBean the web bean corresponding to the region&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 缺省的模板内容不包含processFormData(OAPageContext pageContext, OAWebBean webBean)方法，这个方法在POST处理的第一个阶段被调用。如果需要（非常少见），可以将它加到控制器中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 也可以通过编程的方式将控制器与区域关联。查看OAWebBeanContainer中的setControllerClass(String javaClass)方法。&lt;/p&gt;
&lt;h1&gt;处理HTTP GET&lt;/h1&gt;
&lt;p&gt;在GET处理过程中，每个控制器的processRequest(OAPageContext pageContext, OAWebBean webBean)方法被按照它们被实例化时的层级结构而依次被调用。处理从pageLayout bean开始，然后递归处理整个层级结构。初始化页面&amp;mdash;&amp;mdash;或影响层级结构中的web bean（通过设置属性，创建web bean等等）&amp;mdash;&amp;mdash;属于processRequest()方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 传递到processRequest()方法中的oracle.apps.fnd.framework.webui.OAWebBean参数是与当前控制器关联的区域。&lt;/p&gt;
&lt;p&gt;下面是一个典型的processRequet的代码。它描绘的是根据从&amp;ldquo;search&amp;rdquo;页面传递过来的参数，初始化用于查看的&amp;ldquo;detail&amp;rdquo;页面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Layout and page setup logic for region.&lt;/span&gt;
&lt;span class="cm"&gt; * @param pageContext the current OA page context&lt;/span&gt;
&lt;span class="cm"&gt; * @param webBean the web bean corresponding to the region&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// Always call this before adding your own code.&lt;/span&gt;
   &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// Get the purchase order number from the request.&lt;/span&gt;
   &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"headerId"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// We need to set the page header text to include the PO order number for reference.&lt;/span&gt;
   &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"PO_NUMBER"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;};&lt;/span&gt;

   &lt;span class="c1"&gt;// Always use a translated value from Message Dictionary when setting strings in&lt;/span&gt;
   &lt;span class="c1"&gt;// your controllers.&lt;/span&gt;
   &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;pageHeaderText&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_T_PO_HEADER_TEXT"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// Set the po-specific page title (which also appears in the breadcrumbs. Since this&lt;/span&gt;
   &lt;span class="c1"&gt;// controller is associated with the page layout region, simply cast the webBean&lt;/span&gt;
   &lt;span class="c1"&gt;// parameter to the right type and set the title.&lt;/span&gt;

   &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;OAPageLayoutBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;setTitle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageHeaderText&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// Now we want to initialize the query for our single purchase order with all of its&lt;/span&gt;
   &lt;span class="c1"&gt;// details.&lt;/span&gt;
   &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt; &lt;span class="o"&gt;};&lt;/span&gt;
   &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"initDetails"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end processRequest()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在调用super.processRequest(pageContxt, webBean)后，范例中的代码从request参数中获取名为&amp;ldquo;headerId（从Search页面传递过来的参数）&amp;rdquo;。这个值被显示在页面标题和breadcrumbs上，并且它被传递给模型以便查询。&lt;/p&gt;
&lt;p&gt;使用页面的title值定义页面标题和breadcrumbs：&lt;/p&gt;
&lt;p&gt;&lt;img alt="page_title" src="/oaf_build_control/page_title.gif"/&gt;&lt;/p&gt;
&lt;p&gt;由于显示于页面中的值必须被翻译，我们在Oracle应用消息字典（Oracle Application Message Dictionary）中创建了一个名为FWK_TBX_T_PO_HEADER_TEXT的消息，消息内容为&amp;ldquo;Purchase Order: &amp;amp;PO_NUMBER&amp;rdquo;。这个代码定义了以令牌PO_NUMBER作为Purchase Order Number的占位符，然后从oracle.apps.fnd.framework.webui.OAPageContext（它将操作委派给AOL/J）中提取翻译后的版本。然后将翻译后的字符串作为页面标题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 不要在用户界面中使用硬编码的文本值。所有以编程方式显示的文本值必须来源于消息字典（Message Dictionary）。也可以在设计时在web bean中使用这种方式（所有显示的bean属性都是被翻译的），或者也可以从多国语言表中查询出值来显示。&lt;/p&gt;
&lt;p&gt;最后，这个只读的&amp;rdquo;details&amp;ldquo;页面自动按给定的编号进行查询而不管它是否会被渲染。它通过将编号传递给页面根应用模块的initDetails()方法。然后应用模块将参数传递给适当的视图对象，在那里将参数与WHERE子句绑定并执行查询。&lt;/p&gt;
&lt;h2&gt;修改Bean属性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 作为规则来说，更好的修改web bean属性的方法是使用局部页面渲染（partial page rendering （PPR））和SPEL，在Dynamic User Interface中有描述。在不能通过PPR和SPEL的环境下，也必须在processRequest()方法中修改web bean层级结构（这节被包含在GET处理一章中，也是由于只能在processRequest()方法中才允许修改web bean层级结构）。&lt;/p&gt;
&lt;p&gt;如果需要以编程方式在响应表单提交的事件中修改层级结构，必须forward到同一个页面的processRequest()方法（见下面POST事件处理）。作出这个限制的原因有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;确保web bean层级结构能在需要的时候被正确的重建。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beans被适当的初始化。主要是Rendered属性，或影响复杂组件渲染的prepareForRendering()方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bean层级结构被放在同一个方法中维护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改web bean的属性时，只需要简单的根据它的名称（在JDeveloper中赋给它的ID）查找到正确的bean，然后按下面的方法调用适当的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 当获得web bean时，在调用它的任何方法前都需要检查对象是否为空。即使你认为bean被包含于web bean层级结构中，但也有可能在用户使用个性化定制时半它隐藏了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Always call this before adding your own code.&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;OATableBean&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OATableBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findIndexedChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OrdersTable"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OBJECT_NAME"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"OrdersTable"&lt;/span&gt;&lt;span class="o"&gt;)};&lt;/span&gt;
     &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_OBJECT_NOT_FOUND"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// Set the purchase-order specific "control bar" select text:&lt;/span&gt;
  &lt;span class="c1"&gt;// "Select Purchase Order(s) and..."&lt;/span&gt;

  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;selectPOText&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_T_SELECT_PO"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setTableSelectionText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;selectPOText&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用findIndexedChildRecursive(String name)方法可以在整个web bean层级结构中查找到第一个与名称匹配的被索引的子对象。如果如果要修改的web bean是一个被命名的UIX子对象（或，如果你不确定它是否&amp;ldquo;被命名（named）&amp;ldquo;或&amp;rdquo;被索引（indexed）&amp;ldquo;），则使用findChildRecursive(String name)方法。&lt;/p&gt;
&lt;p&gt;如果需要修改控制器区域的属性，只需要将processRequest()的OAWebBean参数转换为正确的类型并调用需要的方法。&lt;/p&gt;
&lt;h2&gt;编程的方式创建Bean&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 本节包含于GET处理部分，因为只允许在processRequest()方法中修改web bean层级结构。&lt;/p&gt;
&lt;p&gt;如果需要在响应表单提交事件中添加web bean到层级结构中，必须forward到同一个页面的processRequest()代码中执行。&lt;/p&gt;
&lt;p&gt;作为规则，如果你可以通过设计的方式产生web bean就不应该通过编程的方式产生web beans。另外，如果你的页面与局部页面渲染相关，则也不能在运行时修改web bean层级结构。&lt;/p&gt;
&lt;p&gt;对于那些极少见的必须手工实例化web bean的情况，则使用OAControllerImpl类中的createWebBean()工厂方法。不要直接使用web bean的构造器，不必担心要直接创建oracle.apps.fnd.framework.webui.OAWebBeanFactory，因为控制器的createWebBean()方法代理了OAWebBeanFactory。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 对于这些手工创建的beans，使用工厂方法时可以指定bean的&amp;ldquo;name&amp;rdquo;（JDeveloper中的ID属性）。避免使用deprecated的方法，它允许你在创建web bean时不指定name。web bean的名称（name）在同一个页面中必须是一个唯一标识。另外，bean的名称可能被OA Framework用于BC4J对象实例名（比如应用模块实例），因此不应该包含Java命名中规定的无效字符。&lt;/p&gt;
&lt;p&gt;比如，下面的代码描述了如何创建两个web bean并将它们添加到父区域中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OATableLayoutBean&lt;/span&gt; &lt;span class="n"&gt;tableLayout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OATableLayoutBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;findIndexedChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"tableLayout"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Create a row layout and give it the unique ID "topRow"&lt;/span&gt;
&lt;span class="n"&gt;OARowLayoutBean&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OARowLayoutBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;createWebBean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                     &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ROW_LAYOUT_BEAN&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                     &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// no need to specify a data type&lt;/span&gt;
                                                     &lt;span class="s"&gt;"topRow"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Create a row layout and give it the unique ID "bottomRow"&lt;/span&gt;
&lt;span class="n"&gt;OARowLayoutBean&lt;/span&gt; &lt;span class="n"&gt;anotherRow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OARowLayoutBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;createWebBean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                            &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ROW_LAYOUT_BEAN&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                            &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// no need to specify a data type&lt;/span&gt;
                                                            &lt;span class="s"&gt;"bottomRow"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Always check to see if a web bean exists.&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tableLayout&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

   &lt;span class="c1"&gt;// Add the two row layout beans to the table so the "topRow" renders above&lt;/span&gt;
   &lt;span class="c1"&gt;// the "bottomRow"&lt;/span&gt;
   &lt;span class="n"&gt;tableLayout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addIndexedChild&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;tableLayout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addIndexedChild&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;anotherRow&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以通过编程的方式将设计时定制的web bean关联到父区域中。比如，在下面的代码中，名为&amp;ldquo;HomeSearchRN&amp;rdquo;的stackLayout区域是在JDeveloper中定义的，但它必须通过编程的方式创建side navigation component。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OASideNavBean&lt;/span&gt; &lt;span class="n"&gt;sideNav&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OASideNavBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;createWebBean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                     &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;SIDE_NAV_BEAN&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                     &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// no need to specify a data type&lt;/span&gt;
                                                     &lt;span class="s"&gt;"sideNav"&lt;/span&gt; &lt;span class="c1"&gt;// always specify name);&lt;/span&gt;

&lt;span class="n"&gt;OAStackLayoutBean&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
   &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAStackLayoutBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;createWebBean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                    &lt;span class="s"&gt;"/oracle/apps/fnd/framework/toolbox/tutorial/webui/HomeSearchRN"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                    &lt;span class="s"&gt;"HomeSearchRN"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// always specify name&lt;/span&gt;
                                     &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// region created in Oracle JDeveloper OA Extension&lt;/span&gt;

&lt;span class="n"&gt;sideNav&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addIndexedChild&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OA Framework并不能很容易的支持通过编程的方式添加、删除、替换任何&amp;ldquo;默认（default）&amp;rdquo;区域中的子对象（比如OA Extension中的defaultSingleColumn区域是oracle.apps.fnd.framework.webui.beans.layout.OADefaultSingleColumnBean的实例）。这些区域应该通过设计的方式定义。如果绝对必须替换或删除&amp;ldquo;默认（default）&amp;rdquo;区域（不能添加item），则要遵循下面的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;调用webBean.findIndexedChildRecursive()获得要被移除或替换的子web bean。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过调用子web bean的childWebBean.getAttribute(OAWebBeanConstants.PARENT)方法获取子web bean的父对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OAWebBeanConstants.PARENT属性被用作OA Framework内部开发使用（如果查看OAWebBeanConstants的Javadoc将看到警告信息）。只可以对缺省区域使用这个入口。另外，缺省区域已经不被推荐使用（deprecated），因此不应该在新的开发中使用这这些。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行从父bean中替换或移除自己的操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;处理HTTP POST（表单提交）&lt;/h1&gt;
&lt;p&gt;在HTTP POST处理过程中，OA Framework首先检查页面的web bean层级结构是否位于它的缓存中。如果没有（资源被限制或者用户使用了浏览器的后退按钮），则OA Framework必须在处理前重新创建web bean层级结构。这意味着processRequest()中的代码被重新执行，就好像浏览器发出了一个HTTP GET请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 可能发生的重建web bean层级结构将导致产生了大量编码上的考虑，这些在Chapter 6: Supporting the Brower Back Button和OA Framework View和Controller编码规范中有完整的描述。&lt;/p&gt;
&lt;p&gt;POST的主要处理过程发生在整个web bean层级结构中的两个分开的途径中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，OA Framework将在整个web bean层级结构中递归调用web bean的processFormData()方法将form的数据写入模型。任何需要在这个处理阶段执行的代码应该添加到控制器的processFormData(OAPageContext pageContext, OAWebBean webBean)方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假设第一阶段的处理过程中没有发生异常，OA Framework处理第二阶段，在每个web bean上调用processFormRequest(OAPageContext pageContext, OAWebBean webBean)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;processFormData()&lt;/h2&gt;
&lt;p&gt;多数情况（并非所有情况）下没有理由要覆盖这个方法。实际上，使用这种方法只会在极端的情况下，而不像是在OA Framework应用中：如果区域的数据源不是一个视图对象，因此没有为各个web bean定义视图实例和属性，这时你可以在区域的processFormData()方法中编码将子web bean的数据写入适当的数据源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework在item级实现了processFormData()，但你只能在region级别覆盖它，因此如果你实现了这个方法则必须处理region中的所有item。如果是有选择性的修改，则要记得先要调用super.processFormData(OAPageContext pageContext, OAWebBean webBean)。&lt;/p&gt;
&lt;h2&gt;processFormRequest()&lt;/h2&gt;
&lt;p&gt;任何处理用户表单提交的动作属于processFormRequest()方法。&lt;/p&gt;
&lt;p&gt;下面是一个典型的processFormRequest()的代码。它描述了好何决定是哪个组件的区域表单提交（在这里是&amp;ldquo;Go&amp;ldquo;按钮），如果开始在模型中查询，如何执行一个JSP Forward回到同一个页面以便在processRequest()方法中修改web bean的属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// Always call this before adding your code&lt;/span&gt;
   &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// Pressing the Go button causes the search to be executed.&lt;/span&gt;
   &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Go"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"SearchOrder"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Created"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyOrders"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

     &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

     &lt;span class="c1"&gt;// All parameters passed using invokeMethod() must be serializable.&lt;/span&gt;

     &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt; &lt;span class="o"&gt;};&lt;/span&gt;
     &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"search"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

     &lt;span class="c1"&gt;// Now forward back to this page so we can implement UI changes as a&lt;/span&gt;
     &lt;span class="c1"&gt;// consequence of the query in processRequest(). NEVER make UI changes in&lt;/span&gt;
     &lt;span class="c1"&gt;// processFormRequest().&lt;/span&gt;

     &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setForwardURLToCurrentPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// no parameters to pass&lt;/span&gt;
                                            &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// retain the AM&lt;/span&gt;
                                            &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ADD_BREAD_CRUMB_NO&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                            &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;IGNORE_MESSAGES&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end processFormRequest();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子展示了如何使用setForwardUrl()方法传递请求参数，包括了如休替换一个已经存在的参数值（在这里，&amp;ldquo;X&amp;rdquo;将成为目标页面被&amp;ldquo;忽略（ignore）&amp;ldquo;的值）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.sun.java.util.collections.HashMap&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.bali.share.util.IntegerUtils&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// Always call this before adding your code&lt;/span&gt;
   &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;poEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poEvent"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="n"&gt;HashMap&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// Replace the current poEvent request parameter value with "X"&lt;/span&gt;
   &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poEvent"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"X"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// IntegerUtils is a handy utility&lt;/span&gt;
   &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poStep"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IntegerUtils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInteger&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;

   &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setForwardURL&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OA.jsp?page=/oracle/apps/dem/employee/webui/EmpDetailsPG"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// target page&lt;/span&gt;
                             &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// not necessary with KEEP_MENU_CONTEXT&lt;/span&gt;
                             &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;KEEP_MENU_CONTEXT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// no change to menu context&lt;/span&gt;
                             &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// No need to specify since we're keeping menu context&lt;/span&gt;
                             &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// request parameters&lt;/span&gt;
                             &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// retain the root application module&lt;/span&gt;
                             &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ADD_BREAD_CRUMB_YES&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// display breadcrumbs&lt;/span&gt;
                             &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ERROR&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// do not forward w/ errors&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如果视图对象被作为被显示的web bean的数据源，则不要移除视图对象和它的行，以及嵌套包含的应用模块。如果你需要在定向到页面之前移除这些对象，则将不会显示视图对象中数据（出于性能优化的原因），在作出移除的调用后，确保使用oracle.apps.fnd.framework.webui.OAPageContext.forwardImmediatelyOAPageContext.setforwardURL方法定向到新页面。这保证了forward动作将立即发生，当前页面中forward调用后其它的web bean将不会处理；否则，移除视图对象或行实例将导致后续处理产生不良影响。&lt;/p&gt;
&lt;h2&gt;使用不同的技术POST到OA Framework页面&lt;/h2&gt;
&lt;p&gt;如果你使用不同的技术（比如JTT页面）POST到OA Framework页面，OA Framework只会执行目录页面的processRequest段。它不执行processFormData和processFormRequest段。&lt;/p&gt;
&lt;h1&gt;与模型交互&lt;/h1&gt;
&lt;p&gt;简单来说，应该只从OA Controller中直接访问应用模块。换言之，在控制器中唯一有效的模型导入代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.OAApplicationModule&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不应该访问视图对象直接执行查询、迭代行集或与下层的实体交互。比如，下面的代码（尽管技术上是可行的）是不符合OA Framework Controller Coding Starndards的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.OAViewObject&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;...&lt;/span&gt;

   &lt;span class="c1"&gt;// Get the root application module&lt;/span&gt;
   &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRootApplicationModule&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

   &lt;span class="c1"&gt;// Find the view object you want to query&lt;/span&gt;
   &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAViewObject&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;instanceName&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要执行视图对象查询，应该按下面在&amp;ldquo;Search&amp;rdquo;区域中按下&amp;ldquo;Go&amp;rdquo;按钮的事件处理的例子的方式。&lt;/p&gt;
&lt;p&gt;首先，添加方法到应用模块中（这个例子中，它是页面的根应用模块）它接收查询，然后将它委派给视图对象执行查询（查看&lt;a href="/build_model.html"&gt;实现模型&lt;/a&gt;获取关于查询的信息）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;search&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PoSummarySimpleExpVOImpl&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPoSummarySimpleExpVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// Always check for the null condition if the VO cannot be found/created&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OBJECT_NAME"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"PoSummarySimpleExpVO"&lt;/span&gt;&lt;span class="o"&gt;)};&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_OBJECT_NOT_FOUND"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initQuery&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;orderNumber&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end search()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，添加如下的按钮处理代码到控制器中，它调用应用模块中对应的方法。&lt;/p&gt;
&lt;p&gt;注意，总是应该在processFormRequest()的代码中检查事件源；不要假设浏览器发送的POST请求是由于你的item被选中了（即使是一个只有一个按钮的简单页面）。在后台，OA Framework经常提交页面的表单，而这可能是不是你所期望的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

  &lt;span class="c1"&gt;// Check to see if the "Go" button was pressed...&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"gButton"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Get the search criteria&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"SearchOrder"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Created"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyOrders"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// All parameters passed using invokeMethod() must be serializable.&lt;/span&gt;
    &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt; &lt;span class="o"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"search"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 不要在服务端BC4J组件中调用invokeMethod()，任何你传递的参数必须是Serializable类型的。上例中展示的的invokeMethod()方法需要的参数都是字符串。如果需要传递其它对象类型，可以使用带一个类型数组参数版本的invokeMethod()。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;parameterTypes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Hashtable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt; &lt;span class="o"&gt;...};&lt;/span&gt;
&lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"search"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameterTypes&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似地，由于视图对象是实体对象的导管&amp;mdash;&amp;mdash;不应该在控制器中直接与视图对象交互&amp;mdash;&amp;mdash;也应该通过应用模块来处理实体操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如&lt;a href="/build_model.html"&gt;实现模型&lt;/a&gt;中描述的，添加到应用模块中的方法命名应该与UI&amp;ldquo;事件（events）&amp;ldquo;对应。比如，如果用户按了&amp;ldquo;Create&amp;rdquo;按钮，应用模块方法应该命名为&amp;ldquo;create&amp;rdquo;等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建的实例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"create"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;删除的实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个例子展示了调用共享区域中的嵌套应用模块中的delete方法而不是调用页面根应用模块中的方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"DeleteYesButton"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// User has confirmed that she wants to delete this purchase order.&lt;/span&gt;
   &lt;span class="c1"&gt;// Invoke a method on the AM to set the current row in the VO and&lt;/span&gt;
   &lt;span class="c1"&gt;// call remove() on this row.&lt;/span&gt;

   &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;poHeaderId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poHeaderId"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;poHeaderId&lt;/span&gt; &lt;span class="o"&gt;};&lt;/span&gt;

   &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"delete"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

 &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;自定义动作实例（&amp;ldquo;Approve&amp;rdquo;）&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Approve"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"approve"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;提交操作实例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// Simply telling the transaction to commit will cause all the Entity Object validation&lt;/span&gt;
   &lt;span class="c1"&gt;// to fire.&lt;/span&gt;
   &lt;span class="c1"&gt;//&lt;/span&gt;
   &lt;span class="c1"&gt;// Note: there's no reason for a developer to perform a rollback. This is handled by&lt;/span&gt;
   &lt;span class="c1"&gt;// the OA Framework if errors are encountered during the processFormData phase.&lt;/span&gt;

   &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"apply"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;禁用校验&lt;/h1&gt;
&lt;p&gt;有多个机会可以屏蔽在处理OA Framework HTTP POST过程中的校验。比如，实现表格中的&amp;rdquo;Add Another Row&amp;ldquo;中，在用户添加新行的操作时，可能不需要因为未填写完整的行数据而显示错误信息。同样，你可能在一个多步骤的页面流中想要将校验延时到最后一个预览提交页面，或者通过tabs导航到同一个下层对象的不同视图上时。&lt;/p&gt;
&lt;h2&gt;禁用服务端校验&lt;/h2&gt;
&lt;p&gt;为了阻止从模型校验逻辑中抛出异常，在页面中与下面列表对应的bean上调用setServerUnvalidated(true)方法（记住在processRequest()方法中添加修改web bean的代码）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OASubmitButtonBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OATableBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAAdvancedTableBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OASubTabLayoutBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OANavigationBarBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OADefaultHideShowBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAHideShowHeaderBean&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 也可以在设计时设置组件的Disable Server Side Validation属性为True，也可以为那些配置为提交表单的链接或图标设置禁用校验。查看下面的Javascript URL一节获得更多信息。&lt;/p&gt;
&lt;p&gt;当用户执行一个由这些bean导致的表单提交时，OA Framework按上面描述的方式执行所有的HTTP POST处理&amp;mdash;&amp;mdash;包括执行属性级别的校验逻辑（实体级别的校验没有被执行）。如果在处理processFormData()过程中抛出了oracle.apps.fnd.framework.OARowValException或oracle.apps.fnd.framework.OAAttrValException异常（功它们被deprecated的子类），OA Framework只是简单的忽略这些异常，并继续执行就像没有遇到异常一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework不会忽略processFormData()中的严重异常（比如NullPointerException）。这些会按正常的方式显示出来，并且不会继续处理processFormRequest()。而且processFormRequest()中由你或者由BC4J抛出的异常都会被正常的显示出来。&lt;/p&gt;
&lt;h2&gt;禁用客户端校验&lt;/h2&gt;
&lt;p&gt;当一个带的客户输入的数据的表单提交时，UIX执行一些基础的onSubmit JavaScript校验（它校验必填字段，数据类型和格式），如果校验通过就提交表单。为了屏蔽校验，也需要在上节&amp;ldquo;禁用服务端校验&amp;rdquo;中的bean列表中的bean上调用setUnvalidated(true)方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 也可以在设计时设置组件的Disable Server Side Validation属性为True，也可以为那些配置为提交表单的链接或图标设置禁用校验。查看下面的Javascript URL一节获得更多信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 对于tables和HGrid组件，必须通过设置table和HGrid区域自己的属性启用／禁用客户端校验，因为你不能直接访问OANavigationBarBean的用作数据集导航的子web bean。注意，现在不能禁用这些组件的服务端校验。&lt;/p&gt;
&lt;h1&gt;错误处理&lt;/h1&gt;
&lt;p&gt;OA Framework自动显示模型层抛出的任何错误信息；不需要在控制器中做什么就能处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查看Error Handling获取更多关于在控制器中抛出异常和在页面顶端显示错误、警告、确认信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看Chapter 4: Dialog Pages获取关于显示模型错误、警告、确认和信息的对话框页面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;JavaScript&lt;/h1&gt;
&lt;p&gt;UIX和OA Framework正在快速的添加新的功能以提供更好的用户体验（区域页面渲染、自动的表格统计等等）。当这些功能发布后，你将受益于这些功能，但是，在这之前你不应该自己实现这些功能。&lt;/p&gt;
&lt;p&gt;简单来说，Javascript在OA Framework开发团队外是被禁止的。&lt;/p&gt;
&lt;h2&gt;JavaScript URL&lt;/h2&gt;
&lt;p&gt;以前，如果需要配置链接或图像来提交页面表单（由于你需要在导航到新页面前处理事件），可以将它设置在UIX submitForm Javascript函数中。&lt;/p&gt;
&lt;p&gt;现在，应该配置fireAction事件来代替使用Javascript URL。查看Declarative Submit Form文档获取其它信息。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>OA Framework状态管理</title><link href="/oa-frameworkzhuang-tai-guan-li.html" rel="alternate"></link><published>2008-07-25T00:00:00+08:00</published><updated>2008-07-25T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-25:/oa-frameworkzhuang-tai-guan-li.html</id><summary type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;这个文档用于描述OA Framework状态管理架构，包括缓存应用系统用户数据和从页面间值传递的机制。&lt;/p&gt;
&lt;h1&gt;结构预览&lt;/h1&gt;
&lt;p&gt;主要状态管理组：&lt;/p&gt;
&lt;p&gt;&lt;img alt="state_architecture" src="/oaf_state/state_architecture.gif"/&gt;&lt;/p&gt;
&lt;h1&gt;根应用模块（数据库会话和事务状态）&lt;/h1&gt;
&lt;p&gt;如&lt;a href="/page.html"&gt;OA Framework 页面解析&lt;/a&gt;一文中描述的，每个OA Framework页面与一个根应用模块关联，根应用模块提供事务环境和JDBC数据库连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework中，一个数据库会话与一个JDBC连接关联。&lt;/p&gt;
&lt;p&gt;根应用模块是任何OA Framework模块的中枢，因为核心应用数据（存储在BC4J视图，实体对象，等等）和页面web bean层级结构自动缓存于根应用模块的oracle.apps.fnd.framework.OADBTransaction对象中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 使用浏览器后退按钮将导致应用模块状态丢失。可以查看Supporting the Browser Back Button一文。&lt;/p&gt;
&lt;p&gt;任何存储于事务中的数据可以被任何共享同一个根应用模块实例的页面访问（在页面间导航时使用下面描述的方式保留应用模块）。OA Framework提供了方法用于从事务中存储、获取和移除值。可以在控制器（client）和模型（server）代码中访问单一的事务对象，这些工具在oracle …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;这个文档用于描述OA Framework状态管理架构，包括缓存应用系统用户数据和从页面间值传递的机制。&lt;/p&gt;
&lt;h1&gt;结构预览&lt;/h1&gt;
&lt;p&gt;主要状态管理组：&lt;/p&gt;
&lt;p&gt;&lt;img alt="state_architecture" src="/oaf_state/state_architecture.gif"/&gt;&lt;/p&gt;
&lt;h1&gt;根应用模块（数据库会话和事务状态）&lt;/h1&gt;
&lt;p&gt;如&lt;a href="/page.html"&gt;OA Framework 页面解析&lt;/a&gt;一文中描述的，每个OA Framework页面与一个根应用模块关联，根应用模块提供事务环境和JDBC数据库连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework中，一个数据库会话与一个JDBC连接关联。&lt;/p&gt;
&lt;p&gt;根应用模块是任何OA Framework模块的中枢，因为核心应用数据（存储在BC4J视图，实体对象，等等）和页面web bean层级结构自动缓存于根应用模块的oracle.apps.fnd.framework.OADBTransaction对象中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 使用浏览器后退按钮将导致应用模块状态丢失。可以查看Supporting the Browser Back Button一文。&lt;/p&gt;
&lt;p&gt;任何存储于事务中的数据可以被任何共享同一个根应用模块实例的页面访问（在页面间导航时使用下面描述的方式保留应用模块）。OA Framework提供了方法用于从事务中存储、获取和移除值。可以在控制器（client）和模型（server）代码中访问单一的事务对象，这些工具在oracle.apps.fnd.framework.webui.OAPageContext(controller中)和OADBTransaction(model中)类可以访问。&lt;/p&gt;
&lt;h2&gt;根应用模块保留&lt;/h2&gt;
&lt;p&gt;缺省情况下，当用户从一个页面导航到另一个页面（比如使用GET请求或JSP forward）时，OA Framework渲染新的页面，与前一个页面关联的应用模块实例被&amp;ldquo;释放&amp;rdquo;，一个新的实例请求被发送到应用模块池。&lt;/p&gt;
&lt;p&gt;导航到新的页面时，缺省情况下的原页面的根应用模块将被释放：&lt;/p&gt;
&lt;p&gt;&lt;img alt="root_am_default" src="/oaf_state/root_am_default.gif"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework在表单提交（POST）期间不会释放应用模块，除非你显式的在控制器中释放应用模块。比如，如果用户对表格中的数据排序或在表格数据中导航&amp;mdash;&amp;mdash;两个动作隐式的提交了页面表单&amp;mdash;&amp;mdash;页面的根应用模块实例被自动保留。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在页面间保留应用模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在多个页面处理同一个任务时相关的页面需要参与同一个虚拟事务。这时，不同页面需要关联到同一个根应用模块实例。&lt;/p&gt;
&lt;p&gt;相关页面共同同一个根应用模块（和事务）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="root_am_retain" src="/oaf_state/root_am_retain.gif"/&gt;&lt;/p&gt;
&lt;p&gt;为达到这个目的，必须执行下面的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;申明各个页面关联同一个类型的根应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置应用模块的保留标记。通过指定URL参数retainAM=y设置模块保留标记。对于GET请求。当新的页面被渲染时（注意，OA Framework对于POST请求将一直保留应用模块而不管retainAM参数的值）。如果设置为&amp;ldquo;Y&amp;rdquo;，前一个页面的应用模块实例将被保留。如果设置为&amp;ldquo;N&amp;rdquo;（或不指定，缺省为&amp;ldquo;N&amp;ldquo;），OA Framework将释放所有应用模块&amp;mdash;&amp;mdash;包括到达这点前任何可能显式申明为保留的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也可以在调用JSP forward OAPageContext中的方法时设置这个参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 不能简单的让不同页面关联相同的根应用模块。如果忘记设置retainAM标记，每个页面仍将使用不同的应用模块实例和事务，即使这些页面关联的是同一个类型的应用模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 技术上来说，这依赖于应用模块池的状态。Page B可能获取到与Page A使用的同一个物理应用模块。但是，对象的状态将完全被重置，就像被新创建的一样。从这个观点来看，可以看作一个&amp;ldquo;新的实例&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;两个页面引用相同类型的应用模块，但没有设置Retain AM标记：&lt;/p&gt;
&lt;p&gt;&lt;img alt="root_am_noretainproblem" src="/oaf_state/root_am_noretainproblem.gif"/&gt;&lt;/p&gt;
&lt;p&gt;同样，将retainAM标记设置为&amp;ldquo;Y&amp;ldquo;&amp;mdash;&amp;mdash;但没有将页面的根应用模块设置为相同的类型。这将产生不同的应用模块实例（每个页面一个），各自有自己的事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有条件的保留和释放应用模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有些情况下，你需要通过一个条件来决定是否保留或释放应用模块。这时，你可以让应用模块实现oracle.apps.fnd.framework.webui.OAReleaseListener接口，详细描述见Javadoc。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; Oracle Application开发人员应该在使用这个接口时通知OA Framework开发团队。不正确的使用这个接口将导致内存泄漏。OA Framework团队正在跟踪这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显式的释放应用模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以显式的通过代码在OA Framework处理之前释放根应用模块。可以在页面控制器中调用OAPageContext.releaseRootApplicationModule()方法，OA Framework将在页面渲染完成后尽快释放这个页面的根应用模块，而不是等到下次应用模块请求时。&lt;/p&gt;
&lt;h2&gt;根应用模块保留的使用场景&lt;/h2&gt;
&lt;p&gt;下列情况下推荐保留／释放应用模块。&lt;/p&gt;
&lt;p&gt;情况 || 推荐操作
无关的分离的任务 | 当导航到两个不相关的页面时不保留应用模块。比如一连串的不相关的管理任务，它们是独立运行的（即使这们与同一个菜单项目关联），保留应用模块是不必要的。
多页面流 | 当在相关的页面间导航时，这些页面合作完成同一个完整的任务处于单个事务中时，保留应用模块
相关页面（虚拟事务） | 当在关联同一个业务对象（即使页面为用户设置了不同的提交点）的不同任务间的相关页面间导航时，如果UI关联得比较紧密则保留应用模块。比如，一个模块可以查询、查看、更新、删除、打印写单则应该使应用模块保留
多页面流中使用分支事务 | 有一个多页面流使用了分支事务，比如，在创建定单时创建供应商时，在主流程中保留应用模块，而在创建供应商的页面使用OAPageContext.releaseRootApplicationModule方法释放模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在介绍OA Framework的钝化和JDBC池化/回收之前，鼓励开发人员经常的释放应用模块，因为保留JDBC连接是一个昂贵的开销。在了解钝化功能后这不再是个问题。&lt;/p&gt;
&lt;h1&gt;Servlet Session&lt;/h1&gt;
&lt;p&gt;可以在servlet session中缓存小型的，可序列化的对象（OA Framework限定为字符串，数字和日期类型）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 使用session缓存那些需要在多个页面设置或访问的简单值，这些页面可以有不同的根应用模块。（事务缓存不在这个范围内）。由于session变量失效时间较长，且没有好的事件可以释放内存，因此应该把session作为最后一种缓存选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 隐藏域通常不被推荐使用。因此，OA Framework当前的菜单实现（一些菜单发送GET请求而不是POST请求），并不总是能在用户点击菜单时添加额外的值，根应用绑定是交叉的。&lt;/p&gt;
&lt;p&gt;可以使用OAPageContext put&lt;em&gt;()，get&lt;/em&gt;()和remove*()方法访问session变量值。&lt;/p&gt;
&lt;h1&gt;Oracle 应用用户Session&lt;/h1&gt;
&lt;p&gt;当用户登录到OA Framework application时，OA Framework将创建一个AOL/J oracle.apps.fnd.comn.WebAppsContext对象和一个基于session的浏览器cookie以跟踪Oracle Application context信息的key。Oracle Application context中的信息包括当前的责任，组织机构id和用户的各种属性，比如：用户名，用户id，雇员id等等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cookie包含了一个加密的key用于标识存储于Application数据库中的一个session行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每次请求时WebAppsContext获取这个key的值，并使用它查询当前session状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Oracle Application用户session与一个servlet session关联，但是它有自己的生命周期和超时特性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常，Oracle Application用户session的生存时间比servlet session更长。servlet session超时快一些。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个Oracle Application用户session可能关联到多个servlet session中。比如，当用户在创建开支报表时，打电话的过程中servlet session超时了，然后在Oracle Application用户session超时前恢复工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果Oracle Application用户session超时了，只要用户没有关闭浏览器窗口（因此基于浏览器session的coolie并没有丢失）并且没有人删除ICX_SESSION表中相应的session行，用户可以在提示登录后重新登录并恢复她之前停止时的事务点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你需要访问任何存储于Oracle Application user session的信息，可以从OAPageContext(在控制器代码中)或OADBTransaction（在模型代码中）获得。&lt;/p&gt;
&lt;h2&gt;应用状态（Application Context State）&lt;/h2&gt;
&lt;p&gt;当不同访问OAPageContext（Java服务层代码或PL/SQL）时，可以使用Application context存储一些状态信息。使用WebAppsContext.setSessionAttribute(java.lang.String pName,java.lang.String pValue)方法。&lt;/p&gt;
&lt;h1&gt;页面环境（Page Context）&lt;/h1&gt;
&lt;p&gt;每次请求接收一个页面时，OA Framework创建一个OAPageContext并持续到新页面处理完成。明确，OAPageBean的主要能力是在页面后面处理创建OAPageContext。&lt;/p&gt;
&lt;h2&gt;请求和页面边界&lt;/h2&gt;
&lt;p&gt;web应用的工作单元是一个请求／响应对：浏览器提交一个请求，servlet处理请求并返回一个响应。发送一个响应表示单个请求的结束，或者说一个已经完成的请求和一个新请求之间的&amp;ldquo;边界&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;同样，当OAPageBean完成一个页面处理时，这就是当前页面和新页面的&amp;ldquo;边界&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;因此，在下面的简单场景中当用户从Page X转到Page A然后再转到Page B，这里有两个请求边界：第一个是Page X和Page A之间，第二个位于Page A和Page B之间。这里也有两个页面边界位于Page X和Page A，Page A和Page B之间。&lt;/p&gt;
&lt;p&gt;请求和页面边界相同：&lt;/p&gt;
&lt;p&gt;&lt;img alt="boundary_case1" src="/oaf_state/boundary_case1.gif"/&gt;&lt;/p&gt;
&lt;p&gt;有些情况下，请求和页面边界是不相同的。比如下面的JSP Forward情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户如上面的图中所示的，从Page X导航到Page A。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当在Page A上时，用户选择了一个控件，Page A的代码在决定在响应中显示哪个页面前进行计算。浏览器发出请求到Page A，OA Framework进行处理，并为页面创建了一个OAPageContext。一旦Page A的处理完成后，第一个页面的边界到达了，已经如下面的图所示的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Page A的代码中，开发人员执行用户选择的控件并发出JSP Forward到Page B。而不是在这时提供了一个HTTP响应，因为我们不想显示Page A，OA Framework首先处理Page B，并为这个页面创建一个新的OAPageContext对象。一旦Page B的处理完成，第二个页面边界到达。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于Page B现在必须显示给用户了，一个HTTP响应被发送给浏览器。这时响应边界到达了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在JSP Forward情况下，请求界面和页面界面不同：&lt;/p&gt;
&lt;p&gt;&lt;img alt="boundary_case2" src="/oaf_state/boundary_case2.gif"/&gt;&lt;/p&gt;
&lt;p&gt;明确这个区别是很重要的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求参数生存于请求生命周期中，它可以跨越多个页面边界。想像下面的情况：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户选择了Page X中的一个链接导航到Page A。Page A的URL包含了参数foo=bar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Page A请求JSP Forward到Page B。现在，尽管已经在新页面中了，但请求仍然包含了foo=bar。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你不希望请求参数在执行JSP Forward后仍然存在，你必须的替换它。比如，在调用OAPageContext.setForward*()之前，简单的重新设置foo=X。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 不能从请求中移除参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 比较好的处理方式是将参数值设置为一个不需要的值，这样代码可以忽略它。而不要简单的将值设置为""。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于page context和request不是一一对应的，一些人可以会对从OAPageContext中访问请求参数觉得迷惑。只要记住每个页面是一个独立的实体，从它的观点来看，OAPageContext表现了request。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当了钝化的细节后，将更清楚明白页面和请求边界的区别，甚至是受钝化的影响也不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;请求Request&lt;/h1&gt;
&lt;p&gt;对每个HTTP request都将创建一个请求对象。这个对象包含下面的应用状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;任何URL参数，不论是POST或GET请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果浏览器发出一个POST请求：任何form字段值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果浏览空对空发出POST请求：web bean和事件名称与用户选择的动作或控件组件关联。比如：如果用户选择了&amp;ldquo;GO&amp;rdquo;按钮执行一个查询，请求将包含以这个按钮命名的web bean，以便你能获取到是这个按钮被按下了而做出响应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用OAPageContext getParameter*()方法获取任何请求值。不能直接与request对象交互。&lt;/p&gt;
&lt;p&gt;设置request变量值（首选的两个页面间通讯的方法）时，你可以使用下面介绍的方法。参考视图实现和控制器实现的相关信息。&lt;/p&gt;
&lt;h2&gt;使用隐藏域&lt;/h2&gt;
&lt;p&gt;可以在JDeveloper中设置域的style属性为formValue。运行时，是使用oracle.apps.fnd.framework.webui.beans.form.OAFormValueBean来实现的。&lt;/p&gt;
&lt;h2&gt;在JSP Forward或客户端重定向时指定值&lt;/h2&gt;
&lt;p&gt;当显式的forward到新页面时，使用OAPageContext setForward*()方法或调用OAPageContext.sendRedirect()请求客户端重定时，可以随意设置请求的参数值。&lt;/p&gt;
&lt;h2&gt;调用OAPageContext.putParameter()指定参数值&lt;/h2&gt;
&lt;p&gt;OAPageContext包含了一个putParameter()方法，它可以在页面是过程中传递值到web bean结构中。通过调用putParameter()指定的值技术上来说并不是加到request中的，而是存储于特殊的页面缓存中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 可以把这个方法与servlet 2.1 API中的HttpServletRequest.setAttribute()方法等同起来。&lt;/p&gt;
&lt;h2&gt;申明URL参数&lt;/h2&gt;
&lt;p&gt;可以在JDeveloper中开发时指定URL参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; URL长度是受限的；对于添加大量URL参数要谨慎注意它的长度。由于URL对于用户是可见的，要注意加密敏感的数据。&lt;/p&gt;
&lt;h1&gt;状态持久化模型（'钝化Passivation'）&lt;/h1&gt;
&lt;p&gt;OA Framework应用主要是事务导向的。许多事务跨越了多个页面，这些页面的事务需要某种机制保持到用户完成相关的任务。&lt;/p&gt;
&lt;p&gt;HTTP协议天生就是无状态的；它不保留任何应用状态信息或保证状态的持久化。甚至，即使是在JVM实例提供的servlet session失败或servlet session超时后，应用状态也将丢失，挂起的事务也不能恢复。&lt;/p&gt;
&lt;p&gt;OA Framework具有透明的保存和恢复客户端状态的能力&amp;mdash;&amp;mdash;即使servlet session超时（未来的版本将提供JVM失效的支持）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将应用状态保存到辅助介质上的过程叫作钝化（passivation）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从辅助介质上恢复状态的过程叫作激活（activation）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OA Framework当前提供了下面的状态管理功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可伸缩的应用当资源占用比较高的情况下，需要为新的服务线程创建新的资源，OA Framework将保存挂起的线程的状态并回收它们的资源以供其它用户使用。当挂起的用户线程被唤醒后，保存的应用状态被恢复。简单来说，内在被重新分配给JDBC连接，应用模块，用户session而不会影响用户的使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Servlet session超时恢复servlet session允许超时，而不需要强制用户启动一个新的事务。（将来，这个功能将扩展为支持中间层失效）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;应用模块池&lt;/h1&gt;
&lt;p&gt;为提高性能和可伸缩性，OA Framework池化（缓存和重用）应用模块。重用比重新创建更有效。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个JVM有一个应用模块池管理器，它包含并管理各个应用模块池。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个应用模块池包含多个同一应用模块的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用模块池中的实例被设计为可以置为可用或不可用（现在被称为"checked out"）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有根应用模块被池化；嵌套的应用模块不会被池化为根应用模块的子应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用模块池：&lt;/p&gt;
&lt;p&gt;&lt;img alt="am_pool" src="/oaf_state/am_pool.gif"/&gt;&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>OA Framework应用构建之——创建属性集</title><link href="/build_attrsets.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/build_attrsets.html</id><summary type="html">&lt;h1&gt;设计属性集&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt; 这节是为Oracle EBS开发者内部使用的。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;设计属性集&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt; 这节是为Oracle EBS开发者内部使用的。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>OA Framework应用构建之——实现模型</title><link href="/build_model.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/build_model.html</id><summary type="html">&lt;h1&gt;设计模型对象&lt;/h1&gt;
&lt;h2&gt;客户／服务代码分离&lt;/h2&gt;
&lt;p&gt;在OA Framework的MVC框架中，OA Framework划出了客户端和服务端类的清析界限，典型的JSP应用有3个物理层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浏览器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;web应用服务（中间层包含UI web bean结构和应用业务逻辑）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库服务器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在中间层OA Framework对&amp;ldquo;客户端&amp;rdquo;和&amp;ldquo;服务端&amp;rdquo;类划出了界限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端类（视图类和控制器代码）驱动HTML用户界面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端类（模型代码）支持任何客户端（不只是OA Framework）用户界面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个区别是非常重要的，它保证了从不同客户端访问服务代码的能力。&lt;/p&gt;
&lt;p&gt;OA Framework&amp;ldquo;洋葱形&amp;rdquo;的代码层次边界：&lt;/p&gt;
&lt;p&gt;&lt;img alt="onion" src="/oaf_build_model/onion.gif"/&gt;&lt;/p&gt;
&lt;p&gt;通常可以在这些边界征用，对象引用下层的数据流，而不会引用上层的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;模型代码不应该直接引用控制器代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要在客户端引用或导入任何服务端的实现类或接口（位于oracle.apps.fnd.framework.server包中的类和接口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要服务端代码执行一些操作，应该一直通过使用根应用模块接口（oracle.apps.fnd …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;设计模型对象&lt;/h1&gt;
&lt;h2&gt;客户／服务代码分离&lt;/h2&gt;
&lt;p&gt;在OA Framework的MVC框架中，OA Framework划出了客户端和服务端类的清析界限，典型的JSP应用有3个物理层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浏览器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;web应用服务（中间层包含UI web bean结构和应用业务逻辑）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库服务器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在中间层OA Framework对&amp;ldquo;客户端&amp;rdquo;和&amp;ldquo;服务端&amp;rdquo;类划出了界限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端类（视图类和控制器代码）驱动HTML用户界面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端类（模型代码）支持任何客户端（不只是OA Framework）用户界面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个区别是非常重要的，它保证了从不同客户端访问服务代码的能力。&lt;/p&gt;
&lt;p&gt;OA Framework&amp;ldquo;洋葱形&amp;rdquo;的代码层次边界：&lt;/p&gt;
&lt;p&gt;&lt;img alt="onion" src="/oaf_build_model/onion.gif"/&gt;&lt;/p&gt;
&lt;p&gt;通常可以在这些边界征用，对象引用下层的数据流，而不会引用上层的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;模型代码不应该直接引用控制器代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要在客户端引用或导入任何服务端的实现类或接口（位于oracle.apps.fnd.framework.server包中的类和接口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要服务端代码执行一些操作，应该一直通过使用根应用模块接口（oracle.apps.fnd.framework.OAApplicationModule）调用根应用模块的通用远程方法调用invokeMethod()方法，或者为你的应用模块创建一个接口，以便于在编译时检查方法的调用。应用模块可以代理或实现所需要的逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OAApplicationModule接口位于oracle.apps.fnd.framework包中，所有位于这个包中的类、接口、异常都可以在客户端和服务端代码中使用&lt;/p&gt;
&lt;p&gt;如果选择为你的应用模块创建接口而不是使用invokeMethod()方法，应该在应用模块所在包的直接上级包中创建。比如，为oracle.apps.fnd.framework.toolbox.labsolution.server.EmployeeAMImpl所创建的接口EmployeeAM应该位于oracle.apps.fnd.framework.toolbox.labsolution包中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;永远不要直接在客户端代码中包含JDBC或其它服务端处理的代码。如果UI客户端需要服务端的信息，它应该通过应用模块，由应用模块代理或实现适当的响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;保持编码规范一致&lt;/h2&gt;
&lt;p&gt;阅读下面的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Oracle Application Java Coding Standards&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Oracle Framework Nameing/File/Package/Directory Structure Standards&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Oracle Framework Model Coding Standards&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;推荐的构建方法&lt;/h1&gt;
&lt;p&gt;编写OA Framework应用模块时，按下面的流程编写会简单一些。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建BC4J模型对象所需要的业务组件包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现公布的BC4J应用模块，实体对象，实体关联对象和页面所需要的视图对象和视图链接义。将视图对象添加到根应用模块中。这一步不要担心编写代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建应用的菜单定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为页面创建OA用户界面组件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建和实现控制器代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为页面实现UI应用模块代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现实体对象业务逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;业务组件包&lt;/h1&gt;
&lt;p&gt;包有BC4J模型组件必须属于业务组件包（Business Components(BC4J)）。&lt;/p&gt;
&lt;p&gt;如果要修改已经存在的BC4J包使用的数据库连接，可以如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择OA Project中的业务组件包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右键，选择Edit Business Components Project。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Business Componets Project Wizard中，选择Connection。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定新的数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择OK保存修改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;实体对象&lt;/h1&gt;
&lt;p&gt;实体对象为指定的表、视图或同义词实现业务规则。实体对象被确定为用于多种客户端，应该处理与表相关的校验和行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个表应该只有至多一个实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实体对象应该在它的属性中包含表中的所有列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以创建自己的公用实体对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常需要为实体添加对象初始化，属性校验，实体级的验证和其它功能性的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也可以在综合性的业务对旬中创建"entity expert"的单例对象用于在多个相关实体对象间共享。比如，定购单有定单头、定单行和销售信息。其它相引用的实体可以使用entity expert来执行轻量的校验（比如，定单可能需要使用供应商的entity expert检查自己所使用供应商id是否有效）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，你可以根据需要为模型代码创建"helper"对象和接口。比如，在OA Framework的ToolBox教程中，你可以创建一个或多个helper对象在多种实体对象上执行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;实体关联（关联对象）&lt;/h1&gt;
&lt;p&gt;关联可以创建实体之间的关系。在运行时，BC4J使用这些关系来协调相关的对象。有两种基本类型的关联：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;聚合 这是强关联，源实体对象拥有目标实体对象。也就是说，目标不能离开源对象独立存在。比如，定单头由多个行组成，离开它们的头信息后就没有含义了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用 这是弱关联，源对象只引用目标实体。比如，定单引用供应商，但供应商在没有被定单引用的时候仍然可以存在。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;聚合关系适合于在运行时创建、初始化和管理。BC4J自动将聚合作为一个逻辑单元。比如，定单对象将在修改它的条目时被锁定。&lt;/p&gt;
&lt;p&gt;引用关系适合于在运行时候修改、引用。比如，在定单和供应商之间建立关联，如果在编辑定单时可以修改供应商，并不需在供应商和货品条目间建立关联。&lt;/p&gt;
&lt;h2&gt;编程控制&lt;/h2&gt;
&lt;p&gt;关联对象没有代码，并不需要为它们编写代码。&lt;/p&gt;
&lt;h1&gt;视图对象和视图行&lt;/h1&gt;
&lt;p&gt;视图对象包含了数据库查询，通过它可以访问相关的实体对象。关于视图对象的设计的重要决策就是它是应该基于SQL还是实体对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有锁碎的UI视图对象，比如Lists of Values (LOV)和poplists等基于SQL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有验证性的视图对象，用于为实体对象实现简单业务规则的基于SQL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为UI创建的视图对象，不管它们是否可以更新，应该基于实体对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于性能的原因，视图对象需要被优化。在一些UI组件中，创建多个小型的处理特定任务的视图对象优于共同一个单一的大型的视图对象。视图对象应该是为UI而定制的。&lt;/p&gt;
&lt;p&gt;只要可能就应该避免使用动态WHERE子句（视图对象支持用编程的方式修改它的定义）。如果可能，为相同的SELECT定义3个不同的视图对象，每个带一个WHERE子句，用于在运行时绑定。但是，在复杂查询时修改WHERE子句是合适的，因为不可能为所有可能的查询定义独立的视图对象。&lt;/p&gt;
&lt;p&gt;视图对象，与任何BC4J对象一样，可以用申明的方式或编程的方式创建。基于性能的原因，如果可以的话通过申明的方式定义视图对象。&lt;/p&gt;
&lt;p&gt;所有视图对象都是oracle.apps.fnd.framework.server.OAViewObjectImpl的子类。&lt;/p&gt;
&lt;p&gt;视图对象有SQL视图对象，实体视图对象和混合视图对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主键&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几个所有视图对象都需要主键。可以在定义属性时指定主键，或者通过编程的方式调用OAViewObjectImpl类的setKeyAttributeDefs()方法设置主键。&lt;/p&gt;
&lt;h2&gt;编程控制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;查询处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个视图对象都实现了查询，如果需要，它应该能够翻译传递进来的参数，并将它绑定到WHERE子名中的变量上。在编码上通常处理这个工作的方法被命名为initQuery()或其它类似initNameEmployeesQuery()之类的&amp;ldquo;init&amp;rdquo;方法上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 必须使用Oracle风格的参数绑定方式（FOO &amp;gt;= :1）而不是ANSI风格的（FOO &amp;gt;=?）。尽管代码只复杂一点点，OA Framework团队计划在Fusion版本中不支持ANSI风格的绑定。&lt;/p&gt;
&lt;p&gt;下面是修改WHERE子名和绑定查询条件的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Initialize and execute the querypublic void initQuery(String name, String onHold, String number){       StringBuffer whereClause = new StringBuffer(100);   Vector parameters = new Vector(3);   int clauseCount = 0;   int bindCount = 0;       setWhereClauseParams(null); // Always reset&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;()))))&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" NAME like :"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(++&lt;/span&gt;&lt;span class="n"&gt;bindCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;"%"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;clauseCount&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;()))))&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;

     &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;supplierId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

     &lt;span class="c1"&gt;// SUPPLIER_ID is a NUMBER; datatypes should always&lt;/span&gt;
     &lt;span class="c1"&gt;// match, and the parameter passed to this method is a&lt;/span&gt;
     &lt;span class="c1"&gt;// String.&lt;/span&gt;
     &lt;span class="k"&gt;try&lt;/span&gt;
     &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;supplierId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="o"&gt;}&lt;/span&gt;
     &lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;

     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clauseCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" AND "&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="o"&gt;}&lt;/span&gt;

     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" SUPPLIER_ID = :"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(++&lt;/span&gt;&lt;span class="n"&gt;bindCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supplierId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;clauseCount&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;onHold&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;onHold&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;()))))&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clauseCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" AND "&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="o"&gt;}&lt;/span&gt;

     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" ON_HOLD_FLAG = :"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(++&lt;/span&gt;&lt;span class="n"&gt;bindCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Y"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;clauseCount&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="n"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;toString&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bindCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bindCount&lt;/span&gt;&lt;span class="o"&gt;];&lt;/span&gt;

     &lt;span class="c1"&gt;// the copyInto() is 1.1.8 compliant which, as of 4/02/03, is required by ARU&lt;/span&gt;

     &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;copyInto&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;setWhereClauseParams&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
 &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end initQuery( )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;业务逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;视图对象不适合放置业务逻辑；不应该在视图对象或视图行对象编写校验规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视图行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管应该总是创建视图行对象，但很大程度上，你不需要编写视图行代码。视图行代码用于需要计算临时属性的的情况下。比如，你不能或不希望在查询中包含逻辑（可能性能开销太大）。你可以使用视图行代码执行简单的校验或添加用于UI的临时性变量，或者调用实体对象的自定义方法。&lt;/p&gt;
&lt;p&gt;自定义视图行方法不能直接从客户端访问。客户端必须先在应用模块中调用一个方法，由它将任务委派给视图对象。由视图对象来访问视图行。此外，对于有视图行类的应该使用生成的setter/getter方法。因为它比调用通用的setAttribute("&lt;attributename&gt;")和getAttribute("&lt;attributename&gt;")更快。&lt;/attributename&gt;&lt;/attributename&gt;&lt;/p&gt;
&lt;h1&gt;视图链接&lt;/h1&gt;
&lt;p&gt;与上面描述过的实体关联类似。视图链接定义了两个视图间的关系，通过它BC4J能自动从当前的源视图对象查询到相对应的目标视图对象。&lt;/p&gt;
&lt;p&gt;视图链接可以基于关联对象或者申明两个视图对象间的join链接。比如，两个表有基于外键的主从关系。相应的实体对象通过关联对象关联，基于这两个实体的视图对象可以通过基于关联对象的视图链接相关联。&lt;/p&gt;
&lt;p&gt;尽管视图链接可以非常方便，但在web应用页面上应该保守的使用。因为它缓存了主表和从表的记录，当用户从一个主表记录移到另一个主表记录时，这个开销可能相当大。使用视图链接通常只在下面的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当特定的beans（比如HGrid）需要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你有一个可更新的主／从视图对象（在同一个页面或不同的页面），这们下面的实体对象是使用 &lt;strong&gt;&lt;em&gt;聚合&lt;/em&gt;&lt;/strong&gt; 关联的， &lt;strong&gt;&lt;em&gt;你必须在他们之间定义视图链接&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你在同一个页面上有一个只读的主／从视图对象时，导航到一个主记录行的时候将导致自动查询子对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;编程控制&lt;/h2&gt;
&lt;p&gt;由于视图链接没有实现类，所以不需要编写代码。&lt;/p&gt;
&lt;p&gt;但可以使用oracle.jbo.ApplicationModule.createViewLinkBetweenViewObjects动态创建视图对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 编程方式产生的视图链接中的主／从视图对象必须属于同一个应用模块实例。&lt;/p&gt;
&lt;h1&gt;应用模块&lt;/h1&gt;
&lt;p&gt;这里介绍的是应用模块创建／重用的基础。&lt;/p&gt;
&lt;h2&gt;应用模块使用&lt;/h2&gt;
&lt;p&gt;下面列出来在应用中的应用模块的承担的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UI根应用模块（UI Root Application Module）为一个或多个相关的UI页面建立事务环境。每个页面有一个根应用模块它可以包含任何视图对象或这个页面使用的嵌套应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UI共同区域应用模块（UI Shared Region Application Module）任何用于在多个页面使用的UI区域（region）应该包含自己的应用模块。当这个区域在页面中使用时，OA Framework自动嵌套于页面的根应用模块之下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UI List of Values Application Module这是前一个角色中的一种特殊情况。当创建List of Values (LOV)视图对象时，你将这些组件添加到一个应用模块中用于获取LOV集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证应用模块（Validation Application Module）校验应用模块聚集相关视图，执行轻量级的SQL校验。实体对象或experts使用校验应用模块，它与用户界面无关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用模块是oracle.apps.fnd.framework.server.OAApplicationModuleImpl的子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要：&lt;/strong&gt; 如果你没有完全实现和保证页面的钝化支持，就不要设置应用模块的Retention Level为MANAGE_STATE。&lt;/p&gt;
&lt;p&gt;可以在应用模块属性的Peoperties页，创建一个属性，属性名为RETENTION_LEVEL，属性值为MANAGE_STATE。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成应用模块接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;产生应用模块接口可以便于编译时检查，而不用使用invokeMethod()来调用，可以在应用模块编译页面，选择Client Methods启用invoke remotely选择好Available list。&lt;/p&gt;
&lt;h2&gt;编程控制&lt;/h2&gt;
&lt;p&gt;不要将数据校验等业务逻辑放在应用模块中；这些应该放在下层的实体中。应用模块适合放下面的逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;访问任何BC4J相关的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行多种服务端动作，或者跨多个视图对象的单个事件或方法调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从服务端返回客户端从OAPageContext访问不到的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用特殊的PL/SQL程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 如果PL/SQL程序是用于处理单行（或行的集合）时你应该使用基于PL/SQL的实体对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;方法命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何直接用于UI支持的应用模块中的方法应该命名为相应的UI "events"。比如，如果用户按了Create按钮，应用模块方法应该被命名为"create"。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实体对象创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下列描述了应用模块方法创建新插入一行到SuppliersVO视图对象。这个视图对象是基于SupplierEOImpl实体对象的，因此BC4J在行被创建时在幕后处理这些。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;createSupplier&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSuppliersVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;Row&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRow&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;insertRow&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// As specified in OA Framework Model Coding Standards,   // set the new row state to STATUS_INITIALIZED.&lt;/span&gt;
  &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setNewRowState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STATUS_INITIALIZED&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视图对象查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面显示了一个应用应用模块方法查询SuppliersVO视图对象，用于搜索客户端设置的条件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;query&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;supplierName&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;onHoldFlag&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;supplierNumber&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="n"&gt;SuppliersExpVOImpl&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSuppliersExpVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OBJECT_NAME"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"SuppliersExpVO"&lt;/span&gt;&lt;span class="o"&gt;)};&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_OBJECT_NOT_FOUND"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initQuery&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supplierName&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;onHoldFlag&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;supplierNumber&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end query()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的例子显示了当用户导航到页面上时初始中化页面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PoSimpleSummaryVOImpl&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPoSimpleSummaryVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OBJECT_NAME"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"PoSimpleSummaryVO"&lt;/span&gt;&lt;span class="o"&gt;)};&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_OBJECT_NOT_FOUND"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tokens&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="c1"&gt;// Follows Back Button standard of never performing a blind query without&lt;/span&gt;
  &lt;span class="c1"&gt;// checking to see if this is necessary.&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isPreparedForExecution&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initQuery&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end init()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实体删除&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Deletes a purchase order from the PoSimpleSummaryVO using the&lt;/span&gt;
&lt;span class="cm"&gt; * poHeaderId parameter.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;poHeaderId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// First, we need to find the selected purchase order in our VO.&lt;/span&gt;
  &lt;span class="c1"&gt;// When we find it, we call remove( ) on the row which in turn&lt;/span&gt;
  &lt;span class="c1"&gt;// calls remove on the associated PurchaseOrderHeaderEOImpl object.&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;poToDelete&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;parseInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;poHeaderId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPoSimpleSummaryVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// This tells us the number of rows that have been fetched in the&lt;/span&gt;
  &lt;span class="c1"&gt;// row set, and will not pull additional rows in like some of the&lt;/span&gt;
  &lt;span class="c1"&gt;// other "get count" methods.&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getFetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// We use a separate iterator -- even though we could step through the&lt;/span&gt;
  &lt;span class="c1"&gt;// rows without it -- because we don't want to affect row currency.&lt;/span&gt;
  &lt;span class="c1"&gt;// Note that there are also convenience methods for finding matching rows&lt;/span&gt;
  &lt;span class="c1"&gt;// in a view object (see javadoc).&lt;/span&gt;

  &lt;span class="n"&gt;RowSetIterator&lt;/span&gt; &lt;span class="n"&gt;deleteIter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"deleteIter"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeStart&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRowAtRangeIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

          &lt;span class="c1"&gt;// For performance reasons, we generate ViewRowImpls for all&lt;/span&gt;
      &lt;span class="c1"&gt;// View Objects. When we need to obtain an attribute value,&lt;/span&gt;
      &lt;span class="c1"&gt;// we use the named accessors instead of a generic String lookup.&lt;/span&gt;

      &lt;span class="c1"&gt;// Number primaryKey = (Number)row.getAttribute("HeaderId");&lt;/span&gt;
      &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;primaryKey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHeaderId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;primaryKey&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;poToDelete&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;getTransaction&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// only one possible selected row in this case&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;closeRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end deletePurchaseOrder()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;自定义的动作"Approve"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里描述了如何查找到视图对象的行并调用自定义的实体事件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Steps through the POSimpleSummaryVO to look for selected rows. For&lt;/span&gt;
&lt;span class="cm"&gt; * each selected row, this calls the approve( ) method on the&lt;/span&gt;
&lt;span class="cm"&gt; * PurchaseOrderHeaderEOImpl class.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;approvePurchaseOrders&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// To call a custom method on an Entity Object you should add a wrapper&lt;/span&gt;
  &lt;span class="c1"&gt;// in the VO's *RowImpl class (see&lt;/span&gt;
  &lt;span class="c1"&gt;// oracle.apps.fnd.framework.toolbox.schema.server.PoSimpleSumaryVORowImpl).&lt;/span&gt;

  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPoSimpleSummaryVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;matches&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// This tells us the number of rows that have been fetched in the&lt;/span&gt;
  &lt;span class="c1"&gt;// row set, and will not pull additional rows in like some of the&lt;/span&gt;
  &lt;span class="c1"&gt;// other "get count" methods.&lt;/span&gt;
  &lt;span class="c1"&gt;// Note that there are also convenience methods for finding matching rows&lt;/span&gt;
  &lt;span class="c1"&gt;// in a view object (see javadoc).&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getFetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// We use a separate iterator -- even though we could step through the&lt;/span&gt;
  &lt;span class="c1"&gt;// rows without it -- because we don't want to affect row currency.&lt;/span&gt;

  &lt;span class="n"&gt;RowSetIterator&lt;/span&gt; &lt;span class="n"&gt;approveIter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"approveIter"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;approveIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeStart&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;approveIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// For every row with a selected checkbox, we want call&lt;/span&gt;
      &lt;span class="c1"&gt;// the approve( ) wrapper on the POSimpleSummaryVORowImpl which&lt;/span&gt;
      &lt;span class="c1"&gt;// in turn calls the approve ) method on the PurchaseOrderHeaderEOImpl.&lt;/span&gt;

      &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;approveIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRowAtRangeIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

          &lt;span class="c1"&gt;// For performance reasons, we generate ViewRowImpls for all&lt;/span&gt;
      &lt;span class="c1"&gt;// View Objects. When we need to obtain an attribute value,&lt;/span&gt;
      &lt;span class="c1"&gt;// we use the named accessors instead of a generic String lookup.&lt;/span&gt;

      &lt;span class="c1"&gt;// String selectFlag = (String)row.getAttribute("SelectFlag");&lt;/span&gt;
      &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;selectFlag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSelectFlag&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Y"&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;selectFlag&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
      &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;approve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;approveIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;closeRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// If the user didn't actually select any rows, display an error message.&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;getTransaction&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_T_SELECT_FOR_APPROVE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end approve()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;提交&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Commit&lt;/span&gt; &lt;span class="n"&gt;Example&lt;/span&gt; &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Provides a "commit" wrapper so UI controller code doesn't need to&lt;/span&gt;
&lt;span class="cm"&gt; * get a handle to the transaction itself which is a violation of the&lt;/span&gt;

&lt;span class="cm"&gt; * client/sever tier separation rules.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;getTransaction&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end apply()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;测试应用模块&lt;/h2&gt;
&lt;p&gt;在应用模块中添加完视图对象后，可以使用Business Component Browser（BC4J Tester）在为它们构建UI前执行视图对象，或者编写代码支持BC4J对象。&lt;/p&gt;
&lt;h1&gt;Entity Objects, Entity Experts, 'Validation' Application Modules and 'Validation' View Objects&lt;/h1&gt;
&lt;p&gt;这节介绍这些对象在一个应用中所扮演的角色。&lt;/p&gt;
&lt;h2&gt;Validation View Objectc&lt;/h2&gt;
&lt;p&gt;在实体对象中实现业务逻辑时，经常会发现需要执行一些简单的SQL语句，而不是纯校验目的。在执行这种SQL之前，你可以使用SQL语句动态创建一个视图对象，或者先定义一个视图对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从实现的角度来看，Validation View object与正规的view object没有区别；这们的主要区别是在使用上。&lt;/p&gt;
&lt;h2&gt;Validation Application Modules(VAMs)&lt;/h2&gt;
&lt;p&gt;预先定义的视图对象必须被赋给应用模块以便在运行时被访问。也就是说，视图对象不能存在于应用模块环境之外。&lt;/p&gt;
&lt;p&gt;由于实体对象（和他们的关联校验视图对象）可以被多个UI客户端（根应用模块可以当作客户端）共享，它不适合为具体的页面包含视图校验功能。将这些有用的视图对象进行分组，便于重用，并为每个业务逻辑对象创建一个validation application module包含它们。业务对象可以是实体对象聚合的顶级定义，或者是一个单独的实体对象。比如OA Framework ToolBox教程中定单由3个实体组成，但PurchaseOrderHeaderEOImpl类描绘出了定单业务对象。&lt;/p&gt;
&lt;p&gt;比如，在OA Framework ToolBox教程中，我们创建了业务对象级的校验应用模块PurchaseOrderVAM并将所有定单校验视图对象添加给了它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从实现的角度来看，validation application对象与正规的应用对象没有区别；只是使用方式的不同。创建validation application module并把相关的validation view objects关联给它。&lt;/p&gt;
&lt;h2&gt;Entity Experts&lt;/h2&gt;
&lt;p&gt;entity expert被定义为一个单例对象，是业务对象一个特殊的分支（聚合中的顶级实体对象，或一个单独的实体对象）。它包含有能被拥有它的业务对象调用，或者被其它业务对象调用的简单校验例程。比如，PurchaseOrderHeaderEOImpl类不需要整个SupplierEOImpl类，只需要查找出外键supplierId是否有效。因此，它调用了supplier的entity expert单例对象的isSupplierIdValue(Number supplierId)方法，这是一个更加轻量级的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建entity expert，先创建一个oracle.apps.fnd.framework.server.OAEntityExpert的子类。然后将它关联到一个实体对象上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 对于聚合类的业务对象，将expert关联到顶级的对象上。否则关联到单独的实体对象。&lt;/p&gt;
&lt;h1&gt;重用业务对象&lt;/h1&gt;
&lt;h2&gt;Entity Objects, Associations, Validation AMs, Validation VOs, Entity Experts&lt;/h2&gt;
&lt;p&gt;如果希望创建可重用的Entity Objects,Associations,Validation AMs,Validation VOs,Entity Experts，应该知道下面的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下层数据库方案的拥有者，拥有对应的Entity Objects,Associations,Validation Application Modules,Validation View Objects,和Entity Experts。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥有业务对象的产品团队必须编写并发布相应的文档供其它产品团队重用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你创建包括你的EO和另一个产品团队的OtherBaseEO的关联对象时，在创建关联前，你必须继承OtherBaseEO到你的产品空间中(OtherExtendedEO)，并将关联建立在EO和OtherExtendedEO之间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个产品团队使用你拥有的业务对象时应该要继承你提供的校验。那种情况下，消费产品团队应该继承Entity Object,Validation Application Module,Validation View Object和Entity Expert and包括扩展的自定义代码。继承校验方法时，确保在继承的校验方法的开始位置调用了super()。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;扩展业务对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下表描述了创建业务对象和关联到需要扩展的校验时要的相关对象。&lt;/p&gt;
&lt;p&gt;&lt;img alt="modelobjects" src="/oaf_build_model/modelobjects.gif"/&gt;&lt;/p&gt;
&lt;p&gt;第一行列举了定义实体时所有可能创建的对象。第一个格子说明了创建一个实体对象时将产生两个文件：元数据定义的XML文件，和实际的Java实现类文件。实体对象处理属性级和记录级的校验。这些校验通常需要使用Validation View Objects (VVO)。校验对象在Validation Application Module(VAM)中分组。与实体对象类似，创建VVO和VAM产生了元数据定义XMl文件，并为每个对象产生了Java实现类文件。最后，实体对象有时会接收辅助类提供的一些服务，为实体对象提供的验证服务。辅助类是Entity Expert通过实体对象的属性连接到实体对象。&lt;/p&gt;
&lt;p&gt;上图描述了所有业务对象继承时的情况。虽然并不总是这样。多数情况下，将对继承的结果满意。注意，不应该修改蕨类的定义或复制基类。应该使用继承。&lt;/p&gt;
&lt;p&gt;未完！！！！！&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>OA Framework应用构建之——实现视图</title><link href="/build_view.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/build_view.html</id><summary type="html">&lt;h1&gt;页面&lt;/h1&gt;
&lt;p&gt;创建页面的基本步骤是创建pages，region，items。&lt;/p&gt;
&lt;h2&gt;Page LayoutRegion的关键属性&lt;/h2&gt;
&lt;p&gt;创建一个pageLayout区域时，应该特别注意下面的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AutoFooter将这个设置为true以保证在页面上有应用的保密和版权说明链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Help Target如果你需要为当前页显示帮助按钮，必须在这里指定帮助文件（通常是文件名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AM Definition用于设置页面的根应用模块。必须使用类的全名，比如：oracle.apps.fnd.framework.toolbox.tutorial.server.SearchAM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Function Name总是设置页面的保密函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Window Title浏览器窗口标题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Title显示在page header中的文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Form在pageLayout中设置为true，这通常是默认设置，不要在其子对象中添加亲折form。OA Framework在同一个页面中只支持一个form。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pageLayout Components注意OA Framework页面基础　一文中提到的，页面包含了特殊的被命名的组件，其中一个就是标识图案。为了在页面关联标识图案，选择pageLayout区域或pageLayoutComponents节点，然后右键菜单中选择创建image item，并把它的Image URI属性设置为&lt;imagename&gt;.gif。&lt;/imagename&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;页面&lt;/h1&gt;
&lt;p&gt;创建页面的基本步骤是创建pages，region，items。&lt;/p&gt;
&lt;h2&gt;Page LayoutRegion的关键属性&lt;/h2&gt;
&lt;p&gt;创建一个pageLayout区域时，应该特别注意下面的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AutoFooter将这个设置为true以保证在页面上有应用的保密和版权说明链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Help Target如果你需要为当前页显示帮助按钮，必须在这里指定帮助文件（通常是文件名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AM Definition用于设置页面的根应用模块。必须使用类的全名，比如：oracle.apps.fnd.framework.toolbox.tutorial.server.SearchAM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Function Name总是设置页面的保密函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Window Title浏览器窗口标题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Title显示在page header中的文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Form在pageLayout中设置为true，这通常是默认设置，不要在其子对象中添加亲折form。OA Framework在同一个页面中只支持一个form。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pageLayout Components注意OA Framework页面基础　一文中提到的，页面包含了特殊的被命名的组件，其中一个就是标识图案。为了在页面关联标识图案，选择pageLayout区域或pageLayoutComponents节点，然后右键菜单中选择创建image item，并把它的Image URI属性设置为&lt;imagename&gt;.gif。&lt;/imagename&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item 的关键属性&lt;/h2&gt;
&lt;p&gt;每个item类型都有自己的一套属性，不可能每个都介绍，这里介绍一些通常的公共属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Extends说明新的item继承于一个已存在的item。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Attribute Set命名了的item的属性集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Destination URI对于支持页面导航的对象，这个是导航的目标，比如：OA.jsp?page=/oracle/apps/fnd/framework/toolbox/tutorial/webui/PoDetailsPG&amp;amp;retainAM=Y。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(Client Action)Action Type标明item是否可以提交表单，或者产生局部页面渲染事件（partialpage rendering (PPR)）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSS Class指定item使用的样式表。（多数item，UIX将把这个值按BLAF UI指导方案中的值设置）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rendered指明相应的对象是否包含了webbean层级结构，需要UIX将HTML发送给浏览器渲染。对于多数item来说，这用于指定一个item是否显示，但有些item是不会实际显示出来的（比如隐藏域），实际上是指定对象是否存在于页面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;View Instance让item绑定到下层的视图对象上以便读写数据，这里标明将item绑定到哪个视图对象实例（包含在一个应用模块中的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;View Attribute将视图对象实例的属性与item绑定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Admin Personalization决定是否允许系统管理员进行个性化定制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;User Personalization决定是否允许用户个性化定制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Initial Value定义item的缺省值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Simplest Possible Expression Language (SPEL)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于所选的属性，OA Framework支持使用SPEL表达式快速的将属性绑定到下层数据源提供的属性值上。比如，你可以将按钮的Rendered属性绑定到一个视图对象的属性上以检查是否需要显示或隐藏。属性中使用的SPEL语法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;oa&lt;/span&gt;&lt;span class="o"&gt;.&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ViewInstanceName&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;.&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ViewAttributeName&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; SPEL是一个业界标准的表达式语言，它包含于JSTL中。&lt;/p&gt;
&lt;h2&gt;组件重用&lt;/h2&gt;
&lt;p&gt;OA Component开发环境所宣称的一项关键优势就是可以重用通用的page,region,item定义。&lt;/p&gt;
&lt;h2&gt;Regions共享&lt;/h2&gt;
&lt;p&gt;可以按下面的步骤创建共享的region。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 共享region可以包含一个或多个子region。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顶级共享region必须保存在它的XML文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以将共享region设置为接收其它region的值。值可能通过&amp;ldquo;状态管理&amp;rdquo;一文中描述的方式通过请求传递，或者使用页面事务缓存的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享region必须处理失效的情况。比如，如果没有合适的参数传递到region，共享region应该接收或者抛出一个有意义的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果region的scope被设置为Public：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顶级region必须有自己的应用模块。应用模块应该包含与这个region相关的视图对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顶级region必须有自己的控制器。如果需要可以为子region添加控制器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享region必须添加完整的注释文档。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特殊情况： LOV&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LOV与共享region的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LOV不需要关联控制器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当在页面上使用LOV时，并不从它继承，而是将页面字段的External LOV属性配置为页面与LOV的数据交换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Pages共享&lt;/h2&gt;
&lt;p&gt;page实际上只是顶级region为共享region的pageLayout组件。共享page与共享region的创建过程类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果要重用一个单独的page或page flow，只要简单的创建一个新的菜单功能并将它指向主页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要将页面插入到另一个使用了不同根应用模块的page flow，则必须创建一个新的page，并继承共享的page的pageLayout region下的内容。记住正确设置将新页面的根应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Items共享&lt;/h2&gt;
&lt;p&gt;可以从任何区域的单个item继承，尽管我们推荐将准备重用的item放到一个重用region中。共享容器region将确保不会任意的修改item而不明确这样修改将影响使用这个item的页面。&lt;/p&gt;
&lt;p&gt;通过设置item的Extends属性设置共享。&lt;/p&gt;
&lt;h1&gt;属性集 Atribute Sets&lt;/h1&gt;
&lt;p&gt;属性集是一个命名了的可重用的属性集合，可以用于任何OA组件，包括regions，items和其它属性集。它被设计为可以在整个Oracle Application中可以重用的组件，它有效的节约了Oracle和其客户的开销。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Oracle节约了翻译和管理的开销&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户可以更快的定制应用的全局个性化效果。另外，少数UI元素占用更少的中间层内存，提高了性能和伸缩性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，attributes sets被组织到OA组件包中（独立的XML包文件中），这个包与数据训表对应，一个包对应一个表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;包名与不带下划线的数据库表名对应。比如，在OA Framework ToolBox中，有一个表FWK_TBX_PO_HEADERS。对应的属性集包名为FwkTbxPoHeaders。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各个属性集是为了显示表中各个列而设置的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于列的属性集命名与列一致。比如，在FWK_TBS_PO_HEADERS表有一个名为HEADER_ID的列。对应的属性集被命名为HeaderId。如果多个属性集对应于同一个列（这个值被用于不同的情况并使用了不同的prompt属性）时根据实际使用的位置使用不同的前缀来区分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性集也可以包含通用域头部和按钮等的设置。命名则使用与它们相关联的标签。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;使用属性集&lt;/h2&gt;
&lt;p&gt;在下面的情况下使用属性集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有的items都与table.column数值关联。比如，供应商查询字段和数据列表中的供应商字段可以使用同样的属性集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有通用按钮（确定、应用、退出等等）。这种情况下也可以继承按钮的快捷键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; OA Framework通用按钮属性集包位于/oracle/apps/fnd/attributesets/Buttons/&lt;attributesetname&gt;。&lt;/attributesetname&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有通用表格动作列（像删除、修改等等）应该使用相应的 OA Framework按钮属性集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产品中任何通用的按钮；不应该为单独使用的按钮创建或使用属性集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产品中任何共同区域的头部；不应该为单独使用头部创建或使用属性集。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在item上使用属性集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;item的Attribute Set属性可以设置它的属性集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将光标放在Attribute Set字段，使用Property Inspector的Set to Default按钮可以清除属性集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程方式访问属性集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在控制器中访问属性集。比如，下面代码显示了如何保留通用的Create控制属性集的prompt属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.webui.AttributeSet&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

 &lt;span class="n"&gt;AttributeSet&lt;/span&gt; &lt;span class="n"&gt;attrSet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;AttributeSet&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"/oracle/apps/fnd/attributesets/Buttons/Create"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
 &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;createPrompt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;attrSet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PROMPT_ATTR&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;URL 参数：Tokens，Encryption，Encoding&lt;/h1&gt;
&lt;h2&gt;Tokens&lt;/h2&gt;
&lt;p&gt;当在页面定义中指定URL参数时，可以直接指定字符串值或使用token-substituted值，在渲染时它保留了从相关的视图对象的属性（item与视图对象绑定的情况下）。这是很常见的，比如，在表格的列中传递主键到明细页面以便于查询。&lt;/p&gt;
&lt;p&gt;Token Sustitution的例子（使用了视图对象的&amp;ldquo;OrderNum&amp;rdquo;属性）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OA.jsp?OAFunc=FWK_TBX_T_PO_PAGE&amp;amp;order={@OrderNum}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;产生的链接为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OA.jsp?OAFunc=FWK_TBX_T_PO_PAGE&amp;amp;order=123
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Token类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tokens使用了特殊的字符前缀告诉OA Framework如何获取值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;{!Attr} 当URL中存在{!}时将加密属性值（比如，OA.jsp?...&amp;amp;ssn={!SSN}&amp;amp;...）。使用OAPageContext.getParameter("ssn")将返回解密后的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{@Attr} 当URL中存在{@}时属性值将被编码（比如，OA.jsp?...&amp;amp;addr={@EmpAdd}&amp;amp;...）。使用OAPageContext.getParameter("addr")将得到解码后的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{$attr} 原token substitution（不进行编码和加密）因此你必须确保参数值不会打断URL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{@@RETURN_TO_MENU} 可以用于指定应用组件的Destination URI属性，如果你希望用户返回EBS套件的个人主页。如果需要在执行JSP forward时指定这个，可以使用常量OAWebBeanValues.RETURN_TO_MENU_URL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{@@RETURN_TO_PORTAL} 用于指定组件的Destination URI属性，以便让用户返回Portal页。在JSP forward中可以使用常量OAWebBeanValues.RETURN_TO_PORTAL_URL。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;编码&lt;/h2&gt;
&lt;p&gt;任何为请求指定的参数必须遵循HTTP语法规则。比如，不能在URL参数值传递空格；当访问的URL中包含：&lt;code&gt;buyerName=John Doe&lt;/code&gt;时将产生运行时错误。&lt;/p&gt;
&lt;p&gt;为修正这个错误，我们将对这些值进行编码，编码将替换有问题的字符，将值变为：&lt;code&gt;byerName=John%20Doe&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当OA Framework添加参数到请求中时（比如表字段的值），它将对它们自动编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当调用setForward*方法设置参数时，OA Framework将自动编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你自己组装URL参数时（比如，通过调用setDestination方法设置某个bean的URL时），必须对字符串中可能出现的非法字符进行编码。可以将字符串传递给oracle.apps.fnd.framework.webui.OAUrl工具类的encode方法进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 如果手工设置URL参数不包含非法字符（比如，&amp;ldquo;value=Y&amp;rdquo;）则不需要担心编码的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当使用OAPageContext.putParameter设置参数时，如果需要也必须对字符串进行编码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用OAPageContext.getParameter*方法时OA Framework将自动解码参数值，下列情况除外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当为JavaScript函数tokens使用&amp;ldquo;#&amp;rdquo;字符时，OA Framework对token值编码，但不会在你调用pageContext.getParameter("&lt;tokenname&gt;")时自动解码。如果需要，你可以自己使用OAUrl类的decode方法对getParameter方法的返回值进行解码。&lt;/tokenname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你使用一个已经编码了参数调用putParameter方法时，OA Framework将不会对它进行解码。你也必须使用OAUrl的decode方法对getParameter的返回值进行解码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;加密&lt;/h2&gt;
&lt;p&gt;加密处理将混淆参数值。由于URL请求参数可能是对用户可见的（用户查找HTML页面源码时也可以看到隐藏域的值），总是应该对存储于URL参数或隐藏域的数据进行加密。&lt;/p&gt;
&lt;p&gt;另外，上面描述了基于token的加密，OA Framework在oracle.apps.fnd.framework.webui.OAPageContext中提供了方法用于编程中加密和解密请求中的参数值。&lt;/p&gt;
&lt;h1&gt;样式&lt;/h1&gt;
&lt;p&gt;OA Framework使用blaf.xss统一定义用户界面样式。&lt;/p&gt;
&lt;h2&gt;使用样式&lt;/h2&gt;
&lt;p&gt;所有添中到页面的的region和大多数的item都会自动设置风格。&lt;/p&gt;
&lt;p&gt;几种必须为items设置CSS Class属性的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果创建了一个staticStyledText item，用于instruction text，则必须将它的CSS Class设置为OraInstruction Text。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何文本输入域，多选框，poplists和radio必须将CSS Class设置为OraFieldText。不要在radio和checkboxes上使用OraPromptText。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用messageStyledText item来显示只读数据，必须将CSS Class设置为OraDataText以便将文字加粗（不要在table columns中使用这个设置）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; OA Framework新手通常犯的错误是试图修改CSS style来修改组件&amp;ldquo;原生&amp;ldquo;的外观。如果发现这样做出了问题（比较困难因为样式设置不会在运行时起作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;确认你使用了正确的bean（region或item style）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果确认使用了正确的bean，检查它是否公开了一个用于达到这个目的的方法。比如，oracle.apps.fnd.framework.webui.beans.layout.OAHeaderBean继承了setSize(int size)方法以便于你控制header text的size。你不能通过设置header的CSS Class为OraHeaderSubSub来改变这个效果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;创建风格&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;自定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OA Framework自动将custom.xss设置为了主样式。任何自定义设置可以添加到这个样式表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E-Business Suite Application开发者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面所说的custom.xss包含了oa.xss，它依次包含了blaf.xss。&lt;/p&gt;
&lt;p&gt;oa.xss用于包含任何对于BLAF样式的修改。你不应该创建自己的样式表。&lt;/p&gt;
&lt;h1&gt;无障碍环境&lt;/h1&gt;
&lt;p&gt;OA Framework应用是无障碍的，可以由盲人、弱视、色盲或聋人使用。&lt;/p&gt;
&lt;h1&gt;国际化&lt;/h1&gt;
&lt;p&gt;OA Framework应用被设计为完全本地化。国际化相关的章节讨论了关于语言、时区、日期的数字的国际化。&lt;/p&gt;
&lt;h1&gt;模型交互&lt;/h1&gt;
&lt;p&gt;在指定好数据源绑定后，OA Framework自动从模型中读取数据以便视图显示，并自动将用户输入视图中的数据回写到模型。不需要编写代码（除了为下层的实体编写校验）。&lt;/p&gt;
&lt;h2&gt;读取模型数据&lt;/h2&gt;
&lt;p&gt;OA Framework每次渲染页面时，它将为每个web bean关联的视图对象属性调用当前视图对象行的get&lt;attributename&gt;方法。&lt;/attributename&gt;&lt;/p&gt;
&lt;p&gt;例如，对于&amp;ldquo;Suppliers&amp;ldquo;表，绑定到了SuppliersVO视图对象。SuppliersVO映射到了SupplierEOImpl，尽管它也包含了一个&amp;ldquo;计算&amp;rdquo;属性（&amp;ldquo;OnHoldDisplay&amp;rdquo;），它与不对应的实体的属性对应。&lt;/p&gt;
&lt;p&gt;OA Framework在执行查询后读取模型数据：&lt;/p&gt;
&lt;p&gt;&lt;img alt="read_data_flow" src="/oaf_build_view/read_data_flow.gif"/&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户选择&amp;ldquo;Search&amp;ldquo;区域中的&amp;ldquo;Go&amp;ldquo;按钮查询&amp;rdquo;Suppliers&amp;ldquo;表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;Search&amp;ldquo;区域中的控制器处理按钮事件调用根应用模块的search方法，它返回代理了SuppliersVOImpl类，因此它可以查询自己。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在executeQuery方法中，SuppliersVOImpl视图对象在数据库中执行SQL SELECT。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于结果集中的第一行，视图对象创建一个SupplierEOImpl实体对象的实例并根据查询结果设置它的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 实体对象的属性值实际不是存储于视图对象中的。它们&amp;ldquo;生存&amp;rdquo;于实体对象，可以被需要的视图对象访问。&amp;ldquo;计算（Calculated）&amp;rdquo;或&amp;ldquo;临时（Transient）&amp;rdquo;类型的视图属性是存储在SuppliersVORowImpl对象中的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在页面渲染时（在所有查询处理完成后），OA Framework依次为每个web bean调用SuppliersVORowImpl对象中适当的getAttribute("&lt;attributename&gt;")方法绑定数据。&lt;/attributename&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SuppliersVORowImpl get&lt;attributename&gt;方法返回调用对应的SupplierEOImpl get&lt;attributename&gt;方法获得的值。对于&amp;ldquo;计算（calculated）列OnHoldDisplay属性，视图行对象从它自己的缓存中获取值。&lt;/attributename&gt;&lt;/attributename&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;写入模型数据&lt;/h1&gt;
&lt;p&gt;不论何时，浏览器发出POST请求，OA Framework将自动把用户输入表单的数据写入下层的视图对象，它再依次更新对应的实体。&lt;/p&gt;
&lt;p&gt;HTTP POST数据过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="write_data_flow" src="/oaf_build_view/write_data_flow.gif"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 下面的步骤假设数据库行所对应的实体对象已经被实例化和初始化（比如在进入Create页面时已经调用了视图对象的create方法创建实体对象）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;UIX执行onSubmit的JavaScript校验（必填字段，数据类型，格式），并在校验通过时发送POST请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器发送POST请求，OA Framework调用web bean结构中的processFormData方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在processFormData内部，OA Framework自动为每个web bean调用下层视图对象的当前行对象的setAttribute(String name, Object value)方法。这也执行编写于视图行对象中任何属性级别（attribute-level）的校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在setAttribute方法中，视图行自动自动调用对应的下层的实体对象中的set&lt;attributename&gt;方法，这也将执行实体对象中相关的属性级别的校验。&lt;/attributename&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一旦所有属性被设置后，OA Framework为修改过的每一行调用视图对象的validate方法以执行任何相关的行级（row-level）的校验。。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，在validate方法中，视图行对象调用下层实体的validateEntity方法以执行相关的实体级别（entity-level）的校验。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework自动显示模型层在执行processFormData过程中抛出的任何异常，并不会继续调用processFormRequest的下一部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跳过校验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上所述，OA Framework在每次form提交时写入模型数据，这意味着所有属性和实体级的校验都被执行。有几个机会让你&amp;ldquo;短路（short-circuit）&amp;ldquo;这些错误以防在不方便的时候报告给用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺省值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当使用&amp;ldquo;Create&amp;rdquo;页面创建新行时，可以在3个地方指定默认值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;[Model] 如果你的视图对象是基于一个或多个实体，你可以覆盖它们的create()方法以编程的方式设置属性级的缺省值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[Model] 也可以在使用BC4J实体定义向导时定义实体属性的缺省值。注意Oracle内部的EBS开发者不应该使用这个选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[View] 也可以在Oracle JDeveloper OA Extension中设置各个item的Initial Value属性。这个做法的好处是&amp;mdash;&amp;mdash;对于静态值可以在设计时决定&amp;mdash;&amp;mdash;它可以很容易的由用户个性化这些缺省值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺省值功能默认是关闭的，必须根据FND:OA:Enable Defaults/FND OA ENABLE DEFAULTS将值设置为Y来启用这个功能。&lt;/p&gt;
&lt;p&gt;如果在首选项中启用了并且在视图中（OA Extension或个性化）的表单元素（不能是messageChoice或messageRadioGroup）中指定了默认值，则OA Framework将根据下面的规则设置item的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果item与视图对象数据源没有关联，则首选项的设置将不产生影响。OA Framework在页面被渲染后自动设置item为默认值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果item与视图对象关联，OA Framework会在你调用视图对象的createRow()方法时设置缺省值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在首选项中启用了并且在视图对象中（OA Extension或个性化）的表单元素是messageChoice或messageRadioGroup，则OA Framework将根据下面的规则设置适当的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果当前行需要显示的这个属性值不为null，则值被设置为指定的默认值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前需要显示的这个属性值为null，则显示的值将决定于指定的默认值，并且值将被应用于视图对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的例子显示了创建新行的典型代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;createSupplier&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSuppliersVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// The OA Framework applies UI defaults during the scope of this&lt;/span&gt;
  &lt;span class="c1"&gt;// method call.&lt;/span&gt;
  &lt;span class="n"&gt;Row&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRow&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;insertRow&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// As specified in OA Framework Model Coding Standards,&lt;/span&gt;
  &lt;span class="c1"&gt;// always set the new row state to STATUS_INITIALIZED&lt;/span&gt;
  &lt;span class="c1"&gt;// after you create it.&lt;/span&gt;
  &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setNewRowState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STATUS_INITIALIZED&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;createRow()方法调用各个ViewRowImpl的create()方法。在调用create()过程中，OA Framework调用需要指定了缺省值的每个UI组件的setter方法，如果需要这些值将被应用（译：根据下文，应该是指应用到视图对象）。这确保了视图行的校验和相关的实体对象属性的校验。然后OA Framework将视图行对象的状态重置为STATUS_INITIALIZED，以便它不被BC4J组件修改。这确保了用户导航到其它页面时将持有默认值而不会产生丢失工作的警告。在缺省值的处理过程中检查到的任何异常通常都将显示出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 在视图行被创建后默认值只会被应用一次。如果你有一个多页面流带有多个区域，这个区域绑定到相同的下层视图对象&amp;mdash;&amp;mdash;每个区域都对一个视图属性指定了一个不同的Initial Value&amp;mdash;&amp;mdash;只有第一个区域渲染时设置的缺省值会被关联。其它的将被忽略。同样，如果在Page A创建了一个新行，然后导航到Page B，在这里设置了一个属性的Initial Value，缺省值不会被应用，因为行对象是在Page B渲染前创建的。&lt;/p&gt;
&lt;p&gt;对于下面的三种情况，OA Framework遵守下面的优先级：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;（最高级）item属性缺省使用在OA Extension设计的值或Personalizations模块中指定的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编程方式指定的实体对象属性值（在执行vo.createRow()方法时将代理实体对象的create()方法）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（最低级）在设计时指定的实体对象属性值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果需要确保默认值总是被设置而不管值有可能在设计器中指定，你可以覆盖视图对象的insertRow()方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;EmployeesVOImpl&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;OAViewObjectImpl&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

  &lt;span class="o"&gt;...&lt;/span&gt;

  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;insertRow&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Row&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Always call super.insertRow() first.&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;insertRow&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;


    &lt;span class="c1"&gt;// Now call whatever attribute setters you need to call to ensure&lt;/span&gt;
    &lt;span class="c1"&gt;// that your defaults always take precedence.&lt;/span&gt;
    &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttribute&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;attributeName&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;attributeValue&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;);&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;

  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;菜单和页面安全&lt;/h1&gt;
&lt;p&gt;在OA Framework应用中，页面中的菜单是用tab模型来实现的。&lt;/p&gt;
&lt;p&gt;OA Framework ToolBox 教程的菜单：&lt;/p&gt;
&lt;p&gt;&lt;img alt="toolbox_menu" src="/oaf_build_view/toolbox_menu.gif"/&gt;&lt;/p&gt;
&lt;p&gt;菜单结构提供了两个明显的用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将内容组织成有含意的单元&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方便用户在这些单元中导航&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;菜单实现&lt;/h2&gt;
&lt;p&gt;在后台，OA Framework实际上包含了Oracle Applications功能和菜单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导航功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导航功能表示出应用中的各个页面；每个页面与一个预先定义的功能关联。或许最重要的是，这个功能包含了页面的Web HTML Call。比如，在ToolBox Tutorial 应用中，当用户选择Lesson 3菜单项时，Purchase Order Search页被显示出来。我们为这个页面建立了一个功能，并设置它的Web HTML Call指向我们需要显示的XML页面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OA.jsp?page=/oracle/apps/fnd/framework/toolbox/webui/PoSearchPG
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当用户选择Lesson 3菜单项时，请求被路由到OA.jsp，它初始化一个oracle.apps.fnd.framework.webui.OAPageBean对象处理对应的页面XML文件（OA.jsp是访问OA Framework应用页面的唯一的JSP）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 单个页面可以被多个功能调用（每个可能通过URL传递不同的参数），它可以用于多个不同的菜单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导航菜单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导航菜单是一组可重用的功能和子菜单的集合，它最终创建了上面所描述的tab结构。每个OA Framework菜单项都关联到某个Type，这决定了它应该如何被渲染。比如，在上面图表中的Lesson 2 tab的Type为&amp;ldquo;HTML Tab&amp;ldquo;。&lt;/p&gt;
&lt;p&gt;导航菜单包含了所有可以显示于应用中的功能。你可以有选择的为导航菜单中的单个功能授权。这将在应用安全一节中详细描述。&lt;/p&gt;
&lt;h2&gt;应用安全&lt;/h2&gt;
&lt;p&gt;应用安全包含的范围很广泛，在这个章节中我们将涉及一些关键的概念，以便对于它支持的内容及它与菜单定义的关系有个基本的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户和责任&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Oracle应用中的责任是任务的集合，它被授给一个或多个用户。比如，你可能创建一个Benefits Manager和一个普通的Employee责任，两个都在HR应用中使用。你将把这些责任授给单个用户，以便用户快速访问这些模块。&lt;/p&gt;
&lt;p&gt;所有的责任都与应用中单个顶级导航菜单相关联。导航菜单最终将包含你的应用支持的所有tab。&lt;/p&gt;
&lt;p&gt;之前，责任是将用户按角色分组的主要机制。你可以将菜单分配给责任，并通过从你的责任中排除个别的菜单项来创建安全规则。在运行时，当前责任，组织机构和安全组一起包含了安全环境（secutiry context）。&lt;/p&gt;
&lt;p&gt;在R12中，责任的概念被扩展为更广泛的角色（role）。用户可以属于一个或多个角色。所有用户被指定给一个特殊的责任时也被指定给也相应的角色（role）。安全规则是基于许可发放（permission grants）机制，而不是功能排除规则。在运行时，这些许可的发放是在当前安全环境（security context）中被评估（evaluated）的，现在,责任，组织机构和安全组（secutiry group）中了也包含了角色（也被称为接受人（grantee））。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;授权和许可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建导航功能时，必须为页面创建授权功能（Authorization Fuctions也被称为&amp;ldquo;permissions&amp;rdquo;）。然后将这些许可（permission）分组到一个平坦（flat）的菜单结构中（也被你为许可集合（permission set）），以允许用户访问相关的页面。&lt;/p&gt;
&lt;p&gt;介绍许可集合（permission set）最简单的办法就是通过一个简单的用例。比如，假设你有一个非常简单的Benefits应用，它包含下面四个页面：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;页面&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;Benefits（利益）经理访问？&lt;/th&gt;
&lt;th align="left"&gt;员工访问？&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Benefits管理&lt;/td&gt;
&lt;td align="left"&gt;查看、修改、审核、取消审核benefits&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;td align="left"&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;创建Benefits&lt;/td&gt;
&lt;td align="left"&gt;创建新的Benefits&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;td align="left"&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;我的Benefits&lt;/td&gt;
&lt;td align="left"&gt;查看当前选择的benefit，并可将新选择的benefit设为自己的&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;修改Beneficiaries（受益人）&lt;/td&gt;
&lt;td align="left"&gt;修改设置beneficiaries&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如上面所说的，你需要为每个页面创建导航功能（Navigation Functions）并将它们组织到导航菜单中。为确保用户可以访问正确的页面，你需要按下面的过程处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步，创建许可（permissions）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与导航功能类似，许可是FND表单函数，但在这个环境中，它们只被用于应用安全。&lt;/p&gt;
&lt;p&gt;在我们的例子中，我们可以使用为每个页面创建导航功能作为许可。不需要创建额外的许可功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第二步，创建角色（role）或接受人（grantees）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接受人可以是一个用户（FND_USER）或用户组（被称为role）或&amp;ldquo;global&amp;rdquo;。用户（User）（译注：泛指系统用户，可以是人或组织）在FND_USERS中被创建，应该被与单个的具体的人或组织一一对应。角色（Roles）在WF_ROLES中被定义，可以在客户的LDAP系统中被映射到用户组。尽管成员没有被显式的增加，仍然有一个全局（Global）组包含有&amp;ldquo;所有人（everyone）&amp;rdquo;&lt;/p&gt;
&lt;p&gt;在上面的例子中需要两个用户角色：一个用于将所有管理员（managers）分到管理员角色，另一个用户将包含所有的员工（employees）。由于员工包含了所有人，因此也可以使用全局（Global）角色。&lt;/p&gt;
&lt;p&gt;另外，你也可以创建一个责任并把它赋给所有管理员，用这种方式设置授权（grant）。&lt;/p&gt;
&lt;p&gt;我们将在第四步创建授权（grants）时将讨论这两种方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建许可集合（permission sets）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;许可集合&lt;/strong&gt; 被作为菜单来实现，但它们只是简单的将许可分组为平面的列表中以便获取许可。概念上，应该将根据角色需要将许可集合分组为一个或多个许可集。&lt;/p&gt;
&lt;p&gt;上面的例子需要两个许可集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个管理员许可集合可以访问所有管理员需要操作的页面。这包含导航功能&amp;ldquo;Benefits管理&amp;ldquo;和&amp;ldquo;创建Benefit&amp;rdquo;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个Global许可集合允许任何人访问。这包含了导航功能&amp;ldquo;我的Benefits&amp;ldquo;和&amp;rdquo;修改Beneficiaries&amp;ldquo;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建授权&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Grant&lt;/strong&gt; 定义了安全规则，公允许系统中的某些用户访问你的应用中指定的功能或页面。一次 &lt;strong&gt;授权（grant）&lt;/strong&gt; 使 &lt;strong&gt;接受人（grantee）&lt;/strong&gt; 可以访问上面描述的许可集。简单来说，授权将接受人和许可集连接起来。&lt;/p&gt;
&lt;p&gt;对上面的例子需要两个 &lt;strong&gt;授权(grants)&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;管理员被作为管理员角色（manager role）授权关联到管理员许可集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;员工被作为global接受人与Global许可集关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于这个grant是与global grantee（任何人）关联，并没有其它的安全约束（不受任何责任、组织或安全组的约束），它可以被你为global grant。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以通过其它安全环境因素约束指定接受者（grantee）的授权（grant）。这些因素包括当前用户责任、组织机构、安全组。比如，为了将对管理员的授权（grant）限制在特定组织机构中，可以将组织机构信息与授权（grant）相关联。&lt;/p&gt;
&lt;p&gt;可以将管理员许可集合授予管理员角色，也可以将它授予全局接受者（global grantee）。可以将带有安全环境信息的责任与那些允许访问的管理员关联，以限制哪些管理员可以访问。但是，OA Framework推荐使用基于角色的授权替代责任。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;页面安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上面的例子中，我们注意到可以将页面与许可链接来限制访问。这是使用许可来保护页面渲染的情况。&lt;/p&gt;
&lt;p&gt;其它需要使用许可保护页面渲染的情况，包括匿名登录页面，页面需要自动责任设置或切换，且为共享／重用页面。&lt;/p&gt;
&lt;p&gt;详细介绍请阅读Chapter 4: Page Security。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>实现服务端功能之——服务</title><link href="/bus_svc_overview.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/bus_svc_overview.html</id><summary type="html">&lt;h1&gt;面向服务的架构预览&lt;/h1&gt;
&lt;p&gt;服务的概念已经出现了很长时间，但面向服务的概念相对是比较新的。面向服务的架构是一种有助于降低应用耦合的一种构建应用的风格，独立管理的组件可以被重用和重新安排到其它完整功能的应用中。SOA提供下面的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构建和注册服务的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用户发现和调用服务的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行服务的平台&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的图演示了SOA的基本概念：&lt;/p&gt;
&lt;p&gt;SOA的基本概念&lt;/p&gt;
&lt;p&gt;&lt;img alt="srv_overview" src="/oaf_bus_svc_overview/srv_overview.gif"/&gt;&lt;/p&gt;
&lt;p&gt;使用面向服务的架构你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容易的将Oracle Applications和其它的应用集成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;影响已经部署的应用保护现有投资&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易适应更多的需求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;服务预览&lt;/h1&gt;
&lt;p&gt;服务在EBS的开发、测试、分类、公共安全和私有接口架构中是一个关键组件。开发者使用统一的指导方针和实现方式来创建服务，然后当它们控制源代码时被自动发布到集中的接口仓库。&lt;/p&gt;
&lt;p&gt;服务时自描述的，独立的组件可以被部署为web service、EJB session beans或作为共设的Java API（与客户端被部署在同一个JVM中）。服务接口根据用途分为多种不同的类型。Oracle支持业务对象服务。&lt;/p&gt;
&lt;p&gt;业务对象是自包含的代表了真实世界的业务领域对象：一个文档、一个地方、一个人或一件事。从实现的角度来说，业务对象包含一个或多个视力对象（VO）映射到下层的复合实体（EO）（子实体不能没有父对象）。比如，在OA Framework Toolbox Tutorial中采购单业务对象包含了一个头部信息并带有一行或多行明细，每个包含一个或多个供货。供货不能离开明细行独立存在 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;面向服务的架构预览&lt;/h1&gt;
&lt;p&gt;服务的概念已经出现了很长时间，但面向服务的概念相对是比较新的。面向服务的架构是一种有助于降低应用耦合的一种构建应用的风格，独立管理的组件可以被重用和重新安排到其它完整功能的应用中。SOA提供下面的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构建和注册服务的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用户发现和调用服务的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行服务的平台&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的图演示了SOA的基本概念：&lt;/p&gt;
&lt;p&gt;SOA的基本概念&lt;/p&gt;
&lt;p&gt;&lt;img alt="srv_overview" src="/oaf_bus_svc_overview/srv_overview.gif"/&gt;&lt;/p&gt;
&lt;p&gt;使用面向服务的架构你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容易的将Oracle Applications和其它的应用集成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;影响已经部署的应用保护现有投资&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易适应更多的需求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;服务预览&lt;/h1&gt;
&lt;p&gt;服务在EBS的开发、测试、分类、公共安全和私有接口架构中是一个关键组件。开发者使用统一的指导方针和实现方式来创建服务，然后当它们控制源代码时被自动发布到集中的接口仓库。&lt;/p&gt;
&lt;p&gt;服务时自描述的，独立的组件可以被部署为web service、EJB session beans或作为共设的Java API（与客户端被部署在同一个JVM中）。服务接口根据用途分为多种不同的类型。Oracle支持业务对象服务。&lt;/p&gt;
&lt;p&gt;业务对象是自包含的代表了真实世界的业务领域对象：一个文档、一个地方、一个人或一件事。从实现的角度来说，业务对象包含一个或多个视力对象（VO）映射到下层的复合实体（EO）（子实体不能没有父对象）。比如，在OA Framework Toolbox Tutorial中采购单业务对象包含了一个头部信息并带有一行或多行明细，每个包含一个或多个供货。供货不能离开明细行独立存在，明细行不能没有头信息。（供货和行是子业务对象组件）。如果删除头，将删除所有的行和供货。通常业务对象视图对象和下层实体对象的区别在于视图对象中出现外键属性，比如定单中的供应商名称。&lt;/p&gt;
&lt;p&gt;下面的摘要是使用业务对象服务的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;业务－业务的集成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用－应用的集成（服务－服务）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPEL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据导入、导出和同步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;富客户端报表框架，比如XML Publisher&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持SDO标准&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实时数据的企业安全搜索（Secure Enterprise Search of real-time data）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自动创建Web Services&lt;/h2&gt;
&lt;h2&gt;术语&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;业务对象（Business Object）&lt;/th&gt;
&lt;th&gt;自包含的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>wxPython In Action的读书笔记</title><link href="/wxpython-in-actionde-du-shu-bi-ji.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/wxpython-in-actionde-du-shu-bi-ji.html</id><summary type="html">&lt;h1&gt;Chap 1 Welcome to wxPython&lt;/h1&gt;
&lt;p&gt;一个20行的wxPython程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"My Frame"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MOTION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnMove&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StaticText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Pos"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;posCtrl …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Chap 1 Welcome to wxPython&lt;/h1&gt;
&lt;p&gt;一个20行的wxPython程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"My Frame"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MOTION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnMove&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StaticText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Pos"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;posCtrl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TextCtrl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnMove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetPosition&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;posCtrl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;,&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MyFrame&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.1 开始wxPython&lt;/h2&gt;
&lt;p&gt;运行wxPython需要安装的软件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;工具&lt;/th&gt;
&lt;th align="left"&gt;注意点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;操作系统&lt;/td&gt;
&lt;td align="left"&gt;任何Windows 32位系统，Win98以后的版本（如果需要在Win95上运行需要下载一些额外的软件）；Unix或Linux系统兼容GTK；Mac OS X 10.2.3或更高的版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Python&lt;/td&gt;
&lt;td align="left"&gt;任何2.3或以上版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wxPyhon&lt;/td&gt;
&lt;td align="left"&gt;可以从www.wxpython.org&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;文本编辑器&lt;/td&gt;
&lt;td align="left"&gt;Python源码编辑器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;1.2 构建一个最小的wxPython程序&lt;/h2&gt;
&lt;p&gt;bare.py的源码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Bare'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序运行产生一个空窗口。多数人会把它叫作&amp;ldquo;window&amp;rdquo;。在wxPython中称为&amp;rdquo;frame&amp;ldquo;。在wxPython中&amp;ldquo;window&amp;rdquo;是一个通用的术语，它表示任何可以显示在屏幕上的对象（有些工具包中称为&amp;ldquo;widget&amp;rdquo;）。&lt;/p&gt;
&lt;p&gt;这个程序说明了编写wxPython程序必需的5个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;导入必需的wxPython包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建wxPython application类的子类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义application初始化方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个application类的实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入application的主事件循环&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="121-dao-ru-wxpython"&gt;1.2.1 导入wxPython&lt;/h3&gt;
&lt;p&gt;导入wxPython包&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入包后，可以使用wx包前缀引用wxPython类，函数等：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;旧风格的导入：&lt;/strong&gt; 旧的包名为wxPython它包含了一个内置的模块wx。有两种方法从wxPython包中导入wx模块：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wxPython&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt; &lt;span class="c1"&gt;#DEPRECATED-DON'T DO THIS ANY MORE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者，可以wx模块中的所有内容。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;wxPython.wx&lt;/span&gt; &lt;span class="nb"&gt;import&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;DEPRECATED-DON&lt;/span&gt;&lt;span class="ss"&gt;'T&lt;/span&gt; &lt;span class="nv"&gt;DO&lt;/span&gt; &lt;span class="nv"&gt;THIS&lt;/span&gt; &lt;span class="nv"&gt;ANY&lt;/span&gt; &lt;span class="nv"&gt;MORE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种方式都有严重的缺陷。使用第二种方式import &lt;em&gt;有可能导致命令空间混乱。旧的wx模块通过在所有属性前添加wx前缀避免了这个问题。尽管使用这种安全机制，但是import &lt;/em&gt;仍然可能导致问题，但很多wxPython程序员选择了这种风格，在旧代码中经常能看到这样的代码。这种风格使得类名以小写字母开头（使用wx前缀），而大多数wxPython方法名以大写字母开头。这与Python编程习惯是相反的。&lt;/p&gt;
&lt;p&gt;在导入wxPython的其它东西之前时，必须先导入wx。通常，Python中的导入顺序不相关，可以以任何顺序导入。但在wxPython中，尽管它看起来像一个模块，实际上它是一个复杂的模块集合（多数是由Simplified Wrapper and Interface Generator或SWIG自动产生的），它包装了下层的wxWidget C++ toolkit。当第一次导入wx模块时， wxPython执行其它wxPython模块所必须的初始化工作。一些wxPython的子包，比如xrc模块，可能在导入wx模块前不会工作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;                       &lt;span class="c1"&gt;# Always import wx before&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wrc&lt;/span&gt;              &lt;span class="c1"&gt;# any other wxPython packages,&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;html&lt;/span&gt;             &lt;span class="c1"&gt;# just to be on the safe side.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种要求只是针对wxPython模块；对于其它模块仍可以使用原来的方式，那些模块可以在导入wxPython模块之前或之后导入。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;xrc&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;urllib&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="122-applications-he-frames"&gt;1.2.2 applications 和 frames&lt;/h3&gt;
&lt;p&gt;任何wxPython程序必须有一个application对象和至少一个frame对象。application对象必须是wx.App或其子类的一个实例，子类中需要定义一个OnInit()方法。OnInit()方法将在程序启动时被wx.App父类调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wxPython application类&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyApp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Bare"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MyApp是一个常用的名称。OnInit()方法通常是创建frame对象的地方。但不必像这里一样直接创建wx.Frame的实例，而可以使用wx.Frame的子类。wx.Frame的构造器可以接收多个参数，上面提供的3个参数中只有第一个是必须的，其它的有默认值。&lt;/p&gt;
&lt;p&gt;调用Show()方法使frame可见。如果不调用则frame将被创建而不可见。可以向Show()方法传递一个Boolean参数切换frame显示或隐藏：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;# 使frame可见&lt;/span&gt;
&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;# True是缺省参数值&lt;/span&gt;
&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Hide&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                    &lt;span class="c1"&gt;# 与frame.Show(False)相等&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;定义一个应用初始化方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意代码中没有在application类中定义__init__()方法。在Python中，这意味着父类方法，wx.App.&lt;strong&gt;init&lt;/strong&gt;()，将在对象创建时被调用。如果自己定义了__init__()方法，不要忘记调用基类的__init__()：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# 调用基类的构造器&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# 执行其它代码...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不这样做，wxPython将不会初始化，并且OnInit()方法也不会被调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建一个application类实例并进入它的主事件循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后一步是创建wx.App子类的实例，并调用它的MainLoop()方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;application主事件循环进入后，控制权被传给wxPython。与过程式程序不同，wxPython GUI程序主要实现为事件机制，多数决定于用户的鼠标点击和键盘输入。当应用中所有的frame被关闭后，app.MainLoop()方法将返回，程序将退出。&lt;/p&gt;
&lt;h2&gt;1.3 扩展最小的wxPython程序&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="sd"&gt;'''Spare.py is a starting point for a wxPython programs. '''&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Spare'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetTopWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 设置为程序的主 frame&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;文件的第一行是一个 &lt;em&gt;shebang&lt;/em&gt; 行。它看起来像一个Python注释，在一些操作系统上，比如Linux和Unix，shebang 告诉操作系统如何找到适当的解释器来执行程序文件。如果程序文件有执行权限我们可以在命令行直接运行程序：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;spare&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;shebang行有益于Unix和Mac OS X用户，其它平台将忽略这行。即使你不使用这些系统，仍然可以包含这行以方便跨平台执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加了模块的的 &lt;em&gt;docstring&lt;/em&gt; 。当模块的第一行是一上字符串时，这个字符串变成模块的docstring 。它被存储在模块的__doc__属性中。可以在代码里，开发环境中，甚至Python解释器中访问到docstring：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;spare&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;spare&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="vm"&gt;__doc__&lt;/span&gt;
&lt;span class="n"&gt;Spare&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;starting&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;wxPython&lt;/span&gt; &lt;span class="n"&gt;programs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应该尽量在Python支持的地方添加docstring 以便于Python开发工具，比如PyCrust，在编码时提供辅助信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在bare.py中程序只是创建了wx.Frame的实例。在spare.py中，使用了自定义的wx.Frame的子类。可以在Frame上添加按钮、文本框等。实际上如果Frame类变得复杂时，可以将它放到独立的模块中，然后导入到主程序中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在application类的实例中添加了一个指向frame实例的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在OnInit()方法中我们调用了App类的SetTopWindow()方法，并将创建的frame作为参数传递给了它。这个方法可以使frame或dialog作为主窗口。一个wxPython程序可以有多个frame，其中一个作为应用的顶级窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后添加了一些Python方法测试程序是作为程序运行还是作为模块被导入。通过检查模块的__name__属性：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果模块被导入，它的 &lt;strong&gt;name&lt;/strong&gt; 属性值将与模块文件名相同（不含扩展名）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;spare&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;spare&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="vm"&gt;__name__&lt;/span&gt;
&lt;span class="s1"&gt;'spare'&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果模块是被执行，而不是被导入，Python将覆盖默认的__name__属性，将它设置为'&lt;strong&gt;main&lt;/strong&gt;'。我们使用这个机制让模块在被执行进入application实例的主循环。&lt;/p&gt;
&lt;h2&gt;1.4 创建hello.py程序&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python           # Shebang&lt;/span&gt;

&lt;span class="sd"&gt;'''Hello, wxPython! program.'''&lt;/span&gt; &lt;span class="c1"&gt;# docstring&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;                       &lt;span class="c1"&gt;# 导入wx包&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;          &lt;span class="c1"&gt;# wx.Frame子类&lt;/span&gt;
    &lt;span class="sd"&gt;'''Frame class that displays an image.'''&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;# 图像参数&lt;/span&gt;
                 &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DefaultPosition&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Hello, wxPython!'&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;'''Create a Frame instance and display image.'''&lt;/span&gt;
        &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConvertToBitmap&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 显示图像&lt;/span&gt;
        &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetWidth&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetHeight&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StaticBitmap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bitmap&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;              &lt;span class="c1"&gt;# wx.App子类&lt;/span&gt;
    &lt;span class="sd"&gt;'''Application class.'''&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;image&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'./wxPython.jpg'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BITMAP_TYPE_JPEG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 图像处理&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetTopWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;                     &lt;span class="c1"&gt;# main()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="c1"&gt;# Import vs. execute&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.5 wxPython可以做什么&lt;/h2&gt;
&lt;h2&gt;1.6 为什么选择wxPython ？&lt;/h2&gt;
&lt;p&gt;Python与wxWidget 结合&lt;/p&gt;
&lt;h2&gt;1.7 wxPython如何工作&lt;/h2&gt;
&lt;p&gt;wxPython是对C++版本的wxWidgets的封装。&lt;/p&gt;
&lt;p&gt;wxPython 用了SWIG产生C++ wxWidgets库的封装函数（glue code）。但也有大量的widgets是C++版本中不存在的。&lt;/p&gt;
&lt;p&gt;对比wxPython和C++ wxWidget，可以看到wxPython不需要创建starting point。由于Python的动态特性，可以使用 wx.Bind()方法动态绑定事件。C++ 程序中必须使用宏在编译时静态的处理。&lt;/p&gt;
&lt;h1&gt;Chap 2 Giving your wxPython program a solid foundation&lt;/h1&gt;
&lt;p&gt;wxPython程序的两个基础对象：application object和top-level window object。&lt;/p&gt;
&lt;h2&gt;2.1 必需的对象&lt;/h2&gt;
&lt;p&gt;application对象管理主事件循环，它是整个wxPython程序的心跳。application的主要工作是启动主事件循环。另外application对象有最后处理任何事件的机会。没有application对象，wxPython应用不能运行。&lt;/p&gt;
&lt;p&gt;顶层窗口对象通常管理展示给用户的最重要的数据和控件。&lt;/p&gt;
&lt;p&gt;这两个对象的关系如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_2_1.png" src="/wxPython/figure_2_1.png"/&gt;&lt;/p&gt;
&lt;p&gt;这个图显示，application对象&amp;ldquo;拥有&amp;rdquo;顶层窗口和主事件循环，顶层窗口管理窗口中的组件和赋给它的数据。窗口和其中的组件在用户动作时触发事件，并在接收到事件通知时改变显示的内容。&lt;/p&gt;
&lt;h2&gt;2.2 如何创建和使用application对象&lt;/h2&gt;
&lt;p&gt;第个wxPython程序都需要一个application对象。application对象必须是一个wx.App或其子类的一人实例。application对象的主要目的是在后台管理主事件循环。主事件循环响应窗口系统的事件并分配它们到适当的事件处理器。application对象对于wxPython是如此重要，以至于如果没有application对象，将不能创建任何的wxPython图形对象。&lt;/p&gt;
&lt;p&gt;wx.App父类也定义了少量整个应用的全局属性。多数情况下，这就是所有你需要的application对象的功能。在自定义application类中，你可以用它管理全局数据或连接（数据库连接）等。某些情况下你或许需要扩展主事件循环以处理特殊的错误或事件。但是，缺省的事件循环几乎适合于所有你将编写的wxPython程序。&lt;/p&gt;
&lt;h3 id="221-chuang-jian-wxappzi-lei"&gt;2.2.1 创建wx.App子类&lt;/h3&gt;
&lt;p&gt;开始一个新应用的时候创建application的子类是一个好的主意，即使你不需要任何自定义的功能，也可以为将来预留扩展。创建wx.App的子类，需要四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义子类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写OnInit()方法的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在程序中创建这个类的实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用application实例的MainLoop()方法。这个方法将程序控制权传递给wxPython。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OnInit()方法将在wxPython应用启动后，在进入主事件循环开始之前被调用。这个方法不接收参数并返回一个布尔值&amp;mdash;&amp;mdash;如果返回值为False，则应用程序立即退出。多数情况下，将会返回True。退出应该只会出现在错误处理中，比如缺少必要的资源。&lt;/p&gt;
&lt;p&gt;由于OnInit()方法的存在，它是wxPython框架的一部分，任何自定义初始化工作通常在这个里处理，而不是在Python的__init__方法中。如果你决定使用__init__方法，则必须调用父类的__init__方法，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常，你需要在OnInit()方法中至少创建一个frame对象，并调用它的Show()方法。你可以调用SetTopWindow()将这个frame指定为应用程序的顶级窗口。顶级窗口被作为没有父窗口的对话框的缺省父窗口&amp;mdash;&amp;mdash;本质上就是程序的主窗口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎样省略wx.App子类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以不创建wx.App的子类。通常需要在OnInit()方法中创建顶级窗口。但这并不能阻止我们在应用的其它地方创建frame，比如__main__语句。唯一的约束是wx.App实例必须先创建。通常创建wx.App子类是个好的办法，如果系统只有一个frame，这样application的初始化工作没有多少价值。这种情况下，wxPython提供了wx.PySimpleApp类。这个类提供了OnInit()方法的骨架，它的定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;useBestVisible&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clearSigInt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;useBestVisible&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="n"&gt;clearSigInt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个使用wx.PySimpleApp例子，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MyNewFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行创建了一个wx.PySimpleApp()的实例。因为使用wx.PySimpleApp类，我们没有OnInit方法，因此我们在第二行定义了frame，由于没有指定parent，因此它是一个顶级frame。第三行显示frame。最后，调用application的主循环。&lt;/p&gt;
&lt;p&gt;使用wx.PySimpleApp不需要自定义application类。但应该只在非常简单的应用中使用这种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;命名约定&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;wxPython是从C++ wxWidget派生的，使用了C++的命名约定。Python中，方法名通常使用lower_case_separated_by_underscores或者lowerCaseInterCap风格。但在C++ 中，方法名通常使用UppserCaseInterCap风格。为了保持一致性，推荐在 wxPython 类中使用wxWidgets的风格。&lt;/p&gt;
&lt;p&gt;wxPython类也在属性上使用了Get和Set方法。这是C++风格，因为在Python程序通常不定义特殊的访问方法。C++数据成员通常是private的，多数情况下你必须使用访问方法来访问wxPython类成员，而不能访问原始的属性名。&lt;/p&gt;
&lt;h3 id="222-li-jie-applicationdui-xiang-de-sheng-ming-zhou-qi"&gt;2.2.2 理解application对象的生命周期&lt;/h3&gt;
&lt;p&gt;wxPython的生命周期开始于application实例创建，结束于最后一个窗口被关闭。并不是需要在Python脚本的开始和结束位置使用这些代码。可以在创建wxPython程序前做一些操作，在application的MainLoop()退出后执行一些清理操作。但所有wxPython的操作必须在application对象的生命周期中操作。这说明主窗口（frame）必须在wx.App对象创建后才能创建。（这也是推荐在OnInit()中创建顶级窗口的原因，这里保证了application对象已经存在了。）&lt;/p&gt;
&lt;p&gt;如图所示，创建application对象触发OnInit()方法并允许创建新的窗口。OnInit()执行后，将执行MainLoop()，表示wxPython事件被处理。应用继续执行，事件处理直到窗口被关闭才结束。所有顶层窗口被关闭后，MainLoop()函数返回后application对象被销毁。接下来，脚本可以关闭任何连接或存在的线程。&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_2_2.png" src="/wxPython/figure_2_2.png"/&gt;&lt;/p&gt;
&lt;h2&gt;2.3 如何重定向 wxPython 程序的输出？&lt;/h2&gt;
&lt;p&gt;所有Python程序可以通过两个标准流输出文本：标准输出流sys.stdout和标准错误流sys.stderr。但是，在创建application对象时你可以控制wxPython将这些标准流重定向到一个窗口中。这个重定向行为在Windows下是默认行为。在Unix系统中，它更像是一个实际的终端窗口，wxPython缺省不控制标准流。在所有系统中，重定向行为可以在创建application对象时显式的指定。推荐使用这个功能的优点，总是指定重定向以避免在不同平台间产生不同的行为。&lt;/p&gt;
&lt;h3 id="231-zhong-ding-xiang-shu-chu"&gt;2.3.1 重定向输出&lt;/h3&gt;
&lt;p&gt;如果wxPython控制标准流，发送到流中的文本（包括print语句或system trackback）被重定向到单独的wxPython frame。在wxPython应用开始前或之后发送到流中的文本，仍然会像的方式那样处理。下例演示了应用生命周期和stdout/stderr重定向。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c1"&gt;# -*- coding: cp936 -*-&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"Frame __init__"&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"App __init__"&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"OnInit"&lt;/span&gt;                  &lt;span class="c1"&gt;# 写到stdout&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Startup'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 创建frame&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetTopWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"A pretend error message"&lt;/span&gt; &lt;span class="c1"&gt;# 写到stderr&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnExit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"OnExit"&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;            &lt;span class="c1"&gt;# 1.文本重定向从这行开始，这行后，所有文本被重定向到frame中&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"before MainLoop"&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                      &lt;span class="c1"&gt;# 2.进入主循环&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"after MainLoop"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这行创建了application对象。从这行后面开始，所有发送到stderr和stdout的文本被wxPython重定向到一个frame中。构造器参数决定了是否进行重定向。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当运行时，application创建了一个空的frame，也创建了一个显示用于重定向输出的frame。注意，stdout和stderr的信息都被定向到这个窗口中。在运行这个程序后只能在终端看到下面的输出：
&lt;example&gt;
App &lt;strong&gt;init&lt;/strong&gt;
after MainLoop
&lt;/example&gt;
第一行产生于frames被打开之前，第二行产生于它们关闭后。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过查看终端和用于输出的frame，我们可以获知整个应用的生命周期。&lt;/p&gt;
&lt;p&gt;1所示的位置是脚本的启点，从脚本的__main__子句开始运行。接下来在实例上调用wx.App__init__()，控制权转到OnInit()方法，它被wxPython自动调用。从那里，程序转评戏wx.Frame.&lt;strong&gt;init&lt;/strong&gt;()，当wx.Frame实例化后被执行。最后控制转回__main__子句，MainLoop()被调用。主循环结束后，wx.App.OnExit()被wxPython调用，然后执行其余的脚本完成整个过程。&lt;/p&gt;
&lt;p&gt;从OnExit()中发出的消息既没有显示在窗口中也没有显示在终端中。实际上在窗口被关闭前执行了显示消息的操作，只是由于速度太快看不到。&lt;/p&gt;
&lt;p&gt;快速消失的OnExit()消息对于重定向输出的frame有更大的问题。尽管它在开发阶段是个有用的功能，但你不需要在运行时将带有错误消息流的Frame在用户界面中弹出。而且，如果在执行OnInit()方法时发生了错误，它将把消息发送到重定向frame，但错误将导致应用退出，因为OnInit()将在遇到错误时返回False。结果就会出现文本显示了但消失得很快而看不到。&lt;/p&gt;
&lt;h3 id="xiu-gai-que-sheng-de-zhong-ding-xiang-xing-wei"&gt;修改缺省的重定向行为&lt;/h3&gt;
&lt;p&gt;为了修正上面的行为，wxPython允许在创建应用时设置两个参数。第一个参数，redirect，如果被设置为True输出将被重定向到frame中，如果设置为False，输出仍然输出到终端。如果redirect参数为True，第二个参数，filename，可以被设置。如果设置了，输出被重定向到这个参数所指定的文件名，而不是wxPython frame。因此，修改wx.App创建的代码为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将导致下面的输出显示在终端：
&lt;example&gt;
App &lt;strong&gt;init&lt;/strong&gt;
OnInit
Frame &lt;strong&gt;init&lt;/strong&gt;
A pretend error message
before MainLoop
OnExit
after Mainloop
&lt;/example&gt;
注意这里的OnExit()消息显示出来了。将这行代码改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"output"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将使输出发送到名为filename的文件中。App __init__和after MainLoop消息将被发送到终端，这是由于这们发生在wx.App对象控制输出流的周期之外。&lt;/p&gt;
&lt;h2&gt;2.4 如何关闭wxPython应用&lt;/h2&gt;
&lt;p&gt;当应用中最后一个顶级窗口（top-level）被用户关闭后，wxPython应用退出。top-level，指没有parent，不仅仅指使用了SetTopWindow()方法设置的frame。也包括那些由wxPython自己创建的frame。比如，在上例中应用只有在主frame和重定向输出的frame都被关闭时才会被关闭，即使只用主frame使用了SetTopWindow()，即使在应用中没有显式的创建重定向的frame。编程的方式触发关闭，可以在所有top-level窗口中调用Close()。&lt;/p&gt;
&lt;h3 id="241-guan-li-zheng-chang-guan-bi"&gt;2.4.1 管理正常关闭&lt;/h3&gt;
&lt;p&gt;在关闭的过程中，wxPython删除所有窗口和释放相关资源。有一个勾子可以使你在退出时执行自己的代码。如果在wx.App的子类中定义了OnExit()方法，它将在最后一个窗口被关闭后在wxPython进行清理前执行。你可以使用这个方法清理你创建的非wxPython的资源（比如数据库连接）。即使应用是使用wx.Exit()关闭的，OnExit()方法也将被触发。&lt;/p&gt;
&lt;p&gt;如果由于某些原因你希望在最后一个窗口被关闭后继续执行，你可以使用wx.App的方法SetExitOnFrameDelete(flag)改变这个默认行为。如果flag参数被设置为False，程序将继续执行即使最后一个窗口被关闭。这意味着wx.App实例继续存活，事件循环将继续处理事件。你可以创建新的顶级窗口。应用将继续存活直到全局函数wx.Exit()被显式的调用。&lt;/p&gt;
&lt;p&gt;wxPython在进入主事件循环前不会触发这个关闭过程。比如，你在OnInit()方法中打开一个对话框，你可以关闭它而不用担心wxPython会将这个操作解释为最后一个顶级窗口被关闭而关闭程序。&lt;/p&gt;
&lt;h3 id="242-guan-li-jin-ji-guan-bi"&gt;2.4.2 管理紧急关闭&lt;/h3&gt;
&lt;p&gt;某些时候你需要应用立即结束而不关心程序的清理工作。比如系统关闭，你不能执行所有的清理工作。&lt;/p&gt;
&lt;p&gt;紧急情况下有两种机制退出wxPython应用。可以调用wx.App的方法ExitMainLoop()。这个方法显式的导致主消息循环中断，导致程序控制权离开MainLoop()函数。这通常将结束应用程序&amp;mdash;&amp;mdash;效果与关闭所有顶级窗口相等。&lt;/p&gt;
&lt;p&gt;也可以调用全局方法wx.Exit()。两个方法都不推荐在正常情况下使用，因为它可能导致一些清理函数被跳过。&lt;/p&gt;
&lt;p&gt;有时，你的应用由于不可控的外部原因需要关闭。比如当操作系统被关闭或用户登出。这种情况下，你的应用能获得一个机会清理或保存文档或关闭连接。如果应用绑定了一个事件处理器到wx.EVT_QUERY_END_SESSION事件，则那个事件处理器将在应用关闭时被wxPython通知。（第三章将介绍如何绑定事件到事件处理器）事件参数是一个wx.CloseEvent。关闭事件允许应用否决应用的关闭。应用使用事件的方法CanVeto()来否决应用的关闭。如果你不能成功的保存或关闭所有资源，你可能需要这么做。默认的wx.EVT_QUERY_END_SESSION事件处理器调用顶级窗口的Close()方法，这样将依次发送wx.EVT_CLOSE事件到顶级窗口，给了你另一个机会来控制关闭的过程。如果任何Close()方法返回False则应用将试图阻止应用关闭。&lt;/p&gt;
&lt;h2&gt;2.5 如何创建和使用顶级窗口对象&lt;/h2&gt;
&lt;p&gt;顶级窗口对象是一个构件（widget）（通常是一个frame）它不被应用中的其它构件所包含。顶级窗口通常是应用程序的主窗口，它包含构件和用于与用户交互的界面对象。前面说过，当所有顶级窗口被关闭时应用程序将退出。&lt;/p&gt;
&lt;p&gt;应用至少有一个顶级窗口对象。顶级窗口对象通常是wx.Frame类的子类，尽管它也可以是wx.Dialog的子类。多数情况下你会在应用中自定义wx.Frame的子类。但wxPython中定义了许多典型的wx.Dialog的子类。&lt;/p&gt;
&lt;p&gt;通常&amp;ldquo;顶级窗口（top-level）&amp;rdquo;指应用中任何（any）没有父容器的构件。你的应用必须有至少一个，但也可以有多个顶级窗口。但这些窗口中，只有一个被显式的使用SetTopWindow()指定为主顶级窗口（main top window）。如果你不使用SetTopWindow指定一个主顶级窗口，则在wx.App的顶级窗口中的第一个frame被作为主顶级窗口。因此显式的指定主顶级窗口并不是必须的，比如，应用中只有一个顶级窗口。重复调用SetTopWindow()将替换当前的顶级窗口&amp;mdash;&amp;mdash;应用中同一时刻只能有一个顶级窗口。&lt;/p&gt;
&lt;h3 id="251-wxframe"&gt;2.5.1 wx.Frame&lt;/h3&gt;
&lt;p&gt;在wxPython的叫法中，frame通常是被GUI用户称作窗口。也就是说，frame是一个可以由用户在屏幕上移动的容器，它通常包含标题条，菜单条，并能调整大小。wx.Frame是所有frame类的父类。也有一些特殊的wx.Frame的子类。&lt;/p&gt;
&lt;p&gt;当创建wx.Frame的子类时，在__init__()方法中应该调用父对象的构造器wx.Frame.&lt;strong&gt;init&lt;/strong&gt;()。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DefaultPosition&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DefaultSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEFAULT_FRAME_STYLE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"frame"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造器包含了多个参数。通常，应该包含一些合理的默认值。在其它构件的构造器中也可以看到这种参数&amp;mdash;&amp;mdash;这与wxPython中的模式类似。&lt;/p&gt;
&lt;p&gt;parent | 创建这个frame的父窗体。对于top-level窗口，这个值为None。如果窗口使用了parent参数，则新的frame将属于那个父窗口。在父窗口销毁时被销毁。根据具体的平台，新的frame可能被限制于显示在父窗的上面。在MDI窗口中，新的frame只能在父窗口内部移动和改变大小。
id | 新窗口的wxPython ID号。可以显式的传递一个值，或传入-1以由wxPython自动产生一个新的ID。
title | 窗口标题&amp;mdash;&amp;mdash;多数风格下，它将在窗口的标题条上。
pos | 一个wx.Point对象指定新窗口的左上角在屏幕上的位置。在典型的图形应用中，(0,0)指屏幕的左上解。默认的值为(-1,-1)，这将窗口摆放的位置交给下层的系统自动处理。
size | 一个wx.Size对象指定窗口的大小。默认为(-1,-1)指定由下层的系统自动处理。
style | 一个位常量决定窗口的风格。可以使用位或操作符（|）组合一种或多种效果。
name | 给frame设置的内部名称，用于在Motif中设置资源的值。也可以在后面用于通过名称查找窗口&lt;/p&gt;
&lt;p&gt;设置默认值的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"My Friendly Window"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="252-wxpython-id"&gt;2.5.2 wxPython ID&lt;/h3&gt;
&lt;p&gt;ID号是wxPython中所有构件都有的。wxPython应用中每个构件都有一个窗口标识。ID号在每个frame中必须是唯一的，但在不同的frame间可以重用ID。我们建议，在整个应用中使用唯一的ID号，以防止在事件处理时发生错误和混乱。在wxPython中有少量预定义的ID号，它们在部分代码中的特定的含义（比如，wx.ID_OK和wx.ID_CANCEL假设为对话框中的OK和Cancel按钮的ID值）。通常在应用中重用标准ID并没有问题。ID值参数通常是传递给wxPython构件构造器的第二个参数，放在父构件参数的后面。在wxPython中使用ID值最重要的作用是创建对象事件和事件响应函数之间的关系。使用重复的ID有可以导致对事件触发错误的响应。&lt;/p&gt;
&lt;p&gt;有三种方法创建构件所使用的ID值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;的传递一个正整数值给构造器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过wxPython提供的wx.NewId()函数创建ID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传递全局常量wx.ID_ANY或-1给构造的构造器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="xian-shi-di-jue-ding-id"&gt;显式地决定ID&lt;/h4&gt;
&lt;p&gt;最直接的方式，是传递正整数值给构造器作为构件的ID。如果你传递了这个值，则应该确保这个值在同一个frame中的唯一性或者它为一个预定义的常量值。可以使用全局函数ex.RegisterID()来确认wxPython没有在其它地方使用你指定的值。为了防止你的ID与wxPython预定义的ID重复，你使用的ID值应该处于全局变量wx.ID_LOWEST和wx.HIGHEST之间。&lt;/p&gt;
&lt;h4 id="shi-yong-quan-ju-han-shu-newid"&gt;使用全局函数NewId()&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="shi-yong-chang-liang"&gt;使用常量&lt;/h4&gt;
&lt;p&gt;传递wx.ID_ANY或-1给构造器，则wxPython将自动生成一个新的ID。然后你可以用GetId()方法获取这个ID。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetId&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的三种方法并没有明显的区别。&lt;/p&gt;
&lt;h3 id="253-wxsizehe-wxpoint_1"&gt;2.5.3 wx.Size和wx.Point&lt;/h3&gt;
&lt;p&gt;wx.Frame构造器的参数中使用到了wx.Size和wx.Point。这两个类在wxPython程序中使用较频繁。wx.Point类描述点或位置。构造器接收2个参数作为点的x值和y值。如果没有设置参数则缺省为0。使用Set(x,y)设置两个维的值。使用Get()可以获取这两个值，它将把返回值作为包含两个元素的Python元组返回。与多数wxWidgets类不同，wx.Point有访问x和y值的定义。像访问典型的Python属性一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，wx.Point实例可以作相加，相减，比较操作。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="n"&gt;bigger&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在wx.Point实例中，属性是整数。如果需要浮点坐标，可以使用wx.RealPoint，它与wx.Point类似。&lt;/p&gt;
&lt;p&gt;wx.Size类几乎与wx.Point一样，除了实例变量被命名为width和height而不是x和y。他们有同样的属性和操作符定义。&lt;/p&gt;
&lt;p&gt;当在wxPython程序中需要wx.Point和wx.Size实例时&amp;mdash;&amp;mdash;比如，传递给另一个对象的构造器&amp;mdash;&amp;mdash;你不需要创建实例。只需要传递Python元组给构造器，wxpython将隐式的创建wx.Point和wx.Size实例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这不可以用于构造器，也可以用于被封装的C++方法调用。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetPosition&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="wxframefeng-ge"&gt;wx.Frame风格&lt;/h3&gt;
&lt;p&gt;wx.Frame构造器可接收一个位参数作为style参数。每个wxPython构件对象都有一个类似style的参数，尽管不同类型构件的定义是不同的。这节讨论wx.Frame的风格。其中一些也适用于其它wxPython构件。&lt;/p&gt;
&lt;p&gt;所有wxPython构件的风格定义是通过向构造器传递一个位参数来实现的。一些构件也定义了SetStyle()方法，允许你在创建构件后再修改。所有单个的风格元素都对应有预定义的常量（比如wx.MINIMIZE_BOX）。要将多种风格放在一起，可以使用Python位或操作符，|。比如，wx.DEFAULT_FRAME_STYLE的定义是由一些基础风格元素组成的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MAXIMIZE_BOX&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MINIMIZE_BOX&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RESIZE_BORDER&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SYSTEM_MENU&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CAPTION&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CLOSE_BOX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要移除单个风格位时，可以使用异或操作符，^。比如，创建一个基于默认的窗口，但不想它改变大小，可以这么做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEFAULT_FRAME_STYLE&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RESIZE_BORDER&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MINIMIZE_BOX&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MAXIMIZE_BOX&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;强烈建议在顶级frame上使用默认风格以便用户可以很容易的识别他们是顶级的窗体。至少，你需要确保顶级的frame可以被关闭。这只需要在风格中包含wx.SYSTEM_MENU。要注意不要使用与操作（&amp;amp;）代替或操作（|）。如果没有风格设置，frame将没有边框，不能移动或关闭。&lt;/p&gt;
&lt;p&gt;wx.Frame中常用的风格参数&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;风格&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.CAPTION&lt;/td&gt;
&lt;td align="left"&gt;在frame上添加标题条，显示frame的标题属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.CLOSE_BOX&lt;/td&gt;
&lt;td align="left"&gt;指示系统在frame的标题条上显示关闭按钮，并使用系统默认的位置和风格。如果可以的话也将启用系统菜单上的关闭选项。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.DEFAULT_FRAME_STYLE&lt;/td&gt;
&lt;td align="left"&gt;如果没有指定style则这个值被作为默认值。它的定义是&lt;code&gt;wx.MAXIMIZE_BOX&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.FRAME_SHAPED&lt;/td&gt;
&lt;td align="left"&gt;使用这个风格创建的frame可以使用SetShape()方法创建一个非矩形的窗口。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.FRAME_TOOL_WINDOW&lt;/td&gt;
&lt;td align="left"&gt;通过缩小标题条使用frame看起来像一个toolbox窗口。在Windows中以这种风格创建的窗口不会显示在任务栏的窗口列表中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.MAXMIZE_BOX&lt;/td&gt;
&lt;td align="left"&gt;在frame上添加最大化按钮，使用系统参数来决定按钮的位置和外观。如果可以也将启用系统菜单上的最大化按钮。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.MINIMIZE_BOX&lt;/td&gt;
&lt;td align="left"&gt;在frame上添加最小化按钮，使用系统参数来决定按钮的位置和外观。如果可以也将启用系统菜单上的最小化按钮。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.RESIZE_BORDER&lt;/td&gt;
&lt;td align="left"&gt;在frame边框上添加调整大小的功能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.SIMPLE_BORDER&lt;/td&gt;
&lt;td align="left"&gt;在边框上取消装饰。可能不能工作于所有的平台。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.SYSTEM_MENU&lt;/td&gt;
&lt;td align="left"&gt;添加系统菜单（关闭，移动，改变大小，等等。使用系统的外观）和关闭按钮。菜单中的改变窗口大小和关闭操作依赖于wx.MAXMIZE_BOX，wx.MINIMIZE_BOX和wx.CLOSE_BOX的设置。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;2.6 如何添加对象和子窗体到frame上&lt;/h2&gt;
&lt;h3 id="261-tian-jia-gou-jian-dao-frameshang"&gt;2.6.1 添加构件到frame上&lt;/h3&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;InsertFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Frame With Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;# （1）创建面板&lt;/span&gt;
        &lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Close"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;125&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="c1"&gt;# （2）将按钮添加到面板&lt;/span&gt;
                &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （3）绑定按钮点击事件&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_CLOSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;# （4）绑定窗口关闭事件&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Destroy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InsertFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;InsertFrame类的__init__方法创建了两个子窗口（1）和（2）。第一个为wx.Panel，它本质上是一个包含其它窗口的容器它自己只有很少的功能。第二个是wx.Button，它是一个普通的按钮。按钮事件的窗口关闭事件绑定到函数是在（3）和（4）。&lt;/p&gt;
&lt;p&gt;多数情况下，你将创建一个单独的wx.Panel实例它的大小和你的wx.Frame的大小是一样的由它来包含所有需要显示在frame中的内容。这样做以保持用户的内容与窗口的其它元素，如工具条、状态条等分离。另外，在Windows操作系统中，wx.Frame的缺省的背景色不是标准的（它是灰色的，不是白色），当然wx.Panel默认是白色背景（假设你没有修改你的系统的主题设置）。wx.Panel类允许使用tab键遍历内部的元素，而wx.Frame不支持。&lt;/p&gt;
&lt;p&gt;与其它UI工具包不同，你不需要调用方法将子窗口插入到父窗口中。在wxPython中你只需要在创建子窗口时指定父窗口，这样子窗口就被添加到父窗口内部。&lt;/p&gt;
&lt;p&gt;在上面的代码中wx.Button创建时指定了位置和大小，而wx.Panel没有指定。在wxPython中，如果frame中只有一个子窗口，则那个子窗口（这里的wx.Panel）将自动改变大小到填充整个frame的客户区域。这个自动处理的过程将覆盖子窗口中设置的位置和大小信息&amp;mdash;&amp;mdash;即使panel指定了位置和大小信息，它也将被忽略。这种自动改变大小的行为只发生在frame或dialog中只有一个元素的情况下。按钮是panel的子对象，而不是frame，因此它指定的大小和位置被使用。如果按钮的位置和大小没有指定则将使用默认的位置，位于panel的左上角，它的大小取决于标签文本的长度。&lt;/p&gt;
&lt;p&gt;显式的指定每个子窗口大小和位置很快就让人觉得泛味。更重要的是，它不允许你的应用在用户调整窗口大小时重新配置对象的位置。为了解决这些问题，wxPython使用sizers对象来管理复杂的子窗口的定位。&lt;/p&gt;
&lt;h3 id="262-tian-jia-cai-dan-tiao-gong-ju-tiao-huo-zhuang-tai-tiao-dao-frame"&gt;2.6.2 添加菜单条、工具条或状态条到frame&lt;/h3&gt;
&lt;p&gt;通常，一个应用程序窗口将有一到三个特殊的子窗口&amp;mdash;&amp;mdash;顶部的菜单条，工具条和底部的状态条。wxPython提供了特殊的快捷方法来创建工具条和状态条（菜单条不是那么困难）。&lt;/p&gt;
&lt;p&gt;下面的代码中的__init__方法在普通窗口上装钸了所有这三种子窗口。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;images&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ToolbarFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Toolbars'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'White'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;statusBar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateStatusBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# （1）创建状态条&lt;/span&gt;
        &lt;span class="n"&gt;toolbar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateToolBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;     &lt;span class="c1"&gt;# （2）创建工具条&lt;/span&gt;
        &lt;span class="n"&gt;toolbar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddSimpleTool&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getNewBitmap&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
                              &lt;span class="s2"&gt;"New"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Long help for 'New'"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （3）添加工具条按钮&lt;/span&gt;
        &lt;span class="n"&gt;toolbar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Realize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                                   &lt;span class="c1"&gt;# （4）准备显式工具条&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MenuBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                              &lt;span class="c1"&gt;# （5）创建菜单条&lt;/span&gt;
        &lt;span class="n"&gt;menu1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                                   &lt;span class="c1"&gt;# （6）创建两个独立的菜单&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;File"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Copy"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Copy in status bar"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"C&amp;amp;ut"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"Paste"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AppendSeparator&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Options..."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Display Options"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （7）创建独立的菜单项&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Edit"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                            &lt;span class="c1"&gt;# （8）将菜单加到菜单条&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetMenuBar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                                  &lt;span class="c1"&gt;# （9）将菜单条加到frame&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ToolbarFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（1）创建了状态条，它是类wx.StatusBar的一个实例。作为frame来说，它是一个放置在frame底部的子窗体，它的宽度与frame相同，高度决定于下层的操作系统。状态条的目的是为了显式应用中事件所设置的文本信息。文本的大小和字体也取决于所处的操作系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（2）创建了一个wx.ToolBar的实例，它是一个自动定位于frame顶部的包含命令按钮的容器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（3）有两个方法可以添加工具到工具条，这行显式带少量参数的一种，AddSimpleTool()。参数是一个ID、位图、作为帮助信息显式的tips、显式在状态条上的较长的提示信息。尽管工具在工具条上看起来像按钮，但对于事件系统，它的行为更像一个菜单项，它使工具表现得与菜单条中的项一样。特别是点击工具按钮触发的wxPython事件类型与菜单项的一样，这意味着它们可以使用同样的方法来响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（4）Realize()方法告诉工具条计算按钮应该放在什么位置，这是需要的，因为工具条添加工具依赖于动态定位，因为它没有显式指定自己的大小和位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（5）创建一个wx.Menu对象，它描述一个菜单项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（6）创建独立的菜单项，参数有ID、项上的文本、显示在状态栏上的文本。&amp;ldquo;&amp;amp;&amp;rdquo;指定菜单项的快捷键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.7 使用通用对话框&lt;/h2&gt;
&lt;p&gt;wxPython库提供了丰富的预定义的对话框，它使你的应用有统一、熟悉的外观。这节我们讨论三种基本的获取用户信息的对话框：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;消息对话框&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文本输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表选择&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;wxPython中有许多标准的对话框，包括文件选择、颜色选择、进度条对话框、打印设置、字体选择、&lt;/p&gt;
&lt;h3 id="fa-song-xiao-xi"&gt;发送消息&lt;/h3&gt;
&lt;p&gt;最常用的与用户通话的方式是使用wx.MessageDialog，它是一个简单的警告框。wx.MessageDialog可以用于简单的OK对话框，或yes/no对话框。下面的片段显式了yes/no的行为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;dlg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MessageDialog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Is this the coolest thing ever!'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                       &lt;span class="s1"&gt;'MessageDialog'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;YES_NO&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ICON_QUESTION&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ShowModal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Destroy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的构造器结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MessageDialog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;caption&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Message box"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OK&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CANCEL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DefaultPosition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;parent是父窗口，或None如果对话框为顶级对话框。message是显示在对话框中的，catption是显示在标题栏中的字符串。style参数是决定显示在对话框中的按钮和图标的bitmask，pos参数可以接收wx.Point类型或Python元组，允许你指定对话框显示在屏幕上的位置，如果你需要的话。&lt;/p&gt;
&lt;p&gt;ShowModal()方法将对话框显示为模态frame，这表示应用中的其它窗口在用户关闭这个对话框后才能响应用户事件。这个方法通常用于所有对话框。ShowModal()的返回值是一个整数，表示对话框的结果。在这里，结果取决于用户按的按钮。对于wx.MessageDialog，它将返回下面的常量：wx.ID_YES，wx.ID_NO，wx.ID_CANCEL，或wx.ID_OK。&lt;/p&gt;
&lt;p&gt;控制风格的bit位可以组合来控制按钮的显示，规定的值为wx.OK，wx.CANCEL，wx.YES_NO。风格位可以用于设置显示于窗口中的图标，它可以是这些值中的一种：wx.ICON_ERROR，wx.ICON_EXCEPTION，wx.ICON_INFORMATION，wx.ICON_QUESTION。&lt;/p&gt;
&lt;h3 id="shu-ru-dan-xing-wen-ben"&gt;输入单行文本&lt;/h3&gt;
&lt;p&gt;如果你需要从用户获取单行文本，你可以使用wx.TextEntryDialog类。下面的片段创建了这种对话框，如果用户点击OK按钮退出则获取输入框中的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;dlg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TextEntryDialog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Who is buried in Grant's tomb?"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="s1"&gt;'A Question'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Cary Grant'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ShowModal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ID_OK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetValue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wx.TextEntryDialog构造器的参数依次是，父窗口，显示于窗口中的文本，显示于窗口标题栏上的文本（默认为&amp;ldquo;Please enter text&amp;rdquo;），输入框的默认值（默认为空字符串）。也有一个style参数它默认被设置为wx.OK | wx.CANCEL。你可以只向style属性传递wx.OK来创建一个没有cancel按钮的对话框。与wx.MessageDialog类似，ShowModal()方法返回被按下的按钮的ID。GetValue()方法包含用户输入到文本框的值（对应的方法为SetValue()，它允许你修改输入框的值）。&lt;/p&gt;
&lt;h3 id="lie-biao-xuan-ze-kuang"&gt;列表选择框&lt;/h3&gt;
&lt;p&gt;列表选择对话框使用wx.SingleChoiceDialog类。举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;dlg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SingleChoiceDialog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="s1"&gt;'What version of Python are you using?'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="s1"&gt;'Single Choice'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'1.5.2'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'2.0'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'2.1.3'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'2.2'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'2.3.1'&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ShowModal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ID_OK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetStringSelection&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数与文本输入对话框类似，除了传递的字符串文本，在这里传递的是一个列表中的字符串列表。有两种方式区取选择的返回值。GetSelection()返回用户选中的元素的编号，而GetStringSelection()返回选中的实际字符串。&lt;/p&gt;
&lt;h2&gt;2.8 应用程序对象和frame的常见错误&lt;/h2&gt;
&lt;p&gt;在创建wxPython application对象或初始化顶级窗体时有少量错误在发生时可能难于跟踪，特别是当第一次遇到这些错误时。下面的错误列表列出了出错时错误信息没有完全描述清楚实际问题的情况，或者错误验证于分析的情况。这些对于wxPython初学者都是常见的错误：&lt;/p&gt;
&lt;p&gt;常见问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误消息：&amp;ldquo;unable to import module wx.&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因&amp;mdash;&amp;mdash;wxPython模块不在PYTHONPATH中。这表示wx.Python可能没有正确安装。如果系统中安装了多个Python系统，wxpython可能不是被安装到当前使用的那个Python环境中。&lt;/p&gt;
&lt;p&gt;解决办法&amp;mdash;&amp;mdash;检查你使用的Python版本。在Unix系统中，which python命令可以告诉你默认的Python。在Windows系统中，可以通过查看.py文件关联的解释器。如果wxPython没有正确安装，需要装它放到&lt;python-home&gt;/Lib/site-packages子目录中。有可能需要安装或重装wxPython。&lt;/python-home&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用在启动时立即崩溃或显示一个空窗口后崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因&amp;mdash;&amp;mdash;一个wxPython对象先于wx.App之前创建。&lt;/p&gt;
&lt;p&gt;解决办法&amp;mdash;&amp;mdash;在启动时立即创建wx.App。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶级窗口在创建后立即被关闭。应用立即退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因&amp;mdash;&amp;mdash;没有调用wx.App.MainLoop()。&lt;/p&gt;
&lt;p&gt;解决办法&amp;mdash;&amp;mdash;在所有设置完成后调用MainLoop()方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶级窗口在创建后立即被关闭。应用立即退出，并且调用了MainLoop()方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因&amp;mdash;&amp;mdash;在应用的OnInit()方法中发生了错误，或者其中调用的方法发生了错误（比如frame的__init__()方法）。&lt;/p&gt;
&lt;p&gt;解决办法&amp;mdash;&amp;mdash;在调用MainLoop()之前发生的错误将触发异常并退出程序。如果应用设置了重定向stdout和stderr到窗口，则这个窗口将不能停留足够长的时间显示错误信息。创建应用（application）对象时设置redirect=False以便看到错误信息。&lt;/p&gt;
&lt;h2&gt;2.9 总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;wxPython程序的基础是基于两个对象：一个应用程序对象和顶级窗口。每个wxPython应用需要实例化一个wx.App对象，至少要有一个顶级窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用程序对象包含wx.App.OnInit()方法，它在启动时被调用。这个方法是初始化frame和其它全局对象的首选位置。wxPython应用程序在所有顶级窗口被关闭，或主事件循环被退出时被正常关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用程序对象也控制wxPython的文本输出的重定向。默认情况下，wxPython将stdout和stderr重定向到一个特殊的窗口。这个行为可能导致启动故障检测困难。可以改变这种行为将错误信息发送到文件或终端窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.Python应用程序通常至少使用一个wx.Frame的子类。一个wx.Frame对象在创建时可以使用多种style参数。每个wxWidget对象，包括frame，都有一个ID,它可以由应用显式的赋值或由wxPython自动生成。子窗体通过通过指定parent参数插入父窗体中。通常一个frame包含一个wx.Panel其它子窗体放在panel上。frame的单个子窗体将随父窗体缩放而缩放。frame有显式的管理机制管理菜单条、工具条和状态条。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽管使用frame可以适用于任何复杂的需求，当你需要简单快捷的从用户获取信息时，你可以给用户显示标准对话框。这些标准对话框可以完成许多任务，包括：警告框、简单的文本录入或列表选择框。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Chap 3 事件驱动环境&lt;/h1&gt;
&lt;p&gt;事件处理机制是让wxPython工作的基础。一个主要通过事件处理来工作的程序被称作事件驱动。&lt;/p&gt;
&lt;p&gt;事件指系统中发生的一些事情，你的应用可以响应来触发一些功能。事件可以是低级用户动作，比如鼠标移动或按键按下，或由wxPython指定的高级用户事件，因为它在wxPython构件内部被替换了，比如按钮的click或菜单选择事件。事件也可以由下层的操作系统创建，比如请求关机。你甚至可以创建自己的对象来产生你自己的事件。wxPython应用程序通过关联响应代码段与指定类型的事件类型来工作。事件映射到代码的处理被称作事件处理。&lt;/p&gt;
&lt;h2&gt;3.1了解事件之前&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;术语&lt;/th&gt;
&lt;th align="left"&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件（event）&lt;/td&gt;
&lt;td align="left"&gt;应用中发生的需要响应的事情&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件对象（event object）&lt;/td&gt;
&lt;td align="left"&gt;wxPython中事件的具体描述包括针对具体事件的数据属性。事件被描述为wx.Event类和其子类的实例，比如wx.CommandEvent和wx.MouseEvent。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件类型（event type）&lt;/td&gt;
&lt;td align="left"&gt;一个整数ID，wxPython将添加到每个事件对象。事件类型给出了事件更详细的信息。比如，wx.MouseEvent的事件类型指明了事件是鼠标点击还是鼠标移动。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件源（event source）&lt;/td&gt;
&lt;td align="left"&gt;任何创建事件的wxPython对象。比如按钮，菜单项，列表框或其它构件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件驱动（event-driven）&lt;/td&gt;
&lt;td align="left"&gt;一种程序结构花大量时间等侍或响应事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件队列（event queue）&lt;/td&gt;
&lt;td align="left"&gt;连续的事件列表包含已经发生但没有被处理的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件处理器（event handler）&lt;/td&gt;
&lt;td align="left"&gt;用于响应事件的函数或方法。也称为事件处理函数或事件处理方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件绑定器（event binder）&lt;/td&gt;
&lt;td align="left"&gt;一个wxPython对象，维护构件与特定事件类型的关系。为了能被调用，所有事件处理器必须注册到一个事件绑定器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.EvtHandler&lt;/td&gt;
&lt;td align="left"&gt;一个wxPython类，它的实例能创建针对特定类型事件的事件绑定器，事件源，和与事件处理器之间的绑定关系。wx.Evthandler与事件处理函数或先前的方法定义&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;3.2 什么是事件驱动编程&lt;/h2&gt;
&lt;p&gt;事件驱动程序的主要控制结构就是接收事件和响应它们。wxPython程序的结构（或者任何事件驱动程序）与典型的Python脚本是根本不同的。典型的Python脚本有特定的起点的终点，程序员使用条件、循环和函数控制执行顺序。程序不是线性的，但它的顺序通常是不依赖于用户的动作。&lt;/p&gt;
&lt;p&gt;从用户的角度看，一个wxPython程序花大量时间什么也不做。通常，它处理空闲状态直到用户或系统做了什么触发wxPython程序进入动作。wxPython程序结构是一个事件驱动程序架构的例子。&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_1.png" src="/wxPython/figure_3_1.png"/&gt;&lt;/p&gt;
&lt;p&gt;表3.1显示了事件驱动程程序的主要部分。&lt;/p&gt;
&lt;p&gt;把事件驱动系统中的主事件循环想像成类似一个客户服务中心的操作员。当没有电话时这个操作员处于侍命状态。终于，有一个事件发生了，比如电话铃响了。这个操作员启动响应处理，包括与客户谈话直到操作员有足够信息来将客户分配到它请求的人。操作然等侍下个事件。&lt;/p&gt;
&lt;p&gt;尽管每个事件驱动系统都有些不同，但他们也有相似的地方。事件驱动程序结构的主要特征如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;初始化后，程序花多数的时间在等侍循环中，在这里它执行很少的或不执行处理。进入这个循环表示程序用户交互部分的开始，离开循环表示结束。在wxPython中，这个循环是方法wx.App.MainLoop()，它在你的脚本中被显示的调用。当所有顶级窗口被关闭时主循环自动退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序包含事件对应于程序环境中发生的事件。事件通常由用户触发，但也可以由系统触发，或程序中其它地方的任意代码。在wxPython中，所有事件都是wx.Event类或它的子类的实例。每个事件都有一个事件类型属性它标识出不同事件的特点。比如，鼠标向上和向下移动都是作为相同类型的实例来分派的，但它们具有不同的事件类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作为等侍循环的一部分，程序定期检查是否有需要响应的事件发生。事件驱动系统有两种机制可以得到事件的通知。比较流行的方法，也是wxPython中使用的方法是将事件发送到中央队列，在那里触发对事件的处理。另一种事件驱动系统是使用轮询方法，那些可以发生事件的地方被中央处理进程周期性的查询，检查是否有事件未处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当事件发生时，基于事件的系统处理尝试决定哪段代码需要被执行。在wxPython中，本地系统事件（native system event）被翻译为wx.Event实例，然后被传递给wx.EvtHandler.ProcessEvent()来分派给合适的处理器代码。图表3.3描述了处理的概况。事件机制的一部分组件是事件绑定对象和事件处理器，两者的定义在表3.1中。事件绑定器是一个预先定义的wxPython对象。每种事件类型有一个独立的事件绑定器。一个事件处理器是一个函数或方法可以获得一个wxPython事件实例作为参数。事件处理器将在用户触发适当的事件时被调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="321-shi-jian-chu-li-qi-bian-ma"&gt;3.2.1 事件处理器编码&lt;/h3&gt;
&lt;p&gt;在wxPython代码中，事件和事件处理器是在单个构件中管理的。比如，一个按钮的click事件被分配到基于被点击的按钮的处理器。为将事件绑定到绑定到指定构件的指定处理器方法，你需要使用绑定器（binder）对象来管理连接。比如，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aButton&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用预定义的事件绑定器wx.EVT_BUTTON关联到aButton的click事件到self.OnClick方法。Bind()方法是wx.EvtHander的一个方法，它是所有可显示对象的父对象。因此，例子中的这行代码可用于任何可显示的类。&lt;/p&gt;
&lt;p&gt;尽管你的wxPython程序看起来像在被动的等侍事件，实际上它仍在做一些事件。比如，它运行wx.App.MainLoop()方法，它是一个while无限循环。MainLoop()可以下面的简单的Python伪码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pending&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ProcessIdle&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DoMessage&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;换句话说，如果没有消息要处理，执行一些空处理直到有消息进来，然后将消息分配到适当的事件处理方法。&lt;/p&gt;
&lt;h3 id="322-she-ji-shi-jian-qu-dong-cheng-xu"&gt;3.2.2 设计事件驱动程序&lt;/h3&gt;
&lt;p&gt;wxPython事件驱动程序有一些隐式的设计和编码规则。由于不能假设事件何时发生，程序员放弃了许多对程序的控制权给用户。在wxPython程序中多数执行的代码是直接或间接的由用户或系统产生。比如，程序的保存工作通常发生在用户选择菜单项，点击工具条按钮或通过快捷键之后。这些事件触发一个处理器来保存用户的工作。&lt;/p&gt;
&lt;p&gt;事件驱动架构的另一种后果是这个架构经常会扩展。用于响应一种事件的代码通常不定义在触发事件的构件中。或者说，绑定的事件和处理器之间不需要有任何联系。比如，用于响应按钮点击的代码不需是按钮定义的一部分，它可以定义在包含按钮的frame中，或其它地方。当与可靠的面向对象设计结合时，这个构架可以带来松耦合，高复用的代码。你将发现Python的灵活使得不同wxPython应用间重用通用事件处理器和结构非常容易。另一方面，由于程序的分解导致事件驱动的程序难于跟踪和维护。当按钮的click事件发生时绑定到frame中的代码，事件调用了模型类中的方法，它可能难于跟踪。&lt;/p&gt;
&lt;h3 id="323-shi-jian-hong-fa"&gt;3.2.3 事件触发&lt;/h3&gt;
&lt;p&gt;在wxPython中，多数构件将高级事件用于响应低级事件。比如，在wx.Button的内部点击鼠标导致产生一个EVT_BUTTON事件，它是wx.CommandEvent的一个特殊类型。类似的，鼠标拖动窗口的一角导致一个wx.SizeEvent被wxPython自动创建。这些高级事件的优点在于它们使系统集中焦点于最相关的事件，而不用跟踪所有鼠标点击。比如，我们说鼠标点击一个按钮的活动，这个特殊的点击对于系统有上下文含义，而另一个鼠标点击事件可能对于上下文没有含义。高级事件也能包含更多关于事件的信息。当你创建自己的自定义构件时，你可以定义你自己的自定义事件来管理这个过程。&lt;/p&gt;
&lt;p&gt;事件被wxPython描述为对象。wxPython中的事件对象是类wx.Event或其子类的实例。wx.Event类是一个很小的抽像类由getter、setter方法和少数所有事件都需要的通用属性，比如EventType，EventObject和Timestamp。不同的wx.Event子类添加了更丰富的信息。比如，wx.MouseEvent包含了事件发生时鼠标的精确位置，并包含了是哪个鼠个按钮点击，等。&lt;/p&gt;
&lt;p&gt;在wxPython中有许多不同的wx.Event的子类。表3.2包含了常用事件类的列表。记住，一个事件类可以有多个不同的事件类型，每个对应于不同的用户动作。&lt;/p&gt;
&lt;p&gt;表3.2 重要的wx.Event的子类&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;事件&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.CloseEvent&lt;/td&gt;
&lt;td align="left"&gt;当frame关闭时触发。事件类型用于区分frame被正常关闭或者是系统关机事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.CommandEvent&lt;/td&gt;
&lt;td align="left"&gt;广泛用于简单的与构件交互，比如按钮被点击，菜单项被选择，或radio被选择。每个动作都有自己的事件类型。许多复杂的构件，比如list或grid，定义了wx.CommandEvent的子类。命令事件由不同的事件处理系统不同的对侍，而不是由其它事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.KeyEvent&lt;/td&gt;
&lt;td align="left"&gt;按键事件。事件类型有按键被按下，弹起和完整的按键动作。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.MouseEvent&lt;/td&gt;
&lt;td align="left"&gt;鼠标事件。事件类型有鼠标移动和鼠标点击。这些事件类型取决于哪个鼠标按键被点击和它是单击还是双击。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.PaintEvent&lt;/td&gt;
&lt;td align="left"&gt;当窗口的内容需要重绘时触发。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.SizeEvent&lt;/td&gt;
&lt;td align="left"&gt;当窗口调整大小时，通常导致改变窗口的布局。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.TimerEvent&lt;/td&gt;
&lt;td align="left"&gt;可以被wx.Timer类创建，它允许周期性的事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通常，事件对象自己只做很少的操作，但它们需要传递给相关的事件处理器方法或用于事件绑定器和事件处理系统的方法。&lt;/p&gt;
&lt;h2&gt;3.3 如何将事件绑定到处理器&lt;/h2&gt;
&lt;p&gt;事件绑定器由wx.PyEventBinder的实例组成。提供了一个预定义的wx.PyEventBinder的实例用于所有支持的事件类型，如果需要你可以为自己的自定义事件创建自己的事件绑定器。对于每个事件类型只有一个事件绑定器，这意味着多种绑定器可以应用于任何wx.Event子类。这是因为事件类型比wx.Event子类有更多的细节信息。比如，wx.MouseEvent类有十四个独立的事件类型，当用户动作产生时每个都使用了相同的鼠标基础状态信息。（比如，左键，右键，双击）。&lt;/p&gt;
&lt;p&gt;在wxPython中，事件绑定器实例的名称是全局的。为了清楚的将事件类型与处理器关联，这些名称以wx.EVT_开头加上C++ wxWidget代码中的宏名。当讨论wxPython代码时，趋向于使用wx.EVT_绑定器名称作为实际事件类型的标准名称。wx.EVT绑定器名称不是实际的事件类型的整数代码。你可以调用wx.Event实例的GetEventType()方法获取实际的代码。事件类型事件代码有一个全局的唯一名称，在实践中通常不使用。&lt;/p&gt;
&lt;p&gt;作为wx.EVT命名的实例，我们看一下wx.MouseEvent的事件类型。前面提到，一共有14个，其中9个包含了鼠标向下，鼠标向上，双击事件。这9个事件类型使用了下面的名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_LEFT_DOWN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_LEFT_UP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_LEFT_DCLICK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_MIDDLE_DOWN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_MIDDLE_UP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_MIDDLE_DCLICK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_RIGHT_DOWN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_RIGHT_UP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_RIGHT_DCLICK&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，wx.EVT_MOTION由鼠标移动产生。wx.ENTER_WINDOW和WX.LEAVE_WINDOW由于鼠标进入或离开构件产生。wx.EVT_MOUSEWHEEL由鼠标滚轮产生。最后，你可以将所有鼠标事件同时的绑定到一个单一的wx.EVT_MOUSE_EVENTS类型。&lt;/p&gt;
&lt;p&gt;类似的，wx.CommandEvent类有28个不同的事件类型与之关联；只有少量是为旧的Windows操作系统。它们中的多数都是针对于特定的单一构件，比如wx.EVT_BUTTON用于按钮点击，wx.EVT_MENU用于菜单项选择。为特殊构件准备的命令事件将在第二部分讨论。&lt;/p&gt;
&lt;p&gt;这种绑定机制的好处是允许wxPython在非常小粒度的基础上来处理事件，允许类似的事件实例化相同的类，共享数据和功能。这使得在wxPython中编写事件处理器比在其它界面工具包中更加清析。&lt;/p&gt;
&lt;p&gt;事件达赖顺用于将wxPython构件连接到事件对象和事件处理器函数。这个连接允许wxPython系统通过执行处理器函数来响应事件。在wxPython中，任何wx.EvtHandler类的子类对象都能响应事件。所有窗口对象都是wx.EvtHandler类的子类，因此wxPython应用中的所有构件都可以响应事件。wx.EvtHandler　类也可以用于非构件对象，比如wx.App，因此事件处理不只限于可视的构件。也就是说构件可以响应事件意味着那个构件可以创建wxPython在分发时能识别的事件绑定。在事件处理函数中被绑定器代码并不需要位于wx.EvtHandler类中。&lt;/p&gt;
&lt;h3 id="331-shi-yong-wxevthandlerfang-fa"&gt;3.3.1 使用wx.EvtHandler方法&lt;/h3&gt;
&lt;p&gt;wx.EvtHandler类定义了大量方法，这些方法并不是在通常环境下被调用。wx.EvtHandler的方法中你最常用到的是Bind()，它创建事件绑定。方法签名如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ID_ANY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;id2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ID_ANY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bind()函数将对象与事件处理函数关联。event参数是必需的，它是一个wx.PyEventBinder的实例，在3.3中讨论过。handler参数，也是必需的，是一个Python callable对象，通常绑定到方法或函数。handler必须使用一个参数调用，参数为事件对象本身。处理器参数也可以为None，这种情况下将取消事件与它当前关联的处理器之间的关联。source参数是事件源构件。这个参数用于当触发事件的构件与事件处理器所在的构件不是同一个构件时。通常，这是需要的，因为你在使用自定义的wx.Frame类作为处理器时将事件绑定到了包含构件的frame中。父窗口的__init__是一个便于申明绑定的地方。但是，如果父窗口包含超过一个按钮点击事件时（比如，OK按钮和Cancel按钮），source参数用于wxPython区别它们。下面是一个特殊的例子：&lt;/p&gt;
&lt;p&gt;程序 3.1&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个调用将名为button的按钮（只绑定名为button的对象）的按钮事件绑定到包含它的实例的OnClick()方法。程序 3.1，根据第二章中的代码修改，描述了绑定事件时不带source参数。你不需要将你的处理器方法命名为On&lt;event&gt;，但这是一个公共的约定。&lt;/event&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Frame With Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                      &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Close"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;130&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                       &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_CLOSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （1）绑定frame的关闭事件&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （2）绑定按钮事件&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Destroy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（1）这行将frame的关闭事件绑定到self.OnCloseWindow方法。因为事件触发和处理都是在frame中，这里不需要传递source参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（2）这行将按钮点击事件绑定到self.OnCloseMe方法。在这种情况下，产生事件的按钮与绑定它的frame不同。因此，按钮的ID必须传递给Bind方法，使wxPython区别按钮button的点击事件和frame中其它按钮的点击事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你也可以使用source参数来标识项，即使项不是事件源。比如，你可以绑定菜单事件到事件处理器即使菜单事件是由frame触发。程序 3.2描述了绑定菜单事件的例子。&lt;/p&gt;
&lt;p&gt;程序 3.2 绑定菜单事件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MenuEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Menus'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MenuBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;menu1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;menuItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Exit..."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;File"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetMenuBar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;menuItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MenuEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bind()方法的id和id2参数使用ID数指定事件源，而不是构件自己。通常，id和id2不是必需的，因为事件源的ID可以从source参数中获取。但是，直接使用ID提高了可读性。比如，如果你为对话框使用预定义的ID，使用ID数比使用构件更容易。如果你同时使用id和id2参数，你可以绑定两个ID范围之间的所有构件到事件上。这只在你要绑定的构件的ID是有序的时候。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;旧的事件绑定&lt;/em&gt;&lt;/strong&gt; Bind()方法是wxPython 2.5中新增的。在前面的版本中，EVT_*被作为函数对象，因此绑定使用下面的结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;旧和风格不好的地方是它看起来不像面向对象的方法调用。但，旧的风格在2.5中仍然可以使用（因为wx.EVT*对象仍然是callable的），因此你仍将在wxPython代码中看到。&lt;/p&gt;
&lt;p&gt;表3.3列出了你在处理事件时，wx.EvtHandler中最常用的方法。&lt;/p&gt;
&lt;p&gt;表3.3wx.EvtHandler的常用方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;方法&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;AddPendingEvent(event)&lt;/td&gt;
&lt;td align="left"&gt;将事件参数放到事件处理系统。与ProcessEvent()类似，但它不会立即触发事件处理。而是将事件添加到事件队列。在基于事件的线程通讯时非常有用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Bind(event, handler, source=None, id=wx.ID_ANY, id2=wx.ID_ANY)&lt;/td&gt;
&lt;td align="left"&gt;看3.3.1的描述。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;GetEvtHandlerEnabled()和SetEvtHandlerEnabled(boolean)&lt;/td&gt;
&lt;td align="left"&gt;如果处理器当前正在处理事件这个属性为True，否则为False。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ProcessEvent(event)&lt;/td&gt;
&lt;td align="left"&gt;将事件对象放到事件处理系统立即进行处理。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;3.4 wxPython是如何处理事件的？&lt;/h2&gt;
&lt;p&gt;基于事件的系统的一个关键组件是当事件进入系统分派到哪个代码片段来响应。这节我们将讨论当事件进入时wxPython处理的过程。图表3.2显示了一个带有按钮的简单窗口，它用于产生简单的事件。&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_2.png" src="/wxPython/figure_3_2.png"/&gt;&lt;/p&gt;
&lt;p&gt;程序3.3包含了产生这个窗口的代码。这个代码中，wxPython事件在点击按钮和鼠标移过按钮时产生。&lt;/p&gt;
&lt;p&gt;程序3.3 绑定多种鼠标事件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MouseEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Frame With Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Not Over"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnButtonClick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;# （1）绑定按钮事件&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_ENTER_WINDOW&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnEnterWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （2）绑定鼠标进入事件&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_LEAVE_WINDOW&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnLeaveWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （3）绑定鼠标离开事件&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnButtonClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Green'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Refresh&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnEnterWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetLabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Over Me!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Skip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnLeaveWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetLabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Not Over"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Skip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MouseEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MouseEventFrame中间包含了一个按钮。点击鼠标将改变frame的背景为绿色。鼠标点击事件绑定在（1）行的动作。当鼠标指向中间的按钮，按钮的文字将改变，这绑定的（2）。当鼠标离开按钮时按钮文字也将改变，这绑定在（3）行。&lt;/p&gt;
&lt;p&gt;查看鼠标事件的例子带出了几个关于wxPython中事件处理的问题。在（1），触发事件的按钮在frame中。wxPython是怎么样知道在frame对象中查找绑定，而不是在按钮对象中？在（2）和（3），鼠标进入和离开事件绑定到按钮对象。为什么这些事件也可以绑定到frame上？这些问题的答案在于wxPython怎样来响应事件。&lt;/p&gt;
&lt;h3 id="341-li-jie-shi-jian-chu-li-guo-cheng"&gt;3.4.1 理解事件处理过程&lt;/h3&gt;
&lt;p&gt;wxPython事件处理过程被设计为易于程序员在最常见的地方创建事件绑定，而忽略不重要的事件。常用的情况设计简单，而实际上下层的机制有点复杂。下面，我们将跟踪按钮点击事件的鼠标进入事件。&lt;/p&gt;
&lt;p&gt;图表3.3显示了一个基本的事件处理流程图。矩形表示流程的开始和结束，贺表示作为流程中各步骤的各种wxPython对象，菱形表示判断点，带边的矩形表示实际的事件处理方法。&lt;/p&gt;
&lt;p&gt;图表3.3 事件处理过程，开始于事件被触发，过程中各步骤来查找处理器。&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_3.png" src="/wxPython/figure_3_3.png"/&gt;&lt;/p&gt;
&lt;p&gt;事件处理开始于触发事件的对象。通常，wxPython首先查看触发事件的对象中是否有相应的事件类型的事件处理函数。如果找到了，就执行。如果没有，wxPython向容器层次结构上层查找。上层的父构件被搜索，直到wxPython找到一个处理函数或达到顶级对象。如果还同有找到，wxPython将在结束前检查应用程序对象中是否有处理方法。当事件处理器运行时，这个处理过程正常结束。但是，这个函数将告诉wxPython继续查找事件处理器。&lt;/p&gt;
&lt;p&gt;仔细看这个流程的每个步骤。在讨论每个步骤前，我们先查看图表3.3的各个部分。&lt;/p&gt;
&lt;h4 id="di-yi-bu-chuang-jian-shi-jian"&gt;第一步 创建事件&lt;/h4&gt;
&lt;p&gt;处理过程开始于事件创建时。&lt;/p&gt;
&lt;p&gt;图表 3.4 创建事件将焦点转到触发的对象&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_4.png" src="/wxPython/figure_3_4.png"/&gt;&lt;/p&gt;
&lt;p&gt;多数预先存在的事件类型在响应特殊的用户动作或系统通知时被创建。比如，鼠标进入事件在在wxPython注意到鼠标进入一个新构件对象的边界时触发，按钮点击事件在鼠标左键在同一个按钮上按下和弹起时被创建。&lt;/p&gt;
&lt;p&gt;事件首先被创建事件的对象处理。对于按钮点击，这个对象就是按钮，对于鼠标进入事件，这个对象就是所进入的构件。&lt;/p&gt;
&lt;h4 id="di-er-bu-jue-ding-dui-xiang-shi-fou-yun-xu-chu-li-shi-jian"&gt;第二步 决定对象是否允许处理事件&lt;/h4&gt;
&lt;p&gt;事件处理过程的下一步是查看产生当前事件的构件（wx.EvtHandler）是否允许处理事件。&lt;/p&gt;
&lt;p&gt;窗口可以通过调用wx.EveHandler的SetEvtHandlerEnabled(boolean)来设置是否允许事件处理。禁用事件处理产生的效果就是那个构件完全忽略事件处理，关联到这个对象上的绑定不会被搜索，处理流程进入 &lt;strong&gt;&lt;em&gt;no&lt;/em&gt;&lt;/strong&gt; 分支。&lt;/p&gt;
&lt;p&gt;在事件处理级别启用或禁用构件与在UI级别禁用构件是不同的。在UI级别禁用构件是使用wx.Window的Disable()和Enable()方法。在UI场景中禁用构件意味着用户不能与被禁用的构件交互。通常，被禁用的构件显示在屏幕上的状态是灰色的。在UI级别被禁用的窗口不能产生任何事件；但是，如果它处理其它事件的层级容器中，它仍然将处理它接收到的事件。在这节，我们在wx.EvtHandler场景中使用enabled和disabled，查看构件是否允许处理事件。&lt;/p&gt;
&lt;p&gt;检查启动的对象的enabled/disabled状态发生在ProcessEvent()方法中它被wxPython系统用于启动和处理事件分派机制。我们将在这个处理过程中多次看到ProcessEvent()方法，它是wx.EvtHandler类中的方法，它实际上比图表3.3中描绘的做了更多的处理。如果事件处理在这个方法结束的时候完成了则ProcessEvent()方法返回True。如果处理器函数找到了并且事件组合被处理完，则这个处理过程结束。事件处理函数可以显示的调用wx.Event的方法Skip()来要求更多的处理。另外，如果启动的对象是wx.Window的子类，它可以使用一个特殊的对象来过滤事件，这个对象被称为validator。Validator将在第9章讨论。&lt;/p&gt;
&lt;p&gt;图表 3.5 检查触发的对象是否为enabled&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_5.png" src="/wxPython/figure_3_5.png"/&gt;&lt;/p&gt;
&lt;h4 id="di-san-bu-ding-wei-bang-ding-qi-dui-xiang"&gt;第三步 定位绑定器对象&lt;/h4&gt;
&lt;p&gt;图表 3.6 检查触发事件的对象是否有合适的绑定器&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_6.png" src="/wxPython/figure_3_6.png"/&gt;&lt;/p&gt;
&lt;p&gt;ProcessEvent()方法查找能识别事件类型和当前对象间的绑定器对象。&lt;/p&gt;
&lt;p&gt;如果在对象自身没有找到绑定器，处理流程将检查这个对象的父类中是否有这样的绑定器&amp;mdash;&amp;mdash;这与查找容器对象层级结构是不同的。如果找到了绑定器，wxPython调用关联的处理器函数。处理器被调用后，针对这个事件的事件处理流程停止，除非事件处理函数显式的要求更多的处理。&lt;/p&gt;
&lt;p&gt;在程序 3.3中，鼠标进入事件被捕获，因为和按钮对象间定义了绑定，绑定对象wx.EVT_ENTER_WINDWO，和关联的方法OnEnterWindow()，这个方法被调用。由于我们没有绑定鼠标点击事件，wx.EVT_LEFT_DOWN，wxPython在这种情况下将继续搜索。&lt;/p&gt;
&lt;h4 id="di-si-bu-jue-ding-shi-fou-ji-xu-chu-li-liu-cheng"&gt;第四步 决定是否继续处理流程&lt;/h4&gt;
&lt;p&gt;调用第一个事件处理器后，wxPython检查是有要求需要进行更多的处理。事件处理器可以调用wx.Event的Skip()方法来要求更多的处理。如果Skip()方法被调用，处理将继续，那些定义于父类中的处理器将被依次查找到并被执行。Skip()方法可以出现在处理器的任何地方，或任何被处理器调用的代码中。Skip()方法在事件实例中设置一个标记，wxPython在处理器方法完成后检查它。代码 3.3的OnButtonClick()没有调用Skip()，因此在那种情况下事件处理在处理器方法结束后事件处理流程结束。另外两个事件处理器调用了Skip()因此系统将继续查找匹配的事件绑定，最后为鼠标进入和离开事件调用本地构件的默认功能，比如鼠标划过（mouse-over）的事件。&lt;/p&gt;
&lt;h4 id="di-wu-bu-jue-ding-shi-fou-chuan-bo"&gt;第五步 决定是否传播&lt;/h4&gt;
&lt;p&gt;最后wxPython决定事件处理是否传播到容器层级结构中查找事件处理器。容器层级是从特定的构件到顶级frame的路径，转移到每个构件的父容器，并继续向上。&lt;/p&gt;
&lt;p&gt;如果当前对象没有针对这个事件的处理器，或如果事件处理器调用Skip()，wxPython决定事件是否需要向层级结构的上层传播。如果这个答案是No，处理过程在wx.App实例中再次查找处理器，然后停止。如果答案为Yes，事件处理过程将在当前被搜索的窗口的容器中重新开始。处理流程继续向上直到wxPython找到一个适当的绑定，或达到没有父窗口的顶级frame对象，或达到wx.Dialog对象（即使dialog不是顶级的）。如果那个对象的ProcessEvent()返回True，则事件被认为找到了一个合适的绑定，表示处理结束。在wx.Dialog中停止的的基本原理就是阻止父frame处理来自对话框的事件。&lt;/p&gt;
&lt;p&gt;一个事件是否应该被传播到父容器层级结构是每个事件实例的一个动态属性，尽管实践中总是使用默认值。缺省情况下，只有一个wx.CommandEvent实例，或它的子类，传播到容器层级结构中。其它事件不会。&lt;/p&gt;
&lt;p&gt;图表 3.8 事件处理过程继续查找容器层级结构。如果事件是一个命令事件，或它被申明为传播&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_8.png" src="/wxPython/figure_3_8.png"/&gt;&lt;/p&gt;
&lt;p&gt;代码 3.3中，在按钮上点击鼠标产生一个wx.EVT_BUTTON类型的命令事件。由于wx.EVT_BUTTON是wx.CommandEvent类型的，wxPython在按钮对象上查找绑定失败时，它查找父容器对象&amp;mdash;&amp;mdash;面板对象，然后是frame。由于frame上有一个匹配的绑定，ProcessEvent()调用适当的方法，在这里是OnButtonClick()方法。&lt;/p&gt;
&lt;p&gt;第五步也解释了为什么鼠标进入和鼠标离开事件需要被绑定到按钮而不是frame。由于鼠标事件不是wx.CommandEvent的子类，鼠标进入和离开事件不会传播到父容器，因此wxPython在按钮的鼠标进入事件和frame之间找不到绑定。如果在鼠标进入或离开事件绑定到了frame，则当鼠标进入或离开整个frame时将被触发。&lt;/p&gt;
&lt;p&gt;在这里命令事件有特权，因为它们是被实现为高级事件，用于标识用户在应用层面所做的事件，而不是在窗口系统。假定窗口系统类型的事件只对最初接收它们的构件感兴趣，但应用级事件可能对高级的容器层级结构感兴趣。这个规则并不阻止我们在任何地方绑定事件，与被绑定的对象或定义事件处理器的对象无关。比如，尽管鼠标点击事件被绑定到按钮对象，但绑定自己被定义在frame类中，调用frame类中的方法。换言之，低级非命令事件通水地发生到（to）构件的事情或一些系统级的提醒，比如鼠标点击，按键按下，绘制请求，改变大小或移动。另外，命令事件，比如鼠标在按钮上点击或列表选择，通常由构件自己产生和发出。比如，按钮命令事件在鼠标向下并向上的事件发生在相应的构件上后产生。&lt;/p&gt;
&lt;p&gt;最后，如果事件在通过容器层级结构后没有被处理，ProcessEvent()将在wx.App对象上调用。缺省情况下，这不做任何操作，但你可以在你的wx.App中添加事件绑定以非标准的方式来路由事件。比如，如果你编写GUI构造程序，你可能需要你构建的窗口的事件传播到你的代码窗口中，尽管它们都是顶级窗口。实现这种效果的一种办法就是在应用对象中捕获事件并将它们传递到代码窗口。&lt;/p&gt;
&lt;h3 id="342-shi-yong-skipfang-fa_1"&gt;3,4.2 使用Skip()方法&lt;/h3&gt;
&lt;p&gt;事件遇到的第一个事件处理函数将挂起那个事件的处理除非在那个处理函数返回前调用了Skip()方法。调用Skip()允许搜索额外的被绑定的处理器，跟据3.4.1的第四步所描述的，父类和父窗口被搜索就像第一个处理器不存在一样。在某些情况下，你需要事件继续处理以便表现本地构件默认行为。代码3.4显示了一个Skip()的例子，它允许程序响应在同一按钮上的左键按下事件和按钮点击事件。&lt;/p&gt;
&lt;p&gt;代码3.4 同一时间响应鼠标按下和按钮点击事件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DoubleEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Frame With Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Click Me"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnButtonClick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;# （1）绑定按钮点击事件&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_LEFT_DOWN&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnMouseDown&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （2）绑定左键按下事件&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnButtonClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Green'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Refresh&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnMouseDown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetLabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Again"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Skip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                    &lt;span class="c1"&gt;# （3）Skip()确保更多处理&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DoubleEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（1）这行绑定按钮点击事件到OnButtonClick()处理器，它修改frame的背景色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（2）这行绑定鼠标左键按下事件到OnMouseDown()处理器，它修改按钮的标签文本。由于左键按下不是命令事件，这个事件必须被绑定到按钮而不是frame。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当鼠标经过按钮用户点击，通过与下层操作系统交互，左键按下事件首先产生。通常，左键起来时改变按钮的状态，左键起来时创建了一个wx.EVT_BUTTON点击事件。DoubleEventFrame保持了这个处理过程，因为它在（3）处调用了Skip()方法。当没有Skip()语句时，事件处理算法查找（2）创建的绑定，并在按钮生成wx.EVT_BUTTON事件前停止。通过Skip()调用，事件处理继续按钮点击事件被创建。&lt;/p&gt;
&lt;p&gt;在这个例子中，选择wx.EVT_LEFT_DOWN和wx.EVT_BUTTON没有很特殊的。任何一个事件处理器被找到时的情况都是一样的。比如，修改wx.EVT_LEFT_DOWN事件为另一个wx.EVT_BUTTON事件将产生相同的效果。为使两个处理器都被调用，Skip()调用仍然需要。&lt;/p&gt;
&lt;p&gt;遇到相关处理地，默认行为是先到先服务。为允许更多的处理，你必须调用Skip()。尽管这个选择应该按具体案例来，但要记住当绑定到低级事件，比如鼠标按下弹起，wxPython期望捕获这些事件来产生更多的事件。如果你不调用Skip()，将阻止预期的行为；比如，在按钮被点击时丢失可视的通知效果（注：按钮被按下和弹起的动态效果）。&lt;/p&gt;
&lt;h2&gt;3.5 应用对象中还包含哪些事件属性？&lt;/h2&gt;
&lt;p&gt;为了更直接的管理主事件循环，你可以使用wx.App中的一些方法。举例来说，你可能希望按自己的排程启动下一个可用的事件，而不是等侍wxPython来开始这处理。如果你需要执行一个长时间的排程，而不希望GUI被冻结，这个功能是需要的。在这节你不需要经常使用这个方法，但有时这个功能是非常重要的。&lt;/p&gt;
&lt;p&gt;表3.4列出了可用来修改主循环的wx.App的方法。&lt;/p&gt;
&lt;p&gt;表3.4wx.App的主事件循环方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;方法名&lt;/th&gt;
&lt;th align="left"&gt;方法描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Dispatch()&lt;/td&gt;
&lt;td align="left"&gt;编程方式强制发送事件队列中的下个事件。比如由MainLoop()使用，或在自定义的事件循环中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Pending()&lt;/td&gt;
&lt;td align="left"&gt;如果在wxPython应用中的事件队列中存在挂起的事件，则返回True。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Yield(onlyIfNeeded=False)&lt;/td&gt;
&lt;td align="left"&gt;允许挂起的wxWidget事件被分派到那些可能阻塞窗口系统显示或更新的长时间的处理中。如果有挂起事件在被处理则返回True，否则返回False。如果为True，如果有挂起事件onlyIfNeeded参数强制处理yield。如果参数为False，则是一个错误在递归调用Yield。有一个全局函数wx.SafeYield()，它防止用户在yield期间输入数据（通过临时禁止用户输入构件）。这阻止了用户改变一些妨碍yielding任务的状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;另一种自定义管理事件的方法是创建自己的事件类型来匹配你的应用中的特殊的数据和构件。下一节，我们将讨论如何创建自己的自定义事件。&lt;/p&gt;
&lt;h2&gt;3.6 如何创建自己的事件？&lt;/h2&gt;
&lt;p&gt;除了使用wxPython提供的事件类，你可以创建自己的自定义事件。当事件实例被请求携带自定义数据时，你可以在你的应用的响应中修改数据或做其它的修改。&lt;/p&gt;
&lt;h3 id="361-wei-zi-ding-yi-gou-jian-ding-yi-zi-ding-yi-shi-jian"&gt;3.6.1 为自定义构件定义自定义事件&lt;/h3&gt;
&lt;p&gt;图表3.9显示了一个构件，一个容器面板包含两个按钮。自定义事件TwoButtonEvent在用户点击两个按钮时触发。这个事件包含了用户点击构件的时间。这个例子展示了新的命令事件是如何由小的事件构成的&amp;mdash;&amp;mdash;这里是独立按钮的左键按下事件。&lt;/p&gt;
&lt;p&gt;创建自定义事件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义新的事件类，该类为wx.PyEvent的子类。如果你需要把事件作为命令事件，则创建wx.PyCommandEvent的子类。在wxPython中与许多其它重构的情况一样，Py版本的类允许wxWidget系统查看使用Python编写的用于覆盖C++编写的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建事件类型和绑定器对象将事件绑定到特定的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加代码以便创建新的事件的实例，使用ProcessEvent()方法将实例介绍给事件处理系统。一旦事件被创建，你可以创建绑定和处理器方法，就像使用其它wxPython事件一样。代码3.5显示了管理构件的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码3.5创建一个带两个按钮事件的自定义构件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TwoButtonEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PyCommandEvent&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c1"&gt;# （1）定义事件&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;evtType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PyCommandEvent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;evtType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;GetClickCount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;SetClickCount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;

&lt;span class="n"&gt;myEVT_TWO_BUTTON&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewEventType&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;    &lt;span class="c1"&gt;# （2）产生一个事件类型&lt;/span&gt;
&lt;span class="n"&gt;EVT_TWO_BUTTON&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PyEventBinder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myEVT_TWO_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （3）创建一个绑定器对象&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TwoButtonPanel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;leftText&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Left"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;rightText&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Right"&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Parent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;leftText&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rightText&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftButton&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_LEFT_DOWN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnLeftClick&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （4）绑定低级事件&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightButton&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_LEFT_DOWN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnRightClick&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnLeftClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Skip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                    &lt;span class="c1"&gt;# （5）调用Skip()方法以获取更多的处理&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnRightClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Skip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                    &lt;span class="c1"&gt;# （6）调用Skip()方法以获取更多的处理&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftClick&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightClick&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
            &lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TwoButtonEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myEVT_TWO_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetId&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="c1"&gt;# （7）创建自定义事件&lt;/span&gt;
            &lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetClickCount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                   &lt;span class="c1"&gt;# 添加数据到事件中&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetEventHandler&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ProcessEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;             &lt;span class="c1"&gt;# （8）处理事件&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CustomEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Click Count: 0'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TwoButtonPanel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EVT_TWO_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnTwoClick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （9）绑定自定义事件&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnTwoClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;        &lt;span class="c1"&gt;# （10）定义一个事件处理器函数&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetTitle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Click Count: &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetClickCount&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CustomEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（1）事件类的构造器申明它是wx.PyCommandEvent的子类。wx.PyEvent和wx.PyCommandEvent是wxPython特殊的构造器你可以用它创建新的事件类并且用于桥接C++代码和Python代码。如果你想直接使用wx.Event，wxPython将在事件处理中看不到你的子类中的新方法，因为C++事件处理器不知道Python子类。如果你使用wx.PyEvent，一个Python实例的引用它被保存，后来被直接传递给事件处理器，允许Python编写的代码被使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（2）全局函数wx.NewEventType()是一个类似wx.NewId()的方法；它返回一个事件类型ID并保证它的唯一性。这个唯一值标识了事件处理系统中的一个事件类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（3）使用新的事件类型作为参数创建了绑定对象。第二个参数介于0和2之间，用于描述wx.EvtHandler.Bind()方法所需要的wxId标识符的数量。在这里，只有一个ID描述了产生命令事件的构件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（4）创建高级命令事件，这个程序必须响应特定的用户事件，比如，左键在任何一个按钮对象上按下。取决于哪个按钮被点击，事件被绑定到OnLeftClick()和OnRightClick()方法。这个处理器设置了一个布尔变量标识被按下的按钮。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（5）（6）Skip()调用在允许在执行事件处理器后做更多的处理。在这里，新的事件类型不需要skip调用；它在处理器代码完成前被分发。但，所有左键按下事件都需要调用Skip()以便处理器不会阻止最后的按钮按下事件。按钮点击事件在这个程序中不会被处理，但wxPython使用它在按钮点击期间进行绘制。如果它被阻止了，用户不会获取到按钮被按下了的反馈。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们选择不绑定到wx.EVT_BUTTON事件还展示如果在这种情况下不调用Skip()将发生什么。查看不同的效果可以注释掉（5）或（6）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（7）如果左右两个按钮都被点击，代码将产生新事件的实例。事件类型和两个按钮构件的ID作为构件器参数。通常，一个单独的事件类可以有多个事件类型，尽管这个例子不是这样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（8）ProcessEvent()调用将新的事件类型注入到事件处理系统，如3.4.1所描述的那样。GetEventHandler()调用返回了一个wx.EvtHandler类型的实例。在多数情况下，返回的实例是构件对象自身，但如果其它wx.EvtHandler()方法被推到了事件处理器堆栈，则堆栈顶的项将作为返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（9）自定义的事件被绑定，在这里使用了（3）创建的绑定器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（10）事件处理器函数，它修改窗口的标题为事件中的点击计数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这点来看，你的自定义事件可以做任何wxPython预定义的事件可以做的事件，比如创建不同的构件触发相同的事件。创建事件是自定义wxPython中的一个重要部分。&lt;/p&gt;
&lt;h2&gt;3.7 小结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;wxPython应用使用基于事件流来控制。应用的多数时间用于主循环，等侍事件并分发它们到适当的事件处理器函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有wxPython事件都是wx.Event类的子类。低级事件，比如鼠标点击，被用于构建高级指令事件，比如按钮被点击或菜单项被选择。这些由wxPython构件产生的高级指令事件是wx.CommandEvent类的子类。多数事件类通过事件类型来进行更细的归类，不同类型的事件使用相同的数据集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为捕获事件和函数间的关系，wxPython使用wx.PyEventBinder类的实例。有很多预定义的这个类的实例，每个对应于一种特定的事件类型。每个wxPython构件都是wx.EvtHandler类的子类。wx.EvtHandler类有一个Bind()方法，它通常在初始化时调用，带一个事件绑定器实例和一个事件处理器函数作为参数。根据具体的事件类型，其它wxPython对象的ID也可能需要传递给Bind()调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件通常被发送到产生它们的对象中来查找一个绑定了处理器的对象。如果事件是一个命令事件，这个事件将被向容器层级结构的上层传播直到找到这个事件类型的处理器。一量事件处理器被找到，这个事件的处理结束，除非处理器调用了事件的Skip()方法。你可以使用Skip()方法来允许多个处理器响应单个事件，或者让事件的默认行为产生。使用wx.App中的一些方法可以控制主循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在wxPython中创建自定义事件，表达自定义构件的行为。自定义事件是wx.PyEvent的子类，自定义命令事件是wx.PyCommandEvent的子类。为了创建自定义事件，新的类必须被定义，必须为每种事件类型创建一个新绑定器对象并由新类来管理。最后，事件必须在系统的某个地方产生，通过调用ProcessEvent()方法传递一个新的实例到事件处理系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Chap 4 使用PyCrust简化wxPython处理&lt;/h1&gt;
&lt;p&gt;PyCrust是一个图形化shell程序，是wxPython编写的，你可以使用它帮助分析wxPython程序。&lt;/p&gt;
&lt;p&gt;为什么叫PyCrust？当当Patrick O'Brien使用wxPython创建一个交互式Python shell时，最显而易见的名称&amp;mdash;&amp;mdash;PyShell&amp;mdash;&amp;mdash;已经被使用。因而选择了PyCrust。&lt;/p&gt;
&lt;p&gt;PyCrust是一个大的Py包的一部分，这个包包含了其它一些有相近功能的程序包括PyFilling，PyAlaMode，PyalaCarte，和PyShell。将这些程序组合到一个图形界面，点击操作的环境中，可以与wxPython运行时功能进行交互和进行自省。PyCrust实现了这个主题中最完整的功能。&lt;/p&gt;
&lt;p&gt;这章，我们将展示PyCrust和相关程序的功能，及如何使用它们来让你与wxPython工作得更顺利。我们将先从Python的shell入手，然后是PyCrust的特点，最后，将涵盖Py包中的其它程序。&lt;/p&gt;
&lt;h2&gt;如何与wxPython程序交互？&lt;/h2&gt;
&lt;p&gt;Python与其它语言的相比比较引人注意的功能是它可以有两种方式使用：你可以运行已经编写好的Python程序，或者在命令提示符下交互的方式运行Python程序。&lt;/p&gt;
&lt;p&gt;（本章未完，主要介绍PyCrust的使用）&lt;/p&gt;
&lt;h1&gt;Chap 5 创建你的蓝图&lt;/h1&gt;
&lt;p&gt;本意讨论使用MVC设计模式来保持显示和数据的分离。最后将讨论如何对wxPython代码进行单元测试。&lt;/p&gt;
&lt;h2&gt;5.1 重构是如何帮助我提升我的代码的？&lt;/h2&gt;
&lt;p&gt;保证UI代码可控性的关键就是&amp;ldquo;重构&amp;rdquo;，或不断提升已有代码的设计和结构。重构的目的就是保持代码的状态，使它在将来易于阅读和管理。表5.1包含了重构应遵循的一些原则。最重要的基础目标就是要记得将来的人能读懂这些代码。努力使那个人工作轻松一些&amp;mdash;&amp;mdash;毕竟，这个人也有可能是你。&lt;/p&gt;
&lt;p&gt;表5.1 重构的一些重要原则&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;原则&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;不重复&lt;/td&gt;
&lt;td align="left"&gt;避免多段代码有相同的功能。当这些代码要修改时将非常头痛。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;同一时间只做一件事&lt;/td&gt;
&lt;td align="left"&gt;方法应该只做一件事，并且仅仅只做一件事。不同的事情应该移到不同的方法中。方法应该保持简短。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;保持较浅的嵌套&lt;/td&gt;
&lt;td align="left"&gt;尽量保持代码的嵌套不超过2至3层。深层的嵌套代码最好选择放到分开的方法中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;避免直接量魔法（magic literals）&lt;/td&gt;
&lt;td align="left"&gt;字符串和数字直接量应该保持尽量少。一个较好的管理直接量的方法是将它们存储于主代码之外，存储于列表或字典中。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中的一些原则对于Python代码尤为重要。因为Python是基于缩进语法的，精简的方法非常易于阅读。长的方法，难于解析，特别是当不能在一屏完全显示时。另外，在Python中深层的嵌套将使代码难于跟踪。毕竟，Python是一种避免重复的语言，特别是由于它可以把函数当作参数传递的简易性。&lt;/p&gt;
&lt;h3 id="511yi-ge-zhong-gou-de-li-zi"&gt;5.1.1一个重构的例子&lt;/h3&gt;
&lt;p&gt;我们通过一个重构的例子来展示如何在实际中使用这些原则。图5.1展示了一个可能是被作为Microsoft Access数据库前端的窗口。&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_5_1.png" src="/wxPython/figure_5_1.png"/&gt;&lt;/p&gt;
&lt;p&gt;布局比前面看到的复杂一点，但对于真实世界的应用来说，它仍然非常简单。代码5.1展示了生成图5.1所示程序的恶劣的代码。这就是那种大家所说的混乱的UI代码。将多个问题压缩到少量的代码行中可能有些夸张，但这将是你在布局代码中遇到的典型问题。&lt;/p&gt;
&lt;p&gt;代码5.1，生成图5.1的未重构的代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RecactorExample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Refactor Example'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;340&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"White"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;prevButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;lt;&amp;lt; PREV"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnPrev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prevButton&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;nextButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"NEXT &amp;gt;&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnNext&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nextButton&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_CLOSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;menuBar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MenuBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;menu1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;openMenuItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Open"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Copy in status bar"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnOpen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;openMenuItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;quitMenuItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Quit"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Quit"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;quitMenuItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;File"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;copyItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Copy"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Copy"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCopy&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;copyItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cutItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"C&amp;amp;ut"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Cut"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCut&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cutItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;pasteItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Paste"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Paste"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnPaste&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pasteItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Edit"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetMenuBar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StaticText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"First Name"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"White"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TextCtrl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                           &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;static2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StaticText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"Last Name"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;static2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"White"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;text2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TextCtrl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                            &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;firstButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"FIRST"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnFirst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;firstButton&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AppendSeparator&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;opItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Options..."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Display Options"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnOptions&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;optItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;lastButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"LAST"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;240&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnLast&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lastButton&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnPrev&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnNext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnLast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnFirst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnOpen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCopy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCut&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnPaste&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnOptions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Destroy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RefactorExample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分类来看这个代码是如何与表格5.1相背的。从正面来看，这里没有深层嵌套。负面来看，表5.1中的其它三条都不符合。表5.2总结了重构可以提升的地方。&lt;/p&gt;
&lt;p&gt;表5.2 重构清单5.1&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;原则&lt;/th&gt;
&lt;th align="left"&gt;代码中的问题&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;不重复&lt;/td&gt;
&lt;td align="left"&gt;多个模式是重复的，包括&amp;ldquo;创建一个按钮，设置它的action&amp;rdquo;，&amp;ldquo;添加菜单项，设置它的action&amp;rdquo;和&amp;ldquo;创建文本输入项的文字&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;同一时刻只做一件事&lt;/td&gt;
&lt;td align="left"&gt;这个代码做了多个事情。在基础的frame的设置中，它创建了菜单条，添加了按钮，添加了文本项。更恶劣的是，这三个函数是混在一起在，在后面的修改中我们将添加在方法的结尾。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;避免魔法直接量&lt;/td&gt;
&lt;td align="left"&gt;每个按钮，在构造器中菜单项和文本框都有一个字符串和一个直接量。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="512-kai-shi-zhong-gou"&gt;5.1.2 开始重构&lt;/h3&gt;
&lt;h2&gt;5.2 如何保持Model和View的分离&lt;/h2&gt;</content><category term="python"></category><category term="wxpython"></category></entry><entry><title>高级OA Framework开发主题——支持浏览后退按钮的用例</title><link href="/adv_back_use_cases.html" rel="alternate"></link><published>2008-07-04T00:00:00+08:00</published><updated>2008-07-04T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-04:/adv_back_use_cases.html</id><summary type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;本文档描述了与标准后退行为相关的公用应用设计模式，并包含了各个步骤的实现细节。&lt;/p&gt;
&lt;h2&gt;需要阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="/adv_backbutton.html#goals"&gt;Supporting the Browser Back Button - Target Goals&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;一般规则&lt;/h1&gt;
&lt;p&gt;通常，你的产品在用户使用后退按钮时应该遵循下面的规则。参见下面的特殊事务流以了解实现和行为的细节。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;本文档描述了与标准后退行为相关的公用应用设计模式，并包含了各个步骤的实现细节。&lt;/p&gt;
&lt;h2&gt;需要阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="/adv_backbutton.html#goals"&gt;Supporting the Browser Back Button - Target Goals&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;一般规则&lt;/h1&gt;
&lt;p&gt;通常，你的产品在用户使用后退按钮时应该遵循下面的规则。参见下面的特殊事务流以了解实现和行为的细节。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>高级OA Framework开发主题——支持浏览后退按钮</title><link href="/adv_backbutton.html" rel="alternate"></link><published>2008-07-04T00:00:00+08:00</published><updated>2008-07-04T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-04:/adv_backbutton.html</id><summary type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;本文档提供了一组&lt;a href="#goals"&gt;目标&lt;/a&gt;并描述了编码标准，你必须遵守以确保对浏览器后退按钮的支持。&lt;/p&gt;
&lt;p&gt;可用性测试显示用户非常依赖于浏览器后退按钮。不幸的是，这个导航偏好在事务型的应用中将导致一系列潜在的故障点。例如，思考在OA Framework应用中在下面的场景中使用浏览器后退按钮将导致不可预料的问题。&lt;/p&gt;
&lt;table class="table"&gt;
&lt;tr&gt;
&lt;th&gt;用户导航&lt;/th&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户从表格中删除了一行数据页面被重绘并显示了提示信息标明数据行已经被删除（数据行不再显示在表格中）。然后用户按下浏览器后退按钮，页面将显示出数据行仍然在表格中时的页面。这时用户再次尝试删除数据行。&lt;/td&gt;
&lt;td&gt;浏览器缓存了页面内容。如果用户执行的一个动作修改了数据状态，然后使用浏览器后退按钮，浏览的页面缓存没有反映出中间层的状态（在这里，是一个不存在的数据行）。当用户试图对缓存页面中被删除的行进行删除或其它处理时，将导致运行时错误。而支持浏览器后退按钮的页面将检测到这个错误并显示出用户友好的提示信息标明数据行已经被删除了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在构物车结算处理时，用户选择了&amp;ldquo;提交定单&amp;rdquo;按钮购买端口。但不知什么原因，用户使用浏览器后退按钮从确认页面退回了定单提交页面并再次点击了&amp;ldquo;提交定单&amp;rdquo;按钮（可能她想修改定单数量）。&lt;/td&gt;
&lt;td&gt;这个场景与前面描述的第一个场景类似，但未加保护的动作将导致&amp;ldquo;成功&amp;rdquo;执行两次交易。（定单可能会被创建两次，而这并不是用户期望的）。支持浏览器后退按钮的页面将可以检查到两次相同的提交并显示出用户友好的提示信息标明定单已经存在了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户从Page1导航到Page2，然后使用退出按钮返回Page1。然后在Page1中点击了一个表单提交组件，这将导致一个未处理的异常（NullPointerException, IndexOutOfBoundsException）。&lt;/td&gt;
&lt;td&gt;OA …&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</summary><content type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;本文档提供了一组&lt;a href="#goals"&gt;目标&lt;/a&gt;并描述了编码标准，你必须遵守以确保对浏览器后退按钮的支持。&lt;/p&gt;
&lt;p&gt;可用性测试显示用户非常依赖于浏览器后退按钮。不幸的是，这个导航偏好在事务型的应用中将导致一系列潜在的故障点。例如，思考在OA Framework应用中在下面的场景中使用浏览器后退按钮将导致不可预料的问题。&lt;/p&gt;
&lt;table class="table"&gt;
&lt;tr&gt;
&lt;th&gt;用户导航&lt;/th&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户从表格中删除了一行数据页面被重绘并显示了提示信息标明数据行已经被删除（数据行不再显示在表格中）。然后用户按下浏览器后退按钮，页面将显示出数据行仍然在表格中时的页面。这时用户再次尝试删除数据行。&lt;/td&gt;
&lt;td&gt;浏览器缓存了页面内容。如果用户执行的一个动作修改了数据状态，然后使用浏览器后退按钮，浏览的页面缓存没有反映出中间层的状态（在这里，是一个不存在的数据行）。当用户试图对缓存页面中被删除的行进行删除或其它处理时，将导致运行时错误。而支持浏览器后退按钮的页面将检测到这个错误并显示出用户友好的提示信息标明数据行已经被删除了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在构物车结算处理时，用户选择了&amp;ldquo;提交定单&amp;rdquo;按钮购买端口。但不知什么原因，用户使用浏览器后退按钮从确认页面退回了定单提交页面并再次点击了&amp;ldquo;提交定单&amp;rdquo;按钮（可能她想修改定单数量）。&lt;/td&gt;
&lt;td&gt;这个场景与前面描述的第一个场景类似，但未加保护的动作将导致&amp;ldquo;成功&amp;rdquo;执行两次交易。（定单可能会被创建两次，而这并不是用户期望的）。支持浏览器后退按钮的页面将可以检查到两次相同的提交并显示出用户友好的提示信息标明定单已经存在了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户从Page1导航到Page2，然后使用退出按钮返回Page1。然后在Page1中点击了一个表单提交组件，这将导致一个未处理的异常（NullPointerException, IndexOutOfBoundsException）。&lt;/td&gt;
&lt;td&gt;OA Framework&amp;ldquo;Page 1&amp;rdquo;预期的web bean层级结构处理是处于某种状态的，和/或它预期的事务、session或BC4J对象状态值是存在的。当使用后退按钮导航时，这些状态可能丢失。如果页面不符合预期，则将显示unhandled exceptions给用户。支持浏览器后退的页面将预料到在这种场景中将丢失状态，它或者有能力重建状态并继续执行通常的功能，或显示用户友好的提示信息标题页面在使用浏览器后退按钮后不可以再被访问。&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a name="goals"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;为避免出现上面类似问题的出现，使用这些目标来指导我们理解什么是&amp;ldquo;支持&amp;rdquo;浏览器后退按钮。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="#goal1"&gt;在处理浏览后退按钮时提供一致的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#goal2"&gt;避免状态变更导致的严重的不可预知的异常&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="goal1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="mu-biao-1zai-chu-li-liu-lan-hou-tui-an-niu-shi-ti-gong-yi-zhi-de-xing-wei"&gt;目标1：在处理浏览后退按钮时提供一致的行为&lt;/h3&gt;
&lt;p&gt;在处理浏览器后退按钮时保持一致性是很重要的。使用下面的子目标来保持一致性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;允许简单的、直接的操作重复除非技术上存在限制。&lt;/p&gt;
&lt;p&gt;当用户执行查询或查看记录明细时使用调查流；当用户使用导航按钮并再次向前时，允许无缝的查询和查看明细，不显示错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在逻辑事务活动时允许事务重复&lt;/p&gt;
&lt;p&gt;在这个上下文中的逻辑事务流指包含一个或多个页面的任务并带有决定性的结束点（事务提交）。例如对一行或多个选中数据行的单页面的update，多步的create和单个动作的删除（带commit）。。用户可以逻辑事务中使用浏览器后退按钮，并在逻辑事务执行过程上中执行操作而不出现错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免会引起歧义的事务、操作已经被删除的数据的事务或将导致无意识的用户操作的事务。&lt;/p&gt;
&lt;p&gt;为确保事务的完整性，如果可以则限制后退按钮后执行动作。例如，创建流（Create flow）在表单提交动作后点击浏览后退按钮应该不可重入。因为它不清楚用户是想要更新前面创建的记录还是创建一个新的重复记录。这种情况下应该显示错误对话框。操作于已经被删除的数据上时也需要显示明显的错误对话框。&lt;/p&gt;
&lt;p&gt;如果你在用户在一个页面选择一条记录后在另一个页面修改选中的数据行有特殊的更新流（Update flow）；则应选择与创建流（Create flow）类似的受限规则显示的告诉用户数据行正在被修改。或者，如果你没有记住选中数据行的机制则重复相同的更新操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; 为支持浏览器后退按钮，尽管更可取的办法是允许页面的重入，但有疑问的情况下，最好限制页面的重入，对用户来说这样也比显示unhandled exceptions或执行无意识的事务要好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="goal2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="mu-biao-2zai-zhuang-tai-gai-bian-shi-bi-mian-yan-zhong-de-unexpected-exceptions"&gt;目标2：在状态改变时避免严重的Unexpected Exceptions&lt;/h3&gt;
&lt;p&gt;你的最小目标是应该避免严重的unexpected exception，如NullPointerExcpetion或IndexOutOfBoundException，它将显示不可读的信息给用户。应该用用户可读的文本信息对话框来取代异常信息。&lt;/p&gt;
&lt;p&gt;参见 &lt;a href="/adv_back_use_cases.html#general"&gt;Use Case-Specific General Standards&lt;/a&gt; 了解这个目标的更多细节信息。&lt;/p&gt;
&lt;h2&gt;内容&lt;/h2&gt;
&lt;h2&gt;需要阅读&lt;/h2&gt;
&lt;p&gt;本文档假定你已经阅读了下面的内容：
Anatomy of an OA Framework Page
OA Framework State Management
Implementing the Model
Implementing the View
Implementing the Controller&lt;/p&gt;
&lt;h1&gt;概述相关工具和行为&lt;/h1&gt;
&lt;p&gt;深入编码标准前，了解OA和BC4J frameworks提供的内置对象和工具的行为对于你编写支持浏览器后退按钮的页面是很重要的。下一节的&lt;a href="#standards"&gt;编码标准&lt;/a&gt;提供了使用这些来处理后退按钮问题的介绍。&lt;/p&gt;
&lt;h2&gt;唯一的页面实例ID和页面状态缓存&lt;/h2&gt;
&lt;p&gt;OA Framework对于每个分离的页面请求&amp;mdash;&amp;mdash;包括同一个页面的多次请求&amp;mdash;&amp;mdash;都有一个唯一的页面实例ID（一个增长的页面计数参数被添加到form action URL和每个生成的页面链接）。。当form提交发生在用户点击浏览器后退按钮之后时，OA Framework使用页面计数器标识来检测浏览器后退按钮导航。&lt;/p&gt;
&lt;p&gt;另外，新的方法被添加到oracle.apps.fnd.framework.webui.OAPageContext，它允许你保存和获取页面的状态：savePageState()，getPageState()和removePageState()。参见Javadoc了解其它的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt; 如果异常发生在页面处理时，页面状态不会被保存并且它不会被钝化。&lt;/p&gt;
&lt;h2&gt;检查后退按钮导航的方法&lt;/h2&gt;
&lt;p&gt;OAPageContext.isBackNavigationFired()方法使你可以明确的检测到当前请求的浏览器后退按钮导航。这依赖于前面所讲的页面实例ID。&lt;/p&gt;
&lt;p&gt;参见OAPageContext的Javadoc了解使用这个方法的其它信息。&lt;/p&gt;
&lt;h2&gt;Web Bean层级结构的同步&lt;/h2&gt;
&lt;p&gt;在第2章和第3章中讲过，OA Framework在处理HTTP POST时，如果原来缓存的层级结构被丢失它将重建web bean层级结构。具体来说，它将在下面的情况下重新进入整个web bean层级结构的processRequest()。&lt;/p&gt;
&lt;p&gt;恢复丢失的web bean层级结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;POST请求激活了一个新的servlet session或一个被回收的应用模块实例（被钝化后）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST请求失败后转到了新的JVM。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 故障转移支持只在启用了请求级的钝化时才被支持。但是，这个功能目前还只处理测试阶段不被OA Framework所支持。&lt;/p&gt;
&lt;p&gt;使用中间层web bean状态同步客户端UI状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;POST请求是在用户使用浏览器后退按钮后的页面发起的。OA Framework通过调用OAPageContext.isBackNavigationFired()方法检查这种情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST请求从oracle.apps.fnd.framework.webui.OADialogPage发起，请求目标为打开这个对话框的初始页面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当form被提交时能重新创建web bean层级结构是一项重要的特性因为它确保了用户的工作可以在不被打断的并被保持一致的情况下被处理。但是，它不能强制要求代码规则确保任何支持后退按钮访问页面都可以在这种情况下被重建。。&lt;/p&gt;
&lt;h2&gt;UI&amp;ldquo;事务单元（Transaction Unit）&amp;rdquo;&lt;/h2&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.TransactionUnitHelper类允许你描绘用户接口&amp;ldquo;事务单元&amp;rdquo;用于标识出在事务提交后不适当的导航。在这些情况下非常有用：当多个分离的UI任务（每个都有自己的提交点commit points）共享相同的根应用模块&amp;mdash;&amp;mdash;因此是相同的数据库事务。通过事务单元标识器，你可以标明一个特定UI任务的开始和结束，并且如果用户意外导航比如浏览器后退按钮。你可以检查事务单元状态并作出反映确保不合适的动作不会执行BC4J缓存中的不需要的数据不会被提交。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户在Employee Summary页查找employees并选择 &lt;strong&gt;Create Employee&lt;/strong&gt; 按钮。&lt;/p&gt;
&lt;p&gt;你可以开始一个create employee 事务单元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户在Create Employee页面输入一些数据然后点击 &lt;strong&gt;Apply&lt;/strong&gt; 提交修改。&lt;/p&gt;
&lt;p&gt;结束create employee 事务单元。作为 &lt;strong&gt;Apply&lt;/strong&gt; 按钮处理的一部分，Create Employee页面forward到summary Page并在那里显示一个确认信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户点击浏览器后退按钮退回Create Employee页面然后再次修改数据并点击 &lt;strong&gt;Apply&lt;/strong&gt; 按钮。&lt;/p&gt;
&lt;p&gt;通过检查事务单元的状态OA Framework显示一个出错对话框页面，因为在这个范例模块中修改一个新创建的数据行是不允许的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这里没有当前的create employee 事务单元，因为用户没有通过 &lt;strong&gt;Create Employee&lt;/strong&gt; 按钮来导航，如果那样将触发创建一个新的事务单元。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面的&lt;a href="#specific"&gt;Use Case-Specific Standards&lt;/a&gt;提供了如何使用这个技巧的细节。&lt;/p&gt;
&lt;h2&gt;事务撤销（Transaction Undo）&lt;/h2&gt;
&lt;p&gt;在EBS 12版是不支持事务撤销的。&lt;/p&gt;
&lt;h2&gt;视图对象的主键比较（View Object Primary Key Comparison）&lt;/h2&gt;
&lt;p&gt;假定VO对象有一个主键或ROWID属性，OA Framwork将在处理processFormData()时自动检查从表单提交的数据，检查是否有&amp;ldquo;数据过期（stale data）&amp;rdquo;。如果页面数据行的主键或ROWID与VO中同一行（如果数据行的集合已经被修改或数据行已经被删除）数据的主键或ROWID不匹配，OA Framework将显示一个标准的&amp;ldquo;数据过期&amp;rdquo;的出错页面。&lt;/p&gt;
&lt;p&gt;如果定义了主键，而不是依赖于ROWID属性，OA Framework将尝试在结果集中使用主键查找到匹配的数据行。如果找到了，则&amp;ldquo;数据过期&amp;rdquo;错误将被避免，并且用户继续工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework只在VO对象当前的结果集（current view object result set）中查找匹配的数据行。如果VO对象的WHERE子句对结果集进行了限制，匹配有可能不能匹配，这也将产生&amp;ldquo;数据过期&amp;rdquo;的错误提示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用笔记&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;数据过期&amp;rdquo;检测机制的设计目的主要是为了捕捉对已经被删除的数据行进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了优化性能，对于没有表单元素的只读表格OA Framework不会执行数据过期的检查。对于某些特殊情况需要对只读表格进行数据过期检查的，可以表格区域的最后添加一个虚拟的可更新隐藏字段（ &lt;strong&gt;formValue&lt;/strong&gt; ）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了获取&amp;ldquo;数据过期&amp;rdquo;错误的根本原因，可以启用开发模式（Developer Mode）或诊断模式（Diagnostic Mode）。当这两种模式启用时，面向开发者的附加内容将显示在对话框页面的消息中，帮助诊断代码错误。参见&lt;a href="{filename}test_test.md"&gt;测试OA Framework应用&lt;/a&gt;以了解启用这些模式的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;数据过期&amp;rdquo;错误的意外出现也有可能是与VO对象的初始值有关。参见下面的&lt;a href="#uncond"&gt;避免无条件的VO对象/事务状态初始值&lt;/a&gt;以了解更多信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;已知问题：&lt;/strong&gt; 当前的VO对象主键比较逻辑趋向于过度保护；某些情况下，&amp;ldquo;数据过期&amp;rdquo;错误可能会出现在不需要的地方。例如，在通过浏览器后退按钮回退后以新的查询条件执行查询将导致&amp;ldquo;数据过期&amp;rdquo;的错误。为了在只读表格中避免这个问题，你可以在oracle.apps.fnd.framework.webui.beans.table.OATableBean或oracle.apps.fnd.framework.webui.beans.table.OAAdvancedTableBean上使用setSkipProcessFormData(pageContext,true)API。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;在锁定过程中BC4J过期数据检查（BC4J Stale Data Check During Locking）&lt;/h2&gt;
&lt;p&gt;当BC4J试图在数据库提交操作之前锁定行时将使用默认的OA Framework锁方案，如果当前用户查询过的行已经被另一个用户删除或修改它将自动尝试并决定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果行被删除了，BC4J将抛出oracle.jbo.RowAlreadyDeletedException。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果行已经被修改，BC4J将抛出oracle.jbo.RowInconsistentException。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这两种情况下，OA Framework将自动将这些低级的异常转化为用户友好的错误信息。&lt;/p&gt;
&lt;p&gt;这个检查在用户使用后退按钮并再次保存对过期数据的修改时也有好处。&lt;/p&gt;
&lt;p&gt;关于BC4J锁的更多信息，参见第五章&lt;a href="/bus_java.html"&gt;实现Java实体对象&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;标准错误对话框（Standard Error Dialogs）&lt;/h2&gt;
&lt;p&gt;OA Framework包含了一些标准错误对话框。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NAVIGATION_ERROR - 这个错误信息通知用户不能在点击浏览器后退按钮后继续。并指示用户回到全局主页（global Home page）恢复导航并重新启动事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FAILOVER_STATE_LOSS_ERROR - 这个错误信息通知用户在用户session或系统失效后不能继续。并指示用户回到全局主页恢复导航并重新启动事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATE_LOSS_ERROR - 两个特殊错误信息的组合。指示用户在使用后退按钮、用户session过期或系统失效后不能继续。并指示用户回到全局主页恢复导航并重新启动事务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;

  &lt;span class="c1"&gt;// Display a standard error message related to state loss due to Back button&lt;/span&gt;
  &lt;span class="c1"&gt;// navigation or failover as appropriate.&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isBackNavigationFired&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;redirectToDialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OADialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NAVIGATION_ERROR&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;redirectToDialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OADialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FAILOVER_STATE_LOSS_ERROR&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以直接使用pageContext.redirectToDialogPage(new OADialogPage(STATE_LOSS_ERROR))。但是，我们强烈建议你创建怀具体环境相关的消息提高对客户的实用性。&lt;/p&gt;
&lt;h2&gt;AM State Required 标识（AM State Required Flag）（Deprecated）&lt;/h2&gt;
&lt;p&gt;应用模块的AM State Required标识在新的开发中不再被推荐使用。如果你有页面使用了这个功能，并且它的表现与下面章节中的编码标准是一致的，则不需要修改你的实现。&lt;/p&gt;
&lt;h1&gt;编码标准（Coding Standards）&lt;/h1&gt;
&lt;p&gt;尽管在编码标准一章中所有的OA Framework编码标准都已经列出，但这一节提供了将每个标准应用到你的代码中的更多细节信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这些主题也链接到了第八章的摘要列表。&lt;/p&gt;
&lt;p&gt;编码标准被分为两个大的分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#general"&gt;一般标准&lt;/a&gt;应用于所有的使用情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#specific"&gt;特殊情况标准&lt;/a&gt;描述了在特殊应用场景中如何处理后退按钮，如何在一个只读摘要页面中处理删除动作，或如何处理关联到一个可更新页面的多步创建动作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="general"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一般标准&lt;/h2&gt;
&lt;h3 id="1-ding-yi-vodui-xiang-de-zhu-jian-mo-xing-bian-ma-biao-zhun-m39"&gt;1. 定义VO对象的主键 (模型编码标准&lt;a href="{filename}cs_mdlgeneral.md#M39#M39"&gt;M39&lt;/a&gt;)&lt;/h3&gt;
&lt;p&gt;为了使得上面所述的VO对象的主键可以进行比较，所有VO必须一个主键或以ROWID来代替。主键适合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例外：&lt;/strong&gt; 如果是一个不包含逻辑主键的简单只读VO对象，则不需要创建主键。比如，一个单列VO对象查询的是某列的合计值而并不包含逻辑主键。&lt;/p&gt;
&lt;p&gt;如果你需要了解如何定义VO对象的主键，参见&lt;a href="/build_model.html"&gt;实现模型&lt;/a&gt;。如果没有主键则应该使用ROWID，只需要在VO对象的SQL中选择ROWID伪列对应的属性名称为 &lt;strong&gt;Rowid&lt;/strong&gt; 或 &lt;strong&gt;RowId&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id="2-bu-yao-jia-she-vodui-xiang-de-zhuang-tai-mo-xing-bian-ma-biao-zhun-m38m37"&gt;2. 不要假设VO对象的状态（模型编码标准&lt;a href="{filename}cs_mdlgeneral.md#M38#M38"&gt;M38&lt;/a&gt;，&lt;a href="{filename}cs_mdlgeneral.md#M37#M37"&gt;M37&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;对于VO对象的状态永远不要臆测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不要总是认为VO对象一定有数据行。对从VO对象中获取的数据行进行null检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于查询页面中使用动态WHERE子句的VO对象，在执行查询前总是清除先前在的WHERE子句参数。这确保了之前的设置不会影响当前的查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于动态创建的VO对象，在创建之前总是使用find进行检查。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的代码描述了这些规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Bad Code&lt;/span&gt;
&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAllRowsInRange&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="na"&gt;getAttribute&lt;/span&gt;&lt;span class="o"&gt;(...);&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;--&lt;/span&gt; &lt;span class="n"&gt;assumes&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;exist&lt;/span&gt;
&lt;span class="c1"&gt;// Good Code&lt;/span&gt;
&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAllRowsInRange&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;--&lt;/span&gt; &lt;span class="n"&gt;allows&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;possibility&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;cannot&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Take proper action.&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="na"&gt;getAttribute&lt;/span&gt;&lt;span class="o"&gt;(...);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使动态设置WHERE子句（不管它是否为null）之前，总是先清空参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Bad Code&lt;/span&gt;

&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"empno &amp;lt; 10"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"empno = :1"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClauseParam&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;// Good Code&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"empno &amp;lt; 10"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClauseParams&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"empno = :1"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClauseParams&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClauseParam&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClauseParams&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要动态创建VO对象或VO对象的属性，在创建之前先检查同名的对象是否已经存在：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Bad Code&lt;/span&gt;
&lt;span class="n"&gt;ViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyVO"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addDynamicAttribute&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyAttr"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Good Code&lt;/span&gt;
&lt;span class="c1"&gt;// First check whether the VO with the same name exists or not.&lt;/span&gt;

&lt;span class="n"&gt;ViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyVO"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyVO"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Check whether the attribute with the same name exists or not.&lt;/span&gt;
&lt;span class="c1"&gt;// Note that for attributes, we need to use try-catch clause.&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lookupAttributeDef&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyAttr"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addDynamicAttribute&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyAttr"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="3-zai-processrequestzhi-wai-xiu-gai-web-beanshu-xing-kong-zhi-qi-bian-ma-biao-zhun-c16c15"&gt;3. 在processRequest之外修改Web Bean属性（控制器编码标准&lt;a href="{filename}cs_ctrlgeneral.md#C6#C6"&gt;C16&lt;/a&gt;，&lt;a href="{filename}cs_ctrlgeneral.md#C15#C15"&gt;C15&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;不要在processFormData()或processFormRequest()中添加修改web bean的逻辑。如果你需要在处理form提交请求过程中修改web bean层级结构或修改web bean属性，你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参见第四章&lt;a href="{filename}feat_ppr.md"&gt;动态用户界面&lt;/a&gt;将属性绑定到SPEL上和使用页面区域渲染。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用OAPageContext.setForward*()方法退回页面，并半retainAM参数设置为true，然后在processRequest()中执行你的bean处理逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果OA Framework由于上面描述过的原因需要重建web bean层级结构，所有相关逻辑必须包含在processRequest()方法中。而且，任何使得要修改web bean层级结构（包含web bean属性）的信息，必须被添加为 &lt;strong&gt;URL参数（URL parameter）&lt;/strong&gt;。换言之，如果你需要以某种方式在页面跳转（forward）时以编程方式修改web bean属性或层级结构，则这些在你检查用用以决定是否修改web bean的信息必须在调用forward（OAPageContext.setForward*()）时通过&amp;ldquo;参数（parameter）&amp;rdquo;(com.sun.java.util.collections.HashMap)指定。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.sun.java.util.collections.HashMap&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="c1"&gt;// As a result of a button press, return to the current page setting&lt;/span&gt;
&lt;span class="c1"&gt;// a URL parameter value to be used to modify the page layout.&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"someButton"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;HashMap&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"showRegion"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"RegionA"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setForwardURLToCurrentPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// added to the request as URL parameters&lt;/span&gt;
                                           &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// retain the AM&lt;/span&gt;
                                           &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ADD_BREAD_CRUMB_NO&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                           &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;IGNORE_MESSAGES&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;


&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"RegionA"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"showRegion"&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Change your layout accordingly...&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 使用OAPageContext.putParameter()或隐藏域在这种情况下不行，因为这些值不会被作为URL参数添加到请求。&lt;/p&gt;
&lt;p&gt;下面的例子描述了一个主键值如何被传递到setForward*()方法的HashMap参数中并被用于重建合适的web bean层级结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Page A包含了一个动态部分，它根据用户从列表中的选择显示不同的区域。Page A默认显示 &lt;strong&gt;Region1&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户在列表中选中了一个用于决定显示区域值。然后你跳转回页面，并将个值通过OAPageContext.setForwardURLToCurrentPaqge()方法设置到了&amp;ldquo;参数&amp;rdquo;HashMap中。这保证了这个值被作为URL参数添加到了请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户修改了她的主意从列表中选择了不同的项，这样你的代码将forward到页面并显示 &lt;strong&gt;Region3&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户选择浏览器后退按钮退回Page A将显示Page 2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 浏览器的HTML缓存，显示的是 &lt;strong&gt;Region2&lt;/strong&gt; ，不再与中间层的web bean层级结构匹配，中间层包含的是 &lt;strong&gt;Region3&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户在显示于 &lt;strong&gt;Region2&lt;/strong&gt; 的字段中输入一些值然后点击 &lt;strong&gt;Submit&lt;/strong&gt; 按钮。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OA Framework检测到浏览器后退按钮，在响应时，重建web bean层级结构并包含了 &lt;strong&gt;Region2&lt;/strong&gt; 和用户添加到请求的数据。这确保了中间层与浏览器缓存正确同步了动作处理没有出现错误。&lt;/p&gt;
&lt;h3 id="4-bi-mian-wu-tiao-jian-voshi-wu-zhuang-tai-chu-shi-zhi-kong-zhi-qi-bian-ma-biao-zhun-c32"&gt;4. 避免无条件VO/事务状态初始值（控制器编码标准&lt;a href="{filename}cs_ctrlgeneral.md#C32#C32"&gt;C32&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;在上面的&lt;a href="#hier_synch"&gt;Web Bean层级结构同步&lt;/a&gt;一节中描述过processRequest()方法可能重复的进入，避免无条件的VO对象和事务状态初始值。&lt;/p&gt;
&lt;p&gt;初始操作包括下面的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在VO对象上调用executeQuery()从数据库中查询数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在VO对象的insertRow(row)方法之后调用setMaxFetchSize(0)手工插入数据行，而不是从数据库查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用OAPageContext.putTransactionValue()，OAPageContext.putTransactionTransientValue()，OAViewObjectImpl.putValue()，OAApplicationModuleImpl.putValue()或OAPageContext.putSessionValue()来创建事务或session状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应该避免无条件初始化是因为下面两个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当processRequest()方法重入时，无条件初始将导致事务状态丢失。例如，用户对于transient VO属性的修改将丢失，VO对象的当前行数据行将重置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多余的执行查询和状态初始化性能上是不可取的（&lt;a href="http://boulter.com/blog/2004/08/19/performant-is-not-a-word/"&gt;performant&lt;/a&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参见&lt;a href="{filename}bus_vo.md#init#init"&gt;VO对象细节：初始化规则&lt;/a&gt;了解如何对VO对象执行适当的初始化。&lt;/p&gt;
&lt;h4 id="shi-wu-zhuang-tai"&gt;事务状态&lt;/h4&gt;
&lt;p&gt;如果你使用OAPageContext.putTransactionValue()等方法管理事务状态，则总应该检查它是否已经存在。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poTrxStep"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putTransactioinValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poTrxStep"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如果事务值（transaction value）可以改变过程并且你只需要初始化这个值一次，则这个检查是很重要的。&lt;/p&gt;
&lt;h3 id="5-qia-dang-de-pei-zhi-dui-hua-kuang-ye-mian-kong-zhi-qi-bian-ma-biao-zhun-c30_1"&gt;5. 恰当的配置对话框页面（控制器编码标准&lt;a href="{filename}cs_ctrlgeneral.md#C30#C30"&gt;C30&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;如果在导航到对话框页面时，需要根据用户对对话框页面问题的响应来交换数据，可以配置按钮来提交它的表单到调用页面。参见&lt;a href="{filename}ebs_feat_dialog.md"&gt;对话框页面&lt;/a&gt;了解操作细节。OA Framework将在调用processFormData()和processFormRequest()之前重新进入processRequest()，以确保你的页面能预期到&lt;a href="#uncond"&gt;无条件VO对象/事务初始化&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通常，你不需要关心对话框页面的后退按钮的支持。在极少数情况下对话框页面提交表单到它自身而不是提交到调用它的页面，你必须确保对话框页面可以像其它页面一样被重建。换方言之，任何写在processRequest()和processFormRequest()中对话框控制器代码必须预料和处理可能的状态丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用OADialogPage中的deprecated的方法setReleaseAllRootApplicationModules和setReleaseRootApplicationModule。如果使用了这些方法，则用户导航到OA Framework页面如Preference页，并用 &lt;strong&gt;Cancel&lt;/strong&gt; 按钮返回对话框页面时对话框页面的状态时将失效。参见Javadoc以了解这些方法的更多信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="6-zheng-que-de-tong-guo-ye-mian-yu-zhuang-tai-tong-xun-kong-zhi-qi-bian-ma-biao-zhun-c20c17"&gt;6. 正确的通过页面与状态通讯（控制器编码标准&lt;a href="{filename}cs_ctrlgeneral.md#C20#C20"&gt;C20&lt;/a&gt;，&lt;a href="{filename}cs_ctrlgeneral.md#C17#C17"&gt;C17&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;在考虑在特定情况下使用哪种通讯方法之前，先了解一下有哪些可用的选项。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;方法&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;URL 参数&lt;/td&gt;
&lt;td align="left"&gt;你可以直接添加参数及其值到URL。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;隐藏域OAFormValueBean&lt;/td&gt;
&lt;td align="left"&gt;HTML页面隐藏域的值在form提交时将添加到请求中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;FormParameter OAFormParameterBean&lt;/td&gt;
&lt;td align="left"&gt;HTML页面隐藏域的值在form提交时将添加到请求，与OAFormValueBean不同，这个值在每次form提交时会被清空（在fireAction或firePartialAction事件方法给它设置新值之前）。 &lt;strong&gt;注意：&lt;/strong&gt; 这个组件的使用是保留的，是专门用于配置fireAction和firePartialAction事件的。参见第四章的&lt;a href="{filename}feat_submitform.md"&gt;Declarative Form Submit&lt;/a&gt;和&lt;a href="{filename}ebs_feat_ppr.md"&gt;动态用户界面&lt;/a&gt;以了解更多细节。不要直接在你的页面中添加FormParameter beans。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;OAPageContext.putParameter()&lt;/td&gt;
&lt;td align="left"&gt;将参数值添加到特殊的页面缓存中，这个值在单个请求是持久化的。 &lt;strong&gt;注意：&lt;/strong&gt; 如果，用户导航到个性化或首选项页面然后返回你的页面。如果你只依赖于putParameter()设置的值，则它将不能正确重建页面。这是因为导航流承担了多次请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Transaction Value OAPageContext.putTransactionValue()&lt;/td&gt;
&lt;td align="left"&gt;将值添加应用模块的事务中，它在应用模块被保留时将一直存在。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Application Module Value OAApplicationModuleImpl.putValue()&lt;/td&gt;
&lt;td align="left"&gt;将值添加到应用模块中，它在应用模块被保留时将一直存在。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;View Object Value OAViewObjectImpl.putValue()&lt;/td&gt;
&lt;td align="left"&gt;将值添加VO对象，它将在应用模块被保留时一直存在。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Transient Transaction Value OAPageContext.putTransactionTransientValue()&lt;/td&gt;
&lt;td align="left"&gt;事务值存在于当前应用模块中，但仅限于当前JVM。 &lt;strong&gt;注意：&lt;/strong&gt; 这些不会被钝化，因此如果当前的应用模块被钝化并因为其它原因被激活，这些值将会丢失。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Application Module Transient Value OAApplicationModuleImpl.putTransientValue()&lt;/td&gt;
&lt;td align="left"&gt;应用模块值存在于当前JVM中。 &lt;strong&gt;注意：&lt;/strong&gt; 这些不会被钝化，因此如果当前的应用模块被钝化并因为其它原因被激活，这些值将会丢失。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ViewObjectTransientValue OAViewObjectImpl.putTransientValue()&lt;/td&gt;
&lt;td align="left"&gt;VO对象值存在于当前JVM。 &lt;strong&gt;注意：&lt;/strong&gt; 这些不会被钝化，因此如果当前的VO对象被钝化并因为其它原因被激活，这些值将会丢失。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Session Value OAPageContext.putSessionValue()&lt;/td&gt;
&lt;td align="left"&gt;添加到servlet session中的值生存于整个session周期。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;TransientSessionValue OAPageContext.putTransientSessionValue()&lt;/td&gt;
&lt;td align="left"&gt;Session值存在于当前JVM的session中。 &lt;strong&gt;注意：&lt;/strong&gt; 这些值不会被钝化，因此如果当前的session的状态被钝化并因为其它原因被激活，这些值将会丢失。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;浏览器cookie不包含在可用的通讯列表技术中。不要使用浏览器cookie来存储应用中的信息。浏览器可以拒绝cookie值，并且对于cookie的数量也有限制。浏览器cookie通常只在OA Framework内部使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这不适合于用自动强制页面刷新来解决后退问题。如果你因为其它原因需要使用页面刷新，请联系OA Framework团队。&lt;/p&gt;
&lt;h4 id="yong-fa-tui-jian"&gt;用法推荐&lt;/h4&gt;
&lt;p&gt;这节描述了正确的方法在可预期的游览后退按钮操作时与页面相关状态进行通讯。这些推荐方法包括启用&amp;ldquo;Return to&amp;rdquo;链接在不同的模块间导航并确保个性化和首选项模块能与你的页面无缝集成。例如，当用户在个性模块时选择&amp;ldquo;Cancel&amp;rdquo;按钮，你的页面应该能够正确的重建。&lt;/p&gt;
&lt;p&gt;参见&lt;a href="{filename}ess_state.md"&gt;OA Framework状态管理&lt;/a&gt;了解更多相关的技术细节。&lt;/p&gt;
&lt;p&gt;&lt;a name="intra-app-long"&gt;&lt;/a&gt;
应用内导航&lt;/p&gt;
&lt;p&gt;与用于构建目标页面的简单的状态值通讯时，使用URL参数（URL Parameters）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果是在form提交的环境下与状态通讯，使用OAPageContext.setForward*()方法的&amp;ldquo;paramters&amp;rdquo;HashMap。如果可能，应该避免使用OAPageContext.putParameter()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是在GET请求中与状态通讯，直接添加组件的Destination URI的静态绑定值将变成URL参数。在选择菜单项时你也可以将URL参数添加到请求中。参见&lt;a href="{filename}feat_tabs.md"&gt;Tabs/Navigation&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 通过浏览地址栏设置的值将显示给用户。用户通过查看页面源码也可以看到隐藏域值。在这两种情况下，敏感的数据值必须被如&lt;a href="/build_view.html#urlparams"&gt;实现视图：URL参数&lt;/a&gt;中描述的进行加密。&lt;/p&gt;
&lt;p&gt;为了根据更复杂或长时间存在的状态值来构建目标页面，可以使用下面的与应用模块相关的缓存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在事务中缓存值，如果你不需要钝化支持可以使用OAPageContext.putTransactionValue()或OAPageContext.putTransactionTransientValue()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在应用模块中缓存值，如果不需要钝化支持可以调用oracle.apps.fnd.framework.server.OAApplicationModuleImpl.putValue()或OAApplicationModuleImple.putTransientValue()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在VO对象中缓存值，如果不需要钝化支持oracle.apps.fnd.framework.server.OAViewObjectImpl.putValue()或OAViewObjectImpl.putTransientValue()。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用这些缓存策略时，要记得在代码中处理潜在的状态丢失。换言之，在使用值之前总是需要检查所需要的值是否存在，如果它为null或为空，你可以选择重建并重新缓存这个值，如果不行则需要显示一个用户友好的状态丢失的对话框消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例外：&lt;/strong&gt; 如果页面已经使用了如&lt;a href="#specific"&gt;Use Case-Specific Coding Standards&lt;/a&gt;中的UI事务单元来保护，则你不需要检查这些值是否已经存在。&lt;/p&gt;
&lt;p&gt;另外，为了使这个缓存策略能正确的工作，必须遵循下面的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不要为了省事而在只读页面中使用OAApplicationModule，总是使用自己的应用模块类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在页面被渲染前调用OAPageContext.releaseRootApplicationModule()来释放应用模块；这将导致过早的丢失页面状态。可以通过配置保留级别（retention levels）为 &lt;strong&gt;CONNECTION_AGNOSTIC&lt;/strong&gt; 或 &lt;strong&gt;MANAGE_STATE&lt;/strong&gt; 将你的根应用模块申明为无状态连接。参见&lt;a href="{filename}adv_passive.md#ret_level#ret_level"&gt;OA Framework State Persistence Model (Passivation)&lt;/a&gt;以了解更多信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用间导航&lt;/p&gt;
&lt;p&gt;应用内页面流上面已经讨论过了，在交叉页面流中导航最简单的方法是使用URL参数（URL parameters）。&lt;/p&gt;
&lt;p&gt;当原页面和目标页面使用了不同的应用模块时如果需要使用复杂的或长时间存在的值来构建目标页面时，你不能依赖于上面描述过的应用内导航。而应该在原始页面调用OAPageContext.putParameter()或OAPageContext.putSessionValue()/OAPageContext.putTransientSessionValue()来传递值到目标模块，然后在它的应用模块中获取和缓存这些值。目标页面必须：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;复制（&amp;ldquo;迁移（transition）&amp;rdquo;）参数/session值到根UI应用模块。换言之，获取参数或session值然后将它们存储于如&lt;a href="#intra-app-long"&gt;应用内导航&lt;/a&gt;中描述的事务、应用模块或VO对象中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果输入值被缓存于session中，则在复制它们后应该将它从session中删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从应用模块缓存中读取值，总是要考虑应用模块的状态可能会丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面的例子描绘了目标页面控制器的processRequest()方法使用了一个私有的方法&amp;ldquo;迁移&amp;rdquo;传递的值到应用模块缓存中。（这里假定在原页面使用了OAPageContext.putParameter()方法）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Always call this first.&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// Call this before trying to retrieve the value from the transaction.&lt;/span&gt;
  &lt;span class="n"&gt;transitionPageState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;required page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// Handle the loss of page state values when the application module is&lt;/span&gt;
  &lt;span class="c1"&gt;// released. If one of the required page state values does not exist&lt;/span&gt;
  &lt;span class="c1"&gt;// redirect to a context-specific state loss error page.&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Note that you are strongly recommended to use context-specific message&lt;/span&gt;
    &lt;span class="c1"&gt;// instead of the following generic messages.&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isBackNavigationFired&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;redirectToDialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OADialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NAVIGATION_ERROR&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;redirectToDialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OADialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FAILOVER_STATE_LOSS_ERROR&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// Otherwise, use the page state and continue processing the request.&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end processRequest()&lt;/span&gt;


&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;transitionPageState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// First inspect one of the required page state values.&lt;/span&gt;
  &lt;span class="c1"&gt;// Use getParameterObject() instead of getParameter() for&lt;/span&gt;
  &lt;span class="c1"&gt;// non-String object types.&lt;/span&gt;
  &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameterObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;required page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Transition the required value.&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;required page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// If you used session values instead of OAPageContext.putParameter to transport&lt;/span&gt;
    &lt;span class="c1"&gt;// the values, then remove the values from session after each transition.&lt;/span&gt;

    &lt;span class="c1"&gt;// Transition other values.&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameterObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;required page state 2&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;required page state 2&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// For optional values, if the value is not present, explicitly remove values&lt;/span&gt;
    &lt;span class="c1"&gt;// from the transaction.&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameterObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;optional page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;optional page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;removeTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;optional page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end transitionPageState()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 你至少需要一个页面状态值来决定是否需要执行迁移操作。如果只需要一个被所有UI区域共享的session值，并且你决定在每个区域的控制器中都使用transitionPageState()方法，则你可以在最顶层的区域的控制器（page layout region's controller）中对session值执行迁移操作并立即调用OAPageContext.putParameter()传递个额外的标识来向当前请求中的子区域表示需要的值已经存在了。子区域可以直接检查这个额外的标识（译注：而不需要再去重复执行迁移操作）。&lt;/p&gt;
&lt;h4 id="yin-cang-yu"&gt;隐藏域&lt;/h4&gt;
&lt;p&gt;隐藏域可以用于保存不应该显示于页面的应用数据，比如主键。它们不应该用于作为构建目标页面的条件而传递。这是因为当你的页面是通过另一个页面的 &lt;strong&gt;返回（Return to）&lt;/strong&gt; 导航链接来访问时，例如个性化页面时，以前的请求值是放到OAPageContext.putParameter()中的，返回导航是一个新的请求原来的参数已经不再存在了。页面状态也已经丢失，并且存储于隐藏域中的值也已经不能在下面的请求被保存。因此，应该使用上面描述的方法来代替使用隐藏域的方法。&lt;/p&gt;
&lt;h3 id="you-tiao-jian-de-jin-zhi-biao-dan-ti-jiao-dong-zuo_1"&gt;有条件的禁止表单提交动作&lt;/h3&gt;
&lt;p&gt;在某些情况下，在使用浏览后退按钮后用户不应该也不能提交表单。参见下面的&lt;a href="/adv_back_use_cases.html#general"&gt;Use Case-Specific General Standards&lt;/a&gt;指导方针对特殊情况进行处理。&lt;/p&gt;
&lt;h2&gt;使用特殊情况标准&lt;/h2&gt;
&lt;p&gt;除了上面的一般性规则，检查下面的列表看是否有相符合的特殊情况，如果有则应该遵循下面的规则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_create"&gt;只读页面单步创建&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_multistep_create"&gt;只读页面多步创建&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_delet"&gt;只读页面删除&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_update"&gt;只读单页面修改（允许迭代修改）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_single_update"&gt;只读单页面修改（允许单次修改）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_multistep_update"&gt;只读页面多步修改&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#txn_all"&gt;可修改的摘要页面（Summary）单步或多步创建或修改&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#txn_sub"&gt;可修改的摘要页面（Summary）多步创建或修改和子事务&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#txn_crossprod"&gt;摘要（Summary）和事务页面应用间（Inter-Application（Cross-Product））页面流&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#txn_inline"&gt;可修改摘要页面（Summary）或表格中的动作（复制和移除）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#ppr"&gt;PPR页面刷新&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;测试浏览器后退按钮&lt;/h2&gt;
&lt;p&gt;测试应用对浏览后退按钮的支持：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;手工按&lt;a href="{filename}adv_back_use_cases.mdl"&gt;Use Case-Specific Standards&lt;/a&gt;列表中的导航路径进行测试。除了通过后退按钮导航，也要尝试：&lt;/p&gt;
&lt;p&gt;在事务处理页面有意地输入无效的数据并执行表单提交动作以产生一个校验错误。并使用后退按钮退回摘要页面（Summary）。无效的对象不应该引起其它错误，在正确的重新输入数据后事务页面应该可以开始一个新的事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在每个页面，都选择全局的&amp;ldquo;首页&amp;rdquo;链接然后使用浏览后退按钮返回你的页面。再点击页面中的按钮或表单提交的链接。这可以检查你的页面在状态丢失时健壮性。你的页面应该能够正确的重建或显示一个客户化的用户友好的状态丢失错误对话框。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在每个页面中，选择&amp;ldquo;个性化&amp;rdquo;链接并使用个性化页面的返回链接返回你的页面。在首选项页面执行同样的操作并通过取消按钮返回你的页面。这些页面流将保存你的应用模块状态。因此，你的页面应该能够正确的重建。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>Linux内核设备驱动第三版读书笔记</title><link href="/linuxnei-he-she-bei-qu-dong-di-san-ban-du-shu-bi-ji.html" rel="alternate"></link><published>2008-01-17T00:00:00+08:00</published><updated>2008-01-17T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-01-17:/linuxnei-he-she-bei-qu-dong-di-san-ban-du-shu-bi-ji.html</id><summary type="html">&lt;h1&gt;Chap 2 构建和运行内核&lt;/h1&gt;
&lt;h2&gt;设置测试系统&lt;/h2&gt;
&lt;p&gt;书中的例子以Kernel 2.6.x为基础（2.6.10）。&lt;/p&gt;
&lt;h2&gt;Hello World模块&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;linux/init.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;linux/module.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;MODULE_LICENSE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Dual BSD/GPL"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;hello_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KERN_ALERT&lt;/span&gt; &lt;span class="s"&gt;"Hello, world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;hello_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KERN_ALERT&lt;/span&gt; &lt;span class="s"&gt;"Goodbye, cruel world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;module_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello_init&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;module_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello_exit …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Chap 2 构建和运行内核&lt;/h1&gt;
&lt;h2&gt;设置测试系统&lt;/h2&gt;
&lt;p&gt;书中的例子以Kernel 2.6.x为基础（2.6.10）。&lt;/p&gt;
&lt;h2&gt;Hello World模块&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;linux/init.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;linux/module.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;MODULE_LICENSE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Dual BSD/GPL"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;hello_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KERN_ALERT&lt;/span&gt; &lt;span class="s"&gt;"Hello, world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;hello_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KERN_ALERT&lt;/span&gt; &lt;span class="s"&gt;"Goodbye, cruel world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;module_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello_init&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;module_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello_exit&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个模块包含两个函数，一个在模块被加载到内核时时被调用（hello_init），一个在模块被移除时被调用（hello_exit）。module_init和module_exit这两行使用了特殊的内核宏来标明两个行数所扮演的角色。另一个特殊的宏（MODULE_LICENSE）用于告诉内核这个模块具有自由的许可；如果没有这个申明，内核将在模块加载时发出警告。&lt;/p&gt;
&lt;p&gt;printk函数定义于Linux内核中并对模块有效；它的作用类似标准C库中的printf函数。内核需要自己的打印函数，因为它独立运行，没有C库的辅助。模块可以调用printk，因为在insmod加载它之后，模块被链接到内核并可以访问内核所公开的符号（函数和变量）。字符串KERN_ALERT是消息的优先级。在这个模块中我们指定了一个高的优先级，因为消息在默认优先级下可能显示不出来，这依赖于你运行的内核版本，klogd守护进程的版本和你的配置。&lt;/p&gt;
&lt;p&gt;可以使用insmod和rmmod工具来测试模块。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;% make&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Entering&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt; `&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;2.6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;
&lt;span class="n"&gt;CC&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ldd3&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;misc&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;
&lt;span class="n"&gt;Building&lt;/span&gt; &lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="mf"&gt;2.&lt;/span&gt;
&lt;span class="n"&gt;MODPOST&lt;/span&gt;
&lt;span class="n"&gt;CC&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ldd3&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;misc&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;mod&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;
&lt;span class="n"&gt;LD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ldd3&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;misc&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ko&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Leaving&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt; `&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;2.6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;
&lt;span class="c"&gt;% su&lt;/span&gt;
&lt;span class="n"&gt;root&lt;/span&gt;# &lt;span class="n"&gt;insmod&lt;/span&gt; &lt;span class="o"&gt;./&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ko&lt;/span&gt;
&lt;span class="n"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;world&lt;/span&gt;
&lt;span class="n"&gt;root&lt;/span&gt;# &lt;span class="n"&gt;rmmod&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;
&lt;span class="n"&gt;Goodbye&lt;/span&gt; &lt;span class="n"&gt;cruel&lt;/span&gt; &lt;span class="n"&gt;world&lt;/span&gt;
&lt;span class="n"&gt;root&lt;/span&gt;#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为使上面的命令能执行，你必须有一个适当的配置，并且内核树在makefile可以找到的地方（这里是/usr/src/linux-2.6.10）。&lt;/p&gt;
&lt;p&gt;根据你的系统投递消息行的机制不同，你的输出也可能不同。特别是上面的屏幕输出是来自于文本终端；如果你在window系统下的模块终端中运行insmod和rmmod，你可能看不到任何东西。消息可以被发送到某个系统日志文件，比如/var/log/messages（各发行版本不同）。内核消息投递机制在Chap4详述。&lt;/p&gt;
&lt;h2&gt;内核模块与应用的差异&lt;/h2&gt;
&lt;p&gt;多数中小型程序从头至尾执行一个单一的任务，每个内核模块只是注册自己为以后的请求提供服务，它的初始化函数将立即结束。换言之，模块的初始化函数是为将来调用模块的函数作准备的；就好像模块在说&amp;ldquo;我在这里，这是我可以做的。&amp;rdquo;。模块的退出函数（例中的hello_exit）函数在模块被卸载之前被调用。它告诉模块&amp;ldquo;我不存在了；不要再要求我做任何事情。&amp;rdquo;这类似于事件驱动程序，并非所有应用程序都是事件驱动的，但每个内核模块都是的。事件驱动的应用程序和内核代码另一个主要不同的是退出函数：应用程序结束时可以延时来释放资源或做清除操作，内核模块则必须小心撤销init函数设置的所有东西，或保留一小块直到系统被重新启动。&lt;/p&gt;
&lt;p&gt;另外，内核模块卸载的能力是模块化的一个功能，可以节约开发时间，可以测试不同版本的驱动而不用重启机器。&lt;/p&gt;
&lt;p&gt;应用程序中通过链接阶段来解决对外部函数库的引用。比如printf就定义在libc中。内核模块只能链接内核；不能链接库。比如printk函数，就像printf的内核内部的版本被导出到模块中。它表现得像printf函数，只有少量的不同，主要的一个就是缺乏浮点支持。&lt;/p&gt;</content><category term="linux"></category></entry><entry><title>Programming Perl笔记</title><link href="/programming-perlbi-ji.html" rel="alternate"></link><published>2007-12-02T00:00:00+08:00</published><updated>2007-12-02T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-12-02:/programming-perlbi-ji.html</id><summary type="html">&lt;h1&gt;OverView&lt;/h1&gt;
&lt;h2&gt;自然的人工语言&lt;/h2&gt;
&lt;h3 id="bian-liang-yu-fa"&gt;变量语法&lt;/h3&gt;
&lt;p&gt;变量类型&lt;/p&gt;
&lt;p&gt;类型 || 字符 || 例子 || 说明
标量 | $ | $cents | 单个的值（数字或字符串）
数组 | @ | @large | 值列表，键为数字
哈希表 | % | %interest | 一组值，键为字符串
子程序 | &amp;amp; | &amp;amp;how | 一块可被调用的代码
glob | &lt;code&gt;&lt;em&gt;&lt;/em&gt;&lt;/code&gt; | &lt;code&gt;&lt;/code&gt;&lt;/p&gt;struck | 所有被命名为struck的东西
&lt;h3 id="bian-liang-fu-zhi"&gt;变量赋值&lt;/h3&gt;
&lt;h4 id="dan-yi-bian-liang"&gt;单一变量&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$answer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;# 一个整数&lt;/span&gt;
&lt;span class="nv"&gt;$pi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.14159265&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;# 一个实数&lt;/span&gt;
&lt;span class="nv"&gt;$avocados&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;6.02e23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;# 科学计数法&lt;/span&gt;
&lt;span class="nv"&gt;$pet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Camel"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;# 字符串&lt;/span&gt;
&lt;span class="nv"&gt;$sign&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"I love my $pet"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 带插值的字符串&lt;/span&gt;
&lt;span class="nv"&gt;$cost&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'It …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;OverView&lt;/h1&gt;
&lt;h2&gt;自然的人工语言&lt;/h2&gt;
&lt;h3 id="bian-liang-yu-fa"&gt;变量语法&lt;/h3&gt;
&lt;p&gt;变量类型&lt;/p&gt;
&lt;p&gt;类型 || 字符 || 例子 || 说明
标量 | $ | $cents | 单个的值（数字或字符串）
数组 | @ | @large | 值列表，键为数字
哈希表 | % | %interest | 一组值，键为字符串
子程序 | &amp;amp; | &amp;amp;how | 一块可被调用的代码
glob | &lt;code&gt;&lt;em&gt;&lt;/em&gt;&lt;/code&gt; | &lt;code&gt;&lt;/code&gt;&lt;/p&gt;struck | 所有被命名为struck的东西
&lt;h3 id="bian-liang-fu-zhi"&gt;变量赋值&lt;/h3&gt;
&lt;h4 id="dan-yi-bian-liang"&gt;单一变量&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$answer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;# 一个整数&lt;/span&gt;
&lt;span class="nv"&gt;$pi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.14159265&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;# 一个实数&lt;/span&gt;
&lt;span class="nv"&gt;$avocados&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;6.02e23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;# 科学计数法&lt;/span&gt;
&lt;span class="nv"&gt;$pet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Camel"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;# 字符串&lt;/span&gt;
&lt;span class="nv"&gt;$sign&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"I love my $pet"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 带插值的字符串&lt;/span&gt;
&lt;span class="nv"&gt;$cost&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'It costs $100'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;# 无插值的字符串&lt;/span&gt;
&lt;span class="nv"&gt;$thence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$whence&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;# 另一个变量的值&lt;/span&gt;
&lt;span class="nv"&gt;$salsa&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$moles&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;$avocados&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;# 表达式&lt;/span&gt;
&lt;span class="nv"&gt;$exit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"vi $file"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;# 命令返回的数字值&lt;/span&gt;
&lt;span class="nv"&gt;$cwd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sb"&gt;`pwd`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;# 命令输出的字符串&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标量也可以引用其它数据结构，包括子程序和对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$ary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;@myarray&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;# 一个命名数组的引用&lt;/span&gt;
&lt;span class="nv"&gt;$hsh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;%myhash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;# 一个命名哈希的引用&lt;/span&gt;
&lt;span class="nv"&gt;$sub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;\&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mysub&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;# 一个命名子程序的引用&lt;/span&gt;

&lt;span class="nv"&gt;$ary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;          &lt;span class="c1"&gt;# 未命名数组的引用&lt;/span&gt;
&lt;span class="nv"&gt;$hsh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Na&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Cl&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;# 未命名哈希的引用&lt;/span&gt;
&lt;span class="nv"&gt;$sub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sub&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nv"&gt;$state&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;# 未命名的子程序&lt;/span&gt;

&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Camel&lt;/span&gt; &lt;span class="s"&gt;"Amelia"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 对象的引用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果使用了一个未被赋值过的变量，这个未初始化过的变量将自动按需要产生。根据最小惊讶原则，变量创建时可能带的null值，或""或0，依赖于你在什么地方使用它们，变量将被自动解释为字符串，数字或"true"和"false"（布尔变量）。在人类语言中语言环境相当重要。在Perl中，多个操作符希望某一类厅异值作为参数。有时将更具体，将这些参数称作数字环境，字符串环境，或布尔环境。（后面也将谈及列表环境，它与标量环境是相对应的。）Perl将自根据当前环境的需要将数据进行转换。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$camels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'123'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nv"&gt;$camels&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;$camels的初始值是一个字符串，但它被转换成数字后加1，然后转换回字符串被输出为124。"\n"换行符也处于字符串环境中，但由于它已经是一个字符串了，因此不需要转换。但主注意我们在它上面使用了双引号&amp;mdash;&amp;mdash;使用单引号的'\n'将产生包含两个字符的字符串，内容为斜线和&amp;ldquo;n&amp;rdquo;，它不是一个换行符。&lt;/p&gt;
&lt;p&gt;因此，在某种意义上来说，双引号和单引号也是另一种特殊的环境。对引号内的字符串的解释取决于你使用的引号类型。（双引号环境是Perl中的&amp;ldquo;内插（interpolative）&amp;rdquo;环境，它也被许多其它的与双引号不同的操作符支持。&lt;/p&gt;
&lt;p&gt;类似地，当你给引用一个&amp;ldquo;解除引用（dereference）&amp;rdquo;环境时表示得像引用，但另一方面又表现得像一个标量。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Camel&lt;/span&gt; &lt;span class="s"&gt;"Amelia"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;$fido&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nb"&gt;die&lt;/span&gt; &lt;span class="s"&gt;"dead camel"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;$fido&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;saddle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里创建了一个Camel对象的引用并把它赋给变量&lt;span class="math"&gt;\(fido。在下一行，我们把\)&lt;/span&gt;fido作为一个布尔型的标量来检查它是否为&amp;ldquo;true&amp;rdquo;，如果不为true抛出异常。但在最后一行，我们把&lt;span class="math"&gt;\(fido作为一个引用，并要求它在\)&lt;/span&gt;fido中持有的对象中查找saddle()方法，这发生在Camel类，因此Perl在Camel对象上查找saddle()方法。&lt;/p&gt;
&lt;h4 id="fu-shu-bian-liang"&gt;复数变量&lt;/h4&gt;
&lt;p&gt;某些类型的变量持有逻辑上配合在一起的多个值。Perl有两种多值变量：数组和哈希。有些情况下，这些行为像标量&amp;mdash;&amp;mdash;比如，他们在需要时被自动创建。但它们与标量不同，当你给它们赋值时，它们为右值提供了一个列表（list）环境而不是一个标量环境。&lt;/p&gt;
&lt;p&gt;数组和哈布之间也不同。你需要使用数字来查找时应该使用数组。需要通过名称来查找时使用哈希。这是两个补充概念。&lt;/p&gt;
&lt;h5 id="shu-zu"&gt;数组&lt;/h5&gt;
&lt;p&gt;数组是一个标量的列表，通过标量在列表中的位置来访问。列表中可以包含数字，字符串，或两者都有。（它也可以包含子数组或子哈希的引用）给数组赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;@home&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"couch"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"chair"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"table"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"stove"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;反过来，你在列表环境中使用@home，比如在列表赋值的右边，你将得到同样的值。因此你可以像下面这样从数组中设置四个标量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$potato&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$lift&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$tennis&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$pipe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;@home&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这被称为列表赋值。理论上它们是并行发生的，因此你可以像下面这样交换变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$alpha&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;$omega&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$omega&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;$alpha&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与C里一样，数组下标从0开始，通过方括号访问。因为处理的元素是标量，因此你需要在前面加$。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$home&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"couch"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$home&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"chair"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$home&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"table"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$home&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"stove"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于数组是有序的，你可以在上面做更多复杂的操作，比如作为堆栈执行push和pop操作。毕竟堆栈也只是一个有序的列表，有一个开始的结束。特别是结束。Perl把数组的结束作为栈顶。（尽管多数Perl程序员把数组当作是水平的，栈顶在右边。）&lt;/p&gt;
&lt;h5 id="ha-xi"&gt;哈希&lt;/h5&gt;
&lt;p&gt;哈希是一组无序标量的集合，通过关联到每个标量的字符串值来访问。由于这个原因哈希经常被叫作关联数组。
由于哈希中的key不能由它们的位置自动提供，你必须提供key。你可以像数组一样提供一个列表给哈希，但列表中的项将作为键值对分割。哈希使用%来标识。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;%longday&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Sun"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Sunday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Mon"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Monday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Tue"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Tuesday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;"Wed"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Wednesday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Thu"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Thursday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Fri"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;"Friday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Sat"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Saturday"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这难于阅读perl提供了=&amp;gt;，使得更容易区分哈希中的键和值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;%longday&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;"Sun"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Sunday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Mon"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Monday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Tue"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Tuesday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Wed"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Wednesday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Thu"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Thursday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Fri"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Friday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Sat"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Saturday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哈希的排序，可以使用keys函数获取哈希的key列表然后用sort函数进行排序。&lt;/p&gt;
&lt;p&gt;由于哈希是一种奇怪的数组，你必须使用大括号来选择其中的元素。需要再次注意的是你处理的元素是标量，因此应该在它的前面使用$而不是%。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Adam"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Eve"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="fu-za-shu-ju-jie-gou_1"&gt;复杂数据结构&lt;/h4&gt;
&lt;p&gt;在hash元素中保存list时等号右边应该使用方括号，因为在Perl中小括号和其中逗号不足以将list保存到标量中（小括号用于分组，逗号用于分隔）。下面的写法是错误的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Rachel"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Bilhah"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Zilpah"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;# WRONG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正确写法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Rachel"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Bilhah"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Zilpah"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;        &lt;span class="c1"&gt;# ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句创建了一个未命名的array并将它的引用放到hash元素&lt;code&gt;$wife{"Jacob"}&lt;/code&gt;中。这种方式也是Perl处理多维数组和嵌套数据结构的方式。与使用普通array和hash一样，也可以按下面的方式赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Rachel"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Bilhah"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Zilpah"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哈希中的元素为另一个哈希，而这个哈希中的元素为数组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;"Leah"&lt;/span&gt;   &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Reuben"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Simeon"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Levi"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Judah"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Issachar"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Zebulun"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s"&gt;"Rachel"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Joseph"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Benjamin"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s"&gt;"Bilhah"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Dan"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Naphtali"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s"&gt;"Zilpah"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Gad"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Asher"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它比下面的方式简洁多了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Reuben"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Simeon"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Levi"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Judah"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Issachar"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Zebulun"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Rachel"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Joseph"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Rachel"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Benjamin"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Bilhah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Dan"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Bilhah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Naphtali"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Zilpah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Gad"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Zilpah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Asher"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用这种方式添加更多的层，但在内部的描述方式是一样的。&lt;/p&gt;
&lt;p&gt;在这里最重要的一点是Perl允许你将复杂的数据结构描述为一个简单的标量。通过这种简单的封装，Perl构建了面向对象结构。例如前面调用的Camel构造器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Camel&lt;/span&gt; &lt;span class="s"&gt;"Amelia"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们创建了一个Camel对象它被描述为一个标量$fido。但在Camel的内部它更复杂一些。对于面向对象的程序员，我们不需要了解Camel的内部（除非我们是实现Camel类方法的人）。但通常，类似Camel的类是由一个包含Camel的各个属性的hash构成，比如它的名称（在这里是&amp;rdquo;Amelia"，而不是&amp;ldquo;fido&amp;rdquo;），和hump（驼峰）的数量。&lt;/p&gt;
&lt;h4 id="jian-dan-shu-ju-jie-gou"&gt;简单数据结构&lt;/h4&gt;
&lt;p&gt;与真实的语言环境中单词依据不同的环境有不同的含义一样。Perl使用了多种方式来标明当前的环境。其中一个重要的局部环境申明就是package。假设你要在Perl中谈论Camel。你可以这样开始你的模块：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;Camel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将产生多个值得注意的影响。其一就是Perl将假定从这个点开始任何未指明的动词或名词都是关于Camel的。它将自动为任何全局名称前面添加模块名作为前缀&amp;ldquo;Camel::&amp;rdquo;。因此代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;Camel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;fetch&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样&lt;span class="math"&gt;\(fido的真实名称为\)&lt;/span&gt;Camel::fido（&amp;amp;fetch的真实名称为&amp;amp;Camel::fetch，但我们先不谈论动词）。这表示如果另一个模块为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;Dog&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;fetch&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perl不会迷惑，因为&lt;span class="math"&gt;\(fido的真实名称为\)&lt;/span&gt;Dog::fido，而不是$Camel::fido。包只是建立了一个命名空间。你可以创建任意多个命名空间，但由于同一时间只处于其中一个，你可以假设其它命名空间不存在。这种简单是基于假设的。（当然，这过于简单化了，这只是我们在这章所做的。）&lt;/p&gt;
&lt;p&gt;命名空间使得&amp;amp;Camel::fetch和&amp;amp;Dog::fetch不会迷惑，但包真正好的地方在于它对你的动作进行了分类以便其它包使用它们。当我们说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Camel&lt;/span&gt; &lt;span class="s"&gt;"Amelia"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们实际调用了Camel包的&amp;amp;new动作，它的全名为&amp;amp;Camel:new。前面所说的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$fido&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;saddle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的是&amp;amp;Camel::saddle子程序，因为$dido知道它指向的是Camel类型的数据。这就是面向对象编程的工作方式。&lt;/p&gt;
&lt;p&gt;使用已经存在的包时，使用&lt;code&gt;use&lt;/code&gt;申明，这不仅是为了调用另一个包中的动作，也将检查那个模块是否已经从磁盘加载过了。实际上，你必须在使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Camel&lt;/span&gt; &lt;span class="s"&gt;"Amelia"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前，使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;Camel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;否则，Perl不知道Camel的定义。&lt;/p&gt;
&lt;p&gt;事实上一些内置模块不需要实际引入它们的动词。这些特殊模块被称为&lt;code&gt;pragmas&lt;/code&gt;。比如，你经常可以看到人们使用&lt;code&gt;strict&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;strict&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;strict模块将使Perl加强对程序的检查，你对一些事务必须更加显式的指定，比如变量的作用范围等。这对于大型项目是很有帮助的。默认情况下Perl为小型项目而优化，但使用strict模块，Perl也能用于需要更多可维护性的大项目。&lt;/p&gt;
&lt;h3 id="dong-ci_1"&gt;动词&lt;/h3&gt;
&lt;p&gt;与其它命令式计算机语言一样，Perl中的动作是命令：它们告诉Perl解释器做什么。另一方面与自然语言一样，Perl动词的含义也依赖于具体的环境。以动词开头的语句通常是纯命令，被整个执行。（有时称这些动词为子程序，特别是当他们是用户定义的时候。）一个常用的内置命令是print命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"Adam's wif is $wife{'Adam'}.\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将产生下面输出：
&lt;example&gt;
Adam's wife is Eve.
&lt;/example&gt;
但在某些祈使语句内包含有&amp;rdquo;语气&amp;ldquo;。一些动词是用于提问的，对于条件语句非常有用，比如if语句。其它动词将它们的输入参数轮换为返回值，我们称这些动词为函数。&lt;/p&gt;
&lt;p&gt;比如内置的exp函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$e&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;# 2.718281828459 or thereabouts&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但Perl中子程序和函数没有明确区别。动词有时也被称作操作符（当内置时），或子过程。可以按你的喜好来叫&amp;mdash;&amp;mdash;他们都返回一个值，它可能是一个没有意义的值，你可以或使用或忽略它。&lt;/p&gt;
&lt;p&gt;历史上的，Perl需要在任何用户定义的子过程前面加一个&lt;code&gt;&amp;amp;&lt;/code&gt;符号。但从Perl 5开始，&amp;amp;符号变为可选项，因此用户定义的动词与内置动词有相同的语法。当我们谈论子程序的名称时，我们仍将使用&amp;amp;符号，比如当我们获取它的引用时（$fetcher = \&amp;amp;fetch;）。从语言上来说，你可以把&amp;amp;符号当作不定词，&amp;ldquo;to fetch&amp;ldquo;或类似&amp;rdquo;do fetch&amp;ldquo;。但我们说&amp;rdquo;do fetch&amp;ldquo;时我们可以只说&amp;rdquo;fetch&amp;ldquo;。这也是我们在Perl5中抛弃强制使用&amp;amp;符号的实际原因。&lt;/p&gt;
&lt;h2&gt;一个求平均值的例子&lt;/h2&gt;
&lt;p&gt;这个例子用于求数据平均值，数据：
&lt;example&gt;
No&amp;euml;l 25
Ben 76
Clementine 49
Norm 66
Chris 92
Doug 42
Carol 25
Ben 12
Clementine 0
Norm 66
...
&lt;/example&gt;
它保存于名为grades的文件中。&lt;/p&gt;
&lt;p&gt;程序如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="c1"&gt;#!/usr/bin/perl&lt;/span&gt;
 &lt;span class="mi"&gt;2&lt;/span&gt;  
 &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GRADES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"grades"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="nb"&gt;die&lt;/span&gt; &lt;span class="s"&gt;"Can't open grades: $!\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sr"&gt;&amp;lt;GRADES&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="mi"&gt;5&lt;/span&gt;      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$student&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$grade&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
 &lt;span class="mi"&gt;6&lt;/span&gt;      &lt;span class="nv"&gt;$grades&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;$student&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;.=&lt;/span&gt; &lt;span class="nv"&gt;$grade&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="mi"&gt;8&lt;/span&gt; 
 &lt;span class="mi"&gt;9&lt;/span&gt;  &lt;span class="k"&gt;foreach&lt;/span&gt; &lt;span class="nv"&gt;$student&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nb"&gt;keys&lt;/span&gt; &lt;span class="nv"&gt;%grades&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt;      &lt;span class="nv"&gt;$scores&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;11&lt;/span&gt;      &lt;span class="nv"&gt;$total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
&lt;span class="mi"&gt;12&lt;/span&gt;      &lt;span class="nv"&gt;@grades&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$grades&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;$student&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="mi"&gt;13&lt;/span&gt;      &lt;span class="k"&gt;foreach&lt;/span&gt; &lt;span class="nv"&gt;$grade&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;@grades&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="mi"&gt;14&lt;/span&gt;          &lt;span class="nv"&gt;$total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nv"&gt;$grade&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;15&lt;/span&gt;          &lt;span class="nv"&gt;$scores&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;16&lt;/span&gt;      &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;17&lt;/span&gt;      &lt;span class="nv"&gt;$average&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$total&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="nv"&gt;$scores&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;18&lt;/span&gt;      &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"$student: $grades{$student}\tAverage: $average\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;19&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行时使用-w开关以获取警告信息。&lt;/p&gt;
&lt;h2&gt;文件句柄&lt;/h2&gt;
&lt;p&gt;在求平均值的例子中的GRADES是Perl中的另一种数据类型，文件句柄（filehandle）。文件句柄是你给一个文件，设备，socket或管道起的名字，帮助你记得他们是做什么的，隐藏了如缓冲等复杂的东西。（在内部文件句柄像C++等语言中的流。）&lt;/p&gt;
&lt;p&gt;文件句柄使用很容易在不同的地方读写数据。这部分使得Perl成为了一种非常好的脱水语言，它可以在同一时间处理很多文件和操作。&lt;/p&gt;
&lt;p&gt;使用open创建文件句柄并将它绑定到文件。open函数至少需要两个参数：文件句柄和要关联的文件名。Perl也提供了一些预定义的文件句柄。标准输入STDIN，标准输出STDOUT和STDERR，STDERR允许你和程序伪造输出到你的输出中。&lt;/p&gt;
&lt;p&gt;由于你可以使用open创建用于多种目的的文件句柄（输入，输出，管道），因此需要指定你需要的是哪种行为。你可以在命令行上，在文件句前添加字符，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"filename"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;# read from existing file&lt;/span&gt;
&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;filename"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;              &lt;span class="c1"&gt;#   (same thing, explicitly)&lt;/span&gt;
&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"&amp;gt;filename"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;              &lt;span class="c1"&gt;# create file and write to it&lt;/span&gt;
&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"&amp;gt;&amp;gt;filename"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;             &lt;span class="c1"&gt;# append to existing file&lt;/span&gt;
&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"| output-pipe-command"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# set up an output filter&lt;/span&gt;
&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"input-pipe-command |"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;# set up an input filter&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件句柄的命名是任意的。一旦打开，文件句柄SESAME就可以使用，直到显式的关闭它（close(SESAME)），或直到在后面的程序中使了open将这个句柄指向了另一个文件。打开一个已经打开的句柄将隐式的关闭先前打开的文件，使用它变为不可达的句柄，并打开一个不同的文件。对于这个操作要小心。有时会出现意外，比如使用&lt;code&gt;open(&lt;span class="math"&gt;\(handle,\)&lt;/span&gt;file)&lt;/code&gt;时，&lt;span class="math"&gt;\(handle包含了一个constant的字符串。确保\)&lt;/span&gt;handle的唯一性，否则你将在同一个句柄上打开新文件。或者$handle未定义，Perl将填充它。&lt;/p&gt;
&lt;p&gt;可以用&amp;lt;&amp;gt;操作符读取文件中的行。尖括号包含文件句柄（&lt;sesame&gt;）。空的操作符&amp;lt;&amp;gt;将从命令行上指定的所有文件中读入行，或从STDIN中读入。（这是许多过滤程序的标准行为。）一个使用STDIN文件句柄的例子：&lt;/sesame&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="bp"&gt;STDOUT&lt;/span&gt; &lt;span class="s"&gt;"Enter a number: "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;# ask for a number&lt;/span&gt;
&lt;span class="nv"&gt;$number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sr"&gt;&amp;lt;STDIN&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                        &lt;span class="c1"&gt;# input the number&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="bp"&gt;STDOUT&lt;/span&gt; &lt;span class="s"&gt;"The number is $number.\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# print the number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;STDIN是缺省输入，STDOUT是缺省输出。&lt;/p&gt;
&lt;p&gt;行读入操作符不会自动移除换行符需要使用chop移除它。通常可以这样做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;chop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sr"&gt;&amp;lt;STDIN&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;操作符&lt;/h2&gt;
&lt;h2&gt;控制结构&lt;/h2&gt;
&lt;h3 id="truede-ding-yi"&gt;True的定义&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;非""和非"0"的字符串为true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除0外的任何数字为true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何引用都为true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何未定义的值都为false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;正则表达式&lt;/h2&gt;
&lt;h2&gt;列表处理&lt;/h2&gt;
&lt;p&gt;Perl中有两个重要的环境，标量环境（处理单一的东西）和列表环境（处理复数的东西）。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="perl"></category></entry><entry><title>实现服务端功能之——Java实体对象</title><link href="/bus_java.html" rel="alternate"></link><published>2007-09-02T00:00:00+08:00</published><updated>2007-09-02T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-09-02:/bus_java.html</id><summary type="html">&lt;h1&gt;关于实体对象&lt;/h1&gt;
&lt;p&gt;实体对象包含了业务逻辑和对表的DML操作。&lt;/p&gt;
&lt;h2&gt;对象模型和关键类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.server.OAEntityCache：这个缓冲用于存储特殊实体的查询过的行。映射到同样的实体的多个视图对象共享相同的实体缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;yourentityname&gt;EOImpl继承oracle.apps.fnd.framework.server.OAEntityImpl：这是实体对象本身。当实例化后，它代表数据中的一行。&lt;/yourentityname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.server.OAEntityDefImpl：表示描述实体对象的元数据，包括属性（attributes）、事件、校验器、关联和属性（properties）。当实例化后，它描述了实体对象类的所有实例。实体定义类是一个单例类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;yourentityname&gt;Expert继承oracle.apps.fnd.framework.server.OAEntityExpert：这是一个特殊的单例辅助类，它用于注册一个实体。&lt;/yourentityname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.jbo.Key：这是一个不可变的主、外键或复合主键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;创建 …&lt;/h1&gt;</summary><content type="html">&lt;h1&gt;关于实体对象&lt;/h1&gt;
&lt;p&gt;实体对象包含了业务逻辑和对表的DML操作。&lt;/p&gt;
&lt;h2&gt;对象模型和关键类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.server.OAEntityCache：这个缓冲用于存储特殊实体的查询过的行。映射到同样的实体的多个视图对象共享相同的实体缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;yourentityname&gt;EOImpl继承oracle.apps.fnd.framework.server.OAEntityImpl：这是实体对象本身。当实例化后，它代表数据中的一行。&lt;/yourentityname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.server.OAEntityDefImpl：表示描述实体对象的元数据，包括属性（attributes）、事件、校验器、关联和属性（properties）。当实例化后，它描述了实体对象类的所有实例。实体定义类是一个单例类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;yourentityname&gt;Expert继承oracle.apps.fnd.framework.server.OAEntityExpert：这是一个特殊的单例辅助类，它用于注册一个实体。&lt;/yourentityname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.jbo.Key：这是一个不可变的主、外键或复合主键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;创建&lt;/h1&gt;
&lt;p&gt;为了创建实体对象，必须调用对应的上层视图对象中的createRow方法然后再调用insertRow方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// In the application module; this example from the OA Framework&lt;/span&gt;
&lt;span class="c1"&gt;// ToolBox Tutorial will instantiate a SupplierEOImpl.&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSuppliersVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;insertRow&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRow&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;

  &lt;span class="c1"&gt;// Always call this after you perform a row insert. See the Entity Object&lt;/span&gt;
  &lt;span class="c1"&gt;// New / Initial section below for additional information.&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setNewRowState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STATUS_INITIALIZED&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;视图对象的createRow方法调用下层实体对象的create()方法。可以在实体的create()方法中添加初始化代码，可以参考oracle.apps.fnd.framework.toolbox.tutorial.server.SupplierEOImpl类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 不要将初始化逻辑放到实体对象的构造器中；总是应该将这些代码添加到create()方法中super.create(attributeList)方法调用的后面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 如果默认值可以在设计时决定，并且是为特定的UI而决定的，也可以通过在设计器中设置item的Initial Value属性来指定默认值。这些值可以被用户个性化；而不需要创建实体你的对象的子类并覆盖create()方法来设置默认值。查看Defaulting章节查看细节信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * In the SupplierEOImpl class; initialize a new supplier.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="n"&gt;Public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AttributeList&lt;/span&gt; &lt;span class="n"&gt;attributeList&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;create&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attributeList&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
  &lt;span class="n"&gt;OADBTransaction&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// Supplier id is obtained from the table's sequence&lt;/span&gt;
  &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;supplierId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSequenceValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"FWK_TBX_SUPPLIERS_S"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;setSupplierId&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supplierId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// Start date should be set to sysdate&lt;/span&gt;
  &lt;span class="n"&gt;setStartDate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getCurrentDBDate&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end create()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 当在实体对象中设置值时，总是使用set&lt;attributename&gt;(val)代替setAttribute("&lt;attributename&gt;", val)方法可以提高性能，因为前者跳过了查找字段的步骤。如果需要忽略编程方式实现的属性校验而仍需要执行设计时定义的校验时，可以直接调用setAttributeInternal()。查看Entity Object and View Object Attribute Setters以获取更多信息。&lt;/attributename&gt;&lt;/attributename&gt;&lt;/p&gt;
&lt;h2&gt;复合实体关联&lt;/h2&gt;
&lt;p&gt;在复合关联中BC4J将在设置父对象主键属性值时自动设置子实体对象。父对象主键值是在调用create()方法时通过attributeList参数传递进去的，并且在super.create(attributeList)被执行时被设置值。&lt;/p&gt;
&lt;p&gt;不要尝试自己来处理主键值。&lt;/p&gt;
&lt;h2&gt;实体对象的Initial/New状态&lt;/h2&gt;
&lt;p&gt;缺省情况下，实体对象被创建时row状态为STATUS_NEW，并且BC4J将它们添加到它们的校验器中并且post监听。这时，任何事件触发校验或数据库提交sequence包括这些实体对象。（By default, entity objects are created with the     row state of STATUS_NEW, and BC4J adds them to its validation and post listener lists. In this case, any event that triggers a validation or database post sequence includes these entity objects.）&lt;/p&gt;
&lt;p&gt;如OA Framework Model Coding Standards中的规定，应该将通过显式的在视图对象中调用创建新行的方法后立即调用ViewRowImpl对象的setNewRowState(STATE_INITIALIZED)方法。&lt;/p&gt;
&lt;p&gt;当执行这个后，BC4J将从事务中和校验监听列表中移除对应的实体对象，这样它们将不会被校验或提交到数据库。当用户做出修改（属性的&amp;ldquo;setter&amp;rdquo;被调用后），实体对象的状态修改为STATUS_NEW，并且BC4J返回它到validation/post lists。你也可以在ViewRowImpl上调用setNewRowState(STATUS_NEW)在任何时候手工改变状态。&lt;/p&gt;
&lt;h2&gt;特殊&amp;ldquo;Create&amp;rdquo;的情况&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&amp;ldquo;Flattened&amp;rdquo;主／从处于单一行中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在OA Framework ToolBox教程中，我们有主／从实体显示于同一行中，&amp;ldquo;flattened&amp;rdquo;行中。比如采购单包含了很多行，它们依次包含了多个供货商，在我们的UI中，我们将采购单的行和供货单实现为1:1的关系。&lt;/p&gt;
&lt;p&gt;尽管BC4J可以很容易的为单个视图对象行创建多个不同类型的实体对象&amp;mdash;&amp;mdash;这些实体对象是不相关的或是平等的&amp;mdash;&amp;mdash;在一个对象是另一个对象子对象时需要你介入。在这种情况下，必须在你的视图对象行实现的create()方法中添加下面的代码，以确保正确的父对象的主键被设置到低层次的子对象的实体中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// The following is required to support the creating the master/detail line&lt;/span&gt;
&lt;span class="c1"&gt;// and shipment entities that have been "flattened" into a single row in&lt;/span&gt;
&lt;span class="c1"&gt;// POLineShipFullVO with a 1:1 join.&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// If you don't do this, BC4J will automatically treat them like peers and&lt;/span&gt;
&lt;span class="c1"&gt;// try to set the po header id as the parent key for both entities.&lt;/span&gt;

&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;jbo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;AttributeList&lt;/span&gt; &lt;span class="n"&gt;nvp&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt; &lt;span class="n"&gt;lineEO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;getEntity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
  &lt;span class="n"&gt;PurchaseOrderShipmentEOImpl&lt;/span&gt; &lt;span class="n"&gt;shipmentEO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PurchaseOrderShipmentEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;getEntity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;    

  &lt;span class="k"&gt;try&lt;/span&gt; 
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Create Lines EO &lt;/span&gt;
    &lt;span class="n"&gt;lineEO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;create&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nvp&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 

    &lt;span class="c1"&gt;// Create Shipments EO &lt;/span&gt;
    &lt;span class="n"&gt;shipmentEO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;create&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lineEO&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 

    &lt;span class="c1"&gt;// Calling this ensures that any personalization default values are&lt;/span&gt;
    &lt;span class="c1"&gt;// properly set since the OAF normally sets this in the super.create(), but&lt;/span&gt;
    &lt;span class="c1"&gt;// since this is not called in this workaround, we need another method&lt;/span&gt;
    &lt;span class="c1"&gt;// to ensure customer defaults are applied.&lt;/span&gt;
    &lt;span class="n"&gt;setDefaultValue&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; 
  &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;lineEO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;revert&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 
    &lt;span class="n"&gt;shipmentEO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;revert&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="k"&gt;instanceof&lt;/span&gt; &lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;jbo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;JboException&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
    &lt;span class="o"&gt;{&lt;/span&gt; 
      &lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;jbo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;JboException&lt;/span&gt; &lt;span class="n"&gt;jboEx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;jbo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;JboException&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 
      &lt;span class="c1"&gt;// Developers have to do the mapping on their own because of the override. &lt;/span&gt;
      &lt;span class="n"&gt;jboEx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;doEntityToVOMapping&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;jbo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ViewObject&lt;/span&gt;&lt;span class="o"&gt;[]{&lt;/span&gt;&lt;span class="n"&gt;getViewObject&lt;/span&gt;&lt;span class="o"&gt;()});&lt;/span&gt;    
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;jboEx&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 
    &lt;span class="o"&gt;}&lt;/span&gt; 
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;wrapperException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end create() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;实体对象缓存&lt;/h2&gt;
&lt;p&gt;一旦被创建后，BC4J将实体对象因为各种原因被存储于特殊的事务缓冲区中，在JDeveloper BC4J文档中有完整的描述。两个重要的好处在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;处理同一个根应用模块中的多个视图对象可以共享同样的下层实体对象。这意味着在一个视图对象中修改实体后将立即反映到其它引用该实体对象的视图对象中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据修改将被保留在缓冲区中即使视图对象的行集被刷新。比如，在主－从关系中，在 &lt;strong&gt;从&lt;/strong&gt; 视图对象中由实体对象派生的属性值被保存在缓存中，即使用户从一个 &lt;strong&gt;主&lt;/strong&gt; 视图对象转换到另一个。所有数据修改将原封不动的保存在事务生命中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;懂得这个缓冲区的存在是很重要的，因为你必须明确的执行某些验证，比如，当执行唯一性验证时你必须同时检查实体缓冲区和数据库。&lt;/p&gt;
&lt;p&gt;有三种主要方式同时检查缓冲区和数据库：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用findByPrimaryKey()方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手工迭代缓冲区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用关联对象迭代缓冲区&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;findByPrimaryKey()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;findByPrimaryKey()方法确保先查询缓冲区中与给定的主键相匹配的实体对象，然后查找数据库。这是一个非常用有的方法，但它并不是一个轻量的方法，因为它为从数据库中找到的记录实例化实体对象。它将 &lt;strong&gt;整个&lt;/strong&gt; 实体对象放入内存，而不只是主键。这个方法可以&amp;mdash;&amp;mdash;也应该&amp;mdash;&amp;mdash;被用于当你不需要查找一个匹配的情况&amp;mdash;&amp;mdash;比如，当验证一个基于序列的主键。它也适合用于需要在查找到的目标上调用方法以便中间层访问的情况。&lt;/p&gt;
&lt;p&gt;下面的代码来自于oracle.apps.fnd.framework.toolbox.schema.server.SupplierEOImpl类，描述了这个方法的使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setSupplierId&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Supplier id must be unique. To verify this, you must check both the&lt;/span&gt;
    &lt;span class="c1"&gt;// entity cache and the database. In this case, it's appropriate&lt;/span&gt;
    &lt;span class="c1"&gt;// to use findByPrimaryKey( ) because you're unlikely to get a match, and&lt;/span&gt;
    &lt;span class="c1"&gt;// and are therefore unlikely to pull a bunch of large objects into memory.&lt;/span&gt;

    &lt;span class="c1"&gt;// Note that findByPrimaryKey() is guaranteed to check all suppliers. &lt;/span&gt;
    &lt;span class="c1"&gt;// First it checks the entity cache, then it checks the database.&lt;/span&gt;

    &lt;span class="n"&gt;OADBTransaction&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;supplierKey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;EntityDefImpl&lt;/span&gt; &lt;span class="n"&gt;supplierDefinition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDefinitionObject&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt; &lt;span class="n"&gt;supplier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;supplierDefinition&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findByPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supplierKey&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supplier&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
             &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
             &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
             &lt;span class="s"&gt;"SupplierId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
             &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Bad attribute value&lt;/span&gt;
             &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message application short name&lt;/span&gt;
             &lt;span class="s"&gt;"FWK_TBX_T_SUP_ID_UNIQUE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name &lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;setAttributeInternal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUPPLIERID&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end setSupplierId()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;手工迭代缓冲区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过手工的方式检查实体缓冲区，以执行与findByPrimaryKey()相同的检查。然后再在另一步中执行对数据库的检查。这种方式的好处是可以避免不必要的实例对象（译：实体）。&lt;/p&gt;
&lt;p&gt;下面的例子也是来自于ToolBox教程中SupplierEOImpl类中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Since this value is marked as "mandatory," the BC4J Framework will take&lt;/span&gt;
  &lt;span class="c1"&gt;// care of ensuring that it's a non-null value. However, if it is null, we&lt;/span&gt;
  &lt;span class="c1"&gt;// don't want to proceed with any validation that could result in a NPE.&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;()))))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Verify that the name is unique. To do this, we must check both the entity&lt;/span&gt;
    &lt;span class="c1"&gt;// cache and the database. We begin with the entity cache.&lt;/span&gt;
    &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;collections&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Iterator&lt;/span&gt; &lt;span class="n"&gt;supplierIterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
      &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getAllEntityInstancesIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getDBTransaction&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;currentId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSupplierId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;supplierIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt; &lt;span class="n"&gt;cachedSupplier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;supplierIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;next&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

      &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;cachedName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cachedSupplier&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
      &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;cachedId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cachedSupplier&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSupplierId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

      &lt;span class="c1"&gt;// We found a match for the name we're trying to set, so throw an&lt;/span&gt;
      &lt;span class="c1"&gt;// exception. Note that we need to exclude this EO from our test.&lt;/span&gt;

      &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cachedName&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cachedName&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;    
        &lt;span class="n"&gt;cachedId&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                               &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                               &lt;span class="s"&gt;"Name"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                               &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                               &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                               &lt;span class="s"&gt;"FWK_TBX_T_SUP_DUP_NAME"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name &lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// Now we want to check the database for any occurrences of the supplier&lt;/span&gt;
    &lt;span class="c1"&gt;// name. The most efficient way to check this is with a validation view&lt;/span&gt;
    &lt;span class="c1"&gt;// object which we add to a special "Validation" application module.&lt;/span&gt;
    &lt;span class="n"&gt;OADBTransaction&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;vam&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// Look to see if the VAM has already been created in this transaction. If not,&lt;/span&gt;
    &lt;span class="c1"&gt;// create it.&lt;/span&gt;
    &lt;span class="n"&gt;vam&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAApplicationModule&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"supplierVAM"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vam&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt; 
      &lt;span class="n"&gt;vam&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAApplicationModule&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"supplierVAM"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
         &lt;span class="s"&gt;"oracle.apps.fnd.framework.toolbox.schema.server.SupplierVAM"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// Now, we use a lightweight "validation" view object to see if a supplier exists&lt;/span&gt;
    &lt;span class="c1"&gt;// with the given name.&lt;/span&gt;
    &lt;span class="n"&gt;SupplierNameVVOImpl&lt;/span&gt; &lt;span class="n"&gt;valNameVo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SupplierNameVVOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;vam&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"SupplierNameVVO"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;valNameVo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initQuery&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valNameVo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
            &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
            &lt;span class="s"&gt;"Name"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
            &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
            &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message application short name&lt;/span&gt;
            &lt;span class="s"&gt;"FWK_TBX_T_SUP_DUP_NAME"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;setAttributeInternal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end setName()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;关联对象迭代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这与findByPrimaryKey()类似，它保证同时检查实体缓冲区和数据库。它也将会将找到的实体对象加载到内存，这用于需要调用实体中方法时。与findByPrimaryKey()方法不同，它可以通过任何key查找任何类型的实体对象，这只用于与当前对象间通过关联对象相关联的实体对象。&lt;/p&gt;
&lt;p&gt;下面的代码描述了根复合实体对象使用关联对象查找它的所有子对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;checkLineExists&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="c1"&gt;// A purchase order header must have at least 1 associated line.&lt;/span&gt;
  &lt;span class="c1"&gt;// To check this, we first do a manual check of the entity cache&lt;/span&gt;
  &lt;span class="c1"&gt;// If we find a line for this header, we're done (note that the entity cache won't&lt;/span&gt;
  &lt;span class="c1"&gt;// include EOs that are DELETED or DEAD).&lt;/span&gt;

  &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;collections&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Iterator&lt;/span&gt; &lt;span class="n"&gt;fastIterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDefinitionObject&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getAllEntityInstancesIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getDBTransaction&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;

  &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;currentHeaderId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getHeaderId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;fastIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt; &lt;span class="n"&gt;cachedLine&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;fastIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;next&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;cachedHeaderId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cachedLine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHeaderId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// If we find a match, we're done. Don't forget to look ONLY for lines&lt;/span&gt;
    &lt;span class="c1"&gt;// for this header... The entity cache can include lines for other headers&lt;/span&gt;
    &lt;span class="c1"&gt;// also.&lt;/span&gt;

    &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;cachedHeaderId&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cachedHeaderId&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentHeaderId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;))&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// We haven't found any matches in the cache yet, so now we need to check&lt;/span&gt;
  &lt;span class="c1"&gt;// the database...    &lt;/span&gt;

  &lt;span class="c1"&gt;// In this example, we're illustrating the use of the association between the&lt;/span&gt;
  &lt;span class="c1"&gt;// header and its lines to iterate through all the shipments.  This will&lt;/span&gt;
  &lt;span class="c1"&gt;// check both the cache and the database, and will bring all the rows&lt;/span&gt;
  &lt;span class="c1"&gt;// into the middle tier.&lt;/span&gt;
  &lt;span class="c1"&gt;// Note that this looks only at lines for this&lt;/span&gt;
  &lt;span class="c1"&gt;// header so we don't need to filter our results, so it is convenient.&lt;/span&gt;
  &lt;span class="n"&gt;RowIterator&lt;/span&gt; &lt;span class="n"&gt;linesIterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPurchaseOrderLineEO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="n"&gt;linesIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;()))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OARowValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OARowValException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                &lt;span class="s"&gt;"FWK_TBX_T_PO_NO_LINES"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end checkLineExists()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;实体状态&lt;/h2&gt;
&lt;p&gt;每个实体对象都有一个相关的&amp;ldquo;实体状态&amp;rdquo;它描述了实体的状态与下层数据库和事务关联。可以调用getEntityState()检查实体的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; BC4J从实体缓冲区中自动移除任何状态为STATUS_DEAD的实体对象，因此你不需要在查找&amp;ldquo;好&amp;rdquo;的实体对象时关心手工排除这些对象的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;STATUS_NEW 实体对象在当前事务中是新的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATUS_DELETED 实体对象来自于数据库并且在当前事务中已经被删除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATUS_MODIFIED 实体对象来自于数据库并且已经被改变了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATUS_UNMODIFIED 实体对象来源于数据库并且没有被改变为，或者已经被改变过并且改变已经被提交&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATUS_DEAD 实体对象在当前事务中是新的并且已经被删除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATUS_INITIALIZED 实体对象牌&amp;ldquo;临时（temporary）&amp;rdquo;状态并且将不会被提交或校验&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;修改／校验&lt;/h1&gt;
&lt;p&gt;这节描述如何正确执行属性级和实体级的校验。&lt;/p&gt;
&lt;h2&gt;属性级校验&lt;/h2&gt;
&lt;p&gt;如&lt;a href="/build_view.html"&gt;实现视图&lt;/a&gt;一章中描述的，当向页面发起HTTP POST请求时修改的值时，OA Framework将这些值回写到下层的视图对象，再通过调用实体对象的setter方法将这些值写入下层的实体对象。&lt;/p&gt;
&lt;p&gt;因此每个属性的校验应该被添加到它的setter方法中（查看ToolBox的PurchaseOrderHeaderEOImpl的setHeaderId()方法，如下），调用实体对象的setter方法执行的是属性级的校验。&lt;/p&gt;
&lt;p&gt;如果显示的指定了校验（比如，你在JDeveloper Entity Object Wizard中指定一个属性在它被保存后不能被更新），这个校验是在setAttributeInternal()方法中执行的，你应该将它放在你自己的校验逻辑的后面执行。它也将在validateEntity()中执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Sets the PO Header Id.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Business Rules:&lt;/span&gt;
&lt;span class="cm"&gt; * Required; cannot be null.&lt;/span&gt;
&lt;span class="cm"&gt; * Cannot be updated on a committed row.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setHeaderId&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// BC4J validates that this can be updated only on a new line. This&lt;/span&gt;
  &lt;span class="c1"&gt;// adds the additional check of only allowing an update if the value&lt;/span&gt;
  &lt;span class="c1"&gt;// is null to prevent changes while the object is in memory.&lt;/span&gt;

  &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getHeaderId&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                 &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                                 &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                                 &lt;span class="s"&gt;"HeaderId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                                 &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                                 &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                 &lt;span class="s"&gt;"DEBUG -- need message name"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;OADBTransaction&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OADBTransaction&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// findByPrimaryKey() is guaranteed to first check the entity cache, then check&lt;/span&gt;
    &lt;span class="c1"&gt;// the database. This is an appropriate use of this method because finding a    &lt;/span&gt;
    &lt;span class="c1"&gt;// match would be the exception rather than the rule so we're not worried &lt;/span&gt;
    &lt;span class="c1"&gt;// about pulling entities into the middle tier.&lt;/span&gt;

    &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;headerKey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;EntityDefImpl&lt;/span&gt; &lt;span class="n"&gt;hdrDef&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PurchaseOrderHeaderEOImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDefinitionObject&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;PurchaseOrderHeaderEOImpl&lt;/span&gt; &lt;span class="n"&gt;hdrEO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PurchaseOrderHeaderEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;hdrDef&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findByPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;headerKey&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hdrEO&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                   &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                                   &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                                   &lt;span class="s"&gt;"HeaderId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                                   &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                                   &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                   &lt;span class="s"&gt;"FWK_TBX_T_PO_ID_UNIQUE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// Executes declarative validation, and finally sets the new value.&lt;/span&gt;
  &lt;span class="n"&gt;setAttributeInternal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HEADERID&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end setHeaderId()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;不同的&amp;ldquo;Set&amp;rdquo;方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有多种方法可以设置实体变量的值。在编码中，通常调用set&lt;attributename&gt;()和setAttributeInternal()。查看Entity Object and View Object Attribute Setters获取更多的信息。&lt;/attributename&gt;&lt;/p&gt;
&lt;h2&gt;交叉属性校验&lt;/h2&gt;
&lt;p&gt;任何与两个个或更多属性值相关的校验应该被包含在validateEntity()方法中；不要将交叉属性校验放在单个属性的setter方法中，因为属性值的设置可能是无序的。&lt;/p&gt;
&lt;h2&gt;实体校验&lt;/h2&gt;
&lt;p&gt;当OA Framework在HTTP POST处理周期中设置实体对象值时，它总会校验它接触到的视图对象的行，它依次在下层的实体对象（一个或多个）上调用validateEntity()方法。而且，entities are validated again prior to posting (up to 10 times in a composition).&lt;/p&gt;
&lt;p&gt;任何操作于行级的逻辑&amp;mdash;&amp;mdash;且对被重复调用不是非常敏感的校验&amp;mdash;&amp;mdash;应该被包含在validateEntity()方法中。&lt;/p&gt;
&lt;p&gt;下面的PurchaseOrderHeaderEOImpl代码描述了实体级的校验：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Performs entity-level validation including cross-attribute validation that&lt;/span&gt;
&lt;span class="cm"&gt; * is not appropriately performed in a single attribute setter.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;validateEntity&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;validateEntity&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// If our supplier value has changed, verify that the order is in an "IN_PROCESS"&lt;/span&gt;
  &lt;span class="c1"&gt;// or "REJECTED" state. Changes to the supplier in any other state are disallowed. &lt;/span&gt;
  &lt;span class="c1"&gt;// Note that these checks for supplier and site are both performed here&lt;/span&gt;
  &lt;span class="c1"&gt;// because they are doing cross-attribute validation.&lt;/span&gt;

  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getStatusCode&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(((&lt;/span&gt;&lt;span class="s"&gt;"APPROVED"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"COMPLETED"&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Start by getting the original value and comparing it to the current&lt;/span&gt;
    &lt;span class="c1"&gt;// value. Changes at this point are invalid.&lt;/span&gt;

    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;oldSupplierId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;getPostedAttribute&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUPPLIERID&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;currentSupplierId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSupplierId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oldSupplierId&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentSupplierId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                   &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                                   &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                                   &lt;span class="s"&gt;"SupplierId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                                   &lt;span class="n"&gt;currentSupplierId&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                                   &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                   &lt;span class="s"&gt;"FWK_TBX_T_PO_SUPPLIER_NOUPDATE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// If our supplier site has changed, verify that the order is in an "IN_PROCESS"&lt;/span&gt;
    &lt;span class="c1"&gt;// state. Changes to the supplier site in any other state are disallowed.&lt;/span&gt;

    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;oldSiteId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;getPostedAttribute&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUPPLIERSITEID&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;currentSiteId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSupplierSiteId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oldSiteId&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentSiteId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                  &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                                  &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                                  &lt;span class="s"&gt;"SupplierId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                                  &lt;span class="n"&gt;currentSiteId&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                                  &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                  &lt;span class="s"&gt;"FWK_TBX_T_PO_SUPSITE_NOUPDATE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; 

  &lt;span class="c1"&gt;// Verify that our supplier site is valid for the supplier and make sure it is&lt;/span&gt;
  &lt;span class="c1"&gt;// an active "Purchasing" site.&lt;/span&gt;

  &lt;span class="n"&gt;SupplierEntityExpert&lt;/span&gt; &lt;span class="n"&gt;supplierExpert&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSupplierEntityExpert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="n"&gt;supplierExpert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isSiteValidForPurchasing&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getSupplierId&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;getSupplierSiteId&lt;/span&gt;&lt;span class="o"&gt;())))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                 &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                                 &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                                 &lt;span class="s"&gt;"SupplierSiteId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                                 &lt;span class="n"&gt;getSupplierSiteId&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                                 &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                 &lt;span class="s"&gt;"FWK_TBX_T_PO_SUPSITE_INVALID"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end validateEntity();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;交叉实体校验&lt;/h2&gt;
&lt;p&gt;开发者经常认为他们需要实现&amp;ldquo;交叉实体（cross-entity）&amp;rdquo;校验，一个实体对象在校验中调用另一个的方法。在OA Framework中，&amp;ldquo;交叉实体校验&amp;rdquo;意味着某些非常特殊的东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实体A和实体B在执行validateEntity()方法时各自己引用对方（因为实体A需要从实体B获得一些属性，实体B需要从实体A获得一些属性）and...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;期望两个对象都是&amp;ldquo;脏（dirty）&amp;rdquo;对象（需要校验）在同一个事务中and...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个实体对象必须是有效的，以便引用它的对象获取属性值用于自己的校验。这样问题就来了：哪个实体应该先校验？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 对于复合关联的主／从实体对象这不是个问题，因为子对象将会先于父对象被校验，且BC4J Framework将校验复合层级结构向上10次的校验，从底部到顶部直到所有实体都是有效的。&lt;/p&gt;
&lt;p&gt;需要&amp;ldquo;交叉实体校验&amp;rdquo;的环境是非常少见的。如果你觉得需要，解决的办法是创建一个特殊的&amp;ldquo;调停者&amp;rdquo;对象实现BC4J的ValidationListener接口。简单来说，这个对象交叉实体中的哪个对象的校验先执行。&lt;/p&gt;
&lt;h2&gt;不妥当的校验失败处理&lt;/h2&gt;
&lt;p&gt;在实体级的校验方法（validateEntity()，set&lt;attributename&gt;()或其它）中调用Transaction.rollback()，Transaction.clearEntityCache()执行回滚或清除BC4J缓冲的操作。如果因为某些原因需要执行这些操作，你必须按下面的方法在 &lt;strong&gt;应用模块／事务级（application module/transaction level）&lt;/strong&gt; 捕获校验异常，并执行你需要的方法。比如，在应用模块级执行回滚是安全的；在实体级执行回滚或清理实体缓冲区却不是，并且可能导致不可预知的行为。&lt;/attributename&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bad&lt;/span&gt; &lt;span class="n"&gt;Code&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;---------&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;validateEntity&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="n"&gt;DBTransaction&lt;/span&gt; &lt;span class="n"&gt;txn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getDBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// Do not issue a rollback from within the EO.&lt;/span&gt;
  &lt;span class="n"&gt;txn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rollback&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(...);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Good&lt;/span&gt; &lt;span class="n"&gt;Code&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;----------&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;validateEntity&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(...);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// The following logic is written at the application-module level.&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;txn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Cache the exception thrown by the validation logic in the EO, &lt;/span&gt;
  &lt;span class="c1"&gt;// and perform the rollback.&lt;/span&gt;
  &lt;span class="n"&gt;txn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rollback&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;删除&lt;/h1&gt;
&lt;p&gt;为了删除实体对象，可以在对应的视图对象上调用remove()方法，如下面的应用模块中的代码所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Deletes a purchase order from the PoSimpleSummaryVO using the&lt;/span&gt;
&lt;span class="cm"&gt; * poHeaderId parameter.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Boolean&lt;/span&gt; &lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;poHeaderId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// First, we need to find the selected purchase order in our VO.&lt;/span&gt;
  &lt;span class="c1"&gt;// When we find it, we call remove( ) on the row which in turn&lt;/span&gt;
  &lt;span class="c1"&gt;// calls remove on the associated PurchaseOrderHeaderEOImpl object.&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;poToDelete&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;parseInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;poHeaderId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPoSimpleSummaryVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 
  &lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// This tells us the number of rows that have been fetched in the&lt;/span&gt;
  &lt;span class="c1"&gt;// row set, and will not pull additional rows in like some of the&lt;/span&gt;
  &lt;span class="c1"&gt;// other "get count" methods.&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getFetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;rowFound&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// We use a separate iterator -- even though we could step through the&lt;/span&gt;
  &lt;span class="c1"&gt;// rows without it -- because we don't want to affect row currency.&lt;/span&gt;
  &lt;span class="n"&gt;RowSetIterator&lt;/span&gt; &lt;span class="n"&gt;deleteIter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"deleteIter"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeStart&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
    &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt; 
    &lt;span class="o"&gt;{&lt;/span&gt; 
      &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRowAtRangeIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 

      &lt;span class="c1"&gt;// For performance reasons, we generate ViewRowImpls for all&lt;/span&gt;
      &lt;span class="c1"&gt;// View Objects. When we need to obtain an attribute value,&lt;/span&gt;
      &lt;span class="c1"&gt;// we use the named accessors instead of a generic String lookup.&lt;/span&gt;

      &lt;span class="c1"&gt;// Number primaryKey = (Number)row.getAttribute("HeaderId");&lt;/span&gt;
      &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;primaryKey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHeaderId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;primaryKey&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;poToDelete&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;rowFound&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;getTransaction&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// only one possible selected row in this case&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt; 
    &lt;span class="o"&gt;}&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt; 

  &lt;span class="c1"&gt;// Always close iterators.&lt;/span&gt;
  &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;closeRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rowFound&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end delete()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;校验和级联删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;row.remove()方法依次调用下层实体对象的remove()方法。为实现特殊的删除行为，比如，检查删除操作是否被允许，或实现级联删除，应该在实体的remove()方法中添加代码，如下所描述的TooBox中的PurchaseOrderHeaderEOImpl。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 由于Oracle Applications编码规范禁止使用数据库的级联删除功能。BC4J Framework需要我们手工为多层的purchase order业务对象实现自己的级联删除，每个实体对象在在执行super.remove()之前，先删除它自己的直接子对象。如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Marks all the lines for deletion, then mark the header for deletion.&lt;/span&gt;
&lt;span class="cm"&gt; * You can delete a purchase order only if it is "In Process" or "Rejected."&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getStatusCode&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="s"&gt;"IN_PROCESS"&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"REJECTED"&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="c1"&gt;// Note this is a good use of the header -&amp;gt; lines association since we&lt;/span&gt;
    &lt;span class="c1"&gt;// want to call remove( ) on each line.&lt;/span&gt;
    &lt;span class="n"&gt;RowIterator&lt;/span&gt; &lt;span class="n"&gt;linesIterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPurchaseOrderLineEO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;linesIterator&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

      &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;linesIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
      &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;linesIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;next&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; 
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Must be called last in this case.&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; 
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OARowValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OARowValException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                                &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                                &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                &lt;span class="s"&gt;"FWK_TBX_T_PO_NO_DELETE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end remove()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;锁&lt;/h1&gt;
&lt;p&gt;BC4J支持下面的锁技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;悲观锁 BC4J在执行setAttribute()方法时锁定实体对象对应的数据库行（在做出任何修改之前）。如果行已经被锁，BC4J将招聘一个AlreadyLockedException异常。这也是BC4J缺省的锁模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;乐观锁 BC4J在执行数据库post处理逻辑时锁定实体对象对应的数据库行。如果行已经被锁，BC4J将抛出AlreadyLockedException异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework默认使用乐观锁并且推荐使用，由于连接池使传统的悲观锁不能实行。但是对于基于Form的应用是使用悲观锁的。&lt;/p&gt;
&lt;p&gt;如果你需要悲观锁，你必须改变事务的行为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// In the application module...&lt;/span&gt;

&lt;span class="n"&gt;OADBTransaction&lt;/span&gt; &lt;span class="n"&gt;txn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;txn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setLockingMode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LOCK_PESSIMISTIC&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;过期数据侦测&lt;/h2&gt;
&lt;p&gt;当BC4J锁定一行时，它试着决定行对象是否被其它用户删除或修改，因为它是为当前用户而查询的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果行已经被删除了，BC4J抛出RowAlreadyDeletedException。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果行已经被修改，BC4J抛出RowInconsistentException。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为覆盖缺省的逐行比较的检测行为，可以在实体对象属性定义向导中使用属性级的Chage Indicator标志。如果某个属性的这个标志被选中，BC4J限制对这个属性的比较。Oracle Application PL/SQL API通常使用OBJECT_VERSION_NUMBER表列检查数据的改变，这列也可以影响实体对象。查看下面的Object Version Number Column。&lt;/p&gt;
&lt;h1&gt;提交&lt;/h1&gt;
&lt;p&gt;当准备提交实体对象的修改时，只要简单的从应用模块中调用getTransaction()Commit()。当调用这个方法时，你的对象被校验（如果需要），posted和committed。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;commit()方法调用oracle.apps.fnd.framework.OADBTransaction.validate()方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;validate()方法检查所有需要校验的根实体对象的&amp;ldquo;Validation Listener&amp;ldquo;。（在多个实体组成的复合对象，只有根实体对象被添加到Validation list）。校验完成后在commit前，它将不会存在于list中，因为当对象校验成功后，BC4J将会从validation list中移除它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 也可以调用OADBTransaction.validate()方法在任何地方强制进行校验。它执行相同的功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象位于validation list中，OADBTransaction validate()方法将调用实体的final viladate()方法，现依次调用validateEntity()执行你的校验逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在BC4J中对于list中各个实体的校验顺序是随机的。但是，在一个复合对象中，比如一个采购单有多个供货商。BC4J总是在校验父对象前校验子对象。BC4J只会将复合对象的根实体放入validation list中（子对象不会被包含进来）。当根实体对象调用super.validateEntity时，BC4J调用它的子对象的validate，直到遍历整个层级结构。由于这个原因，你应该在你的校验逻辑之前调用super.validateEntity以保证父对象在校验子对象后才校验自己。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;commit方法调用OADBTransaction postChanges方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;postChanges方法检查&amp;ldquo;Post Listener&amp;rdquo;获得实体对象中哪些数据需要被提交（posted）到数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于post list中的任何对象，OADBTransaction postChanges方法调用实体的postChanges方法。当对象被提交（posted），BC4J将它从post list中移除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有错误发生，数据库commit被发出，任何数据库锁被释放。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;回滚&lt;/h1&gt;
&lt;p&gt;OA Framework为post和commit动作实现了一个&amp;ldquo;all or nothing&amp;ldquo;的事务处理方式。不管错误是否严重，如果数据库post或commit失败，OA Framework：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发起JDBC rollback释放数据库锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这不会影响中间层的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;恢复视图行对象的状态以便于事务发起第二次尝试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这意味着你不需要显式的rollback失败的实体对象事务；OA Framework将在post或commit失败后自动显示出用户友好的错误信息。下面的例子描述了用户按下Apply按钮后commit和后来显示&amp;ldquo;Confirmation&amp;ldquo;对话框的情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// In the root application module&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;getTransaction&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="n"&gt;Commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; 

&lt;span class="c1"&gt;// In the controller&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processFormData&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// Handle the user pressing the "Apply" button&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Apply"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRootApplicationModule&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// No need for any special exception handling.  You can just display the&lt;/span&gt;
    &lt;span class="c1"&gt;// confirmation message because the OAF won't reach this code if the post/commit&lt;/span&gt;
    &lt;span class="c1"&gt;// fails.&lt;/span&gt;
    &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"apply"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;OAException&lt;/span&gt; &lt;span class="n"&gt;confirmMessage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
      &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_T_SUPPLIER_CREATE_CONF"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                       &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;CONFIRMATION&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putDialogMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;confirmMessage&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;回滚方法&lt;/h2&gt;
&lt;p&gt;手工清除中间层视图对象和实体对象缓冲，可以从应用模块中调用getTransaction().rollback()。这也将roll back任何数据库修改并清除任何缓存于事务中的值。查找Support the Browser Back Button了解这对于创建实体对象的作用。&lt;/p&gt;
&lt;p&gt;如果执行PL/SQL过程需要显式的roll back数据库而不影响中间层，可以在应用模块中调用getTransaction().executeCommand("rollback")。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如BC4J Native JDBC Statement Management中说过的。Transaction.rollback()会调用vo.clearCache()关闭相关的视图对象的JDBC结果集（游标）。比如，如果按下面的顺序执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;Transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rollback&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;next&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SQL异常&amp;ldquo;ORA-01002: fetch out of sequence&amp;rdquo;（这通常是由于在数据库中执行rollback使打开的cursors失效）将不会发生，因为Transaction.rollback()关闭了游标，强制vo.next()重新执行视图对象的查询并打开一个新的有效游标。&lt;/p&gt;
&lt;p&gt;当Transaction.rollback() roll back 数据库状态和中间层业务对象状态，下层直接JDBC调用并不会有意识的rollback任何中间层业务对象的状态，因此不要关闭JDBC游标。&lt;/p&gt;
&lt;p&gt;i. Transaction.executeCommand("rollback")调用或&lt;/p&gt;
&lt;p&gt;ii. BC4J的&amp;ldquo;rollback to savepoint&amp;rdquo;数据库调用是在Transaction.postChanges()或Transaction.commit()方法调用时validation或post出错时，由内部发出的的。尽管实体对象或视图对象中用户修改的数据仍然存在，实体的post state已经变回modified state以便用户可以再次发起post/commit。&lt;/p&gt;
&lt;p&gt;BC4J Framework不会补偿JDBC或数据库的rollback，无效的JDBC和数据库游标中的结果集（当数据库执行rollback调用后，游标被打开）。因此，如果你需要使用Transaction.executeCommand("rollback")，请先查看M52 model coding standards。&lt;/p&gt;
&lt;p&gt;如果需要覆盖post处理或EntityImpl中的beforeCommid，请先参考下节不当的Post处理。&lt;/p&gt;
&lt;h2&gt;不当的Post处理&lt;/h2&gt;
&lt;p&gt;在下面的情况下避免调用executeQuery()：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在视图对象的EntityImpl的post处理器方法（postChanges，beforePost，afterPost）中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在beforeCommit中并且随后试图在相同的视图对象中使用vo.next()，vo.first()等方法获取行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;未完成！！&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>OA Framework应用构建之——错误处理</title><link href="/build_error.html" rel="alternate"></link><published>2007-08-21T00:00:00+08:00</published><updated>2007-08-21T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-08-21:/build_error.html</id><summary type="html">&lt;h1&gt;异常类型&lt;/h1&gt;
&lt;p&gt;OA Framework处理三种基本类型的异常：通用、校验和严重。这些类型在这节中简单的描述；特殊异常的使用在下面介绍。&lt;/p&gt;
&lt;h2&gt;通用异常&lt;/h2&gt;
&lt;p&gt;BC4J框架中的错误是通过抛出类型为oracle.jbo.JBOException的隐式（runtime）异常。OA Framework中有自己的对应的版本为oracle.apps.fnd.framework.OAException。这个特殊化的版本提供了一种机制，可以将多个异常捆绑在一起，并使用Oracle应用消息字典（Oracle Applications Message Dictionary）翻译这些异常信息，以便显示出有用的信息。在任何代码中，通常可以抛出一个OAException类型的页面级别异常。&lt;/p&gt;
&lt;h2&gt;校验异常&lt;/h2&gt;
&lt;p&gt;校验异常是从实体对象和视图对象中抛出的，可以是由于属性级或行级的校验失败引起。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.OAAttrValException 特殊版本的OAException，用于属性级校验失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.OARowValException 特殊版本的OAException，用于行（row）（entity）级校验失败 …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;异常类型&lt;/h1&gt;
&lt;p&gt;OA Framework处理三种基本类型的异常：通用、校验和严重。这些类型在这节中简单的描述；特殊异常的使用在下面介绍。&lt;/p&gt;
&lt;h2&gt;通用异常&lt;/h2&gt;
&lt;p&gt;BC4J框架中的错误是通过抛出类型为oracle.jbo.JBOException的隐式（runtime）异常。OA Framework中有自己的对应的版本为oracle.apps.fnd.framework.OAException。这个特殊化的版本提供了一种机制，可以将多个异常捆绑在一起，并使用Oracle应用消息字典（Oracle Applications Message Dictionary）翻译这些异常信息，以便显示出有用的信息。在任何代码中，通常可以抛出一个OAException类型的页面级别异常。&lt;/p&gt;
&lt;h2&gt;校验异常&lt;/h2&gt;
&lt;p&gt;校验异常是从实体对象和视图对象中抛出的，可以是由于属性级或行级的校验失败引起。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.OAAttrValException 特殊版本的OAException，用于属性级校验失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.OARowValException 特殊版本的OAException，用于行（row）（entity）级校验失败。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OA Framework使用下面的方式显示错误信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;属性级异常将在错误项目（item）和页面顶部标示出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行级异常将在错误行（row）和页面顶部标示出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面级异常通常在页面顶部标示出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;严重异常&lt;/h2&gt;
&lt;p&gt;严重（severe）（或称为&amp;ldquo;毁灭（fatal）&amp;rdquo;）性的异常包括不希望出现的系统级的错误（比如NullPointerException）和所选的JBOException如：NoDefExcpetion。可以直接在代码中抛出严重异常。&lt;/p&gt;
&lt;p&gt;如果严重异常发生，用户将被定向到OAErrorPage（异常被渲染在页面的中间，页面是区域渲染的，页面显示了用户友好的错误信息，并包含了一个指向堆栈跟踪细节的链接）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这是一个未翻译过的信息客户可以在站点中修改。&lt;/p&gt;
&lt;h2&gt;Oracle工作流通知&lt;/h2&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>Python 编码规则</title><link href="/python-bian-ma-gui-ze.html" rel="alternate"></link><published>2007-06-19T00:00:00+08:00</published><updated>2007-06-19T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-06-19:/python-bian-ma-gui-ze.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;呆板的坚持使用一致性是傻得没边！(A Foolish Consistency is the Hobgoblin of Little Minds)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打破一条既定规则的两个好理由：
 a. 当应用这个规则是将导致代码可读性下降，即便对某人来说，他已经习惯于按这条规则来阅读代码了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b. 为了和周围的代码保持一致而打破规则（也许是历史原因）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码布局
 a. 缩进
使用Emacs的Python-mode的默认4个空格。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;永远不要混用制表符和空格，最流行的方式是采用空格，其次是使用制表符。混合空格和制表符的代码将被转换成空格。（Emacs中，选中整个缓冲区，按ESC-x去除制表符（untabilfy))。调用Python解释器时-t选项，可对混合制表符和空白的发出警告，-tt时警告将变成错误。&lt;/p&gt;
&lt;p&gt;b. 行
将行限制在79个字符，对顺序排放的大文本块或者注释推荐限制在72个字符。&lt;/p&gt;
&lt;p&gt;折叠长行的首选方法是使用Python支持的圆括号，方括号和花括号内的行延续。如果需要你可以在表达式周围增加一对额外的圆括号，但有时使用反斜杠看起来更好。&lt;/p&gt;
&lt;p&gt;c. 空行&lt;/p&gt;
&lt;p&gt;用两行空行分割顶层函数和类的定义，类内方法的定义使用单个行分割，额外的空行可被用于相关函数组成的群。在一组相关的单句中间可以省略空行。&lt;/p&gt;
&lt;p&gt;当空行用于分割方法的定义时，在'class'行和第一个方法定义之间也需要一个空行。&lt;/p&gt;
&lt;p&gt;在函数中使用空行时 …&lt;/p&gt;</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;呆板的坚持使用一致性是傻得没边！(A Foolish Consistency is the Hobgoblin of Little Minds)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打破一条既定规则的两个好理由：
 a. 当应用这个规则是将导致代码可读性下降，即便对某人来说，他已经习惯于按这条规则来阅读代码了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b. 为了和周围的代码保持一致而打破规则（也许是历史原因）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码布局
 a. 缩进
使用Emacs的Python-mode的默认4个空格。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;永远不要混用制表符和空格，最流行的方式是采用空格，其次是使用制表符。混合空格和制表符的代码将被转换成空格。（Emacs中，选中整个缓冲区，按ESC-x去除制表符（untabilfy))。调用Python解释器时-t选项，可对混合制表符和空白的发出警告，-tt时警告将变成错误。&lt;/p&gt;
&lt;p&gt;b. 行
将行限制在79个字符，对顺序排放的大文本块或者注释推荐限制在72个字符。&lt;/p&gt;
&lt;p&gt;折叠长行的首选方法是使用Python支持的圆括号，方括号和花括号内的行延续。如果需要你可以在表达式周围增加一对额外的圆括号，但有时使用反斜杠看起来更好。&lt;/p&gt;
&lt;p&gt;c. 空行&lt;/p&gt;
&lt;p&gt;用两行空行分割顶层函数和类的定义，类内方法的定义使用单个行分割，额外的空行可被用于相关函数组成的群。在一组相关的单句中间可以省略空行。&lt;/p&gt;
&lt;p&gt;当空行用于分割方法的定义时，在'class'行和第一个方法定义之间也需要一个空行。&lt;/p&gt;
&lt;p&gt;在函数中使用空行时，表示一个逻辑段落。&lt;/p&gt;
&lt;p&gt;Python接受Ctrl+L换页符作为空格，Emacs和一些打印工具视这个为分页符。因此可以在代码中用它来为相关代码片段分页。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编码
Python核心发布中的代码必须始终使用ASCII或Latin=1(ISO-8859-1).使用ASCII的文件不必有译码cookie(coding cookie)。Latin-1公当注释或文档字符串涉及作者名字需要Latin-1时才被使用；另外\x转义字符是在字符串中包含非ASCII数据的首选方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python 2.4以后内核支持Unicode。&lt;/p&gt;
&lt;p&gt;不论什么情况使用UTF-8吧！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导入
通常应该在单独的行中导入，例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;No&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="n"&gt;Yes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样也是可以的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;type&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;StringType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ListType&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Imports通常被放置在文件的顶部，仅在模块注释和文档字符串之后，在模块的全局变量和常量之前。Imports应该有顺序的成组放置：&lt;/p&gt;
&lt;p&gt;a. 标准库的导入&lt;/p&gt;
&lt;p&gt;b. 相关的主包的导入&lt;/p&gt;
&lt;p&gt;c. 特定应用的导入&lt;/p&gt;
&lt;p&gt;应该在每组导入之间放置一个空行&lt;/p&gt;
&lt;p&gt;对于内部包的导入是不推荐使用相对导入，所有的导入都应使用包的绝对路径&lt;/p&gt;
&lt;p&gt;从一个包含类的模块中导入类时，通常可以写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;MyClass&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;MyClass&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;foo.bar.YourClass&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;YourClass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这样写导致了本地名字冲突，就写成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;MyClass&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;foo.bar.YourClass&lt;/span&gt; &lt;span class="nn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;YourClass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即使用"MyClass.MyClass"和"foo.bar.YourClass.YourClass"&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空格
  Guido不喜欢在以下地方出现空格：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a. 紧挨着圆括号、方括号、花括号的&lt;/p&gt;
&lt;p&gt;b. 紧贴在逗号、分号、冒号前的&lt;/p&gt;
&lt;p&gt;c. 紧贴着函数调用的参数列表前开式括号的，如"spam (1)"要写成"spam(1)"&lt;/p&gt;
&lt;p&gt;d. 紧贴在索引或切片开始的开式括号前的&lt;/p&gt;
&lt;p&gt;e. 在赋值（或其它）运算符周围的用于和其它并排的一个以上的空格&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其它建议
 a. 始终在这些二元运算符两边放置一个空格：=,==,&amp;lt;,&amp;gt;,!=,&amp;lt;&amp;gt;,&amp;lt;=,&amp;gt;=,is,is not,in,not in布尔运算符and,or,not。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b. 按你的看法在算术运算符周围插入空格，始终保持二元运算符两边空格的致。&lt;/p&gt;
&lt;p&gt;c. 不要在用于指定关键字参数或默认参数值的"&lt;code&gt;=&lt;/code&gt;"周围使用空格。&lt;/p&gt;
&lt;p&gt;e. 不要将多条语句写在同一行上&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注释
 a. 同代码不一致的注释比没注释更差，当代码修改时，始终优先更新注释。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b. 注释应该是完整的句子。如果注释是一个句子或短语，首字母应该大写，除非是一个小写开头的标识符（永远不要修改标识符的大小写）。&lt;/p&gt;
&lt;p&gt;c. 如果注释很短，最好省略末尾的句号。注释块通常由一个或多个完整句子构成的段落组成。每个句子应该以句号结束。&lt;/p&gt;
&lt;p&gt;d. 应该在句末，句号后使用两个空格，以便Emacs的断行和填充工作能正常工作。"."给出了文档结构的提示&lt;/p&gt;
&lt;p&gt;e. 用英语书写时，断词和空格是可用的。&lt;/p&gt;
&lt;p&gt;f. 非英语国家的Python程序员，请使用英语写你的注释，除非你120%的确信，这些代码不会被不懂你语言的人阅读。&lt;/p&gt;
&lt;p&gt;g. 编写使用统一的文档化注释格式有得于良好习惯和团队建议！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;注释块
 a. 注释块通常应用于跟随着一些（或全部）代码并和这些代码有着相同的缩进层次。注释块中每行以#和一个空格开始。注释块中的段落以仅含单个#的行分割，注释块上下方最好有一空行包围（或上方两行下方一行，对一个新函数定义段的注释。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行内注释
一个行内注释是和语句在同一行的注释，行内注释应该谨慎使用。行内注释应该至少用两个空格和语句分开，它们应该以#和单个空格开始。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文档化
应该一直遵守编写好的文档字符串(docstring)的约定。
为所有公共模块、函数、类和方法编写文档字符串。文档字符串对非公开的方法不是必要的，但你应该有一个描述这个方法做什么的注释，这个注释应该在"def"这个行后&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多行文档字符串最后的""",应该单独成行。&lt;/p&gt;
&lt;p&gt;单行文档字符串最后的""",可以在同一行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;版本标记
例：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;__version__=="$Revision: 1.4$"
# $Source: E:/cvsroot/python_doc/pep8.txt,v$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个行应该包含在模块的文档字符串之后，所有代码之前，上下用一个空行分隔。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命名约定
应该避免的名字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;永远不要用字符'l'，'O'，或'I'作单字符的变量名。在某些字体中，这些字符不能与数字1和0分开，当然要使用'l'时，使用'L'代替它。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块名
模块应该是不含下划线的、 简短的、小写的名字。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为模块名被映射到文件名，有些文件系统大小写不敏感并且截短长名字，模块名被选为相当短是重要的。&lt;/p&gt;
&lt;p&gt;当一个用C或C++写的扩展模块有一个伴随的Python模块，这个Python模块提供了一个更高层的接口时，C/C++模块有一个前导下划线。&lt;/p&gt;
&lt;p&gt;Python包应该是不含下划线的、简短的、全小写的名字。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;类名
类名总是使用首字母大写单词串的约定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常名
如果模块对所有情况定义了单个异常，它通常被叫做"error"或"Error"。似乎内建（扩展）模块使用"error"，而Python模块通常用"Error"，趋势似乎是倾向于使用CapWords异常名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局变量名
让我们希望这些变量打算只被用于模块内部，这些约定与那些用于函数的约定差不多，被设计为可以通过"from M import *"来使用的那些模块，应该在那些不想被导入的全局变量（还有内部函数和类）前加一个下划线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数名
函数名应该为小写，可能用下划线风格单词可以增加可读性。mixedCase仅被允许用于这种风格已经占优势的上下文，以便保持向后兼容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法名称和实例变量
这段大体和函数相同，通常用小写，必要时使用下划线。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用一个前导下划线仅用于不打算作为类的公共接口的内部方法和实例变量。&lt;/p&gt;
&lt;p&gt;使用两个前导下划线以表示类私有的名字。通常双前导下划线应该只用来避免与类（可以为子类化所设计）中的属性发生名字冲突。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承的设计
始终要确定一个类中的方法和实例变量是否要被公开，通常，永远不要将数据变量公开，除非你本质上实现的只是记录，人们总是共喜欢给类提供一个函数的接口作为替换。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同样，确定你的属性是否应该为私有的，私有的与非私有的区别在于：前者永远不会被用在一个派生类中，而后者可能会。是的，你应该在大脑中就用继承设计好了你的类。&lt;/p&gt;
&lt;p&gt;私有属性必须有两个前置下划线，无后置下划线。&lt;/p&gt;
&lt;p&gt;非公有属性必须有一个前导下划线，无后置下划线。&lt;/p&gt;
&lt;p&gt;公共属性没有前导和后置下划线，除非它们与保留字冲突，在这种情况下，单个后置下划线比前置或混乱的拼写要好，例如：class_比klass好。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计建议&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同象None之类的单值进行比较，应该永远用：'is'或'is not'来做，当你本意是"if x is not None时，对写成"if x"要小心－－例如当你测试一下默认值为None的变量或参数是否被设置为其它值时，这个其它值也可能是一个在布尔上下文中为假的值！&lt;/p&gt;
&lt;p&gt;基于类的异常总是好过基于字符串的异常，模块和包应该定义它们自己的域内特定的基异常类（base exception class），基类应该是内建的Exception类的子类，还始终包含一个类的的文档字符串，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;MessageError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="s2"&gt;"""Base class for errors in the email package."""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用字符串方法代替字符串模块，除非必须向后兼容Python2.0以前的版本。字符串方法总是非常快，而且和unicode字符串共用同样的API。&lt;/p&gt;
&lt;p&gt;在检查前缀和后缀时避免对字符串进行切片。&lt;/p&gt;
&lt;p&gt;用startswith()和endswith()代替，因为它们是明确的并且错误更少，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;No&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;Yes&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startswith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="o"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例外是如果你的代码必须工作在Python1.5.2以前。&lt;/p&gt;
&lt;p&gt;对象类型的比较应该始终用isinstance()代替直接比较类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;No&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;):&lt;/span&gt;
&lt;span class="n"&gt;Yes&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;isinstance&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查一个对象是否是字符串时，谨记它也可能是unicode字符串！在Python2.3，str和unicode有公共的基类，basestring，所以你可以这样做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if isinstance(obj,basestring)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python2.2类型模块为此定义了StringType类型。&lt;/p&gt;
&lt;p&gt;对序列，（字符串（strings)，列表(lists)，元组(tuple)）使用空列表是false这个事实，因此"if not seq"或"if seq"比"if len(seq)"或"if not len(seq)"好。&lt;/p&gt;
&lt;p&gt;书写字符串文字时不要依赖于有意义的的后置空格，这种后置空格在视觉上是不可辩别的，并且有些编辑器会把它们修整掉。&lt;/p&gt;
&lt;p&gt;不要用==来比较布尔型的值以确定是True或False。 &lt;/p&gt;</content><category term="python"></category></entry></feed>