<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jamsa的笔记 - 效率</title><link href="/" rel="alternate"></link><link href="/feeds/xiao-lu.atom.xml" rel="self"></link><id>/</id><updated>2010-12-07T00:00:00+08:00</updated><entry><title>Writing GNU Emacs Extensions笔记</title><link href="/writing-gnu-emacs-extensionsbi-ji.html" rel="alternate"></link><published>2010-12-07T00:00:00+08:00</published><updated>2010-12-07T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-12-07:/writing-gnu-emacs-extensionsbi-ji.html</id><summary type="html">&lt;h1&gt;定制Emacs&lt;/h1&gt;
&lt;h2&gt;全局按键绑定&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="nv"&gt;keysequence&lt;/span&gt; &lt;span class="nv"&gt;command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;keysequence 中普通字符按键直接用相应的字符表示。&lt;code&gt;\&lt;/code&gt;应该被写作&lt;code&gt;\\&lt;/code&gt;。特殊字符如META-问号应该写作&lt;code&gt;\M-?&lt;/code&gt;。CONTROL-x应该写作&lt;code&gt;\C-x&lt;/code&gt; CONTROL META-x写作&lt;code&gt;\C-\M-x&lt;/code&gt;。CONTROL-x在文档中也被缩写为&lt;code&gt;^x&lt;/code&gt;，相应的应该表示为&lt;code&gt;\^x&lt;/code&gt;。&lt;code&gt;\M-?&lt;/code&gt;也可以表示为&lt;code&gt;\e?&lt;/code&gt;字符串&lt;code&gt;\e&lt;/code&gt;是转义字符。&lt;/p&gt;
&lt;h2&gt;查询按键绑定&lt;/h2&gt;
&lt;p&gt;C-h b命令来查询按键绑定信息，这个命令被绑定到了describe-bindings。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\M-?"&lt;/span&gt; &lt;span class="ss"&gt;'help-command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;对Lisp表达式求值的方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将表达式放到文件中然后load这个一拥而入。M-x load-file RET rebind.el RET。&lt;/li&gt;
&lt;li&gt;使用eval-last-sexp，它被绑定到C-x C-e。&lt;/li&gt;
&lt;li&gt;使用eval-express，它被绑定到&lt;code&gt;M-:&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;*scratch*&lt;/code&gt;缓冲构 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;定制Emacs&lt;/h1&gt;
&lt;h2&gt;全局按键绑定&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="nv"&gt;keysequence&lt;/span&gt; &lt;span class="nv"&gt;command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;keysequence 中普通字符按键直接用相应的字符表示。&lt;code&gt;\&lt;/code&gt;应该被写作&lt;code&gt;\\&lt;/code&gt;。特殊字符如META-问号应该写作&lt;code&gt;\M-?&lt;/code&gt;。CONTROL-x应该写作&lt;code&gt;\C-x&lt;/code&gt; CONTROL META-x写作&lt;code&gt;\C-\M-x&lt;/code&gt;。CONTROL-x在文档中也被缩写为&lt;code&gt;^x&lt;/code&gt;，相应的应该表示为&lt;code&gt;\^x&lt;/code&gt;。&lt;code&gt;\M-?&lt;/code&gt;也可以表示为&lt;code&gt;\e?&lt;/code&gt;字符串&lt;code&gt;\e&lt;/code&gt;是转义字符。&lt;/p&gt;
&lt;h2&gt;查询按键绑定&lt;/h2&gt;
&lt;p&gt;C-h b命令来查询按键绑定信息，这个命令被绑定到了describe-bindings。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\M-?"&lt;/span&gt; &lt;span class="ss"&gt;'help-command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;对Lisp表达式求值的方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将表达式放到文件中然后load这个一拥而入。M-x load-file RET rebind.el RET。&lt;/li&gt;
&lt;li&gt;使用eval-last-sexp，它被绑定到C-x C-e。&lt;/li&gt;
&lt;li&gt;使用eval-express，它被绑定到&lt;code&gt;M-:&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;*scratch*&lt;/code&gt;缓冲构。在这个缓冲区处于Lisp Interaction模式。这个模式下，按C-j将调用eval-print-last-sexp，它与eval-lastsexp类似，但是它会将执行的结果插到光标位置。Lisp Interaction模式下的另一个作用是按M-TAB将能自动完成Lisp符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Apropos&lt;/h2&gt;
&lt;p&gt;使用apropos来查找命令。
&lt;example&gt;
M-x apropos RET delete RET
&lt;/example&gt;
查找符合"delete"的Emacs变量和函数。&lt;/p&gt;
&lt;p&gt;可以给apropos传递前缀参数。在Emacs中，在执行一个命令前按C-u可以向命令传递特殊信息。C-u通常跟数字参数；例如，C-u 5 C-b表示将光标向左移动5个字符。有些情况下，这个额外信息只是表明你按过了C-u。当调用apropos时使用了前缀参数时，它不光会报告匹配到的函数和变量，还会报告每个命令所使用的按键绑定。&lt;/p&gt;
&lt;p&gt;当知道要搜索的目标是Emacs命令时，可以直接使用command-apropos（M-? a）代替apropos。命令和函数的区别在于命令可以交互的执行。&lt;/p&gt;
&lt;h2&gt;想法&lt;/h2&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;h1&gt;简单的新命令&lt;/h1&gt;</content><category term="emacs"></category></entry><entry><title>Learn VI 笔记</title><link href="/learn-vi-bi-ji.html" rel="alternate"></link><published>2010-09-29T00:00:00+08:00</published><updated>2010-09-29T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-09-29:/learn-vi-bi-ji.html</id><summary type="html">&lt;h1&gt;VI编辑器&lt;/h1&gt;
&lt;p&gt;vi默认模式为命令模式&lt;/p&gt;
&lt;p&gt;基本编辑命令都是1到2个字母，如i和cw（change word）&lt;/p&gt;
&lt;p&gt;命令特点：
 - 命令大小写敏感
 - 输入的时候没有回显
 - 不需要回车&lt;/p&gt;
&lt;p&gt;也有一些命令有回显如/、:和?等。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h2&gt;打开关闭文件&lt;/h2&gt;
&lt;p&gt;在命令行上指定路径和文件名。&lt;/p&gt;
&lt;p&gt;使用vi时可能会出现一些问题如：
 - 终端类型引起的问题
 - 文件已经存在
 - 处理ex line-editing模式
 - 文件只读的提示
 - 不能编辑的文件（目录、非ascii、可执行文件等等）&lt;/p&gt;
&lt;p&gt;遇到这些问题时可以用:quit!强制退出。&lt;/p&gt;
&lt;p&gt;:w命令保存文件，:wq、ZZ保存并退出。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h2&gt;不保存而退出&lt;/h2&gt;
&lt;p&gt;:e!放弃自打开文件以来所做的编辑操作。&lt;/p&gt;
&lt;p&gt;:q!不保存而强制退出。&lt;/p&gt;
&lt;p&gt;保存文件可能遇到：
 - 文件已经存在。可以用:w!强制覆盖文件，或:w newfile写入其它文件。
 - 没有权限写文件。同上用 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;VI编辑器&lt;/h1&gt;
&lt;p&gt;vi默认模式为命令模式&lt;/p&gt;
&lt;p&gt;基本编辑命令都是1到2个字母，如i和cw（change word）&lt;/p&gt;
&lt;p&gt;命令特点：
 - 命令大小写敏感
 - 输入的时候没有回显
 - 不需要回车&lt;/p&gt;
&lt;p&gt;也有一些命令有回显如/、:和?等。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h2&gt;打开关闭文件&lt;/h2&gt;
&lt;p&gt;在命令行上指定路径和文件名。&lt;/p&gt;
&lt;p&gt;使用vi时可能会出现一些问题如：
 - 终端类型引起的问题
 - 文件已经存在
 - 处理ex line-editing模式
 - 文件只读的提示
 - 不能编辑的文件（目录、非ascii、可执行文件等等）&lt;/p&gt;
&lt;p&gt;遇到这些问题时可以用:quit!强制退出。&lt;/p&gt;
&lt;p&gt;:w命令保存文件，:wq、ZZ保存并退出。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h2&gt;不保存而退出&lt;/h2&gt;
&lt;p&gt;:e!放弃自打开文件以来所做的编辑操作。&lt;/p&gt;
&lt;p&gt;:q!不保存而强制退出。&lt;/p&gt;
&lt;p&gt;保存文件可能遇到：
 - 文件已经存在。可以用:w!强制覆盖文件，或:w newfile写入其它文件。
 - 没有权限写文件。同上用:w newfile。
 - 文件系统满了。用:!rm junkfile删除不需要的文件腾出空间。:!df查看硬盘空间。
 - 临时文件系统满了。
 - 硬盘空间限制达到上限。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h1&gt;简单编辑&lt;/h1&gt;
&lt;h2&gt;vi命令&lt;/h2&gt;
&lt;p&gt;vi有两个模式：命令模式和插入模式。进入时默认为命令模式。按ESC一到二次可退回命令模式。&lt;/p&gt;
&lt;h2&gt;移动光标&lt;/h2&gt;
&lt;p&gt;命令模式下h j k l分别代表左、下、上和右。&lt;/p&gt;
&lt;p&gt;移动前可以加数字参数比如4l代表按4次l。&lt;/p&gt;
&lt;p&gt;通过:set wm=10这样的选项可以让vi在距右边10个字符时自动插入换行符。&lt;/p&gt;
&lt;p&gt;行内移动：0移到行首，$移到行末。&lt;/p&gt;
&lt;p&gt;:set nu显示行号。&lt;/p&gt;
&lt;p&gt;块移动：w和W向前移动一个单词，b和B向后移动一个单词。两组的区别在于移动时大写的命令将包含标点。块移动命令也可以带数字参数。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h2&gt;简单编辑指令&lt;/h2&gt;
&lt;p&gt;a追加，c修改，d删除。&lt;/p&gt;</content><category term="vi"></category><category term="vim"></category></entry><entry><title>Emacs Lisp参考手册</title><link href="/emacs-lispcan-kao-shou-ce.html" rel="alternate"></link><published>2009-12-31T00:00:00+08:00</published><updated>2009-12-31T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2009-12-31:/emacs-lispcan-kao-shou-ce.html</id><summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;介绍和约定&lt;/p&gt;
&lt;p&gt;这是2.9版的GNU Emacs Lisp参考手册，适应于GNU Emacs 22.1。&lt;/p&gt;
&lt;h2&gt;警告&lt;/h2&gt;
&lt;h2&gt;Lisp历史&lt;/h2&gt;
&lt;h2&gt;习惯约定&lt;/h2&gt;
&lt;p&gt;这节说明了手册中的符号约定。&lt;/p&gt;
&lt;h3 id="yi-xie-zhu-yu"&gt;一些术语&lt;/h3&gt;
&lt;p&gt;整个手册中，词Lisp阅读器（the Lisp reader）&amp;ldquo;和&amp;ldquo;Lisp打印机（the Lisp printer）&amp;rdquo;指那些Lisp例程包括将文本方式描述的Lisp对象转换为真实的Lisp对象，反之亦然。&amp;ldquo;你&amp;rdquo;，指阅读本手册的你，即&amp;ldquo;程序员&amp;rdquo;。&amp;ldquo;用户&amp;rdquo;指使用Lisp程序的人，包括你写的那些程序。&lt;/p&gt;
&lt;p&gt;Lisp代码被格式化为：(list 1 2 3)。函数中不合法的变量或参数将被显示为斜体： &lt;strong&gt;&lt;em&gt;first-number&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id="nilhe-t"&gt;nil和t&lt;/h3&gt;
&lt;p&gt;Lisp中符号nil有三种含义：它是一个名为&amp;lsquo;nil&amp;lsquo;的符号；它是逻辑值false；它是空的list&amp;mdash;&amp;mdash;有零个元素的list。当作为变量时 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;介绍和约定&lt;/p&gt;
&lt;p&gt;这是2.9版的GNU Emacs Lisp参考手册，适应于GNU Emacs 22.1。&lt;/p&gt;
&lt;h2&gt;警告&lt;/h2&gt;
&lt;h2&gt;Lisp历史&lt;/h2&gt;
&lt;h2&gt;习惯约定&lt;/h2&gt;
&lt;p&gt;这节说明了手册中的符号约定。&lt;/p&gt;
&lt;h3 id="yi-xie-zhu-yu"&gt;一些术语&lt;/h3&gt;
&lt;p&gt;整个手册中，词Lisp阅读器（the Lisp reader）&amp;ldquo;和&amp;ldquo;Lisp打印机（the Lisp printer）&amp;rdquo;指那些Lisp例程包括将文本方式描述的Lisp对象转换为真实的Lisp对象，反之亦然。&amp;ldquo;你&amp;rdquo;，指阅读本手册的你，即&amp;ldquo;程序员&amp;rdquo;。&amp;ldquo;用户&amp;rdquo;指使用Lisp程序的人，包括你写的那些程序。&lt;/p&gt;
&lt;p&gt;Lisp代码被格式化为：(list 1 2 3)。函数中不合法的变量或参数将被显示为斜体： &lt;strong&gt;&lt;em&gt;first-number&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id="nilhe-t"&gt;nil和t&lt;/h3&gt;
&lt;p&gt;Lisp中符号nil有三种含义：它是一个名为&amp;lsquo;nil&amp;lsquo;的符号；它是逻辑值false；它是空的list&amp;mdash;&amp;mdash;有零个元素的list。当作为变量时，nil一直表示nil值。&lt;/p&gt;
&lt;p&gt;对于Lisp阅读器来说&amp;lsquo;()&amp;rsquo;和&amp;lsquo;nil&amp;rsquo;是同等的：他们代表相同的对象，符号nil。这个符号的两种不同的写法只是对于用户阅读不同。对于Lisp阅读器来说读取&amp;lsquo;()&amp;rsquo;或&amp;lsquo;nil&amp;rsquo;之后是无法知道程序员编写的代码时的实际写法。&lt;/p&gt;
&lt;p&gt;在本手册中，当我们要强调是空的list时我们写作()，当写为nil时表示我们要强调它表示 &lt;strong&gt;false&lt;/strong&gt;。这也是Lisp程序中一个很好的约定。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;con&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;                   &lt;span class="c1"&gt;; 强调为空的list&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;foo-flag&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;             &lt;span class="c1"&gt;; 强调为false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在希望得到true时，任何非nil值都将被作为 &lt;strong&gt;true&lt;/strong&gt;。但是，用t是表示true的首选方式。当你需要用一个值描述true时，在没有其它较好选择时就使用t。符号t的值总是t。&lt;/p&gt;
&lt;p&gt;在Emacs Lisp中，nil和t是特殊的符号，它们的值总是他们自己。这也是为什么在程序中你不需要使用引号把它们作为常量的原因。试图改变他们的值时将导致setting-constant错误。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;booleanp&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果object是两个布尔值（t或nil）中的一个则返回非nil值。&lt;/p&gt;
&lt;h3 id="qiu-zhi-de-biao-shi-fang-fa"&gt;求值的表示方法&lt;/h3&gt;
&lt;p&gt;可求值的Lisp表达式被称为form。对一个form求值总会生成一个结果，它是一个lisp对象。本手册中的例子中，使用&amp;lsquo;=&amp;gt;&amp;rsquo;标识求值的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以把这读作&amp;ldquo;(car '(1 2))的值为1。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;当form是一个宏调用时，它将被展开为一个新的form被Lisp求值。我们使用&amp;lsquo;==&amp;gt;&amp;rsquo;标识展开的结果。我们将有可能不显示展开的form的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;third&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;==&amp;gt; (car (cdr (cdr '(a b c))))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时为了帮助描述一个form与另一个form产生同样的值。将使用等价符号。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-sparse-keymap&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="ss"&gt;'keymap&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="da-yin-de-biao-shi-fang-fa"&gt;打印的表示方法&lt;/h3&gt;
&lt;p&gt;本手册中的许多例子在被求值时将打印文本。如果你在Lisp交互缓冲区（比如&amp;lsquo;&lt;em&gt;scratch&lt;/em&gt;&amp;rsquo;）中执行示例，打印的文本被插入到缓冲区中。如果你通过其它方法执行例子（比如使用函数eval-region求值），打印的文本将显示在回显区（echo area）。&lt;/p&gt;
&lt;p&gt;本手册中的例子使用&amp;lsquo;-|&amp;lsquo;标识打印的文本，而不关心文本被输出到哪里。对form求值的结果显示在单独的一行上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;prinl&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;princ&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;prinl&lt;/span&gt; &lt;span class="ss"&gt;'bar&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;-| foo&lt;/span&gt;
     &lt;span class="c1"&gt;;-| bar&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="cuo-wu-xin-xi"&gt;错误信息&lt;/h3&gt;
&lt;p&gt;有些例子将产生错误。通常错误信息显示在回显区域。我们将错误信息显示在以&amp;lsquo;error--&amp;gt;&amp;rsquo;开头的行上。注意&amp;lsquo;error--&amp;gt;&amp;rsquo;自身并不会显示在回显区。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(+ 23 'x)
error--&amp;gt; Wrong type argument: number-or-marker-p, x
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="huan-chong-qu-wen-ben-fu-zhu"&gt;缓冲区文本附注&lt;/h3&gt;
&lt;p&gt;有些例子可能会修改缓冲区的内容，本手册将使用&amp;ldquo;before&amp;rdquo;和&amp;ldquo;after&amp;rdquo;标识文本的版本。这些例子将缓冲区的内容显示在包含缓冲区名称的短划线之间。另外，将使用&amp;lsquo;-|-&amp;rsquo;标识point的位置。（这个符号当然也不是缓冲区中文本的一部分；它标明当前point的位置。）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     ---------- Buffer: foo ----------
     This is the -!-contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          =&amp;gt; nil
     ---------- Buffer: foo ----------
     This is the changed -!-contents of foo.
     ---------- Buffer: foo ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="miao-shu-de-ge-shi"&gt;描述的格式&lt;/h3&gt;
&lt;p&gt;函数、变量、宏、命令、用户属性和特殊的form的描述在手册中都有统一的格式。描述的第一行包括项的名称和它的参数（如果有）。项类型可以是函数，变量或其它内容&amp;mdash;&amp;mdash;显示在行的开头位置。项的描述显示在余下的行中，有时带有示例。&lt;/p&gt;
&lt;h4 id="yi-ge-jian-dan-de-han-shu-de-miao-shu"&gt;一个简单的函数的描述&lt;/h4&gt;
&lt;p&gt;在函数描述中，函数名称最先显示。在同一行上跟着参数名的列表。这些名称将用于在描述体中使用，代表参数的值。&lt;/p&gt;
&lt;p&gt;参数列表中的关键字&amp;amp;optional标明subsequent参数可以被忽略（被忽略的参数默认为nil）。在调用函数时不要写&amp;amp;optional。&lt;/p&gt;
&lt;p&gt;关键字&amp;amp;rest（它必须出现在单个变量的后面）标明后面可以带任意数量的参数。单一参数名后的&amp;amp;rest将被接收，它的值将作为其它参数传递给函数。在调用函数时不要写&amp;amp;rest。&lt;/p&gt;
&lt;p&gt;下面是一个虚拟的函数foo的描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;foo&lt;/code&gt; integer1 &amp;amp;optional integer2 &amp;amp;rest integers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数foo将从integer2中减integer1，然后加上其它参数。如果integer2不存在，则将使用19作为默认值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 16&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 14&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更通俗的表达方式，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo w x y...)
==
(+ (- x w) y...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;任何参数名包含类型描述（例如，integer，integer1或buffer）表示它需要那种类型的值。复数形式（比如buffers）通常表示包含那一类型的list对象。参数名为object表示可以为任何类型。参数名有其它名称的（比如，new-file）将在函数的描述中论述。在有些情况下，多个具有类似功能的函数的通用参数将在开始的位置进行描述。&lt;/p&gt;
&lt;p&gt;参见Lambda表达式，详细了解optional和rest参数。&lt;/p&gt;
&lt;p&gt;命令，宏和特殊form的描述具有相同的格式，只是将&amp;lsquo;Function&amp;rsquo;分别替换为&amp;rsquo;Command&amp;lsquo;，&amp;lsquo;Macro&amp;rsquo;或&amp;lsquo;Special Form&amp;rsquo;。命令与函数相比只是可以交互式的被调用；宏处理参数的方式与函数不同（参数不会被求值），但可以以相同的方式描述。&lt;/p&gt;
&lt;p&gt;特殊form的描述使用了更复杂的标记方法来指定optional和repeated参数，因为它们可以以更复杂的方式将参数列表分解为独立的参数。&amp;lsquo;[optional-arg]&amp;lsquo;表示optional-arg是可选的，&amp;lsquo;repeated-args...&amp;rsquo;表示零个或多个参数。圆括号用于将多个参数分组到辅助的list结构。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Special Form: &lt;strong&gt;count-loop&lt;/strong&gt; (var [from to [inc]]) body...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个虚拟的特殊form实现了循环执行body form然后在每次迭代时将变量var自增。在第一次迭代时，变量的值为from的值；在后面的迭代中，它每次加1（或增加由inc指定的值）。如果var等于to则这个循环在执行body之前退出。下面是使用它的一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;printl&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;princ&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;ptinl&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;aref&lt;/span&gt; &lt;span class="nf"&gt;vector&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;terpri&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果from和to被忽略，var将在循环开始时被设置为nil，如果在迭代开始时var是非nil值则循环退出。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;done&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pending&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fixit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;done&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个特殊的form中，参数from和to是可选的，但必须同时存在或不存在。如果都存在，inc是可选的。这些变量被参数var分组到一个list中，为了将他们区别于body，它将包括form中的其它元素。&lt;/p&gt;
&lt;h4 id="yi-ge-jian-dan-de-bian-liang-de-miao-shu"&gt;一个简单的变量的描述&lt;/h4&gt;
&lt;p&gt;变量是可以保存值的对象的名字。尽管几乎所有变量都可以被用户设置，某些变量将明确用户可以修改它们；它们被称为用户选项（user options）。变通变量和用户选项的描述格式与函数是相同的只是它们没有参数。&lt;/p&gt;
&lt;p&gt;下面是一个虚拟的变量electric-future-map。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;electric-future-map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变量的值是用于Electric Command Future mode的keymap。这个map中的函数允许你编辑还没有想过执行的命令。&lt;/p&gt;
&lt;p&gt;用户选项的描述具有相同的格式，只是将&amp;lsquo;Variable&amp;lsquo;替换为&amp;rsquo;User Option&amp;lsquo;。&lt;/p&gt;
&lt;h2&gt;版本信息&lt;/h2&gt;
&lt;p&gt;下面的设施提供了当前使用的Emacs的版本信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command: &lt;code&gt;emacs-version&lt;/code&gt; &amp;amp;optional here&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数返回一个字符串描述当前运行的Emacs的版本信息。报告bug时将它包含进去非常有用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;emacs-version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="c1"&gt;;=&amp;gt; "GNU Emacs 20.3.5 (i486-pc-linux-gnulibc1, X toolkit) of Sat Feb 14 1998 on psilocin.gnu.org"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果here是非nil值，它将在缓冲区的point的前面插入文本，并返回nil。交互式调用时，函数将在回显区显示相同的信息，但需要通过前缀参数使用here为非nil值（译注：M-2 M-x emacs-version）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;emacs-build-time&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值标明Emacs是在当前站点何时构建的。它是一个包含三个整数的list，类似current-time的值（参见Time of Day）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;emacs-build-time&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (13623 62065 344633)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;emacs-version&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值是当前运行的Emacs的版本。它是一个类似&amp;ldquo;20.3.1&amp;rdquo;的字符串。字符串的最后一个数字并不真是Emacs release 版本的版本号的一部分；它将在你每次构建时自动加一。由四个数字组成的类似&amp;ldquo;20.3.9.1&amp;rdquo;的值，表明是一个unrelease的test版本。&lt;/p&gt;
&lt;p&gt;下面两个变量从Emacs 19.23版开始存在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;emacs-major-version&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Emacs的主版本号，是一个整数。对于Emacs 20.3，它的值为20。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;emacs-minor-version&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Emacs的次版本号，是一个整数。对于Emacs 20.3，它的值为3。&lt;/p&gt;
&lt;h2&gt;感谢&lt;/h2&gt;
&lt;h1&gt;Lisp数据类型&lt;/h1&gt;
&lt;p&gt;一个Lisp对象（object）是一块数据可以被Lisp程序使用和操作。对于我们来说，类型或者说数据类型是一组可能的对象。&lt;/p&gt;
&lt;p&gt;每个对象至少属于一个类型。相同的对象有类似的结构通常可以在相同的上下文使用。类型可以被覆盖，对象可以属于两个或更多类型。因此，我们可以询问某个对象是否属于某个特殊类型，但不是&amp;rdquo;那个&amp;ldquo;个类型的一个对象。&lt;/p&gt;
&lt;p&gt;一些基本对象类型是Emacs内置的。其它所有类型都是由这些类型构建起来的，这些基本对象类型被称为原生类型（primitive types）。每个对象有且只能属于一个原生类型。这些类型包括integer、float、cons、symbol、string、vector、hash-table、subr和byte-code函数，加上一些特殊类型，比如buffer，它与编辑相关。（参见Editing Types。）&lt;/p&gt;
&lt;p&gt;每个原生类型有相应的Lisp函数用于检查某个对象是否是那种类型的成员。&lt;/p&gt;
&lt;p&gt;注意Lisp不像其它语言，在Lisp中对象是类型是自描述的（self-typing）：原生类型的对象的对象类型被隐式包含在对象自身中。比如，如果对象是一个vector，则不能将它作为一个数字；Lisp知道它是一个vector而不是数字。&lt;/p&gt;
&lt;p&gt;在多数语言中，程序员必须申明每个变量的类型，编译器知道变量的类型但不会描述在数据自身中。这样的对象申明不存在于Emacs Lisp中。Lisp变量可以有任何类型的值，它记得你存储于它里面的任何值，类型和其它所有信息。（实际上，少数Emacs Lisp变量只能用于保存某些类型的值。参考Variables with Restricted Values。）&lt;/p&gt;
&lt;p&gt;在这章的目的是描述GNU Emacs Lisp中每个标准类型的打印表示方法和读取格式。使用这些类型的细节可以在后续章节找到。&lt;/p&gt;
&lt;h2&gt;打印表示方法和读取语法&lt;/h2&gt;
&lt;p&gt;对象的打印表示方法（printed representation）指由Lisp打印机（prinl函数）产生的那个对象的输出。每个数据类型有唯一的打印表示方法。对象的读取语法（read syntax）指可以被Lisp阅读器（read函数）读取的对象格式。这不需要是唯一的；很多对象类型可以有一个或多个语法。参考Read和Print。&lt;/p&gt;
&lt;p&gt;在多数情况下，一个对象的打印表示方法也是这个对象的读取语法。然而，某些类型没有读取语法，因为在Lisp程序中输入这些类型的对象作为常量没有意义。这些对象被打印为hash notation，由字符&amp;lsquo;#&amp;lt;&amp;rsquo;，一个描述字符串（通常是类型的名称跟在对象名称后面），和&amp;lsquo;&amp;gt;&amp;rsquo;组成。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;current-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;buffer objects.texi&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hash notation根本不能被读取，因此Lisp阅读器将在它遇到&amp;lsquo;#&amp;lt;&amp;rsquo;时报错invalid-read-syntax。在其它语言中，一个表达式是文本；它没有其它form。在Lisp中，一个表达式首先是一个Lisp对象第二才可被读取的文本格式的对象。通常这不需要强调他们的区别，但你必须在大脑中保持清析的概念，否则有时会非常迷惑。&lt;/p&gt;
&lt;p&gt;当你交互式的执行表达式时，Lisp解释器首先读取它的文本化描述，生成Lisp对象，然后对那个对象求值（参考Evaluation）。但，求值和读取是分开的活动。读取将返回读取的文本描述的Lisp对象；这个对象可能会被求值也可能不会。参考Input Functions，获取read的描述和读取对象的基本函数。&lt;/p&gt;
&lt;h2&gt;注释&lt;/h2&gt;
&lt;p&gt;注释写在程序中是为了让人们能读懂程序，对于程序本身没有作用。在Lisp中，不存在于字符串或字符常量中的分号（&amp;lsquo;;&amp;rsquo;）标明注释的开始。注释直到行尾结束。Lisp阅读器忽略注释；他们不会变成Lisp系统中的Lisp对象。&lt;/p&gt;
&lt;p&gt;&amp;lsquo;#@count&amp;lsquo;结构，用于忽略下面的count个字符，它对于程序生成的包含二进制数据的注释非常有用。&lt;/p&gt;
&lt;p&gt;参考Comment Tips，了解注释的格式约定。&lt;/p&gt;
&lt;h2&gt;编程类型&lt;/h2&gt;
&lt;p&gt;在Emacs Lisp中只有两类通用类型：与Lisp编程有关，另一些与编辑有关。前者存在于很多Lisp实现中。后者是Emacs Lisp特有的。&lt;/p&gt;
&lt;h3 id="zheng-xing_1"&gt;整型&lt;/h3&gt;
&lt;p&gt;Emacs Lisp整型值在多数机器上的范围为-268435456至268435455（29位；例如，-2&lt;strong&gt;28至2&lt;/strong&gt;28-1）。（某些机器可以提供更大的范围。）记得Emacs Lisp数学函数不检查溢出是很重要的。因此在多数机器上(1+ 268435455)为-268435456。&lt;/p&gt;
&lt;p&gt;整型的读取表达式为一串十进制的数字可带正负号和后面的小数点。由Lisp解释器打印出来的打印格式不会包含前面的&amp;lsquo;+&amp;rsquo;或最后的&amp;lsquo;.&amp;lsquo;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;                              &lt;span class="c1"&gt;; 整数-1。&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;                               &lt;span class="c1"&gt;; 整数1。&lt;/span&gt;
&lt;span class="mi"&gt;1.&lt;/span&gt;                              &lt;span class="c1"&gt;; 也是整数1。&lt;/span&gt;
&lt;span class="mi"&gt;+1&lt;/span&gt;                              &lt;span class="c1"&gt;; 也是整数1。&lt;/span&gt;
&lt;span class="mi"&gt;536870913&lt;/span&gt;                       &lt;span class="c1"&gt;; 在29-bit的实现上也是整数1。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考Numbers，获取更多信息。&lt;/p&gt;
&lt;h3 id="fu-dian-lei-xing"&gt;浮点类型&lt;/h3&gt;
&lt;p&gt;浮点数相当于计算机科学计数法；你可以把浮点数当作十进制分数的集合。浮点数的精度与具体的机器有关；Emacs使用C的双精度类型存储浮点值，在内部它被表示为二进制而不是十进制。&lt;/p&gt;
&lt;p&gt;浮点数的打印表示法可以是十进制小数，或指数形式，或两者都用。例如：&amp;lsquo;1500.0&amp;rsquo;，&amp;lsquo;15e2&amp;rsquo;，&amp;lsquo;25.0e2&amp;rsquo;，&amp;lsquo;1.5e3&amp;rsquo;，&amp;lsquo;.15e4&amp;rsquo;五种方法都表示值为1500的浮点数。这些表示法都是等价的。&lt;/p&gt;
&lt;p&gt;参考Numbers，获取更多信息。&lt;/p&gt;
&lt;h3 id="zi-fu-lei-xing"&gt;字符类型&lt;/h3&gt;
&lt;p&gt;Emacs Lisp中的字符不过是整型。换言之，字符是使用他们的代码来描述的。比如字符A被描述为整数65。&lt;/p&gt;
&lt;p&gt;单独的字符偶尔会用于程序中，但更常见的情况是与字符串一起工作，字符串是由有序的字符组成的。参见String Type。&lt;/p&gt;
&lt;p&gt;字符串，缓冲区和文件中了字符被限制在0至52487-19的范围。但不是所有在这个范围的字符都是有效的字符编码。0至127为ASCII码；其它的为非ASCII字符（参考Non-ASCII Characters）。用于描述键盘输入的字符范围更宽，以编码Control，Meta和Shift等修饰符。&lt;/p&gt;
&lt;p&gt;有一些特殊的函数可以生成字符的可阅读的文本化的描述。见Describing Characters。&lt;/p&gt;
&lt;h3 id="fu-hao-lei-xing"&gt;符号类型&lt;/h3&gt;
&lt;p&gt;GNU Emacs Lisp中的符号（symbol）是一个有名称的对象。符号名被作为符号的打印表示方法。经常用于Lisp中，（参见Creating symbols），符号的名称是唯一的－没有两个符号具有相同的名称。&lt;/p&gt;
&lt;p&gt;符号可以作为变量或函数名，或用于保存属性列表（property list）。或它只是作为区别于其它Ｌisp对象的标识，以便于它在一个数据结构中能被可靠的识别。在一个具体的上下文中，通常只有一种类型（符号作为变量名、函数名、属性列表、区别于其它对象的标识）有意义。但是可以将符号独立的用作所有的用途。&lt;/p&gt;
&lt;p&gt;符号名称以冒号（&amp;lsquo;:&amp;rsquo;）开头称为键盘符号（keyword symbol）。这些符号自动地作为常量，通常只被用于与未知的符号比较具有少量特殊的选择。&lt;/p&gt;
&lt;p&gt;符号名可以包括任何字符。多数符号由字母，数字和标点符号&amp;lsquo;-+=*/&amp;rsquo;组成。名称不需要特殊的标点符号；组成名称的字符应该足够长以使它看起来不像是一个数字。（如果不是这样，则要在开如的位置添加&amp;lsquo;\&amp;rsquo;强制解释器将它作为符号。）&amp;lsquo;_~!@$%^&amp;amp;:&amp;lt;&amp;gt;{}?&amp;rsquo;这些字符很少使用但是并不需要的标点符号。其它字符可以通过使用反斜线转义字符将其包含在符号名称中。对比用于字符串中，符号中的反斜线只会简单的引用后面的单个字符。比如，在字符串中&amp;rsquo;\t&amp;lsquo;表示一个tab字符；在符号中，&amp;rsquo;\t&amp;lsquo;只是表示字母&amp;rsquo;t&amp;lsquo;。要在符号名称中使用tab字符，必须真正的使用tab（以反斜线为前缀）。但这对于字符串是非常少见的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Common Lisp注意：&lt;/strong&gt; 在Common Lisp中，小写字母总是被&amp;ldquo;folded&amp;rdquo;为大写字母，除非显式的转义。在Emacs Lisp中，字母大小写字母是敏感的。&lt;/p&gt;
&lt;p&gt;下面是一些符号名称的例子。注意第五个例子中的&amp;lsquo;+&amp;rsquo;例子使用转义字符防止它被作为数字。这在第四个例子中是不需要的，因为其它部分使它不成为一个有效的数字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;                             &lt;span class="c1"&gt;; 符号名称为&amp;rsquo;foo&amp;lsquo;&lt;/span&gt;
&lt;span class="nv"&gt;FOO&lt;/span&gt;                             &lt;span class="c1"&gt;; 符号名称为&amp;rsquo;FOO&amp;lsquo;，与&amp;rsquo;foo&amp;lsquo;不同&lt;/span&gt;
&lt;span class="nf"&gt;char-to-string&lt;/span&gt;                  &lt;span class="c1"&gt;; 符号名称为&amp;lsquo;char-to-string&amp;rsquo;&lt;/span&gt;
&lt;span class="nf"&gt;1+&lt;/span&gt;                              &lt;span class="c1"&gt;; 符号名称为&amp;rsquo;1+&amp;lsquo;&lt;/span&gt;
                                &lt;span class="c1"&gt;; （不是&amp;rsquo;+1&amp;lsquo;，那是一个整数）&lt;/span&gt;
&lt;span class="nv"&gt;\+1&lt;/span&gt;                             &lt;span class="c1"&gt;; 符号名称为&amp;rsquo;+1&amp;lsquo;&lt;/span&gt;
&lt;span class="nv"&gt;\(*\1\2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                        &lt;span class="c1"&gt;; 符号名称为&amp;rsquo;(*12)&amp;rsquo;（一个更差的名称）&lt;/span&gt;

&lt;span class="nv"&gt;+-*/_~!@$%^&amp;amp;=:&amp;lt;&amp;gt;{}&lt;/span&gt;              &lt;span class="c1"&gt;; 符号名称为&amp;lsquo;+-*/_~!@$%^&amp;amp;=:&amp;lt;&amp;gt;{}&amp;rsquo;&lt;/span&gt;
                                &lt;span class="c1"&gt;; 这些字符不需要转义&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常Lisp阅读器保留所有符号（参见Creating Symbols）。为防止被保留，你可以在符号名前面添加&amp;lsquo;#:&amp;rsquo;。&lt;/p&gt;
&lt;h3 id="xu-lie-lei-xing"&gt;序列类型&lt;/h3&gt;
&lt;p&gt;序列（sequence）是一个Lisp对象用于描述有序的元素集合。在Emacs Lisp中有两种类型的序列，list和array。因此，list或array类型的对象也被作为序列。&lt;/p&gt;
&lt;p&gt;数组可以再细分为string，vector，char-table和bool-vector。Vector可以保存任何类型的元素，但是string中的元素必须是字符，Bool-vector元素必须是t或nil。Char-table与vector类似除了他们可以被任何有效字符代码索引。String中的字符与buffer的字符类似可以有文本属性（text properties）（参见Text Properties），但vector不支持text properties，即使当它的元素是字符时也不支持。&lt;/p&gt;
&lt;p&gt;List，string和其它数组类型也不同，但他们有重要的相似点。比如，都有长度l，都有可以从０到l索引访问的元素。一些函数被称为sequence函数，可以接收任何类型的sequence。比如，可以向函数elt传递索引值从sequence中获得元素（译注：类似从数组中获取元素，索引类似于下标）。参见Sequences Arrays Vectors。&lt;/p&gt;
&lt;p&gt;通常不能对同一个sequence读取两次，因为序列都是建立后，重新读取。如果你用读取sequence的语法读取两次，将会获得两个内容相同的sequence。有一个例外的就是空list()，它总是表示nil对象。&lt;/p&gt;
&lt;h3 id="cons-cellhe-listlei-xing"&gt;Cons Cell和List类型&lt;/h3&gt;
&lt;p&gt;cons cell是一个对象由两个slot组成，称为CAR slot和CDR slot。每个slot可以保存或指向任何Lisp 对象。我们也可以说&amp;ldquo;cons cell的CAR是&amp;rdquo;whatever object its car slot currently holds, and likewise for the cdr.&lt;/p&gt;
&lt;p&gt;C程序员要注意：　在Lisp中，对于&amp;ldquo;holding&amp;rdquo;一个值和&amp;ldquo;pointing to&amp;rdquo;一个值是不区分的，因为Lisp中的指针是隐式使用的。&lt;/p&gt;
&lt;p&gt;list是一连串的cons cells，每个cons cell的CDR slot保存下一个cons cell或为空的list。空的list实际上是符号nil。参见Lists，了解工作于list的函数。因为多数cons cells被用于list的一部分，术语list结构（list structure）指向任何由con cells构成的结构。&lt;/p&gt;
&lt;p&gt;Cons cells对于Lisp是如此重要，因此们也需要了解&amp;ldquo;不是cons cell的对象&amp;rdquo;。这些对象被称为原子（atoms）。&lt;/p&gt;
&lt;p&gt;list的读取语法和打印描述方法是相同的，由左括，任意数量的元素和右括号组成。下面是list的一些例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="s"&gt;"A"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                       &lt;span class="c1"&gt;; 有三个元素的list&lt;/span&gt;
&lt;span class="p"&gt;()&lt;/span&gt;                              &lt;span class="c1"&gt;; 没有元素的list（空list）&lt;/span&gt;
&lt;span class="no"&gt;nil&lt;/span&gt;                             &lt;span class="c1"&gt;; 没有元素的list（空list）&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"A ()"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                        &lt;span class="c1"&gt;; 有一个元素的list，字符串"A()"&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;                          &lt;span class="c1"&gt;; list有两个元素：A和一个空的list&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                         &lt;span class="c1"&gt;; 等同于前一个例子&lt;/span&gt;
&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="nv"&gt;B&lt;/span&gt; &lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;                       &lt;span class="c1"&gt;; 有一个元素的list&lt;/span&gt;
                                &lt;span class="c1"&gt;; （它是一个包含三个元素的list）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;括号内的每个对象都会变成list中的一个元素。每个元素被构造为一个cons cell。cons cell的CAR slot保存元素本身，CDR slot保存list中下一个cons cell，它保存了list中的下一个元素。最后一个cons cell的CDR slot被设置为nil。&lt;/p&gt;
&lt;p&gt;CAR和CDR这两个名称源自于Lisp的历史。原始的Lisp实现运行在IBM 704计算机上它将words（译注：从下文看寄存器）分为两个部分，称为&amp;ldquo;address&amp;rdquo;部分和&amp;ldquo;decrement&amp;rdquo;部分；CAR指令是用于获取寄存器address部分的内容，CDR指令用于获取decrement的内容。对比来看， &amp;ldquo;cons cells&amp;rdquo;的命名来自于创建他们的函数cons，函数的命名来自于它的目的，即cells的构造器（construction）。&lt;/p&gt;
&lt;h4 id="listde-he-zhuang-tu"&gt;List的盒状图&lt;/h4&gt;
&lt;p&gt;list可以使用盒状图描绘，在盒状图中cons cells被显示为成对的盒，像多米诺骨牌。（Lisp阅读器不能读取这种图表；它与文本化的表示方法不同，文本化的方法即可以被人读懂也可以被机器阅读，盒状图只能被人类理解。）这张图描绘了有三个元素的list(rose violet buttercup)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; |   |   |--&amp;gt; nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --&amp;gt; rose     --&amp;gt; violet   --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这张图中，每个盒表示一个可以保存或指向任何Lisp对象的slot。每对盒子表示表示一个cons cell。每个箭头表示引用一个Lisp对象，可以是atom或其它cons cell。&lt;/p&gt;
&lt;p&gt;在这个例子中，第一个盒子，保存第一个cons cell的CAR部分，指向（refers to）或保存（holds）rose（一个符号）。第二个盒子，保存第一个cons cell的CDR部分，指向下一对盒子，即第二个cons cell。第二个cons cell的CAR是violet，它的CDR是第三个cons cell。第三个cons cell（最后一个）的CDR为nil。&lt;/p&gt;
&lt;p&gt;下面是同一个list的另一个图表，(rose violet buttercup)，在某种意义是另一个补充：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o--------&amp;gt;| violet |   o--------&amp;gt;| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没有元素的list是空list（empty list）；它等同于符号nil。换言之，nil既是符号也是一个list。&lt;/p&gt;
&lt;p&gt;下面是list (A ())，等同于(A nil)，描述成盒状图如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; nil
         --- ---      --- ---
          |            |
          |            |
           --&amp;gt; A        --&amp;gt; nil
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是一个更复杂的图例，展示了三个元素的list，((pine needles) oak maple)，第一个元素是一个有两个元素的list：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; |   |   |--&amp;gt; nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --&amp;gt; oak      --&amp;gt; maple
          |
          |     --- ---      --- ---
           --&amp;gt; |   |   |--&amp;gt; |   |   |--&amp;gt; nil
                --- ---      --- ---
                 |            |
                 |            |
                  --&amp;gt; pine     --&amp;gt; needles
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示成第二种盒状图如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   o   |   o-------&amp;gt;| oak   |   o-------&amp;gt;| maple |  nil |
     |   |   |      |     |       |      |     |       |      |
      -- | ---------       --------------       --------------
         |
         |
         |        --------------       ----------------
         |       | car   | cdr  |     | car     | cdr  |
          ------&amp;gt;| pine  |   o-------&amp;gt;| needles |  nil |
                 |       |      |     |         |      |
                  --------------       ----------------
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="dian-dui-biao-ji-fa-dotted-pair-notation"&gt;点对标记法（Dotted Pair Notation）&lt;/h4&gt;
&lt;p&gt;Dotted pair表示法是cons cells的一般语法，用于显式的描述CAR和CDR。在这种语法中，(a . b)表示cons cell的CAR是对象a它的CDR是对象b。Dotted pair表示法比list表示法更通用因为CDR可以不必要是list。但，如果list语法能工作的时候，这种方式更加笨重。在Dotted pair表示法中，list&amp;lsquo;(1 2 3)&amp;rsquo;可以被写作&amp;lsquo;(1 . (2 . (3 . nil)))&amp;rsquo;。对于以nil结尾的list，你可以任意的使用这两种表示方法，但list表式方法更加清析和方便。当打印list时，dotted paire表示法只用于cons cell的CDR不是list时。&lt;/p&gt;
&lt;p&gt;下面使用盒状图描述了dotted pair表示法。这个例子展示了(rose . violet)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---
        |   |   |--&amp;gt; violet
         --- ---
          |
          |
           --&amp;gt; rose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以组合使用dotted pair表达方式和list表达方式，以便于链接以非nil结束的CDR。你可以在list的最后一个元素后写一个点，后面跟最后的cons cell的CDR。例如，(rose violet . buttercup)等同于(rose . (violet . buttercup))。这个对象看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; buttercup
         --- ---      --- ---
          |            |
          |            |
           --&amp;gt; rose     --&amp;gt; violet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表达式(rose . violet . buttercup)是无效的因为它不能表达任何东西。它将buttercup放到cons cell的CDR而它的CDR已经用于violet了。&lt;/p&gt;
&lt;p&gt;list (rose violet)等同于(rose . (violet))，看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; nil
         --- ---      --- ---
          |            |
          |            |
           --&amp;gt; rose     --&amp;gt; violet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似地，包含三个元素的list(rose violet buttercup)等同于(rose . (violet . (buttercup)))。它的结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; |   |   |--&amp;gt; nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --&amp;gt; rose     --&amp;gt; violet   --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="guan-lian-listlei-xing-association-list-type"&gt;关联list类型（Association List Type）&lt;/h4&gt;
&lt;p&gt;association list或alist是一种特殊结构的list它的元素是cons cells。每个元素中，CAR被作为key，CDR作为关联的值（associated value）。（某些情况下，关联值被存在CDR的CAR中）Association list通常用作栈，因为它很容易从list的前面添加或移除关联对象。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;alist-of-colors&lt;/span&gt;
           &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;rose&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;red&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lily&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;white&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buttercup&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;yellow&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将变量alist-of-colors设置了包含三个元素的alist。在第一个元素中，rose是key，red是值。&lt;/p&gt;
&lt;p&gt;参见Association Lists，了解更多关于alist及作用于alist的函数。参见Hash Tables，了解另一种lookup table，它在处理大量keys的时候更加快。&lt;/p&gt;
&lt;h3 id="shu-zu-lei-xing-array-type_1"&gt;数组类型（Array Type）&lt;/h3&gt;
&lt;p&gt;array由任意数量的slots以保存或引用其它Lisp对象，存储在一块连续的内存中。访问数组中的任何元素所花的时间大致是相同的。相反，访问list中的一个元素所花的时间与他们存储在list中的位置成比例。（访问list结束位置的元素所花的时间比访问list开始位置的元素所花的时间更长。）&lt;/p&gt;
&lt;p&gt;Emacs定义了四种类型的array：strings，vectors，bool-vectors和char-tables。&lt;/p&gt;
&lt;p&gt;string是一个字符的数组，vector是任意类型对象的数组。bool-vector只可以保存t或nil。这些类型的数组的长度可以达到整型的最大值。Char-tables是稀疏的数组可以使用任意有效的字符代码作为索引；他可以保存任意的对象。&lt;/p&gt;
&lt;p&gt;数组的第一个元素的索引为0，第二个元素索引为1，以些类推。这称为zero-origin索引。例如，数组有四个元素则有索引0，1，2和3。最大可能的索引值比数组长度小1。一旦数组被创建，它的长度就是固定的。&lt;/p&gt;
&lt;p&gt;所有Emacs Lisp数组都是一维的。（多数其它语言支持多维数组，但他们并不是必需的；可以通过嵌套的一维数组来达到相同的效果。）每种类型的数组有其自己的读取语法；参见下面的章节了解细节。&lt;/p&gt;
&lt;p&gt;数组类型是sequence类型的子类型，包括string，vector，bool-vector和char-table类型。&lt;/p&gt;
&lt;h3 id="zi-fu-chuan-lei-xing"&gt;字符串类型&lt;/h3&gt;
&lt;p&gt;string是字符的数组。在Emacs中字符串有很多用途，例如，作为Lisp符号名，作为显示给用户的信息，作为从缓冲区中提取的文本。Lisp中的字符串是不可变的：对字符串求值返回相同的字符串。&lt;/p&gt;
&lt;p&gt;参见Strings and Characters，了解操作字符串的函数。&lt;/p&gt;
&lt;h4 id="zi-fu-chuan-yu-fa"&gt;字符串语法&lt;/h4&gt;
&lt;p&gt;字符串的读取语法是双引号，任意数量的字符，另一个双引号，例如"like this"。为了在字符串中包含双引号，可以在双引号前添加反斜线；因而，"\""是一个字符串包含了单个双引号字符。同样，也可以使用两个双斜线表示斜线符号，如"this \ is a single embedded backslash"。&lt;/p&gt;
&lt;p&gt;换行符不是字符串的特殊读取语法；如果你需要在双引号间添加换行符，它将变成字符串中的一个字符。但如果换行符前有转义字符&amp;lsquo;\&amp;rsquo;则换行符不会变成字符串的一部分；例如，Lisp阅读器在读取字符串时将忽被转义的换行符。转义符后面的空格&amp;lsquo;\ &amp;rsquo;也将被忽略。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          =&amp;gt; "It is useful to include newlines
     in documentation strings,
     but the newline is ignored if escaped."
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="zi-fu-chuan-zhong-de-fei-asciizi-fu"&gt;字符串中的非ASCII字符&lt;/h4&gt;
&lt;p&gt;可以在字符串常量书写时添加非ASCII的国际化字符。在Emacs字符串（和缓冲区中）有两种非ASCII文本描述方法：单字节（unibyte）和多字节（multibyte）。如果字符串常量是从一个多字节的源码中读取的，比如多字节的缓冲区或字符串，或以多字节方式访问的文件，这时字符被以多字节字符读取，并且将生成多字节的字符串。如果字符串常量是从多字节的源码中读取的，则字符将被以多字节的方式读取并且生成多字节的字符串。&lt;/p&gt;
&lt;p&gt;你也可以以多字节的非ASCII字符的代码来表示字符：使用十六进制前缀，&amp;lsquo;\xnnnnnnn&amp;rsquo;，可以带有多个数字。（多字节非ASCII字符编码都会大于256。）任何无效的十六朝向数字将结束这个结构。如果字符串中的下一个字符可以被解释为十六进制数字，则以&amp;lsquo;\ &amp;rsquo;（转义字符和空格）来结束十六进制转义&amp;mdash;&amp;mdash;比如，&amp;lsquo;\x8e0&amp;rsquo;表示一个字符，带重音符号的&amp;lsquo;a&amp;rsquo;。字符串常量中的&amp;lsquo;\ &amp;rsquo;与斜线-换行符类似；它不会添加任何字符到字符串，但它会终结前面的十六进制转义。&lt;/p&gt;
&lt;p&gt;你可以字符的编码来描述多字节的非ASCII字符，它必须在128（八进制的0200）到255（八进制的0377）之间。如果你以八进制书写所有那些字符的代码并且字符串不包含其它字符强制字符串为多字节，则将产生一个单字节的字符串。但是，在字符串中使用十六进制黑底（即使是使用在ASCII字符上）将强制字符串为多字节。&lt;/p&gt;
&lt;p&gt;你也可以在字符串中使用字符的Unicode数字编号，使用&amp;lsquo;\u&amp;rsquo;和&amp;lsquo;\U&amp;rsquo;（参见Character Type）。&lt;/p&gt;
&lt;p&gt;参见Text Representations，了解这两种文本描述方式的更多信息。&lt;/p&gt;
&lt;h4 id="zi-fu-chuan-zhong-de-fei-da-yin-zi-fu"&gt;字符串中的非打印字符&lt;/h4&gt;
&lt;p&gt;你可以在字符串常量中使用反斜线的转义字符序列（但不要以问号开始字符常量）。比如，你可以写一个字符串包括非打印字符tab和C-a，在他们之间添加逗号和空格："\t, C-a"。参见Character Type，了解字符读取语法的描述。&lt;/p&gt;
&lt;p&gt;但是，并不是所有使用转义字符的字符都是有效的字符串字符。只有控制字符，ASCII控制字符可以保存在字符串中。字符串不会区别ASCII控制字符的大小写。&lt;/p&gt;
&lt;p&gt;确切的说，字符串不能保存meta字符；但当字符串用作按键序列（key sequence）时，有一个特殊的约定提供了一个方法可以在字符串中描述meta版的ASCII字符。如果你使用&amp;lsquo;\M-&amp;rsquo;语法标明字符串常量中的meta字符，这将设置字符串中的字符的2**7bit。如果字符串用于define-key或lookup-key，这个数字代码将被转译为相当于meta字符。参见Character Type。&lt;/p&gt;
&lt;p&gt;字符串不能保存修饰字符hyper，super和alt。&lt;/p&gt;
&lt;h4 id="zi-fu-chuan-zhong-de-wen-ben-shu-xing-text-properties"&gt;字符串中的文本属性（Text Properties）&lt;/h4&gt;
&lt;p&gt;字符串可以保存它包含的字符的文本属性。这使程序在string和buffer中复制文本和文本属性时不需要特殊的工作。参见Text Properties，以了解什么是文本属性。带文本属性的字符串使用特殊的读取和打印语法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;"characters"&lt;/span&gt; &lt;span class="nv"&gt;property-data...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当属性数据由0个或多个元素组成时，可以用三个参数来分组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;beg end plist
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;元素beg和end是整数，一起指定字符串中文本的范围；plist是属性列表。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;"foo bar"&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;face&lt;/span&gt; &lt;span class="nv"&gt;bold&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;face&lt;/span&gt; &lt;span class="nv"&gt;italic&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;描述了一个字符串，它的文本内容为&amp;lsquo;foo bar&amp;rsquo;，它的前三个字符有一个face属性，属性的值为bold，后三个字符的face属性值为italic。（第四个字符没有文本属性，因此它的属性列表为nil。实际上不需要论及以nil作为属性列表的范围，因为任何不在范围中的字符默认都没有属性。）&lt;/p&gt;
&lt;h3 id="vectorlei-xing_1"&gt;Vector类型&lt;/h3&gt;
&lt;p&gt;vector是一个元素可以为任何类型的一维数组。花相同的时间可以访问任何vector中的任何元素。（在List中，访问时间与元素离list开始位置的距离成正比。）&lt;/p&gt;
&lt;p&gt;vector的打印描述方法由一个左方括号，元素和右方括号组成。这也是它的读取语法。与数字和字符串类似，vector对于求值来说是常量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="s"&gt;"two"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;three&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;               &lt;span class="c1"&gt;; 有三个元素的vector&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; [1 "two " (three)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参见Vectors，了解工作于vector的函数。&lt;/p&gt;
&lt;h3 id="char-tablelei-xing"&gt;Char-Table类型&lt;/h3&gt;
&lt;p&gt;char-table是一个元素可以是任何类型的一维数组，通过字符代码进行索引。Char-table有某些特殊的功能使它们对于很多与设置字符代码信息相关的工作时非常有用&amp;mdash;&amp;mdash;比如，char-table可以从父对象继承，默认值，和少量用于特目的的额外的slot。char-table也可以为整个字符集合指定单个值。&lt;/p&gt;
&lt;p&gt;char-table的打印描述方法与vector类似，只是在开始位置添加了额外的&amp;lsquo;#^&amp;rsquo;。&lt;/p&gt;
&lt;p&gt;参见Char-Tables，了解操作char-tables的特殊函数。使用char-tables的包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Case tables&lt;/li&gt;
&lt;li&gt;Character category tables&lt;/li&gt;
&lt;li&gt;Display tables&lt;/li&gt;
&lt;li&gt;Syntax tables&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bool-vectorlei-xing"&gt;Bool-Vector类型&lt;/h3&gt;
&lt;p&gt;bool-vector是一个一维数组，它的元素必须是t或nil。&lt;/p&gt;
&lt;p&gt;bool-vector的打印描述方法像一个字符串，但它以&amp;lsquo;#&amp;amp;&amp;rsquo;开头后面跟长度。这个字符串常量后面的bool-vector内容实际上看像一个bitmap&amp;mdash;&amp;mdash;这个字符串中的每个字符包含8bits，它指定了bool-vector后面的8个元素（1表示t，0表示nil）。字符的其它的有效位对应于bool-vector底部。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-bool-vector&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;amp;3"^G"&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-bool-vector&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;amp;3"^@"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些结果很有意义，因为&amp;lsquo;C-g&amp;rsquo;的二进制代码为111，&amp;lsquo;C-@&amp;rsquo;的字符代码为0。&lt;/p&gt;
&lt;p&gt;如果长度不是8的倍数，则打印描述将显示额外的元素，但这些额外的内容不会产生差异。比如，在下面的例子中，两个bool-vector是相等的，因为只有前三个bit被使用了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;&amp;amp;3&lt;/span&gt;&lt;span class="s"&gt;"\377"&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;&amp;amp;3&lt;/span&gt;&lt;span class="s"&gt;"\007"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ha-xi-biao-lei-xing-hash-table-type"&gt;哈希表类型（Hash Table Type）&lt;/h3&gt;
&lt;p&gt;哈希表是一种非常快的lookup table，有点像alist，alist将key映射到对应的值，但哈希表更快。哈希表没有读取语法，打印的时候使用哈希表示法。参见Hash Tables，了解操作哈希表的函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-hash-table&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;hash-table 'eql nil 0/65 0x83af980&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="han-shu-lei-xing-function-type"&gt;函数类型（Function Type）&lt;/h3&gt;
&lt;p&gt;Lisp函数是可执行的代码，与其它编程语言中的函数类似。在Lisp中，与某些语言不同的是函数也是Lisp对象。一个不编译的Lisp函数是一个lambda表达式：它也是一个list，它的第一个元素是符号lambda（参见Lambda Expressions）。&lt;/p&gt;
&lt;p&gt;多数编程语言不允许函数没有名称。在Lisp中函数没有内部名称。Lambda表达式可以在没有名称的情况下被函数调用；为强调这一点，我们也称它为匿名函数（ananymous function参见Anonymous Function）。命名的Lisp函数也只是一个符号它的function cell有一个有效的函数（参见Defining Function）。&lt;/p&gt;
&lt;p&gt;多数情况下，函数将在Lisp程序的Lisp表达式中出现它的名称时被调用。但你可以在运行时构造或得到一个函数对象，并使用原生函数（primitive function）funcall和apply调用它。参见Calling Functions。&lt;/p&gt;
&lt;h3 id="hong-lei-xing-macro-type"&gt;宏类型（Macro Type）&lt;/h3&gt;
&lt;p&gt;Lisp宏是用户定义的扩展Lisp语言的结构。将作为对象更像函数，但具有不同的参数传递语义。Lisp宏具有form list，它的第一个元素是符号macro它的CDR是一个Lisp函数对象，包括lambda符号。&lt;/p&gt;
&lt;p&gt;Lisp宏对象通常使用内置函数defmacro来定义，but any list that begins with macro is a macro as far as Emacs is concerned。参见Macros，它说明了如何编写宏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt;Lisp宏和键盘宏（参见Keyboard Macros）是完全不同的事情。当我们使用不带限定词的单词&amp;ldquo;macro&amp;rdquo;时，表示是Lisp宏，而不是键盘宏。&lt;/p&gt;
&lt;h3 id="yuan-sheng-han-shu-lei-xing-primitive-function-type"&gt;原生函数类型（Primitive Function Type）&lt;/h3&gt;
&lt;p&gt;原生函数（primitive function）是可以从Lisp调用的函数但它是用C语言编写的。原生函数也称为subrs或built-in functions。（subr源自于subroutine）多数原生函数在他们被调用时对他们的所有参数求值。不对它的参数求值的原生函数被称为 special form（参见Special Forms）。&lt;/p&gt;
&lt;p&gt;对于调用者来说并不关心它调用的函数是否为原生的。但如果你使用Lisp代码重新定义原生函数会产生麻烦因为原生函数可以直接被C代码调用。在Lisp代码中调用重定义的函数将使用新的定义，但如果从C代码中调用将仍然使用内置的定义。因此， &lt;strong&gt;我们不推荐重新定义原生函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;术语function指Emacs中的所有函数，不论是用Lisp或C编写的。参见Function Type了解使用Lisp编写函数。&lt;/p&gt;
&lt;p&gt;Primitive functions have no read syntax and print in hash notation with the name of the subroutine.&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt; &lt;span class="ss"&gt;'car&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;; 访问符号的function cell&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;subr car&amp;gt;&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;subrp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt; &lt;span class="ss"&gt;'car&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;; 是否为一个原生函数？&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; t                       ; 是的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="byte-codehan-shu-lei-xing"&gt;Byte-Code函数类型&lt;/h3&gt;
&lt;p&gt;byte compiler生成byte-code函数对象。在内部，byte-code函数对象更象vector；但是，当它出现为一个被调用的函数时求值器将特殊地处理这种数据类型。参见Bypte Compilation，了解关于byte compiler的相关信息。&lt;/p&gt;
&lt;p&gt;byte-code函数对象的打印和读取格式类似于vector，在&amp;lsquo;[&amp;rsquo;前添加了&amp;lsquo;#&amp;rsquo;。&lt;/p&gt;
&lt;h3 id="autoloadlei-xing"&gt;Autoload类型&lt;/h3&gt;
&lt;p&gt;autoload对象是一个list它的第一个元素是符号autoload。它像符号的函数定义一样被存储，它作为真实定义的占位符。autoload对象表明真实的函数定义可以在Lisp代码的文件中找到，可以在需要时加载。它包括文件的名称，和一些关于实际定义的相关信息。&lt;/p&gt;
&lt;p&gt;当文件被加载后，符号将有一个新的函数定义而不再是一个autoload对象。这时新的定义可以被调用就像它一开始就存在于那里一样。从用户的观点来看，函数调用工作起来和预期的一样，可以使用被加载的文件中定义的函数。&lt;/p&gt;
&lt;p&gt;autoload对象通常使用autoload函数创建，它将这个对象存储于符号的function cell区域。参见Autoload，了解更多细节。&lt;/p&gt;
&lt;h2&gt;编辑类型（Editing Types）&lt;/h2&gt;
&lt;p&gt;前一节讲述的类型用于通用编程目的，它们中的大多数也用于大多数的Lisp方言中。Emacs Lisp提供了几个特殊的类型用于连接编辑处理。&lt;/p&gt;
&lt;h3 id="huan-chong-qu-lei-xing"&gt;缓冲区类型&lt;/h3&gt;
&lt;p&gt;buffer是一个对象用于保存可编辑的文本（参见Buffers）。多数缓冲区用于保存磁盘文件的内容（参见Files）以便于被编辑，但另一些用于其它目的。有时，在一个窗口中（参见Windows），一些缓冲区只用于显示给用户查看。但缓冲区不必要一定显示在窗口中。&lt;/p&gt;
&lt;p&gt;缓冲区的内容更像一个字符串，但缓冲区在Emacs Lisp中不能用作字符串，它们的操作也是不同的。例发，你可以在一个缓冲区中插入文本更改缓冲区的内容，但是&amp;ldquo;插入&amp;rdquo;文本到字符串中需要连接子字符串（concatenating substring），其结果是一个全新的新字符串对象。&lt;/p&gt;
&lt;p&gt;每个缓冲区都有一个指定的位置称为point（参见Positions）。在任何时候，有一个缓冲区是当前缓冲区。多数编辑命令操作当前缓冲区中邻近point的内容。许多标准Emacs函数操作或测试当前缓冲区中的字符；这个手册中有一整章用于描述这些函数（参见Text）。&lt;/p&gt;
&lt;p&gt;有几个其它的数据结构与每个缓冲区关联&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地语法表（local syntax）（参见Syntax Tables）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地按键映射（local keymap）（参见Keymaps）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓冲区局部绑定的变量的list（参见Buffer-Local Variables）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;overlays（参见Overlays）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓冲区的文本属性（参见Text Properties）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;局部按键映射和变量列表包含了覆盖全局按键绑定的值或新值的入口。这些用于在不同的缓冲区自定义程序的行为，而不会改变程序本身。&lt;/p&gt;
&lt;p&gt;缓冲区可能是indirect的，这与另一个缓冲区共享文本，但用它的不同的方式呈现内容。参见Indirect Buffers。&lt;/p&gt;
&lt;p&gt;缓冲区没有读取语法。打印时将显示缓冲区的名称。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;current-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;buffer objects.texi&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="markerlei-xing"&gt;Marker类型&lt;/h3&gt;
&lt;p&gt;marker指示了具体缓冲区的位置。markers有个组件：一个用于缓冲区，另一个用于位置。修改缓冲区的文本将自动重新定位位置的值以确保marker总是指向缓冲区中的两个字符之间的位置。&lt;/p&gt;
&lt;p&gt;markers没有读取语法。打印为hash表示法时，将显示当前字符的位置和缓冲区的名称。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;marker at 10779 in objects.texi&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参见Markers，了解如何测试，创建，复制和移动markers。&lt;/p&gt;
&lt;h3 id="windowlei-xing"&gt;Window类型&lt;/h3&gt;
&lt;p&gt;window表示终端屏幕的一部分，Emacs用它显示一个缓冲区。每个window有一个相关的缓冲区，它的内容显示在窗口中。相反，一个缓冲区可以显示在一个窗口中，或不显示在窗口中，或显示在多个窗口中。&lt;/p&gt;
&lt;p&gt;尽管可以同时存在很多窗口，同一时候只有一个窗口是当前选中窗口（selected window）。这是当前光标停留的窗口，在这个窗口中Emacs等侍命令输入。选中的窗口通常显示当前缓冲区（current buffer），但这并不是必需的情况。&lt;/p&gt;
&lt;p&gt;窗口在屏幕上被组织到frames中；每个窗口属于一个并且只能属于一个frame。参见Frame Type。&lt;/p&gt;
&lt;p&gt;窗口没有读取语法。打印为hash表示法时，将显示窗口号和显示的缓冲区的名称。窗口号用于唯一标识窗口，因为显示在窗口中的缓冲区可能会改变。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;selected-window&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;window 1 on objects.texi&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参见Windows，了解工作于窗口的函数。&lt;/p&gt;
&lt;h3 id="framelei-xing"&gt;Frame类型&lt;/h3&gt;
&lt;p&gt;frame是一个屏幕区域包含一个或多个Emacs窗口；我们也使用术语&amp;ldquo;frame&amp;rdquo;指向Lisp对象，Emacs使用它指向屏幕区域。&lt;/p&gt;
&lt;p&gt;Frames没有读取语法。它们打印为哈希标记法，frame标题加它在核心中的的地址（用于唯一标识frame）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;selected-frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;frame emacs@psilocin.gnu.org 0xdac80&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参见Frames，了解工作于frames的函数。&lt;/p&gt;
&lt;h3 id="chuang-kou-pei-zhi-lei-xing-window-configuration-type"&gt;窗口配置类型（Window Configuration Type）&lt;/h3&gt;
&lt;p&gt;window configuration存储frame中的窗口的位置，尺寸，内容相关的信息，因此你可以重新组织窗口的位置。&lt;/p&gt;
&lt;p&gt;Window configurations没有读取语法；它的打印语法格式如&amp;ldquo;#&lt;window-configuration&gt;&amp;rdquo;。参见Window Configurations，了解与window configurations相关的函数。&lt;/window-configuration&gt;&lt;/p&gt;
&lt;h3 id="frame-configurationlei-xing"&gt;Frame Configuration类型&lt;/h3&gt;
&lt;p&gt;Frame configuration存储了所有frame中的窗口的位置，大小和内容等信息。它实际上是一个list，它的CAR是frame-configuration它的CDR是一个alist。每个alist元素描述一个frame，它作为那个元素的CAR出现。&lt;/p&gt;
&lt;p&gt;参见Frame Configurations，了解与frame configurations相关的函数。&lt;/p&gt;
&lt;h3 id="jin-cheng-lei-xing"&gt;进程类型&lt;/h3&gt;
&lt;p&gt;单词&amp;ldquo;进程&amp;rdquo;通常表示运行的程序。Emacs自己也是那样一个运行的进程。在Emacs Lisp中，进程是一个Lisp对象，表示由Emacs进程创建的子进程。shell，GDB，ftp和编译器等程序作为Emacs子进程运行，扩展了Emacs的能力。&lt;/p&gt;
&lt;p&gt;Emacs子进程从Emacs接收文本化输入并返回文本化的输出到Emacs中以便处理。Emacs也可以发送信号到子进程。&lt;/p&gt;
&lt;p&gt;进程对象没有读取语法。它使用哈希表示法打印，显示进的名称：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;process-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; (#&amp;lt;process shell&amp;gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参见[[#Processes][Processes]]，了解关于进程创建，删除，返回信息，发送输入或信号和接收输出到进程的函数。&lt;/p&gt;
&lt;h3 id="streamlei-xing"&gt;Stream类型&lt;/h3&gt;
&lt;p&gt;stream是一个对象流可以提供字符作为输入或输出。很多不同的类型可以使用这种方式，比如：marks，buffers，strings和functions。通常，输入流（字符源）可以从键盘、缓冲区或文件获得，输出流可以发送到缓冲区，例如&lt;em&gt;Help&lt;/em&gt;缓冲区或回显区。&lt;/p&gt;
&lt;p&gt;nil对象，用于流有其它的含义。它表示变量standard-input或standard-output。对象t作为流指定使用minibuffer作为输入（参见MiniBuffers）或输出到回显区（参见The Echo Area）。&lt;/p&gt;
&lt;p&gt;参见Read and Print，了解与流相关的函数，包括解析和打印函数。&lt;/p&gt;
&lt;h3 id="keymaplei-xing"&gt;Keymap类型&lt;/h3&gt;
&lt;p&gt;keymap将按键映射到用户命令。这个映射控制了用户命令如何被输入执行。按键映射实际上是一个list，它的CAR是keymap符号。&lt;/p&gt;
&lt;p&gt;参见[[#Keymaps][Keymaps]]，了解创建keymaps，处理前缀参数，局部和全局映射，修改按键组合。&lt;/p&gt;
&lt;h3 id="overlaylei-xing"&gt;Overlay类型&lt;/h3&gt;
&lt;p&gt;overlay指定了将应用到缓冲区的属性。每个overlay将应用到缓冲区的指定范围，包括了一个属性列表（一个包含将要修改的属性和值的list）。overlay属性用于将当前缓冲区临时设置为不同的显示风格。Overlay没有读取语法，在打印为哈希表达方式时，将显示缓冲区的名称和位置范围。&lt;/p&gt;
&lt;p&gt;参见[[#Overlays][Overlays]]，了解如何创建和使用overlays。&lt;/p&gt;
&lt;h2&gt;环状对象的读取语法（Read Syntax for Circular Objects）&lt;/h2&gt;
&lt;p&gt;为在一个复杂的Lisp对象中描述共享或通知结构时，你可以使用读取结构&amp;lsquo;#n=&amp;rsquo;和&amp;lsquo;#n#&amp;rsquo;。&lt;/p&gt;
&lt;p&gt;在一个对象前使用#n=标明它是一个延时的引用；在后面，你可以在另一个地方使用#n#来引用同一个对象。在这里，n是个整数。比如，下面的例子产生了一个list，在这里第一个元素在第三个元素处重现了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#1=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="o"&gt;#1#&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这不同于普通的表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个表达式生成的list中第一个和第三个元素看起来相同，但他们不是同一个Lisp对象。下面显示了他们的不同：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#1=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="o"&gt;#1#&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以使用相同的语法产生一个环状结构，它表现了一个元素处理它自己内部。这里有一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="o"&gt;#1=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="o"&gt;#1#&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样生成的list的第二个元素是list自身。这里展示了它是如何工作的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="o"&gt;'#1=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="o"&gt;#1#&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cadr&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果将变量print-circle设置成了非nil值Lisp打印器可以按这种语法在Lisp对象中生成环状和共享结构。参见[[#Output_Variables][Output Variables]]。&lt;/p&gt;
&lt;h2&gt;类型判定（Type Predicates）&lt;/h2&gt;
&lt;p&gt;Emacs Lisp解释器对于传递给被调用的函数的参数并不会对参数执行类型检查。它也做不到这一点，因为Lisp中的函数参数并没有申明数据类型，这与其它编程语言不同。对此可以使用检查参数属于哪种类型的函数。&lt;/p&gt;
&lt;p&gt;所有内置函数都会检查他们的实参是否适当，如果参数类型错误将生成wrong-type-arguemnt错误。例如，下面展示了如果传递不能处理的参数给+将产生错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ss"&gt;'a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="nv"&gt;error--&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;Wrong&lt;/span&gt; &lt;span class="nv"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;argument:&lt;/span&gt; &lt;span class="nv"&gt;number-or-marker-p,&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你希望程序可以用不同的方式处理不同的类型，则必须显式的进行类型检查。通常检查对象的类型的方法是调用类型判定（type predicate）函数。Emacs对于每个类型都有类型判定函数，对于一些组合类型也有类型判定函数。&lt;/p&gt;
&lt;p&gt;类型判定函数接收一个参数；如果参数属于相应的类型则返回t，否则返回nil。按Lisp对于类型判定函数的的习惯，多数类型判定函数名称心&amp;lsquo;p&amp;rsquo;结束。&lt;/p&gt;
&lt;p&gt;下面的例子使用了listp检查是list，使用symbolp检查symbol。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;add-on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;symbolp&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="c1"&gt;;; If X is a symbol, put it on LIST.&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
             &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;listp&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="c1"&gt;;; If X is a list, add its elements to LIST.&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
              &lt;span class="c1"&gt;;; We handle only symbols and lists.&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"Invalid argument %s in add-on"&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下表列举了预定义的类型判定函数，按字母顺序排列。&lt;/p&gt;
&lt;p&gt;atom&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;参见[[#atom][atom]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;arrayp&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;参见[[#arrayp][arrayp]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bool-vector-p&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;参见[[#bool-vector-p][bool-vector-p]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bufferp
    参见[[#bufferp][bufferp]]&lt;/p&gt;
&lt;p&gt;byte-code-function-p
    参见[[#byte-code-function-p][byte-code-function-p]]&lt;/p&gt;
&lt;p&gt;case-table-p
    参见[[#case-table-p][case-table-p]]&lt;/p&gt;
&lt;p&gt;char-or-string-p
    参见[[#char-or-string-p][char-or-string-p]]&lt;/p&gt;
&lt;p&gt;char-table-p
    参见 char-table-p.&lt;/p&gt;
&lt;p&gt;commandp
    参见 commandp.&lt;/p&gt;
&lt;p&gt;consp
    参见 consp.&lt;/p&gt;
&lt;p&gt;display-table-p
    参见 display-table-p.&lt;/p&gt;
&lt;p&gt;floatp
    参见 floatp.&lt;/p&gt;
&lt;p&gt;frame-configuration-p
    参见 frame-configuration-p.&lt;/p&gt;
&lt;p&gt;frame-live-p
    参见 frame-live-p.&lt;/p&gt;
&lt;p&gt;framep
    参见 framep.&lt;/p&gt;
&lt;p&gt;functionp
    参见 functionp.&lt;/p&gt;
&lt;p&gt;hash-table-p
    参见 hash-table-p.&lt;/p&gt;
&lt;p&gt;integer-or-marker-p
    参见 integer-or-marker-p.&lt;/p&gt;
&lt;p&gt;integerp
    参见 integerp.&lt;/p&gt;
&lt;p&gt;keymapp
    参见 keymapp.&lt;/p&gt;
&lt;p&gt;keywordp
    参见 Constant Variables.&lt;/p&gt;
&lt;p&gt;listp
    参见 listp.&lt;/p&gt;
&lt;p&gt;markerp
    参见 markerp.&lt;/p&gt;
&lt;p&gt;wholenump
    参见 wholenump.&lt;/p&gt;
&lt;p&gt;nlistp
    参见 nlistp.&lt;/p&gt;
&lt;p&gt;numberp
    参见 numberp.&lt;/p&gt;
&lt;p&gt;number-or-marker-p
    参见 number-or-marker-p.&lt;/p&gt;
&lt;p&gt;overlayp
    参见 overlayp.&lt;/p&gt;
&lt;p&gt;processp
    参见 processp.&lt;/p&gt;
&lt;p&gt;sequencep
    参见 sequencep.&lt;/p&gt;
&lt;p&gt;stringp
    参见 stringp.&lt;/p&gt;
&lt;p&gt;subrp
    参见 subrp.&lt;/p&gt;
&lt;p&gt;symbolp
    参见 symbolp.&lt;/p&gt;
&lt;p&gt;syntax-table-p
    参见 syntax-table-p.&lt;/p&gt;
&lt;p&gt;user-variable-p
    参见 user-variable-p.&lt;/p&gt;
&lt;p&gt;vectorp
    参见 vectorp.&lt;/p&gt;
&lt;p&gt;window-configuration-p
    参见 window-configuration-p.&lt;/p&gt;
&lt;p&gt;window-live-p
    参见 window-live-p.&lt;/p&gt;
&lt;p&gt;windowp
    参见 windowp.&lt;/p&gt;
&lt;p&gt;booleanp
    参见 booleanp.&lt;/p&gt;
&lt;p&gt;string-or-null-p
    参见 string-or-null-p.&lt;/p&gt;
&lt;p&gt;最通用的检查对象类型的方法是调用type-of函数。再次强调每个对象只属于且仅能属于一个原生类型；type-of可以告诉你它属于哪种类型（参见[[#Lisp_Data_Types][Lisp Data Types]]）。但是type-of不了解非原生类型的信息。在多数情况下，更方便的是使用类型判定函数type-of。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;type-off&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数返回object的原生类型的名称的符号。返回值可能是下面的一个符号：symbol，integer，float，string，cons，vector，char-table，bool-vectorhash-table，subr，compiled-function，marker，overlay，window，buffer，frame，或window-configuration。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type-of&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; integer&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type-of&lt;/span&gt; &lt;span class="ss"&gt;'nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; symbol&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type-of&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;    &lt;span class="c1"&gt;; () is nil.&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; symbol&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type-of&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; cons&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相等判定（Equality Predicates）&lt;/h2&gt;
&lt;p&gt;这里我们讲述两个用于测试两个对象的相等性的函数。其它函数测试特定类型的对象的相等性，比如，string。对于这些判定，可以参见相应的章节描述。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;eq&lt;/code&gt; object1 object2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果object1和object2是相同的对象，则返回t，否则返回nil。&lt;/p&gt;
&lt;p&gt;如果object1和object2是整数并有相同的值eq将返回t。因为符号名通常是唯一的，如果参数是符号并有相同的名字，则它们相等。对于其它类型（比如，lists，vectors，strings），两个参数有相同的同内容或元素不必要每个都相等：它们是同样的对象时相等，这意味着改变一个的内容将影响反映到另一个上产生同样的变化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="mi"&gt;456&lt;/span&gt; &lt;span class="mi"&gt;456&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; (1 (2 (3)))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;make-symbol函数返国 个uninterned符号，这有别于你编写在Lisp表达式的符号。这两种不同的符号有相同的名称但不相等（eq）。参见[[Creating_Symbols][Creating Symbols]]。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-symbol&lt;/span&gt; &lt;span class="s"&gt;"foo"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;eqal&lt;/code&gt; object1 object2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果object1和object2有相等的内容则返回t，否则返回nil。eq检查它的参数是否为相同的对象，equal检查它的参数内部的元素或内容是否一样。因此，如果两个对象eq则他们equal，反之则不一定。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="mi"&gt;456&lt;/span&gt; &lt;span class="mi"&gt;456&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字符串比较时是大小写敏感的，但不会考虑文本属性（）text properties），它只会比较字符串中的字符。因为技术原因，单字节字符串和多字节字符串比较时，如果他们包含相同的字符代码序列并且所有这些代码都处于0至127（ASCII）之间或160至255（八bit图元），则两个字符串equal。（参见[[#Text_Representations][Text Representations]]）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt; &lt;span class="s"&gt;"ASDF"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个不同的buffer总不会equal，即使他们的文本内容是相同和。&lt;/p&gt;
&lt;p&gt;相等性的测试是通过递归实现的：例如，两个cons cells分别为x和y，在下面的两个表达式都返回t时(equal x y)返回t。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为这是一个递归方法，circular list将会至进入无限递归（导致产生错误）。&lt;/p&gt;
&lt;h1&gt;数字（Numbers）&lt;/h1&gt;
&lt;p&gt;GNU Emacs支持两种数字类型：整形（integer）和浮点（floating point)类型。Integer值如－3，0，7，13和511。他们的值是精确的。Floating point数字是带有小数部分的数字，比如－4.5，0.0或2.71828。他们也可以表示为科学计数法：1.5e2等于150；在这个例子中，&amp;lsquo;e2&amp;rsquo;表示10的2次方，乘1.5。Floating point值是不精确的；他们有一个固定的有限的精度。&lt;/p&gt;
&lt;h2&gt;整数基础（Integer Basics）&lt;/h2&gt;
&lt;p&gt;Integer的范围依赖于具体的机器类型。最小范围是-268435456至268435455（29位；-2&lt;strong&gt;28至2&lt;/strong&gt;28-1），但有些机器可以提供更宽的范围。这章中的许多例子都假设整数为29bits。Lisp阅读器将整数当作数字序列读取，前面可以带有符号后面可以带有小数点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      &lt;span class="mi"&gt;1&lt;/span&gt;               &lt;span class="c1"&gt;; The integer 1.&lt;/span&gt;
      &lt;span class="mi"&gt;1.&lt;/span&gt;              &lt;span class="c1"&gt;; The integer 1.&lt;/span&gt;
     &lt;span class="mi"&gt;+1&lt;/span&gt;               &lt;span class="c1"&gt;; Also the integer 1.&lt;/span&gt;
     &lt;span class="mi"&gt;-1&lt;/span&gt;               &lt;span class="c1"&gt;; The integer ?1.&lt;/span&gt;
      &lt;span class="mi"&gt;536870913&lt;/span&gt;       &lt;span class="c1"&gt;; Also the integer 1, due to overflow.&lt;/span&gt;
      &lt;span class="mi"&gt;0&lt;/span&gt;               &lt;span class="c1"&gt;; The integer 0.&lt;/span&gt;
     &lt;span class="mi"&gt;-0&lt;/span&gt;               &lt;span class="c1"&gt;; The integer 0.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;十进制以外的其它整数表示方法使用&amp;lsquo;#&amp;rsquo;后跟一个字母指定进制：&amp;lsquo;b&amp;rsquo;表示二进制，&amp;lsquo;o&amp;rsquo;表示八进制，&amp;lsquo;x&amp;rsquo;表示十六进制，或&amp;lsquo;radixr&amp;rsquo;以指明进制。指定进制的字母的大小写无关。因此，&amp;lsquo;#binteger&amp;rsquo;将以二进制读取整数，&amp;lsquo;#radixrinteger&amp;rsquo;将以指定的进制读取整数。进制指定的范围为2至36。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="mb"&gt;#b101100&lt;/span&gt; &lt;span class="c1"&gt;;=&amp;gt; 44&lt;/span&gt;
     &lt;span class="mo"&gt;#o54&lt;/span&gt; &lt;span class="c1"&gt;;=&amp;gt; 44&lt;/span&gt;
     &lt;span class="mh"&gt;#x2c&lt;/span&gt; &lt;span class="c1"&gt;;=&amp;gt; 44&lt;/span&gt;
     &lt;span class="m"&gt;#24r1k&lt;/span&gt; &lt;span class="c1"&gt;;=&amp;gt; 44&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;了解整数处理相关的函数，特别是位操作（参见[[#Bitwise_Operations][Bitwise Operations]]），它对于了解数字的二进制处理很有帮助。&lt;/p&gt;
&lt;p&gt;在29bit的二进制中，数字5看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     0 0000  0000 0000  0000 0000  0000 0101
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（我们在以4bits为一组插入了一个空格，8bits一组插入了两个空格，以便阅读。）&lt;/p&gt;
&lt;p&gt;整数-1看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     1 1111  1111 1111  1111 1111  1111 1111
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-1被描述为29个1。（This is called two's complement notation.）&lt;/p&gt;
&lt;p&gt;在这种实现方式中，最大的29bit的二进制整数值为268,435,455。它的二进制形式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     0 1111  1111 1111  1111 1111  1111 1111
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于算术函数不会检查整数是否溢出，当你将1和268,435,455相加后将得到负整数-268,435,456：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;268435455&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; -268435456&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; 1 0000  0000 0000  0000 0000  0000 0000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这章中介绍的许多函数在接收number的地方都可以接收marker。（参见[[#Markers][Markers]]。）因为这些函数的实参可以是numbers或markers，我们通常将这些参数称为number-or-marker。当参数值是marker时，将使用它的位置信息而它的buffer信息将被忽略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;most-positive-fixnum&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值是Emscs Lisp可以处理的最大的整数值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;most-negative-fixnum&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值是Emacs Lisp可以处理的最小的整数值。它是一个负数。&lt;/p&gt;
&lt;h2&gt;浮点数基础（Floating Point Basics）&lt;/h2&gt;
&lt;p&gt;Floating point用于描述非整型的数字。Floating point的精度范围与具体机器相关；它的范围与你使用的机器的C语言double类型的精度范围相同。&lt;/p&gt;
&lt;p&gt;Floating point的读取语法需要一个小数点（后面至少有一个小数），一个整数部分，或者两者都有。例如，&amp;lsquo;1500.0&amp;rsquo;、&amp;lsquo;15e2&amp;rsquo;、&amp;lsquo;15.0e2&amp;rsquo;、&amp;lsquo;1.5e3&amp;rsquo;和&amp;lsquo;.15e4&amp;rsquo;这5种写法都是表示1500。它们都是相等的。你也可以使用减号写floating point的负数，&amp;lsquo;-1.0&amp;rsquo;。&lt;/p&gt;
&lt;p&gt;多数现代的计算机都支持IEEE floating point标准，它提供正负无穷大的floating point值。它也提供了一个值类型NaN或称为&amp;ldquo;not-a-number&amp;rdquo;；算术函数函数在不能正确响应时返回这个类型的值。例如，(/ 0.0 0.0)将返回NaN。在实际应用中，Emacs Lisp中不同的NaN值之间的区别并没有实际意义，没有规则表明在某个特殊情况下需要使用哪个NaN，因此Emacs Lisp不会去区分它们（但它在打印时不会报告出标记）。下面是特殊的floating point值的读取语法：&lt;/p&gt;
&lt;p&gt;正无穷大&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;1.0e+INF&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;负无穷大&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;-1.0e+INF&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not-a-number&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;`0.0e+NaN' 或 `-0.0e+NaN'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了测试一个floating point值是否为NaN，可以将它与自身使用=比较。如果是NaN则返回nil，其它floating point值将返回t。&lt;/p&gt;
&lt;p&gt;在IEEE的floating point中-0.0与普通的0是有区别的，但是Emacs Lisp中equal和=都把他们当作相等的值。&lt;/p&gt;
&lt;p&gt;你可以使用logb提取二进制数的浮点数值（或取整数的对数）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;logb&lt;/code&gt; number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数返回number的二进制数。更精确的讲，返回值是number的以2为底的对数四舍五入的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;logb&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; 3&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;logb&lt;/span&gt; &lt;span class="mf"&gt;10.0e20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; 69&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;数字的类型判定（Type Predicates for Numbers）&lt;/h2&gt;
&lt;p&gt;这节中的函数用于测试数字，或指定数字的类型。函数intergerp和floatp可以接收任何类型的Lisp对象作为参数（否则它们将没有多大作用），但zerop判定需要一个数字作为参数。参见[[#Predicates_on_Markers][Predicates on Markers]]中的integer-or-marker-p和number-or-marker-p。&lt;/p&gt;
&lt;p&gt;－ Function: &lt;code&gt;floatp&lt;/code&gt; object&lt;/p&gt;
&lt;p&gt;这个判定测试它的参数是否为一个floating point数，如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;p&gt;floatp在Emacs 18版或更早的版本中不存在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;integrep&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个判定测试它的参数是束为一个integer，如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Funtion: &lt;code&gt;numberp&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个判定测试它是参数是否为数字（integer或floating point），如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;wholenump&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;wholenump判定（它的名称来自于短语&amp;ldquo;whole-number-p&amp;rdquo;）测试它的参数是否为一个非负的整数，如果是则返回t，否则返回nil。0被作为非负。&lt;/p&gt;
&lt;p&gt;natnump是wholenump被废弃的同义词。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function &lt;code&gt;zerop&lt;/code&gt; number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个判定测试它的参数是否为0，如果是则返回t，否则返回nil。参数必须是一个数字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(zerop x) 等同于 (= x 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Comparison-of-Numbers&lt;/h1&gt;
&lt;h2&gt;数字的比较（Comparision of Numbers）&lt;/h2&gt;
&lt;p&gt;测试数字的数值相等性，通常应该使用=，而不是eq。具有相同的数值的floating point数字对象可能是截然不同。如果使用eq比较他们，则你在测试两个值是否为相同的对象。相反，=只比较对象的数值。&lt;/p&gt;
&lt;p&gt;目前，在Emacs Lisp中每个integer值有一个唯一的Lisp对象。因此，在处理integer时eq等同于=。某些情况下使用eq比较一个未知的值和一个integer比较方便，因为如果这个未知值不是数字时eq不会产生错误&amp;mdash;&amp;mdash;它可以接收任何类型的参数。相反，如果参数不是numbers或markers，则=号将产生错误。但是，如果可以则使用=号是一个好主意，即使是在比较integers时，以防我们在将来的Emacs版本中修改integers的表示方法。&lt;/p&gt;
&lt;p&gt;有时使用equal比较两个number也比较有用；如果两个number有相同的数据类型（都是integer或都是floating point）它将两个number当作equal。相反，=可以将integer和floating point当作相等。参见[[#Equality_Predicates][EqualityPredicates]]。&lt;/p&gt;
&lt;p&gt;另一个小问题：因为floating point的数学运算是不精确的，检查两个floating point的相等性不是个好主意。通常较好的方法是比较他们的相似性。有一个函数可以完成这个比较：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;fuzz-factor&lt;/span&gt; &lt;span class="mf"&gt;1.0e-6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;approx-equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;abs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;max&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;abs&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;abs&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
              &lt;span class="nv"&gt;fuzz-factor&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Common Lisp注意：&lt;/strong&gt;在Common Lisp中比较number总是需要=因为Common Lisp实现了multi-word integers，两个不同的integer对象可以有相同的数值。Emacs Lisp对于给定的值只有一个integer对象，因为它的integer值的范围是有限的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;=&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查它的参数的数字是否相等，如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;eql&lt;/code&gt; value1 value2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;的行为类似eq，除了在两个参数都是number时。它比较number的类型的数值，因此(eql 1.0 1)返回nil，但(eql 1.0 1.0)和(eql 1 1)都返回t。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;/=&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查它的参数的数字是否相等（numerically equal），如果不是则返回t，如果是则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;&amp;lt;&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查它的第一个参数是否严格地（strictly）小于第二个参数。如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;&amp;lt;=&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查它的第一个参数是否小于或等于它的第二个参数。如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;&amp;gt;&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查它的第一个参数是否大于第二个参数。如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;&amp;gt;=&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试第一个参数是否大于或等于第二个参数。如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;max&lt;/code&gt; number-or-marker &amp;amp;rest numbers-or-markers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回参数列表中的最大值。如果参数中的任何一个值为float型，则返回值也为float型，即使这个最大的参数是以整型传入的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;min&lt;/code&gt; numbers-or-markers &amp;amp;rest numbers-or-markers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回参数列表中的最小值。如果参数中的任何一个值为float型，则返回值也为float型，即使这个最小的参数是以整型传入的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;abs&lt;/code&gt; number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回参数的绝对值。&lt;/p&gt;
&lt;h1&gt;Numeric-Conversions&lt;/h1&gt;
&lt;h2&gt;数值转换（Numeric Conversions）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;float&lt;/code&gt; number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将number转换为浮点类型。如果number本身就是浮点型的则返回它自身。&lt;/p&gt;
&lt;p&gt;有四个函数用于将浮点类型转变为整数；他们的区别在于进位处理上。它们都接收number型参数和可选的divisor参数。这两个参数都可以是整数或浮点数。divisor也可以是nil。如果divisor为nil或被忽略，则这些函数将number参数转化为整型，如果number原来是整型则返回原来的整数。如果divisor是非nil值，则将number除以divisor将并将结果转换为整数。如果divisor为0则返回arith-error。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;truncate&lt;/code&gt; number &amp;amp;optional divisor&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Processes&lt;/h1&gt;
&lt;h1&gt;进程&lt;/h1&gt;
&lt;p&gt;执行子进程并与其通讯。&lt;/p&gt;
&lt;p&gt;在操作系统术语中，进程是程序可以执行的的一块区域。Emacs是作为一个进程进行的。Emacs Lisp程序可以调用其它进程。这些被称为Emacs进程的子进程（subprocesses或processes），Emacs进程是它们的父进程。&lt;/p&gt;
&lt;p&gt;Emacs的子进程可以是同步或异步的，这取决于怎样子进程如何被创建。当创建同步子进程时，Lisp程序在继续执行之前将等侍子进程结束。当创建异步子进程时，它将与Lisp程序并行的运行。这些子进程类型在Emacs内部被描述为Lisp对象，它也被称为&amp;ldquo;进程（process）&amp;rdquo;。Lisp程序可以使用这个对象与子进程通讯或控制它。比如，你可以向它发送信号，获取状态信息，接收进程的输出，或向它发送输入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;processp&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数返回t如果object是一个进程，否则返回nil。&lt;/p&gt;
&lt;h2&gt;子进程的创建&lt;/h2&gt;
&lt;p&gt;启动子进程的函数。&lt;/p&gt;
&lt;p&gt;有三个函数创建新的子进程来运行程序。start-process，创建一个异步进程并返回一个process对象。call-process和call-process-region，创建一个同步进程并且它不会返回一个process对象。&lt;/p&gt;
&lt;p&gt;同步和异步进程将在后面的章节解释。由于这三个函数的调用方式是类似的，它们的公共参数在这里描述。&lt;/p&gt;
&lt;p&gt;在所有的情况下，函数的program参数指定要被运行的程序。如果文件未找到或不能被执行将显示错误。如果文件名是相对路径，变量exec-path包含了将搜索的目录的列表。Emacs在它启动时初始化exec-path，它的值基于环境变量PATH。标准文件名结构&amp;lsquo;~&amp;lsquo;，&amp;lsquo;.&amp;lsquo;和&amp;lsquo;..&amp;lsquo;，在exec-path中被正确的解释，但环境变量代入（比如，&amp;lsquo;$HOME&amp;lsquo;）将不被识别；使用substitute-in-file-name来处理它们。这个list中的nil指向default-directory。&lt;/p&gt;
&lt;p&gt;执行程序时将尝试在名称后添加指定的后缀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;exec-suffixes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量是一个将添加到指定程序名后的后缀名的列表。这个list应该包含&amp;rdquo;&amp;ldquo;，如果你需要使用完整的执行文件名时。这个变量的默认值是与平台相关的。&lt;/p&gt;
&lt;p&gt;注意：包含参数的程序应该只使用程序的名称；不可以包含命令行参数。应该使用 args 来提供参数。&lt;/p&gt;
&lt;p&gt;每个用于创建子进程的函数都有一个 buffer-or-name 参数用于指定程序的标准输出。它可以是一个缓冲区或缓冲区名称；如果它是一个缓冲区名称，则将在缓冲区不存在时创建这个缓冲区。它也可以是 nil，在没有过虑处理函数时这表示忽略输出。通常，应该避免将多个进程的输出发送到同一个缓冲区因为它们的输出将被随机的混合在一起。&lt;/p&gt;
&lt;p&gt;所有这三个创建子进程的函数都有一个 &amp;amp;rest 参数，args 。args 必须都是都是字符串，它们被提供给程序作为独立的命令行参数。这个字符串中的通配符和其它shell中的字符将没有特殊意义，因为字符串将被直接传递给程序。&lt;/p&gt;
&lt;p&gt;子进程将获取 default-directory 的值作为它的当前目录。&lt;/p&gt;
&lt;p&gt;子进程从 Emacs 中继承环境变量，但你指定 process-environment 来覆盖这个值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;exec-directory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值是一个字符串，包含 GNU Emacs 所包含的程序的目录名称。例如 movemail ；Rmail 使用它从收件箱中获取新邮件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User Option: &lt;code&gt;exec-path&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值是一个目录的 list ，它用于搜索作为子进程运行的程序。每个元素可以是一个目录名或 nil ，nil 表示缺省目录（变量 default-directory 的值）。exec-path 将在 program 参数不是绝对路径时被用于 call-process 和 start-process 。&lt;/p&gt;
&lt;h2&gt;Shell 参数&lt;/h2&gt;
&lt;p&gt;Lisp 程序有时需要运行 shell 并给它一个包含用户指定的文件名称的命令。这个程序应该能处理任何有效的文件名。但 shell 将对特殊字符作特殊的处理，如果这些字符包含在文件名中，将会导致 shell 迷惑。为了处理这些字符，可以使用 shell-quote-argument 函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;shell-quote-argument&lt;/code&gt; argument&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Variables&lt;/h1&gt;
&lt;h1&gt;变量&lt;/h1&gt;
&lt;p&gt;Lisp中符号名为变量名，符号的value cell存储的是变量的值。同一个符号既可以作为变量名又可以作为函数名。参见[[#Symbol Components][Symbol Components]]&lt;/p&gt;
&lt;h1&gt;Global Variable&lt;/h1&gt;
&lt;h2&gt;全局变量：变量值在任何地方都存在。&lt;/h2&gt;
&lt;p&gt;通常创建的变量都是全局变量，在整个Lisp系统中都有效。&lt;/p&gt;
&lt;p&gt;通过setq来指定符号的值。&lt;/p&gt;
&lt;h1&gt;Major和Minor Modes&lt;/h1&gt;
&lt;h2&gt;Font Lock Mode&lt;/h2&gt;
&lt;p&gt;Font Lock mode是用于根据缓冲区的语法规则自动设置某些部分的face属性的一项功能。它如何来解析缓冲区依赖于major mode；多数major mode都为自己定义了基于语法规则的face。&lt;/p&gt;
&lt;p&gt;Font Lock mode查找文本并高亮有两个方法：根据语法表通过语法解析或通过搜索（通常是正则表达式）。基于语法的方式先进行；它找出注释和字符串常量并高亮它们。然后再进行基于搜索的操作。&lt;/p&gt;
&lt;h3 id="font-lock-basics"&gt;Font Lock Basics&lt;/h3&gt;
&lt;p&gt;有多个变量可以控制Font Lock mode对文本进行高亮显示。但major modes不应该直接设置其它变量。它应该设置buffer-local变量font-lock-defaults。当Font Lock mode被开启时，将使用这个变量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;font-lock-defaults&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量由major mode设置为buffer-local变量，用于指定在那种mode下如何显示文本。当设置它时它将自动变为buffer-local变量。如果它的值为nil，Font Lock mode不会高亮，你可以使用&amp;lsquo;Edit&amp;rsquo;下的&amp;lsquo;Text Properties&amp;rsquo;中的&amp;lsquo;Faces&amp;rsquo;菜单显式的设置缓冲区中文本的外观。&lt;/p&gt;
&lt;p&gt;如果它为非nil值，它的值应该类似下面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(keywords [keywords-only [case-fold
           [syntax-alist [syntax-begin other-vars...]]]])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个元素，keywords间接指定font-lock-keywords的值，它导致基于查询的字体设置。它可以是符号，变量或函数（值是一个用于font-lock-keywords的list）。&lt;/p&gt;</content><category term="emacs"></category></entry><entry><title>Emacs Org Mode及GTD</title><link href="/emacs-org-modeji-gtd.html" rel="alternate"></link><published>2009-01-09T00:00:00+08:00</published><updated>2009-01-09T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2009-01-09:/emacs-org-modeji-gtd.html</id><summary type="html">&lt;h1&gt;Org Mode常用快捷键&lt;/h1&gt;
&lt;h2&gt;文档操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TAB 折叠或打开子项&lt;/li&gt;
&lt;li&gt;S-TAB 折叠整个文档&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;节点操作相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;M-左右 左右移动节点&lt;/li&gt;
&lt;li&gt;M-S-左右 整体左右移动节点及子节点&lt;/li&gt;
&lt;li&gt;M-上下 上移或下移条目&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;记录操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;S-上下 调整条目的优先级&lt;/li&gt;
&lt;li&gt;C-c C-t 切换条目状态&lt;/li&gt;
&lt;li&gt;C-c C-s 设置计划时间&lt;/li&gt;
&lt;li&gt;C-s C-d 设置最后完成期限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;查找操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C-c / 按关键查找&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;日程相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C-c a a 日程表，再输入d、w或m分别表示按日、周或月查看&lt;/li&gt;
&lt;li&gt;C-c a t TODO列表&lt;/li&gt;
&lt;li&gt;C-c a m 按tag查找&lt;/li&gt;
&lt;li&gt;C-c a M 按tag查找，但只针对TODO项 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;Org Mode常用快捷键&lt;/h1&gt;
&lt;h2&gt;文档操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TAB 折叠或打开子项&lt;/li&gt;
&lt;li&gt;S-TAB 折叠整个文档&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;节点操作相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;M-左右 左右移动节点&lt;/li&gt;
&lt;li&gt;M-S-左右 整体左右移动节点及子节点&lt;/li&gt;
&lt;li&gt;M-上下 上移或下移条目&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;记录操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;S-上下 调整条目的优先级&lt;/li&gt;
&lt;li&gt;C-c C-t 切换条目状态&lt;/li&gt;
&lt;li&gt;C-c C-s 设置计划时间&lt;/li&gt;
&lt;li&gt;C-s C-d 设置最后完成期限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;查找操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C-c / 按关键查找&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;日程相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C-c a a 日程表，再输入d、w或m分别表示按日、周或月查看&lt;/li&gt;
&lt;li&gt;C-c a t TODO列表&lt;/li&gt;
&lt;li&gt;C-c a m 按tag查找&lt;/li&gt;
&lt;li&gt;C-c a M 按tag查找，但只针对TODO项&lt;/li&gt;
&lt;li&gt;C-a a C 按自定义方式查找&lt;/li&gt;
&lt;/ul&gt;</content><category term="emacs"></category><category term="org"></category></entry><entry><title>Programming in Emacs Lisp笔记</title><link href="/programming-in-emacs-lispbi-ji.html" rel="alternate"></link><published>2008-07-16T00:00:00+08:00</published><updated>2008-07-16T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-16:/programming-in-emacs-lispbi-ji.html</id><summary type="html">&lt;h1&gt;序&lt;/h1&gt;
&lt;h1&gt;表处理&lt;/h1&gt;
&lt;h2&gt;Lisp列表&lt;/h2&gt;
&lt;h3 id="shu-zi-lie-biao-zhong-de-lie-biao"&gt;数字，列表中的列表&lt;/h3&gt;
&lt;p&gt;列表里也可以包含数字：(+ 2 2)。&lt;/p&gt;
&lt;p&gt;Lisp里的数据和程序都是相同的方式实现的，他们都是在括号中由单词、数字或者其它列表组成的用空白分隔的列表。因为程序看起来像数据，所以一个程序可以当作数据传递给另一个程序，这是lisp一强非常强大的功能。&lt;/p&gt;
&lt;h3 id="lispyuan-zi"&gt;Lisp原子&lt;/h3&gt;
&lt;p&gt;Lisp列表中的单词叫原子（意为原子在Lisp列表中不可再分割成更小的单位）。与原子不同，list可以分隔成更小的单位（car cdr &amp;amp; cons）。&lt;/p&gt;
&lt;p&gt;空的列表：()，被称作空列表。与其它的数据类型不同，空列表被同时看作原子和列表。&lt;/p&gt;
&lt;p&gt;与自然界的原子一样,Lisp中的原子这个名称来出现得太早（意指与自然界的原子一样，原子还可以再分割）。Lisp中部分原子，比如数组就可以进行分割。但是这种机制与列表的分隔是不同的。如果依据对列表的分隔方式来说，列表中原子就是不可分隔的了。&lt;/p&gt;
&lt;h3 id="lie-biao-zhong-de-kong-bai"&gt;列表中的空白&lt;/h3&gt;
&lt;p&gt;额外的空白被用来提高代码的可读性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;
   &lt;span class="nv"&gt;looks&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;looks&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是相同的。&lt;/p&gt;
&lt;h3 id="lie-biao-pai-ban"&gt;列表排版 …&lt;/h3&gt;</summary><content type="html">&lt;h1&gt;序&lt;/h1&gt;
&lt;h1&gt;表处理&lt;/h1&gt;
&lt;h2&gt;Lisp列表&lt;/h2&gt;
&lt;h3 id="shu-zi-lie-biao-zhong-de-lie-biao"&gt;数字，列表中的列表&lt;/h3&gt;
&lt;p&gt;列表里也可以包含数字：(+ 2 2)。&lt;/p&gt;
&lt;p&gt;Lisp里的数据和程序都是相同的方式实现的，他们都是在括号中由单词、数字或者其它列表组成的用空白分隔的列表。因为程序看起来像数据，所以一个程序可以当作数据传递给另一个程序，这是lisp一强非常强大的功能。&lt;/p&gt;
&lt;h3 id="lispyuan-zi"&gt;Lisp原子&lt;/h3&gt;
&lt;p&gt;Lisp列表中的单词叫原子（意为原子在Lisp列表中不可再分割成更小的单位）。与原子不同，list可以分隔成更小的单位（car cdr &amp;amp; cons）。&lt;/p&gt;
&lt;p&gt;空的列表：()，被称作空列表。与其它的数据类型不同，空列表被同时看作原子和列表。&lt;/p&gt;
&lt;p&gt;与自然界的原子一样,Lisp中的原子这个名称来出现得太早（意指与自然界的原子一样，原子还可以再分割）。Lisp中部分原子，比如数组就可以进行分割。但是这种机制与列表的分隔是不同的。如果依据对列表的分隔方式来说，列表中原子就是不可分隔的了。&lt;/p&gt;
&lt;h3 id="lie-biao-zhong-de-kong-bai"&gt;列表中的空白&lt;/h3&gt;
&lt;p&gt;额外的空白被用来提高代码的可读性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;
   &lt;span class="nv"&gt;looks&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;looks&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是相同的。&lt;/p&gt;
&lt;h3 id="lie-biao-pai-ban"&gt;列表排版&lt;/h3&gt;
&lt;p&gt;在Emacs Lisp mode下，有多种方法来对Lisp语句进行排版。比如，按&lt;tab&gt;键将自动缩进当前光标所在行到正确的位置。M-C-\可以格式化当前所选区域中的代码。&lt;/tab&gt;&lt;/p&gt;
&lt;h2&gt;运行一个程序&lt;/h2&gt;
&lt;p&gt;执行Lisp程序时，将执行下列三者之一：
 1. 什么都不做，返回列表本身
 2. 返回错误信息
 3. 把列表中的第一个符号当作命令执行一些操作&lt;/p&gt;
&lt;p&gt;放在列表前的单引号被称作引用（quote）；当用它来处理列表时，它告诉Lisp不要对列表进行处理。但如果列表前没有单引号，则列表前的第一个元素是特殊的，它被当作命令被执行（Lisp中这些命令被称作函数）。列表(+ 2 2)显示也与加引号的列表的不同，Lisp知道需要用+来处理列表中的其它元素：把后面的数字相加。&lt;/p&gt;
&lt;h2&gt;生成错误信息&lt;/h2&gt;
&lt;p&gt;错误信息是由内置的GNU Emacs debugger生成的。进入debugger后，可以用按键q退出debugger。&lt;/p&gt;
&lt;h2&gt;符号名称和函数定义&lt;/h2&gt;
&lt;p&gt;Lisp中同一指令可以被绑定到多个名称。&lt;/p&gt;
&lt;p&gt;另一方面,在同一时刻一个符号只允许绑定到一个函数定义上。&lt;/p&gt;
&lt;p&gt;由于Emacs Lisp的庞大，它有一套按照不同函数功能分类的符号命名规则。如：所有处理Texinfo的函数都心textinfo-开头，而处理邮件的函数以rmail-开头。&lt;/p&gt;
&lt;h2&gt;Lisp解释器&lt;/h2&gt;
&lt;p&gt;Lisp的工作方式：首先，它查看列表前是否有单引号，如果有则解释器给出这个列表。如果没有引号，解释器检查列表中的第一个元素是否有对应的函数定义，如果找到则解释器调用函数定义的指令。否则，解释器将打印出错误信息。&lt;/p&gt;
&lt;h3 id="fu-za-yi-dian-de-nei-rong"&gt;复杂一点的内容&lt;/h3&gt;
&lt;p&gt;Lisp解释器可以对没有单引号且不被括号包围的符号。Lisp解释器将检测符号是否为一个变量。&lt;/p&gt;
&lt;p&gt;一些函数不是普通的方法。被用来处理一些特殊的工作，比如定义一个函数。&lt;/p&gt;
&lt;p&gt;Lisp求值时，将先对列表内部嵌入的列表进行求值，从内向外。&lt;/p&gt;
&lt;p&gt;Lisp解释器工作时从左向右，从一个语句到另一个语句（从上至下）。&lt;/p&gt;
&lt;h3 id="bian-yi-byte-compiling"&gt;编译（Byte Compiling）&lt;/h3&gt;
&lt;p&gt;Lisp解释器可以解释两种类型的代码：人可以读的代码和另一种被你为byte compiled code的代码。编译过的代码执行更快。&lt;/p&gt;
&lt;p&gt;可以用byte-compile-file编译代码。被编译好的字节码文件扩展名为.elc。&lt;/p&gt;
&lt;h2&gt;求值&lt;/h2&gt;
&lt;p&gt;当Lisp解释器工作于一个语句上时，这个活动的过程被称为求值（evaluation）。求值完成后解释器将返回函数定义的执行结果，或者在函数出错时给出错误信息。&lt;/p&gt;
&lt;h3 id="dui-nei-bu-lie-biao-qiu-zhi"&gt;对内部列表求值&lt;/h3&gt;
&lt;p&gt;可以把光标停留在内部列表右括号的后面，按C-x C-e执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把光标放在括号后面，或者把光标放在代码下面的空行的行首，都可以得到8。如果用C-x C-e对一个数字求值将得到数字自身，这也是数字与符号的不同。&lt;/p&gt;
&lt;h2&gt;变量&lt;/h2&gt;
&lt;p&gt;Emacs Lisp中符号可以有一个值绑定到它或者一个函数定义绑定到它。两者不同在于，函数定义是指令的集合。值是可以修改的数字或者其它。符号的值可以是任意的Lisp表达式，比如符号、数字、列表、字符串等。有值的符号通常被称作变量。&lt;/p&gt;
&lt;p&gt;符号可以同时有一个函数定义和值。两个是分开的。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;test_f&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="s"&gt;"test2"&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"bbb"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;test_f&lt;/span&gt; &lt;span class="s"&gt;"124"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;test_f&lt;/span&gt;          &lt;span class="nv"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;变量值&lt;/span&gt;&lt;span class="s"&gt;"124"&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;test_f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="nv"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;函数调用显示&lt;/span&gt;&lt;span class="s"&gt;"bbb"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="fill-columnyi-ge-bian-liang-de-li-zi"&gt;fill-column一个变量的例子&lt;/h3&gt;
&lt;p&gt;变量fill-column，每个Emacs缓冲区，这个符号通常被设置成72或70,但也可能有不同的值。可以用C-x C-e对fill-column这个符号求值。&lt;/p&gt;
&lt;p&gt;符号可以有值绑定到上面，我们可以绑定变量到值、数字、字符串、列表甚至是函数定义。&lt;/p&gt;
&lt;h3 id="han-shu-fu-hao-wei-ding-yi-shi-de-cuo-wu-xin-xi"&gt;函数符号未定义时的错误信息&lt;/h3&gt;
&lt;p&gt;当我们对fill-column求值时将得到变量的值时并没有在符号外面添加括号。这是因为我们不打算将符号当作函数的名称。&lt;/p&gt;
&lt;p&gt;如果fill-column是列表中的第一个元素或者唯一的元素，Lisp解释器将查找绑定到符号上的函数定义。但fill-column不是一个函数定义。当我们对&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fill-column&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;求值时将产生错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数fill-column未定义。&lt;/p&gt;
&lt;p&gt;按q退出调试器。&lt;/p&gt;
&lt;h3 id="fu-hao-mei-you-zhi-shi-de-cuo-wu-xin-xi"&gt;符号没有值时的错误信息&lt;/h3&gt;
&lt;p&gt;例如对&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中的+号求值（光标停留在+的后面，按C-x C-e）时将产生错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个错误信息与上节函数未定义时的不同。表示变量+未定义。&lt;/p&gt;
&lt;h2&gt;参数&lt;/h2&gt;
&lt;h3 id="can-shu-lei-xing"&gt;参数类型&lt;/h3&gt;
&lt;p&gt;传递给函数的数据类型依赖于函数需要使用何种信息。比如+函数需要数字类型的参数。concat需要字符串类型的参数。substring是一个特殊一点的函数（称作原子粉碎机），它能把从原子类型中解析出一部分数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="s"&gt;"The quick brown fox jumped."&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bian-liang-zhi-huo-zhe-lie-biao-dang-zuo-can-shu"&gt;变量值或者列表当作参数&lt;/h3&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;fill-column&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="s"&gt;"The "&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;number-to-string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;fill-column&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="s"&gt;" red foxes."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="can-shu-shu-liang"&gt;参数数量&lt;/h3&gt;
&lt;p&gt;一些函数可以带多个参数，例如：+、*。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;; =&amp;gt; 0&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;; =&amp;gt; 1&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;; =&amp;gt; 3&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;; =&amp;gt; 3&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; =&amp;gt; 12&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; ==&amp;gt; 60&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shi-yong-cuo-wu-lei-xing-de-can-shu"&gt;使用错误类型的参数&lt;/h3&gt;
&lt;p&gt;当传递了错误的参数类型时Lisp解释器将产生错误信息。例如对&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ss"&gt;'hello&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;求值的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error:
         (wrong-type-argument number-or-marker-p hello)
  +(2 hello)
  eval((+ 2 (quote hello)))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;错误信息的第一部分直截告诉我们参数类型错误(wrong-type-argument。第二个部分看起来有些迷惑number-or-marker-p，这部分告诉了我们+函数所需要的参数类型。&lt;/p&gt;
&lt;p&gt;符号number-or-marker-p说明Lisp解释器检查提供给函数的信息（参数的值）是否是数字或marker（C-@或C-&lt;spc&gt;设置的位置，mark可以被当作数字进行处理－mark在缓冲区中的字符位置）。Emacs Lisp中+可以将数字和作为数字的marker位置相加。&lt;/spc&gt;&lt;/p&gt;
&lt;p&gt;number-of-marker-p中的p是早期Lisp程序中的用法。p是'predicate'的简写。是早期Lisp研究者所使用的术语，predicate指明了函数用于决定一些属性是true还是false。因此p告诉我们number-or-marker-p是一个根据参数是否为数字或者marker而返回true或者false的函数。另一个以p结尾的Lisp符号包括zerop，这是一个检查参数值是否为0的函数，listp则是一个检测参数是否为一个列表（list）的函数。&lt;/p&gt;
&lt;p&gt;最后，错误信息的其它部分将显示出符号hello。这是传递给+的参数值。&lt;/p&gt;
&lt;h3 id="messagehan-shu"&gt;message函数&lt;/h3&gt;
&lt;p&gt;message函数显示信息到回显区。占位符%s表示字符串，%d为整数。例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"This message appears in the echo area!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"The name of this buffer is: %s."&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"The value of fill-column is %d."&lt;/span&gt; &lt;span class="nv"&gt;fill-column&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"There are %d %s in the office!"&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;fill-column&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"pink elephants"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"He saw %d %s"&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;fill-column&lt;/span&gt; &lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="s"&gt;"red "&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt;
                  &lt;span class="s"&gt;"The quick brown foxes jumped."&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="s"&gt;" leaping."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;设置变量值&lt;/h2&gt;
&lt;p&gt;有几种方法给变量赋值。set或setq函数，let函数。&lt;/p&gt;
&lt;h3 id="shi-yong-set"&gt;使用set&lt;/h3&gt;
&lt;p&gt;要把符号flowers的值设置为列表'(rose violet daisy buttercup)，可以执行下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;'flowers&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;rose&lt;/span&gt; &lt;span class="nv"&gt;violet&lt;/span&gt; &lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;列表(rose violet daisy buttercup)将显示在回显区。这是set函数的返回值。另一方面符号flowers被绑定到列表；这样符号flower可以看作一个变量，它具有那个列表值。&lt;/p&gt;
&lt;p&gt;在对set语句求值后，就可以对符号flowers求值，它将返回set设置的值。
当对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;flowers&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;求值时，回显区将显示(ros violet daisy buttercup)。&lt;/p&gt;
&lt;p&gt;这时如果对'flowers求值，将在回显区看到符号自身flowers。&lt;/p&gt;
&lt;p&gt;当使用set时，需要在两个参数前加单引号，除非你想对它们进行求值。如果没有加单引号，则解释器将先对参数进行求值，例如对flowers求值，如果flowers之前未赋过值，则将报错，如果对flowers的求值返回了值，则后面的变量值将赋给对flowers求值所返回的值上。这种情况非常少见。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;'flowers&lt;/span&gt; &lt;span class="ss"&gt;'aaa&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;flowers&lt;/span&gt; &lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="nv"&gt;aaa&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="nv"&gt;-&amp;gt;显示&lt;/span&gt;&lt;span class="s"&gt;"123"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shi-yong-setq"&gt;使用setq&lt;/h3&gt;
&lt;p&gt;setq与set类似，但setq将自动给第一个参数前加单引号。另一方面，setq允许在一条语句中同时设置多个不同的变量值。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;carnivores&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt; &lt;span class="nv"&gt;leopard&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;'carnivores&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt; &lt;span class="nv"&gt;leopard&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相同。&lt;/p&gt;
&lt;p&gt;setq可以给多个变量赋值，例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;trees&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;herbivores&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;antelope&lt;/span&gt; &lt;span class="nv"&gt;zebra&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尽管我们一直在用赋值（'assign'），但有另一种方式思考set和setq；即set和setq使一个符号指向（point）一个列表。&lt;/p&gt;
&lt;h3 id="ji-shu-qi"&gt;计数器&lt;/h3&gt;
&lt;p&gt;这是一个在计数器中使用setq的例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;; 初始化&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;    &lt;span class="c1"&gt;; 增加&lt;/span&gt;
&lt;span class="nv"&gt;counter&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lisp程序由表达式组成，表达式可以是列表或者原子。&lt;/li&gt;
&lt;li&gt;列表由零个或者多个原子或内部列表组成，各元素由空白分隔，被括号包括。列表可以为空。&lt;/li&gt;
&lt;li&gt;原子是多个字符符号，比如：forward-paragraph，单字符比如+，双引号间的字符串，数字。&lt;/li&gt;
&lt;li&gt;对自身求值的数字。&lt;/li&gt;
&lt;li&gt;双引号间的字符串也将对自身求值。&lt;/li&gt;
&lt;li&gt;当对符号自身求值时，将返回它指向的值。&lt;/li&gt;
&lt;li&gt;当对列表求值时，Lisp解释器查看列表中的第一个符号所绑定的函数定义。然后按定义的指令执行。&lt;/li&gt;
&lt;li&gt;单引号，'，告诉Lisp解释器应该把后面的表达式按原样返回，不对它进行求值。&lt;/li&gt;
&lt;li&gt;参数是传递给函数的信息。函数是列表中的第一个元素，其它元素被求值并作为参数传递给函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;实践&lt;/h1&gt;
&lt;h2&gt;执行代码&lt;/h2&gt;
&lt;p&gt;通过C-x C-e执行代码&lt;/p&gt;
&lt;h2&gt;缓冲区名称&lt;/h2&gt;
&lt;p&gt;buffer-name和buffer-file-name这两个函数用于区分文件和缓冲区。&lt;/p&gt;
&lt;p&gt;如果是在&lt;em&gt;scratch&lt;/em&gt;缓冲区中，可以用C-u C-x C-e运行代码，这样运行结果会显示在表达式的后面。&lt;/p&gt;
&lt;h2&gt;获取缓冲区&lt;/h2&gt;
&lt;p&gt;buffer-name可以获取缓冲区名称，current-buffer可以返回缓冲区本身。&lt;/p&gt;
&lt;p&gt;other-buffer可以获得上一次访问过的缓冲区。&lt;/p&gt;
&lt;h2&gt;切换缓冲区&lt;/h2&gt;
&lt;p&gt;switch-to-buffer可以切换当前缓冲区。产生与按C-x b类似的效果。
下面的代码将切换当前缓冲区到上次访问过的缓冲区：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;switch-to-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;other-buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一个函数set-buffer也是用于切换缓冲区的，但与switch-to-buffer不同在于它只改变程序处理的缓冲区，并不改变当前屏幕显示的缓冲区。&lt;/p&gt;
&lt;h2&gt;缓冲区大小和光标位置&lt;/h2&gt;
&lt;p&gt;几个简单的函数用于缓冲区大小和检测光标位置：buffer-size,point,point-min,point-max。&lt;/p&gt;
&lt;h1&gt;编写函数&lt;/h1&gt;
&lt;h2&gt;关于基本函数(Primitive Function)&lt;/h2&gt;
&lt;p&gt;除了少数C编写的基本函数外，所有的函数都是由其它函数语句定义的。当编写自己函数时，C所编写的函数与Emacs Lisp编写的函数看起来是一样的。&lt;/p&gt;
&lt;p&gt;除非你想去考究，否则不需要知道知道一个函数是用Emacs Lisp编写的还是C编写的。&lt;/p&gt;
&lt;h2&gt;defun&lt;/h2&gt;
&lt;p&gt;在一个函数的定义中，在defun关键字后面有5个部分：
 1. 函数符号的名称
 2. 传递给函数的参数列表,如果没有参数则传递给函数的是一个空列表,()
 3. 描述函数的文档字符串。（可选）
 4. 当用户按M-x func_name以交互方式运行函数时的提示信息;或按键组合。（可选）
 5. 函数体&lt;/p&gt;
&lt;p&gt;模板&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;function-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;arguments...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="s"&gt;"optional-documentation..."&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="nv"&gt;argument-passing-info&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; optional&lt;/span&gt;
    &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个实例（非交互）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Multiply NUMBER by seven."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数参数列表中的变量名对每个函数是私有的，不同函数的参数名可以相同。&lt;/p&gt;
&lt;p&gt;参数列表后面是描述函数功能的文档字符串。也就是按C-h f name_of_function时所看到的信息。&lt;/p&gt;
&lt;p&gt;在调用的时候使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尽管传递给函数的参数外面没有加括号。但函数能计算出来。&lt;/p&gt;
&lt;p&gt;当对这个表达式求值时将出错。这是因为我们只编写了函数定义，但并未告诉机器在Emacs中安装(install/load)这个函数定义。&lt;/p&gt;
&lt;h2&gt;安装函数定义&lt;/h2&gt;
&lt;p&gt;将光标停留上节所写的函数定义的最后一个括号后面，按C-x C-e。这时回显区将显示multiply-by-seven(这表示函数定义被计算，计算的返回值是所定义的函数的名字)。这时函数就已经安装好，可以在像使用Emacs中其它函数一样使用了。&lt;/p&gt;
&lt;h3 id="an-zhuang-hou-de-xiao-guo"&gt;安装后的效果&lt;/h3&gt;
&lt;p&gt;可以在&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;的最后一个括号后按C-x C-e，回显区将显示计算结果21。
还可以查看函数帮助文档。按C-h f(describe-function) function_name，multiply-by-seven。y&lt;/p&gt;
&lt;h3 id="xiu-gai-han-shu-ding-yi"&gt;修改函数定义&lt;/h3&gt;
&lt;p&gt;可以直接修改函数的定义，然后重新把光标停留在在函数定义的最后一个括号后面按C-x C-e。&lt;/p&gt;
&lt;h2&gt;制作交互式函数&lt;/h2&gt;
&lt;p&gt;用户可以通过按键或者M-x 函数名来调用。&lt;/p&gt;
&lt;h3 id="jiao-hu-shi-han-shu-multiply-by-sevenyu-lan"&gt;交互式函数multiply-by-seven预览&lt;/h3&gt;
&lt;p&gt;交互式版本的multiply-by-seven：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Multiply NUMBER by seven."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"The result is %d"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装上面的函数后，可以使用C-u number参数，然后输入M-x multiply-by-seven然后回车。回显区将显示计算结果。&lt;/p&gt;
&lt;p&gt;调用这个函数的两种方法：
 1. 输入前缀参数，然后输入M-x和函数名，比如C-u 3 M-x forward-sentence
 2. 输入任意按键绑定例如：C-u 3 M-e&lt;/p&gt;
&lt;p&gt;输入C-u不带数字，则参数默认为4。&lt;/p&gt;
&lt;h3 id="jiao-hu-shi-han-shu-multiply-by-seven"&gt;交互式函数multiply-by-seven&lt;/h3&gt;
&lt;p&gt;在上节所写的函数中,表达式(interactive "p")中的"p"告诉Emacs把前缀参数(C-u后带的参数)作为函数参数(number)传递给函数。&lt;/p&gt;
&lt;p&gt;message是一个Emacs Lisp函数，用于显示信息给用户。&lt;/p&gt;
&lt;h2&gt;不同的interactive选项&lt;/h2&gt;
&lt;p&gt;emacs有超过20过的选项可以传递给interactive。具体可以查阅elisp手册。&lt;/p&gt;
&lt;p&gt;例如，字符r，Emacs将把当前选中区域作为两个参数传递给函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B告诉Emacs提示用户输入缓冲区名称，并把该缓冲区作为参数传递给函数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BAppend to buffer:"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当函数需要2个或更多参数时，可以在interactive中添加新的部分。每个部分用\n分隔。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;name-of-function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BAppend to buffer: \nr"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;body-of-function...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果一个函数不需要参数，可以直接使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;永久的安装函数&lt;/h2&gt;
&lt;p&gt;安装函数的几种方法：
 1. 把代码放在.emacs文件中。
 2. 把代码放在其它文件中，使用load函数装载文件。
 3. 如果所有用户都要使用可以把代码放在site-init.el文件中&lt;/p&gt;
&lt;h2&gt;let&lt;/h2&gt;
&lt;p&gt;let表达式是在多数函数中都要用到的一个Lisp表。&lt;/p&gt;
&lt;p&gt;let用于修改或者绑定值到符号上。&lt;/p&gt;
&lt;h3 id="let-ke-yi-fang-zhi-hun-luan"&gt;let 可以防止混乱&lt;/h3&gt;
&lt;p&gt;let创建的是本地变量，作用范围止于let表达式范围内，不影响let外部的变量。let可以一次创建多个变量，并给每个变量赋值，初始值也可以是nil。在let执行完后，将返回最后一个语句的值。&lt;/p&gt;
&lt;h3 id="letbiao-da-shi-de-zu-cheng"&gt;let表达式的组成&lt;/h3&gt;
&lt;p&gt;let表达式分为3个部分，第一部分是符号"let"。第二个部分被称为变量列表（varlist），每个元素都一个符号或者包含二个元素的列表，每个列表中的一个元素是一个符号。第三部分是let的体（body）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;variable&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;variable&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="letbiao-da-shi-ju-li"&gt;let表达式举例&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zebra&lt;/span&gt; &lt;span class="ss"&gt;'stripes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;tiger&lt;/span&gt; &lt;span class="ss"&gt;'fierce&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"One kind of animal has %s and another is %s."&lt;/span&gt;
           &lt;span class="nv"&gt;zebra&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="letyu-ju-zhong-de-wei-chu-shi-hua-bian-liang"&gt;let语句中的未初始化变量&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;birch&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;pine&lt;/span&gt;
      &lt;span class="nv"&gt;fir&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="ss"&gt;'some&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
   &lt;span class="s"&gt;"Here are %d variables with %s, %s, and %s value."&lt;/span&gt;
   &lt;span class="nv"&gt;birch&lt;/span&gt; &lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的pine、fir的值都是nil。&lt;/p&gt;
&lt;h2&gt;if语句&lt;/h2&gt;
&lt;p&gt;if的基本理念就是，如果if测试为真则表达式被执行。&lt;/p&gt;
&lt;h3 id="if-xi-jie"&gt;if 细节&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;true-or-false-test&lt;/span&gt;
    &lt;span class="nv"&gt;action-to-carry-out-if-test-is-true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;type-of-animal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;characteristic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print message in echo area depending on CHARACTERISTIC.&lt;/span&gt;
&lt;span class="s"&gt;If the CHARACTERISTIC is the symbol &lt;/span&gt;&lt;span class="ss"&gt;`fierce'&lt;/span&gt;&lt;span class="s"&gt;,&lt;/span&gt;
&lt;span class="s"&gt;then warn of a tiger."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="nv"&gt;characteristic&lt;/span&gt; &lt;span class="ss"&gt;'fierce&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"It's a tiger!"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;type-of-animal&lt;/span&gt; &lt;span class="ss"&gt;'fierce&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;type-of-animal&lt;/span&gt; &lt;span class="ss"&gt;'zebra&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(type-of-animal 'fierce)将在回显区显示"It's a tiger!"，第二行将返回nil。&lt;/p&gt;
&lt;h2&gt;if-then-else语句&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;true-or-false-test&lt;/span&gt;
    &lt;span class="nv"&gt;action-to-carry-out-if-the-test-returns-true&lt;/span&gt;
  &lt;span class="nv"&gt;action-to-carry-out-if-the-test-returns-false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;type-of-animal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;characteristic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; Second version.&lt;/span&gt;
  &lt;span class="s"&gt;"Print message in echo area depending on CHARACTERISTIC.&lt;/span&gt;
&lt;span class="s"&gt;If the CHARACTERISTIC is the symbol &lt;/span&gt;&lt;span class="ss"&gt;`fierce'&lt;/span&gt;&lt;span class="s"&gt;,&lt;/span&gt;
&lt;span class="s"&gt;then warn of a tiger;&lt;/span&gt;
&lt;span class="s"&gt;else say it's not fierce."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="nv"&gt;characteristic&lt;/span&gt; &lt;span class="ss"&gt;'fierce&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"It's a tiger!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"It's not fierce!"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Emacs Lisp中的真值与假值&lt;/h2&gt;
&lt;p&gt;符号nil作为假值，nil外的其它值都为真。&lt;/p&gt;
&lt;h3 id="dui-nilde-jie-shi"&gt;对nil的解释&lt;/h3&gt;
&lt;p&gt;在Emacs Lisp中对符号nil有两种解释。一种代表空的列表，另一种为真假判断中的假值。nil可以被写作：()、nil。对Lisp解释器来说两种写法是相同的。推荐用nil表示false，()表示空的列表。&lt;/p&gt;
&lt;p&gt;在Emacs lisp里，任何非nil非空列表的值都被当作真。&lt;/p&gt;
&lt;h2&gt;save-excursion&lt;/h2&gt;
&lt;p&gt;save-excursion函数保存当前的point和mark，然后执行函数体，然后恢复point和mark的位置。它的主要目的是为了保存用户在调用函数前所设置的point和mark。&lt;/p&gt;
&lt;h3 id="pointhe-mark"&gt;point和mark&lt;/h3&gt;
&lt;p&gt;Point指当前光标之前的一个位置。在Emacs Lisp中，point是一个整数。缓冲区中第一个字符的point数字是1，函数point返回当前光标位置。&lt;/p&gt;
&lt;p&gt;Mark是缓冲区中的另一个位置。其值是通过C-&lt;spc&gt;（set-mark-command）设置的。通过C-x C-x（exchange-point-and-mark）可以在point和mark间跳转。如果设置了另一个mark，前一个mark被保存到mark ring里去。可以通过C-u C-&lt;spc&gt;将光标跳转到被保存的mark。&lt;/spc&gt;&lt;/spc&gt;&lt;/p&gt;
&lt;p&gt;缓冲区中point和mark之间的区域叫作region。大量命令用于region上，例：center-region，count-lines-region，kill-region和print-region。&lt;/p&gt;
&lt;p&gt;Emacs里函数工作时经常移动point尽管用户感觉不到这一点。例如：count-lines-region。为防止用户的point被移动到非预期的位置（相对于执行函数之前），save-excursion常用于保存point的位置，使用save-excursion是一个好的习惯。&lt;/p&gt;
&lt;p&gt;不论代码运行是否成功（非正常结束），save-execursion总是恢复point和mark的位置。&lt;/p&gt;
&lt;p&gt;另外，save-excursion也将记录当前所在的缓冲区，并恢复它。这意味着可以在代码中修改当前缓冲区，结果后save-excursion将切换回原来的缓冲区。&lt;/p&gt;
&lt;h3 id="save-excursionyu-ju-mo-ban"&gt;save-excursion语句模板&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更详细一些的模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="nv"&gt;first-expression-in-body&lt;/span&gt;
  &lt;span class="nv"&gt;second-expression-in-body&lt;/span&gt;
  &lt;span class="nv"&gt;third-expression-in-body&lt;/span&gt;
   &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="nv"&gt;last-expression-in-body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Emacs Lisp代码中，save-excursion语句通常放在let语句中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;varlist&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;p&gt;部分函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eval-last-sexp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对当前poing前的表达式求值。通常被绑定到C-x C-e上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;defun&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义函数。这个表(form)有5个部分：名称、参数定义、文档字符串、可选的交互式描述，函数体定义。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;back-to-indentation&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Move point to first visible character on line."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;skip-chars-forward&lt;/span&gt; &lt;span class="s"&gt;" \t"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;interactive&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;告诉解释器函数可以交互。跟在字符串后的特殊的表（form）可以作为参数传递给函数。多个部分之间用\n分隔。常用的字符代码如下：
b | 一个buffer的名称
f | 一个文件名
p | 数字前缀（按C-u时输入的数字，默认为4）
r | 传递poing和mark两个数字参数，小的数字在前。这是唯一一个传递两个参数的字符代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;let&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;申明并初始化作用于let函数体的局部变量，变量值可以为nil。在let内部，Lisp解释器对外部的同名变量不可见。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;bar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
   &lt;span class="s"&gt;"This buffer is %s and has %d characters."&lt;/span&gt;
   &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="nv"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;save-excursion&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录当前point、mark和当前所在缓冲区，在函数体执行完后恢复这些值。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"We are %d characters into this buffer."&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;if&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对第一个参数求值；如果返回的为true，则对第二个参数求值；否则如果第三个参数存在，则对第三个参数求值。if被称作条件语句。Emacs Lisp也有其它的条件语句，但if是最常用的。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-equal&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;number-to-string&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;emacs-version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"This is version 21 Emacs"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"This is not version 21 Emacs"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;equal&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eq&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查两个对象是否相同。equal检测是否&amp;rdquo;相同（same）&amp;ldquo;，如果两个对象有相似的结构和内容就返回true。eq则需要两个参数指向同一个对象才返回true。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;lt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;lt;=&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;=&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的比较函数的参数都必须是数字或者mark（C-&lt;spc&gt;产生的）。&lt;/spc&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;string&amp;lt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string-lessp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string=&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string-equal&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;string-lessp函数检测第一个参数是否小于第二个参数。string&amp;lt;是它的简写。传递给string-lessp的参数必须是字符串或者符号（symbols）。空字符串""小于任何其它字符串。&lt;/p&gt;
&lt;p&gt;string-equal用于检查字符串的一致性。string=是它的简写。没有针对字符串&amp;gt;、&amp;gt;=或&lt;code&gt;&amp;lt;=&lt;/code&gt;的函数定义。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;message&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在回显区显示消息。第一个参数是一个字符串，它可以包含%s，%d或%c这些占位符。%s必须对应于字符串或符号。%d对应于整数。%c必须是一个ascii编码数字。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setq&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;setq函数设置第一个变量的值为第二个变量。第一个变量自动被加上单引号。setq可以同时对多个变量赋值。set只能给带两个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;buffer-name&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不需要参数，返回缓冲区的名字。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;buffer-file-name&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不需要参数，返回缓冲区所对应的文件名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;current-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回当前活动的缓冲区；它可以不是当前屏幕上显示的缓冲区（编程时使用）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;other-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回最近访问过的访问区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;switch-to-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择一个缓冲区显示到当前用户窗口。磁盘被绑定到C-x b。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在程序运行时切换Emacs的焦点到某个缓冲区。并不会改变当前窗口中显示的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;buffer-size&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回当前缓冲区的字符数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;point&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回当前光标所在位置，返回值是从缓冲区开始处到光标位置的字符数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;point-min&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回当前缓冲区的开始位置。默认为1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;point-max&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回当前缓冲区的结束位置。&lt;/p&gt;
&lt;h1&gt;部分与缓冲区有关的函数&lt;/h1&gt;
&lt;h2&gt;查找更多信息&lt;/h2&gt;
&lt;p&gt;可以通过C-h f查看函数的说明，C-h v查看变量的说明，这些说明就是Emacs Lisp代码中的文档字符串。&lt;/p&gt;
&lt;p&gt;在20或更高版本以后，可以用describe-function（C-h f）将告诉你函数定义的位置。在文件名上按回车（这个操作是help-follow函数调用）将打开函数定义。&lt;/p&gt;
&lt;p&gt;etags：在代码中如果想要查看函数源文件，可以使用find-tags函数跳转到源文件上去。find-tags可以处理多种语法，不限于Lisp和C，也可以工作于非编程语言如Texinfo文档。在Texinfo文档里调用find-tags将跳转到对应的文件节点。&lt;/p&gt;
&lt;p&gt;find-tags函数依赖于标签表'tags tables'，它记录了函数、变量和其它信息的位置。&lt;/p&gt;
&lt;p&gt;使用M-.调用find-tags函数，然后在提示符后要查找的函数名，比如mark-whole-buffer。Emacs将转到显示该函数源码缓冲区。&lt;/p&gt;
&lt;p&gt;符号表'tags table'通常是一个名为TAGS的文件。Emacs源码的TAGS存储在/usr/local/share/emacs目录中。但可以通过M-x visit-tags-table命令指定一个符号表。&lt;/p&gt;
&lt;p&gt;通过etags命令可以创建符号表。使用M-x cd命令或C-x d（dired）切换到要建立符号表的目录，然后运行编译命令执行&lt;code&gt;etags *.el&lt;/code&gt;命令。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;M-x&lt;/span&gt; &lt;span class="nv"&gt;compile&lt;/span&gt; &lt;span class="nv"&gt;RET&lt;/span&gt; &lt;span class="nv"&gt;etags&lt;/span&gt; &lt;span class="nv"&gt;*.el&lt;/span&gt; &lt;span class="nv"&gt;RET&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件中的代码通常称为库。通过C-h p可以查看Emacs Lisp的标准库。&lt;/p&gt;
&lt;h2&gt;简化版的beginning-of-buffer函数定义&lt;/h2&gt;
&lt;p&gt;beginning-of-buffer命令将把光标移动到缓冲区起始位置，并把mark设置在前一个位置。通常被绑定到M-&amp;lt;上。&lt;/p&gt;
&lt;p&gt;简化版本的函数具有与标准库版本类似的功能，但不包含完整的功能。&lt;/p&gt;
&lt;p&gt;设想一下该函数的定义应包括：包含能让用户交互的表达式，比如按M-x beginning-of-buffer或按键C-&amp;lt;；必须包含能在原位置设置mark的代码；必须包含让光标移动到缓冲区起始位置的代码。&lt;/p&gt;
&lt;p&gt;简化版本的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;simplified-beginning-of-buffer&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Move point to the beginning of the buffer;&lt;/span&gt;
&lt;span class="s"&gt;leave mark at previous position."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与其它函数一样，这个函数也包含了defun需要的五个部分：
 1. 函数名，这里使用的：simplified-beginning-of-buffer。
 2. 参数列表：这里是一个空列表()。
 3. 文档字符串。
 4. 交互表达式。
 5. 函数体。&lt;/p&gt;
&lt;p&gt;这个函数定义中，参数列表为空，意味着函数不需要任何参数。（查看完整函数定义时，我们可以看到它可能传递了可选的参数）。&lt;/p&gt;
&lt;p&gt;interactive语句告诉Emacs函数允许交互。这个例子中interactive没有参数，因此调用simplified-beginning-of-buffer时也不需要参数。&lt;/p&gt;
&lt;p&gt;函数体由两行代码组成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(push-mark)执行时将在当前光标所在位置设置mark，之前的mark被保存到mark ring上。&lt;/p&gt;
&lt;p&gt;(goto-char (point-min))将光标转移到缓冲区起始位置。&lt;/p&gt;
&lt;p&gt;在阅读这些代码遇到陌生的函数时，比如goto-char，可以使用describe-function命令，按C-h f然后输入函数名。describe-function将在一个&lt;em&gt;Help&lt;/em&gt;窗口打印出函数的帮助文档。&lt;/p&gt;
&lt;p&gt;调用describe-function时，如果光标停留在函数名上，describe-function默认将把光标所在位置的函数名作为参数。&lt;/p&gt;
&lt;p&gt;end-of-buffer的函数定义与beginning-of-buffer类似，只是用(goto-char (point-max))替换(goto-char (point-min))。&lt;/p&gt;
&lt;h2&gt;mark-whole-buffer的定义&lt;/h2&gt;
&lt;p&gt;mark-whole-buffer函数标把整个缓冲区标记为区域。把point设置在缓冲区开始位置，mark设置在缓冲区结束位置。通常被绑定到C-x h上。&lt;/p&gt;
&lt;h3 id="mark-whole-bufferyu-lan"&gt;mark-whole-buffer预览&lt;/h3&gt;
&lt;p&gt;在Emacs 20中，完整的函数代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;mark-whole-buffer&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Put point at beginning and mark at end of buffer."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与函数定义模板类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;name-of-function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;argument-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;interactive-expression...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="mark-whole-bufferde-han-shu-ti"&gt;mark-whole-buffer的函数体&lt;/h3&gt;
&lt;p&gt;mark-whole-buffer的函数体仅有3行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行(push-mark (point))与simplified-beginning-of-bufer函数相同，那里写的是(push-mark。两种写法都是告诉解释器在当前光标所在位置设置mark。&lt;/p&gt;
&lt;p&gt;下一行(push-mark (point-max))在缓冲区结尾设置mark。设置这个mark后，前一行设置的mark将进入mark ring。这意味着你可以通过按两次C-u C-&lt;spc&gt;重新回到那个位置。&lt;/spc&gt;&lt;/p&gt;
&lt;p&gt;在Emacs 21里，(push-mark (point-max))看起来更复杂：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数增加了两上参数，第二个参数为nil。这告诉函数，在设置mark后，需要显示消息：'Mark set'。第三个参数t，它告诉push-mark如果当Transient Mark mode是开启状态，则应该将mark设置为活动状态。Transient Mark mode将高亮显示当前活动的区域，它默认是关闭的。&lt;/p&gt;
&lt;p&gt;最后一行(goto-char (point-min))与beginning-of-buffer完全一样。这个语句将光标移动到缓冲区开始位置。运行的结果：point被设置到缓冲区开始位置，mark被设置为缓冲区结束位置。整个缓冲区被标记为区域（region）。&lt;/p&gt;
&lt;h2&gt;append-to-buffer的定义&lt;/h2&gt;
&lt;p&gt;append-to-buffer函数从当前缓冲区中拷贝选中区域到指定的缓冲区中。&lt;/p&gt;
&lt;h3 id="append-to-bufferhan-shu-yu-lan"&gt;append-to-buffer函数预览&lt;/h3&gt;
&lt;p&gt;append-to-buffer命令使用insert-buffer-substring函数来拷贝区域。insert-buffer-substring函数将缓冲区的一部分作为字符串（substring）插入到另一个缓冲区。完整的函数代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;append-to-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Append to specified buffer the text of the region.&lt;/span&gt;
&lt;span class="s"&gt;It is inserted into that buffer before its point.&lt;/span&gt;

&lt;span class="s"&gt;When calling from a program, give three arguments:&lt;/span&gt;
&lt;span class="s"&gt;a buffer or the name of one, and two character numbers&lt;/span&gt;
&lt;span class="s"&gt;specifying the portion of the current buffer to be copied."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BAppend to buffer: \nr"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;current-buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer-create&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="append-to-bufferhan-shu-zhong-de-jiao-hu-biao-da-shi"&gt;append-to-buffer函数中的交互表达式&lt;/h3&gt;
&lt;p&gt;append-to-buffer函数需要与用户交互，因此函数使用了interactive表达式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BAppend to buffer: \nr"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句有一个双引号包含的字符串，该字符串被\n分隔为两部分。&lt;/p&gt;
&lt;p&gt;第一部分BAppend to bufefer：这里的B告诉Emacs传递一个缓冲区给函数。Emacs将在回显区用B后面的字符串（Append to buffer:）提示用户输入缓冲区名称。然后Emacs将该缓冲区到参数buffer上。&lt;/p&gt;
&lt;p&gt;\n分隔了交互表达式中的字符串。\n后的r告诉Emacs将point和mark的值分别绑定到参数buffer后面的两个参数上。&lt;/p&gt;
&lt;h3 id="append-to-bufferde-han-shu-ti"&gt;append-to-buffer的函数体&lt;/h3&gt;
&lt;p&gt;函数体是以let开头的。定义了局部变量，在函数中let将(current-buffer)的返回值绑定到oldbuf上。这个变量用于跟踪当前工作的缓冲区。&lt;/p&gt;
&lt;p&gt;单独来看let语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;append-to-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BAppend to buffer: \nr"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;variable&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;let语句包含三个元素：
 1. 符号let。
 2. 变量列表，列表中的元素是只含有两个元素的列表。
 3. let语句体。&lt;/p&gt;
&lt;h3 id="append-to-bufferzhong-de-save-excursion"&gt;append-to-buffer中的save-excursion&lt;/h3&gt;
&lt;p&gt;let语句的body部分是一个save-excursion语句。它用于在执行完代码后恢复point，mark和buffer的值。&lt;/p&gt;
&lt;p&gt;使用save-excursion函数处理过程与下面的模板类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="nv"&gt;first-expression-in-body&lt;/span&gt;
  &lt;span class="nv"&gt;second-expression-in-body&lt;/span&gt;
   &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="nv"&gt;last-expression-in-body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在函数定义中，save-excursion只包含了两个语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer-create&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;save-excursion依次执行这两条语句，save-excursion函数执行的最后一条语句被作为该次函数调用的返回值。&lt;/p&gt;
&lt;p&gt;save-excursion的body部分的第一条语句set-buffer函数用于改变当前缓冲区到append-to-buffer函数调用时第一个参数所指定的缓冲区。（set-buffer变不改当前屏幕显示的内容，只在Lisp程序内部改变当前处理的缓冲区）。第二条语句执行了函数的主要工作。&lt;/p&gt;
&lt;p&gt;(get-buffer-create buffer)语句根据名称获取缓冲区，如果缓冲区不存在，就创建一个同名的缓冲区。这意味着可以用append-to-buffer将文本放到一个之前不存在的缓冲区上。&lt;/p&gt;
&lt;p&gt;get-buffer-create也使set-buffer可以从错误中恢复：set-buffer需要一个缓冲区才能工作；如果传递给它的缓冲区不存在，Emacs将报错。get-buffer-create将在缓冲区不存在时创建一个，因此set-buffer将总能获取到一个缓冲区。&lt;/p&gt;
&lt;p&gt;最后一行append-to-buffer执行追加文本的工作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;insert-buffer-substring函数从指定的缓冲区中拷贝字符串到当前缓冲区。在这里，传递给inset-buffer-substring的参数值是由let绑定的，并被命名为oldbuf，它是开始执行append-to-buffer时的当前缓冲区（执行命令时屏幕上显示的缓冲区）。&lt;/p&gt;
&lt;p&gt;在insert-buffer-substring执行完后，save-excursion将恢复原缓冲区，append-to-buffer工作完成。&lt;/p&gt;
&lt;p&gt;append-to-buffer的函数体工作骨架：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;bind-oldbuf-to-value-of-current-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;                       &lt;span class="c1"&gt;; Keep track of buffer.&lt;/span&gt;
    &lt;span class="nv"&gt;change-buffer&lt;/span&gt;
    &lt;span class="nv"&gt;insert-substring-from-oldbuf-into-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="nv"&gt;change-back-to-original-buffer-when-finished&lt;/span&gt;
&lt;span class="nv"&gt;let-the-local-meaning-of-oldbuf-disappear-when-finished&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结append-to-buffer的工作方式：它保存当前缓冲区到变量oldbuf。获取或者新建一个缓冲区并让Emacs切换到那个缓冲区（非屏幕上显示的缓冲区）。使用oldbuf变量从旧缓冲区中获取文本区域插入到新缓冲区；然后使用save-excursion函数回到最初的缓冲区。&lt;/p&gt;
&lt;p&gt;查看append-to-buffer代码，探究了复杂的函数。它展示了如何使用let和save-excursion，如何从另一个缓冲区回到原来的缓冲区。许多函数定义中以这种方式使用了let、save-excursion和set-buffer。&lt;/p&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;describe-function&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;describe-variable&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打印函数或变量文档字符串。通常被绑定到C-h f和C-h v。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;find-tag&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找包含函数或变量的源码，并在缓冲区打开，并定位到对应的位置。通常绑定到M-.上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;save-excursion&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;保存当前的point和mark，在传递给save-excursion的参数执行完后恢复这两个值。它也会记录下当前的缓冲区并重新回到这个缓冲区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push-mark&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在某个位置设置mark并将之前的mark保存到mark ring里面去。mark是缓冲区中的一个位置，不管缓冲区中的文本添加或者删除，它都将保持它的相对位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;goto-char&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置point到参数指定的位置，参数可以是数字、mark或者返回位置数据的表达式，例如：(point-min).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert-buffer-substring&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从传递给它的第一个参数（缓冲区）对应的缓冲区拷贝区域中的文本到当前缓冲区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mark-whole-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把整个缓冲区标记为一个区域。通常绑定到C-x h上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;get-buffer-create&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;get-buffer&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按名称查找缓冲区，如果缓冲区不存在就创建一个。get-buffer函数在查找不到缓冲区后将返回nil。&lt;/p&gt;
&lt;h1&gt;一些更复杂的函数&lt;/h1&gt;
&lt;h2&gt;copy-to-buffer的函数定义&lt;/h2&gt;
&lt;p&gt;这个函数拷贝文本到缓冲区，但它不是追加到第二个缓冲区，而是替换第二个缓冲区之前的文本。copy-to-buffer函数与append-to-buffer代码很类似，但它使用了erase-buffer和二个save-excursion。&lt;/p&gt;
&lt;p&gt;该函数的函数体如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BCopy to buffer: \nr"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;current-buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer-create&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;erase-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码与append-to-buffer类似：不同处在于，改变buffer后append-to-buffer添加文本到缓冲区；而copy-to-buffer函数先删除缓冲区的内容。在删除之前的缓冲区的内容后，第二次使用了save-excursion，并且插入了新的文本。&lt;/p&gt;
&lt;p&gt;为什么需要执行save-excursion两次？&lt;/p&gt;
&lt;p&gt;单独提取copy-to-buffer函数体如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;bind-oldbuf-to-value-of-current-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;         &lt;span class="c1"&gt;; First use of save-excursion.&lt;/span&gt;
    &lt;span class="nv"&gt;change-buffer&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;erase-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;     &lt;span class="c1"&gt;; Second use of save-excursion.&lt;/span&gt;
        &lt;span class="nv"&gt;insert-substring-from-oldbuf-into-buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个save-excursion让Emacs返回被复制文本的缓冲区。很清楚，这与append-to-buffer函数中的使用是一致的。为什么要使用第二个save-excursion呢？原因在于insert-buffer-substring总是将point设置在被插入的区块（region）的结束位置。第二个save-excursion将使用Emacs将point设置在被插入区块的开始位置。多数情况下，用户喜欢看到point停留在被插入文本的开始位置。（copy-to-buffer函数将返回用户最初所在的缓冲区，当用户切换到拷贝的目标缓冲区时，point停留在缓冲区开始的位置）。&lt;/p&gt;
&lt;h2&gt;insert-buffer的函数定义&lt;/h2&gt;
&lt;p&gt;与append-to-buffer和copy-to-buffer相反，这个命令拷贝另一个缓冲区到当前缓冲区。&lt;/p&gt;
&lt;h2&gt;insert-buffer的代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;insert-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Insert after point the contents of BUFFER.&lt;/span&gt;
&lt;span class="s"&gt;Puts mark after the inserted text.&lt;/span&gt;
&lt;span class="s"&gt;BUFFER may be a buffer or a buffer name."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"*bInsert buffer: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;bufferp&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;newmark&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;newmark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="nv"&gt;newmark&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="insert-bufferzhong-de-jiao-hu"&gt;insert-buffer中的交互&lt;/h3&gt;
&lt;p&gt;insert-buffer中的interactive有两个部分，*号和bInsert buffer:&lt;/p&gt;
&lt;h4 id="zhi-du-huan-chong-qu"&gt;只读缓冲区&lt;/h4&gt;
&lt;p&gt;星号用于只读缓冲区。如果insert-buffer是在一个只读缓冲区上被调用，提示信息将在回显区显示提示不允许插入到当前的缓冲区。星号不需要使用\n与下一个参数分隔。&lt;/p&gt;
&lt;h4 id="jiao-hu-biao-da-shi-b"&gt;交互表达式b&lt;/h4&gt;
&lt;p&gt;交互表达式的第二个参数是小写b开头的（append-to-buffer中是大写的B）。小写b告诉Lisp解释器，insert-buffer需要一个已存在的缓冲区或者已存在的缓冲区名称作为参数。（大写的B可以使用一个不存在的缓冲区）Emacs将提示输入缓冲区名称，并提供了默认的缓冲区，输入时可以使用自动完成功能。如果缓冲区不存在，将给出"No match"的提示。&lt;/p&gt;
&lt;h3 id="insert-bufferhan-shu-ti_1"&gt;insert-buffer函数体&lt;/h3&gt;
&lt;p&gt;insert-buffer函数有两个主要部分：or语句和let语句。or语句用于确保参数buffer参数不仅仅只是被绑定到缓冲区的名字上。let语句包含复制其它缓冲区到当前缓冲区的代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;insert-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"*bInsert buffer: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;varlist&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;body-of-let...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要明白or如何确保参数buffer不只是被绑定到缓冲区名称上，先要清楚or函数。&lt;/p&gt;
&lt;h3 id="zai-insert-bufferyong-ifti-dai-or"&gt;在insert-buffer用if替代or&lt;/h3&gt;
&lt;p&gt;主要工作在于确保buffer变量值是一个缓冲区，而不是缓冲区的名字。如果变量值是名字，则需要获取对对应的缓冲区。&lt;/p&gt;
&lt;p&gt;通过if来实现：如果没有获取到buffer就获取它。&lt;/p&gt;
&lt;p&gt;这里使用了bufferp函数，这个函数检查参数是否为一个缓冲区（或者缓冲区的名字），我们可以如下编码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;bufferp&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;              &lt;span class="c1"&gt;; if-part&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;  &lt;span class="c1"&gt;; then-part&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面说过bufferp中的字符p是一个约定的函数描述，它意味着函数用于决定某些属性为true或false。这里bufferp就是用于检查参数是否为一个缓冲区。&lt;/p&gt;
&lt;p&gt;not函数用于取逻辑值的反值。&lt;/p&gt;
&lt;p&gt;当buffer参数不是一个缓冲区但它是一个缓冲区名称时，true-or-false-test返回true。这时(set q buffer (get-buffer buffer))被执行。语句使用get-buffer函数获取缓冲区名称所对应的缓冲区。setq将buffer绑定到缓冲区上。&lt;/p&gt;
&lt;h3 id="han-shu-ti-zhong-de-or"&gt;函数体中的or&lt;/h3&gt;
&lt;p&gt;insert-buffer函数中使用or语句的目的在于确保buffer被绑定到缓冲区。上一节用if实现了这个功能。但在insert-buffer函数中实际使用的却是or函数。&lt;/p&gt;
&lt;p&gt;or函数可以接收任何意数量的参数。它依次对每个参数求值并返回第一个结果不为nil的值。or并不会对第一个返回值不为nil的参数的后面的参数求值。&lt;/p&gt;
&lt;p&gt;or语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;bufferp&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该语句中or的第一个参数为(bufferp buffer)。如果buffer参数是一个缓冲区则返回true（一个非nil值）。在or语句中，这种情况下or将返回true，并且不执行后面的语句。&lt;/p&gt;
&lt;p&gt;如果(bufferp buffer)返回值为nil，即buffer是一个缓冲区的名字，Lisp解释器将执行or语句的下一个元素：(setq buffer (get-buffer buffer))。这个语句将返回一个非nil值，这个值为绑定到buffer变量上的缓冲区而不是缓冲区的名字。&lt;/p&gt;
&lt;p&gt;使用or的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;holding-on-to-guest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;find-and-take-arm-of-guest&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="insert-bufferzhong-de-letyu-ju"&gt;insert-buffer中的let语句&lt;/h3&gt;
&lt;p&gt;确保了buffer变量绑定到缓冲区后，insert-buffer函数中接下来是一个let语句。它设置了3个局部变量start、end和newmark并初始化为nil。这些变量是let语句中的临时变量。&lt;/p&gt;
&lt;p&gt;let语句体包含了两个save-excursion语句。内部的那个save-excursion如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(set-buffer buffer)将将当前缓冲区设置为将要复制文本的缓冲区。在那个缓冲区中将start和end分别设置为缓冲区开始位置和结束位置。这里可以看到setq可以在一个语句中设置多个变量。第一个参数值设置为第二个参数，第三个参数值为第四个参数。&lt;/p&gt;
&lt;p&gt;外部的那个save-excursion表达式结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;inner-save-excursion-expression&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;go-to-new-buffer-and-set-start-and-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;newmark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;insert-buffer-substring函数从原缓冲区中把start和end所定义的区域中的文本拷贝到buffer中。第二个缓冲区所有内容都处于start和end之间，因此整个缓冲区都将被拷贝到当前编辑的缓冲区中。这时，point位于被插入的文本的结束位置，被保存到newmark变量中。&lt;/p&gt;
&lt;p&gt;在执行外部的save-excursion语句后，point和mark将回到原来的位置。&lt;/p&gt;
&lt;p&gt;然而，合适的mark位置应该被设置在被插入的文本块的结束位置，而point应当被设置在这个文本块的开始位置。newmark记录了被插入文本的结束位置。let语句的最后一行(push-mark newmark)语句将mark设置到了那个位置。（前一个mark仍然可以访问，它被保存在mark ring里面，可以用C-u C-&lt;spc&gt;回到那个位置）。同时，point被设置到被插入文本的开始位置，这也是函数调用前point所在的位置。&lt;/spc&gt;&lt;/p&gt;
&lt;h2&gt;完整的beginning-of-buffer函数的定义&lt;/h2&gt;
&lt;p&gt;前面讨论过"简化版的beginning-of-buffer函数定义"。在那个版本中，调用的时候没有传递参数。Emacs中的beginning-of-buffer将光标移到缓冲区开始位置，并将mark设置在之前光标所在位置。调用的时候可以传递1-10之间的数字给这个命令，函数将把参数当作移动的百分比：整个缓冲区当作10份，C-u 7 M-&amp;lt;将跳转到整个缓冲区70%的位置。M-&amp;lt;将中跳转到缓冲区的开始位置。如果传递的参数大于10，则将移动到缓冲区的结束位置。&lt;/p&gt;
&lt;p&gt;beginning-of-buffer的参数是可选的，可以不带参数调用。&lt;/p&gt;
&lt;h3 id="ke-xuan-can-shu"&gt;可选参数&lt;/h3&gt;
&lt;p&gt;在调用需要参数的函数时，如果没有设置参数Lisp解释器将报错：Wrong number of arguments。&lt;/p&gt;
&lt;p&gt;但Lisp提供了可选参数的功能：用&amp;amp;optional（&amp;amp;是这个关键字的一部分）关键字告诉解释器参数是可选的，如果参数跟在&amp;amp;optional的后面，则在调用函数时可以不传递这个参数&lt;/p&gt;
&lt;p&gt;beginning-of-buffer函数定义的第一行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;beginning-of-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个函数看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;beginning-of-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"P"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;if-there-is-an-argument&lt;/span&gt;
        &lt;span class="nv"&gt;figure-out-where-to-go&lt;/span&gt;
      &lt;span class="nv"&gt;else-go-to&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个函数与simplified-beginning-of-buffer函数类似，除了interactive语句用了"P"参数和goto-char函数跟了一个用于在传递了参数时计算光标位置if-then-else语句。&lt;/p&gt;
&lt;p&gt;"P" interactive语句告诉Emacs传递一个前缀参数，这个参数来自于按&lt;meta/&gt;键前输入的数字。或者输入C-u时输入的数字。(如果不输入数字，C-u缺省为4）&lt;/p&gt;
&lt;p&gt;if语句部分比较简单：如果参数arg的值不为nil，即调用beginning-of-buffer时有带参数，则true-or-false-test返回true，if语句的then部分将被执行。如果beginning-of-buffer调用时没有带参数则if语句将被执行。else部分(goto-char (point-min))被执行。&lt;/p&gt;
&lt;h3 id="dai-can-shu-zhi-xing-beginning-of-buffer"&gt;带参数执行beginning-of-buffer&lt;/h3&gt;
&lt;p&gt;当带参数执行时，用于计算传递给goto-char的参数值的语句被执行。这个语句初看起来比较复杂。它内部包含了一个if语句和更多的数学计算。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;;; Avoid overflow for large buffer sizes!&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="jie-kai-beginning-of-buffer"&gt;解开beginning-of-buffer&lt;/h4&gt;
&lt;p&gt;解开上面的条件语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer-is-large&lt;/span&gt;
    &lt;span class="nv"&gt;divide-buffer-size-by-10-and-multiply-by-arg&lt;/span&gt;
  &lt;span class="nv"&gt;else-use-alternate-calculation&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;if语句检查缓冲区的大小。这样做主要是由于在由的Emacs 18版本中计算出来的数字不允许大于8百万，Emacs怕缓冲区太大，后面的计算结果超过上限而溢出。在Emacs 21中使用大数字，但这个代码没被改动。&lt;/p&gt;
&lt;h4 id="huan-chong-qu-hen-da-shi-de-qing-kuang"&gt;缓冲区很大时的情况&lt;/h4&gt;
&lt;p&gt;在beginning-of-buffer中，内部的if语句为了检查缓冲区是否大于1000个字符使用了&amp;gt;函数和buffer-size函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果超过了if语句的then部分将执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语句使用*函数将两个参数相乘。&lt;/p&gt;
&lt;p&gt;第一个参数(prefix-number-value arg)。当使用"P"作为interactive时，传递给函数的参数值是一个"raw prefix argument"，不是一个数字（是一个包含了一个数字的列表）。为了执行数字运行，需要通过prefix-number-value来做转换。&lt;/p&gt;
&lt;p&gt;第二个参数是(/ (buffer-size) 10)。这个语句将数值与十相除。这计算出了缓冲区中1/10有多少个字符。&lt;/p&gt;
&lt;p&gt;在整个相乘的语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;numeric-value-of-prefix-arg&lt;/span&gt;
   &lt;span class="nv"&gt;number-of-characters-in-one-tenth-of-the-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果传递的参数是7，计算出的位置就是缓冲区70%的位置。&lt;/p&gt;
&lt;p&gt;缓冲区很大的时候，goto-char语句的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="huan-chong-qu-jiao-xiao-shi-de-qing-kuang"&gt;缓冲区较小时的情况&lt;/h4&gt;
&lt;p&gt;如果缓冲区包含的字符数量小于10000，计算上有些不同。也许你会认为这没有必要，因为第一个计算方式（大于10000时的情况）也能工作。然而在小型缓冲区中，第一种方法不能将光标放在需要位置；第二种方法则工作得好一些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;格式化后看得更清楚一些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
   &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看最内部的括号(prefix-numberic-value arg)，它将raw argument转换为数字。然后将数字与缓冲区大小相乘。
&amp;lt;src lang="emacs-lisp"
(* (buffer-size) (prefix-numeric-value arg)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;这个操作将得到一个大于缓冲区几倍的数字。然后用这个数字加上10最后再除以10得到一个大于百分比位置的值。

这个结果被传递给goto-char将光标移到那个点。

### beginning-of-buffer的完整代码
```emacs-lisp
(defun beginning-of-buffer (&amp;amp;optional arg)
  "Move point to the beginning of the buffer;
leave mark at previous position.
With arg N, put point N/10 of the way
from the true beginning.
Don't use this in Lisp programs!
\(goto-char (point-min)) is faster
and does not set the mark."
  (interactive "P")
  (push-mark)
  (goto-char
   (if arg
       (if (&amp;gt; (buffer-size) 10000)
           ;; Avoid overflow for large buffer sizes!
           (* (prefix-numeric-value arg)
              (/ (buffer-size) 10))
         (/ (+ 10 (* (buffer-size)
                     (prefix-numeric-value arg)))
            10))
     (point-min)))
  (if arg (forward-line 1)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中的文档字符串中使用了一个语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;\(goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语句第一个括号前的\告诉Lisp解释器应该打印这个表达式而不是对它求值。&lt;/p&gt;
&lt;p&gt;beginning-of-buffer的最后一行代码：如果执行命令时带了参数，则移动point到下一行的起始位置。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这行代码将光标移动到了计算位置的下一行的起始位置。(这行代码并非必要的，只是为了看起来更好）&lt;/p&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;or&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依次执行各个参数直到遇到一个返回值不为nil的值。如果没有返回值为nil的参数，则返回nil，否则返回第一个返回值不为nil的值。简单来说就是：返回参数中第一个为true的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;and&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依次执行各个参数，直到遇到返回值为nil时，返回nil；如果没有nil则返回最后一个参数的值。简单来说就是：如果所有参数都为true就返回true；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;amp;optional&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个关键字用于标明函数定义中的参数是可选的参数。意味着调用函数时可以不传递这个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prefix-numeric-value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将从(interactive "P")获取到的"raw prefix argument'转换为数字。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;forward-line&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将point移到下一行的行首，如果参数大于1，则向下移动多行。如果不能移动那么多行，则forward-line尽量移动到能到达的位置，并返回没有进行操作的多余次数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;erase-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;删除当前整个缓冲区中的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bufferp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果参数是一个缓冲区，则返回t，否则返回nil。&lt;/p&gt;
&lt;h1&gt;Narrowing and Widening&lt;/h1&gt;
&lt;p&gt;Narrowing是Emacs的一项功能，它使你可以将焦点集中在缓冲区的某个部分上，而不用担心意外的修改了其它部分。Narrowing通常被禁用，因为它可能会使新手觉得迷惑。&lt;/p&gt;
&lt;h2&gt;Narrowing的优点&lt;/h2&gt;
&lt;p&gt;使用narrowing时，缓冲区的其它部分不可见，看起来就像其它部分不存在一样。利用这点你可以只在缓冲区中的某个部分进行查找或替换操作，而不会影响缓冲区的其它部分。narrow-to-region被绑定到C-x n n。&lt;/p&gt;
&lt;p&gt;narrowing将使缓冲区的其它部分不可见，如果用户在无意中执行了narrowing命令时他们有可能会认为其它部分被删除了。而且，在这里用undo命令也不（C-x u）也不能关闭narrowing。这时可以使用widen（C-x n w）命令让其它部分重新显示出来。&lt;/p&gt;
&lt;p&gt;Narrowing对于Lisp解释器或者用户都是很有用的。Emacs Lisp函数通常被设计为工作于缓冲区的一部分，或者工作于被narrow处理的整个缓冲区。比如：what-line函数（这个函数存在narrow时将显示两两个行号narrowing情况时的行数和非narrowing时的行数），从缓冲区中移除narrowing，工作完成后恢复narrowing。另一个函数count-lines，它被what-line调用，它使用narrowing将工作范围限定在需要处理的区域，在处理完成后再恢复。&lt;/p&gt;
&lt;h2&gt;特殊的save-restriction表(form)&lt;/h2&gt;
&lt;p&gt;在Emacs Lisp中，可以使用save-restriction保持对所有narrowing操作的跟踪。当Lisp解释器遇到save-restriction时，它执行save-restriction语句的body部分，然后撤消在body部分代码执行中的所有narrowing相关的操作。比如：缓冲区当前是narrowed状态，save-restriction中的代码删除了narrowing，save-restriction返回时将回到narrorwed的状态。在what-line命令中，所有的narrowing缓冲区都可能被save-restriction后面的widen命令撤消。所有原始的narrowing将在函数完成后被恢复。&lt;/p&gt;
&lt;p&gt;使用save-restriction语句的简单模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-restriction&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;save-restriction函数的body部分是一个或多个将被依序执行的语句。&lt;/p&gt;
&lt;p&gt;注意：同时使用save-excursion和save-restriction时，应该将save-excursion放在外部。如果放反了顺序，就有可能使Emacs在调用save-excursion后无法记录当前的narrowing信息。因此，这两个函数同时使用应该写成下面的结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-restriction&lt;/span&gt;
    &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这两个函数不紧挨在一起，也必须按顺序使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-restriction&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;widen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;what-line&lt;/h2&gt;
&lt;p&gt;what-line命令告诉你当前光标所在行的行号。这个命令个使用了save-restriction和save-excursion函数的例子。函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;what-line&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Print the current line number (in the buffer) of point."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-restriction&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;widen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Line %d"&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-lines&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数有一个文档字符串和交互语句。接下来的两行使用了save-restriction和widen。&lt;/p&gt;
&lt;p&gt;save-restriction将在其body部分的代码执行完后恢复narrowing。&lt;/p&gt;
&lt;p&gt;save-restriction下面的widen撤消调用what-line时缓冲区中的所有narrowing（这些narrowing就save-restriction所记录的那些）。widen使得可以从缓冲区的开始位置计数。否则，它将只能对可访问区域进行计数。在save-restriction执行完成后将恢复原来的narrowing。&lt;/p&gt;
&lt;p&gt;widen后面是save-excursion语句，它将保存当前光标位置（mark point等），在执行完成后恢复。在save-excursion的body部分使用了beginning-of-line函数移动poing。&lt;/p&gt;
&lt;p&gt;注意：这里的widen语句在save-restriction和save-excursion之间。当同时使用时save-excursion应该在最外面。&lt;/p&gt;
&lt;p&gt;what-line函数的最后两行用于统计缓冲区中的行数，并显示在回显区。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Line %d"&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-lines&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;message函数在Emacs回显区显示了一行消息。第一个参数是一个双引号单间的字符串。字符串中可以包含%d，%s或%c来打印参数。%d用于打印数字。&lt;/p&gt;
&lt;p&gt;所打印的数字%d是最后一行函数计算出来的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-lines&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它从缓冲区中的第一行统计，从1开始计数直到(poing)，并在这个数字上加1。（1+是一个自增加1的函数。）这里加1是因为在第2行的前面只有一行，count-lines计数时只计算到当前所在行的前一行。&lt;/p&gt;
&lt;p&gt;在count-lines执行完后，将显示消息在回显区，save-excrusion恢复point和mark；save-restriction恢复原来的narrowing。&lt;/p&gt;
&lt;h1&gt;基础函数:car, cdr, cons&lt;/h1&gt;
&lt;p&gt;Lisp中car，cdr和cons都是基础函数。cons用于构造lists，car和cdr用于分割lisp。&lt;/p&gt;
&lt;h2&gt;奇怪的命名&lt;/h2&gt;
&lt;p&gt;cons函数的名称并非没有含意：它是单词'construct'的缩写。car是短语'Contents of the Address part of the Register'；cdr（'could-er'）是短语'Contents of the Decrement part of the Register'。这些短语说明了Lisp是在多么原始的机器上被开发的。&lt;/p&gt;
&lt;h2&gt;car和cdr&lt;/h2&gt;
&lt;p&gt;一个list的CAR是list中的第一个元素。(rose violet daisy buttercup)的CAR就是rose。&lt;/p&gt;
&lt;p&gt;执行下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;rose&lt;/span&gt; &lt;span class="nv"&gt;violet&lt;/span&gt; &lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行这个语句后，回显区将显示rose。&lt;/p&gt;
&lt;p&gt;有一个更合理的car函数：first。&lt;/p&gt;
&lt;p&gt;car并不从list移除第一个元素；它只返回第一个元素。car执行完后list并没有发生改变。car是一个无害的函数（'non-destructive'）。&lt;/p&gt;
&lt;p&gt;CDR是list中的其余部分，cdr函数返回list中首元素后面的其它元素。因此'(rose violet daisy buttercup)的CDR部分是(violet daisy buttercup)。&lt;/p&gt;
&lt;p&gt;对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;rose&lt;/span&gt; &lt;span class="nv"&gt;violet&lt;/span&gt; &lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;求值将在回显区显示(violet daisy butercup)&lt;/p&gt;
&lt;p&gt;cdr也不从列表中移除元素。&lt;/p&gt;
&lt;p&gt;附带说明一下：在这个例子中list前面加了单引号。如果不加，Lisp解释器把rose当作函数执行。在这个例子中我们并不需要那样。&lt;/p&gt;
&lt;p&gt;cdr的一个更合理的名称是：rest。&lt;/p&gt;
&lt;p&gt;当car和cdr应用于符号组成的列表时，比如(pine fir oak maple)，函数car将返回列表中的pine元素，并且pine不会被括号包含。这个list的CDR也是一个list，(fir oak maple)。&lt;/p&gt;
&lt;p&gt;如果car和cdr应用于包含list的list，第一个元素也是list。car将返回list中的第一个list元素。&lt;/p&gt;
&lt;p&gt;car和cdr是无害的，它们不修改list中的数据。这是非常重要的一点。&lt;/p&gt;
&lt;p&gt;在第一章中曾说过：&amp;ldquo;在Lisp中某些原子类型，比如数组，可以被分隔成更小的部分；但这种机制与分割list的机制是不同的。这与Lisp的早期概念有关，list中的原子是不可分隔的。&amp;rdquo;（car和cdr也并不修改list。）car和cdr是用于分割list的基础函数。但它们不能用于分割数组或者访问数组中的一部分。数组被看作原子类型。另一个基础函数cons可以用于构造列表，但也不能用于数组。&lt;/p&gt;
&lt;h2&gt;cons&lt;/h2&gt;
&lt;p&gt;cons函数是构造list的函数。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'pine&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行时回显区将显示(pine fir oak maple)。cons将新的元素放到列表的开头，它将新元素推入list中。&lt;/p&gt;
&lt;h3 id="gou-zao-yi-ge-list_1"&gt;构造一个list&lt;/h3&gt;
&lt;p&gt;cons函数必须要有一个可以被插入的list参数。构造一个list时，至少要提供一个空的list。下面是一些构造list的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'buttercup&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (buttercup)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'daisy&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (daisy buttercup)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'violet&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (violet daisy buttercup)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'rose&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;violet&lt;/span&gt; &lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (rose violet daisy buttercup)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在第一个例子中，()是一个空的list并且用空list和buttercup构造了一个list。可以看到空list并没有显示在被构造的list中。只能看到(buttercup)。空list不会被当作一个list元素，因为空list中没有任何元素。空list是不可见的。&lt;/p&gt;
&lt;h3 id="jian-cha-listde-chang-du-length"&gt;检查list的长度：length&lt;/h3&gt;
&lt;p&gt;可以用函数length检查list中的元素数量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 1&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 2&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'violet&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以将length应用于空list上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当调用length函数而不传递参数给它时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你将得到一个错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Wrong number of arguments: #&amp;lt;subr length&amp;gt;, 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表示函数接收到了错误的参数个数，0，函数需要一定数量的参数。在这里length需要一个参数，参数应该是一个list。（一个list也是一个参数而不管list中有多少元素）&lt;/p&gt;
&lt;p&gt;错误信息中的#&lt;sub length=""&gt;是函数的名称。#&amp;lt;subr，标明函数length是用C写的原生函数而不是用Emacs Lisp编写的。（subr是'subroutine'的缩写）&lt;/sub&gt;&lt;/p&gt;
&lt;h2&gt;nthcdr&lt;/h2&gt;
&lt;p&gt;nthcdr是一个与cdr相关的函数。它用于多次获取list的CDR部分。&lt;/p&gt;
&lt;p&gt;如果获取(pine fir oak maple)的CDR部分，将得到(fir oak maple)。如果在这个结果上再重复操作将得到(oak maple)。（如果你在原来的list上取CDR，将一直得到同样的结果，因为原来的list并没有被修改）如果继续下去，将得到一个空的list，这时将不会显示为()，而是显示为nil。
例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt;(fir oak maple)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (oak maple)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt;(maple)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="ss"&gt;'nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者用下面的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (oak maple)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;nthcdr函数与多次调用cdr类似。下面的例子中，参数2和一个list被传递给nthcdr，返回的值与原list相比，不含前面两个元素，相当于在list上执行了两次cdr。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (oak maple)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Leave the list as it was.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (pine fir oak maple)&lt;/span&gt;

&lt;span class="c1"&gt;;; Return a copy without the first element.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (fir oak maple)&lt;/span&gt;

&lt;span class="c1"&gt;;; Return a copy of the list without three elements.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (maple)&lt;/span&gt;

&lt;span class="c1"&gt;;; Return a copy lacking all four elements.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

&lt;span class="c1"&gt;;; Return a copy lacking all elements.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;nth&lt;/h2&gt;
&lt;p&gt;nthcdr重复取list的CDR部分。nth函数取nthcdr返回值的CAR部分。它返回list中的Nth元素。&lt;/p&gt;
&lt;p&gt;如果nth没有被因为效率原因而用C定义，那么nth的定义将会是下面的样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Returns the Nth element of LIST.&lt;/span&gt;
&lt;span class="s"&gt;N counts from zero.  If LIST is not that long, nil is returned."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（最初的nth在定义在Emacs Lisp文件subr.el中，但后来在1980年被重新用C实现。）&lt;/p&gt;
&lt;p&gt;元素计数从0开始而不是1。这就是说list的第一个元素CAR是第零个元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"one"&lt;/span&gt; &lt;span class="s"&gt;"two"&lt;/span&gt; &lt;span class="s"&gt;"three"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;=&amp;gt; "one"&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"one"&lt;/span&gt; &lt;span class="s"&gt;"two"&lt;/span&gt; &lt;span class="s"&gt;"three"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;=&amp;gt; "two"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：nth与nthcdr和cdr一样，也不修改原来的list，也是一个无害函数。&lt;/p&gt;
&lt;h2&gt;setcar&lt;/h2&gt;
&lt;p&gt;从命名上就可以猜想到，setcdr和setcar函数用于设置list的CAR或CDR部分为一个新值。与car和cdr不同，它们将修改原始的list。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;antelope&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nv"&gt;animals&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (antelope giraffe lion tiger)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcar&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="ss"&gt;'hippopotamus&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;animals&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (hippopotamus giraffe lion tiger)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到setcar函数并非像cons那样向list中添加元素；它将giraffe替换为hippopotamus；它修改了list。&lt;/p&gt;
&lt;h2&gt;setcdr&lt;/h2&gt;
&lt;p&gt;setcdr与setcar函数类似，它用于替换list中除首元素外的其它元素。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;domesticated-animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;horse&lt;/span&gt; &lt;span class="nv"&gt;cow&lt;/span&gt; &lt;span class="nv"&gt;sheep&lt;/span&gt; &lt;span class="nv"&gt;goat&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nv"&gt;domesticated-animals&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (horse cow sheep goat)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="nv"&gt;domesticated-animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cat&lt;/span&gt; &lt;span class="nv"&gt;dog&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nv"&gt;domesticated-animals&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (horse cat dog)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;剪切和存储文本&lt;/h1&gt;
&lt;p&gt;当使用'kill'命令剪切文本时，Emacs将它存储到一个列表中，可以用'yank'命令重新获取到。&lt;/p&gt;
&lt;h2&gt;存储文本到列表&lt;/h2&gt;
&lt;p&gt;当文本被剪切出缓冲区时，它将被存储到一个list中。文本块连续的存储在list中，这个列表看如下面的形式：
&amp;lt;src lang="emacs-lisp"
("a piece of text" "previous piece")&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;函数cons可以添加文本块到list，如：
```emacs-lisp
(cons "another piece"
      '("a piece of text" "previous piece"))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行上面的语句，回显区将显示&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"another piece"&lt;/span&gt; &lt;span class="s"&gt;"a piece of text"&lt;/span&gt; &lt;span class="s"&gt;"previous piece"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用car和nthcdr函数，可以获取到list中任意的一个文本块。。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"another piece"&lt;/span&gt;
                 &lt;span class="s"&gt;"a piece of text"&lt;/span&gt;
                 &lt;span class="s"&gt;"previous piece"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; "a piece of text"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，Emacs中实际处理这些时更复杂一些。Emacs中编写的剪切函数能猜想出你需要的是list的哪个元素。&lt;/p&gt;
&lt;p&gt;包含这些文本块的list被称作kill ring。&lt;/p&gt;
&lt;h2&gt;zap-to-char&lt;/h2&gt;
&lt;h3 id="wan-zheng-de-zap-to-charshi-xian"&gt;完整的zap-to-char实现&lt;/h3&gt;
&lt;p&gt;这个函数将移除光标和指定的字符之间的文本。被移除的文本被放入kill ring中，可以用C-y（yank）获取到。如果命令带了数字前缀参数n(C-u)，它将移除当前光标位置至遇到的第n个字符之间的文本。&lt;/p&gt;
&lt;p&gt;如果指定的字符不存在，zap-to-char将显示"Search failed"。&lt;/p&gt;
&lt;p&gt;为了决定要移除多少文本，zap-to-char使用了search函数。搜索在文本处理代码中使用得非常广泛。&lt;/p&gt;
&lt;p&gt;下面是zap-to-char在Emacs 19中的完整代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zap-to-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="nv"&gt;char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; version 19 implementation&lt;/span&gt;
  &lt;span class="s"&gt;"Kill up to and including ARG'th occurrence of CHAR.&lt;/span&gt;
&lt;span class="s"&gt;Goes backward if ARG is negative; error if CHAR not found."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"*p\ncZap to char: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;char-to-string&lt;/span&gt; &lt;span class="nv"&gt;char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="interactiveyu-ju"&gt;interactive语句&lt;/h3&gt;
&lt;p&gt;zap-to-char的interactive语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"*p\ncZap to char: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引号中的部分"*p\ncZap to char: "，指定了3个不同的东西。第一，星号，如果当前缓冲区是只读缓冲区将产生一个错误信息。这意味着如果将zap-to-char用于只读缓冲将得到错误信息"Buffer is read-only"。&lt;/p&gt;
&lt;p&gt;在Emacs21的实现中没有包含星号。函数与Emacs19中一样能工作，但在只读缓冲区中它不会移除文本，它将复制文本并将文本放到kill ring中。在这种情况下，两个版本中都将显示错误信息。&lt;/p&gt;
&lt;p&gt;在Emacs19中的实现也能从只读缓冲区中复制文本，这只是interactive的一个Bug。interactive的文档中说明了，星号将阻止zap-to-char函数对只读缓冲区做任何操作，这个函数不应该复制文本到kill ring中。&lt;/p&gt;
&lt;p&gt;在Emacs21中interactive的实现是正确的。因此星号不得不被移除。如果你在这个这个函数的定义中插入了星号，并重新执行函数定义，下次你再在只读缓冲区上运行zap-to-char时，将不能再复制文本到kill ring里。&lt;/p&gt;
&lt;p&gt;从这点来看，两个版本中的zap-to-char是一致的。&lt;/p&gt;
&lt;p&gt;"&lt;code&gt;*p\ncZap to char:&lt;/code&gt;"中的第二个部分是p。这个部分与下一部分用\n分隔了。p表示参数应该是一个前缀参数'processed prefix'，这个参数是用C-u加数字或者M-加数字传递的。如果调用时没有加参数，1将作为默认的参数值。&lt;/p&gt;
&lt;p&gt;"&lt;code&gt;*p\ncZap to char:&lt;/code&gt;"中的第三个部分是"cZap to char: "，小写的c指定了参数必须是一个字符。c后面的字符串Zap to char: 是提示字符串。&lt;/p&gt;
&lt;h3 id="zap-to-charde-han-shu-ti"&gt;zap-to-char的函数体&lt;/h3&gt;
&lt;p&gt;zap-to-char函数体包含kill当前光标位置至指定字符之间文本的代码。代码的第一部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(point)是光标的当前位置&lt;/p&gt;
&lt;p&gt;代码的下一个部分是一个progn语句。progn的body部分由search-forward和point组成。&lt;/p&gt;
&lt;p&gt;在学习完search-forward后，很容易懂progn。&lt;/p&gt;
&lt;h3 id="search-forwardhan-shu"&gt;search-forward函数&lt;/h3&gt;
&lt;p&gt;search-forward函数被用于定位字符（zapped-for-character）。如果查找成功，search-forward会将point设置在要查找的目标字符串的最后一个字符的后面。（zap-to-char中目标字符串只有一个字符）如果是向后查找，则search-forward会将point设置在查找目标字符串第一个字符的前面。查找成功后，search-forward将返回t。&lt;/p&gt;
&lt;p&gt;在zap-to-char中，search-forward函数部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;char-to-string&lt;/span&gt; &lt;span class="nv"&gt;char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;search-forward函数包含四个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一个参数是要查询目标，必须是一个字符串，比如"z"。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;传递给zap-to-char是一个字符。Lisp解释器对字符串和字符的处理是不同的。因为search-forward函数查询的是一个字符串，传递给zap-to-char函数接收到的是一个字符，因此参数必须被转换为字符串，否则search-forward将报错。char-to-string用于处理这种转换。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第二个参数限制查询的范围；它是一个缓冲区位置。在这里，可以查询到缓冲区的结束位置，因此第二个参数为nil。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个参数告诉函数如果查询失败该如何做：比如打印错误信息或者返回nil。第三个参数为nil将在查询失败时显示错误信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;search-forward的第四个参数用于指定重复查询的次数。这个参数是可选，如果没有传递，则默认为1.如果参数是一个负数，查询将向后查询。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用search-forward语句的模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt; &lt;span class="s"&gt;"target-string"&lt;/span&gt;
                &lt;span class="nv"&gt;limit-of-search&lt;/span&gt;
                &lt;span class="nv"&gt;what-to-do-if-search-fails&lt;/span&gt;
                &lt;span class="nv"&gt;repeat-count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="progn"&gt;progn&lt;/h3&gt;
&lt;p&gt;progn是一个特殊的form。它使传递给它的参数依次被执行，并返回最后一个值。前面部分只是被执行，它们的返回值被丢弃。&lt;/p&gt;
&lt;p&gt;progn语句的模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zap-to-char中的progn语句做了两件事：将point设置到正确的位置；返回point的位置以便kill-region知道要操作的范围。&lt;/p&gt;
&lt;p&gt;progn的第一个参数是search-forward。当search-forward找到了字符串，它会将point设置在查找目标字符串的最后一个字符的后面。（这里目标字符串只有一个字符长）如果是向后查找，search-forward会将poing设置在查找目标的第一个字符的前面。point的移动是side effect（单方面的，不影响界面）。&lt;/p&gt;
&lt;p&gt;progn的第二个参数是表达式(point)。这个表达式返回point的值，即search-forward设置的那个值。这个值被作为progn语句的返回值将作为kill-region的第二个参数传递给kill-region函数。&lt;/p&gt;
&lt;h3 id="zap-to-charde-zong-jie"&gt;zap-to-char的总结&lt;/h3&gt;
&lt;p&gt;前面了解了search-forward和progn是如何工作的，我们可以看到整个zap-to-char函数是如何工作的。&lt;/p&gt;
&lt;p&gt;kill-region的第一个参数是执行zap-to-char命令时的光标位置。在progn的内部，查找函数将poing移动到要查找目标（zapped-to-character）的后面。kill-region函数将这两个point中的第一个作为操作区域（region）的开始位置，第二个参数作为结束位置，然后移除这个区域。&lt;/p&gt;
&lt;p&gt;progn是必需的，因为kill-region命令需要两个参数；如果把search-forward和point语句直接作为kill-region的参数将报错。progn语句是一个单独的参数，它的返回值将作为传递给kill-region的第二个参数。&lt;/p&gt;
&lt;h2&gt;kill-region&lt;/h2&gt;
&lt;p&gt;zap-to-char函数使用了kill-region函数。函数将从一个region中clip文本到kill ring中。&lt;/p&gt;
&lt;p&gt;在Emacs 21中这个函数使用了condition-case和copy-region-as-kill，这两个函数都将在后面解释，confition-case是一个特别重要的form。&lt;/p&gt;
&lt;p&gt;实际上，kill-region函数调用了condition-case，它需要3个参数。第一个参数不做什么，第二个参数包含了正常工作时需要执行的代码。第三个参数包含了出错时需要执行的代码。&lt;/p&gt;
&lt;h3 id="wan-zheng-de-kill-regionding-yi"&gt;完整的kill-region定义&lt;/h3&gt;
&lt;p&gt;下面将介绍condition-case。首先来看kill-region的完整定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;kill-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Kill between point and mark.&lt;/span&gt;
&lt;span class="s"&gt;The text is deleted but saved in the kill ring."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;;; 1. `condition-case' takes three arguments.&lt;/span&gt;
  &lt;span class="c1"&gt;;;    If the first argument is nil, as it is here,&lt;/span&gt;
  &lt;span class="c1"&gt;;;    information about the error signal is not&lt;/span&gt;
  &lt;span class="c1"&gt;;;    stored for use by another function.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;condition-case&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;

      &lt;span class="c1"&gt;;; 2. The second argument to `condition-case'&lt;/span&gt;
      &lt;span class="c1"&gt;;;    tells the Lisp interpreter what to do when all goes well.&lt;/span&gt;

      &lt;span class="c1"&gt;;;    The `delete-and-extract-region' function usually does the&lt;/span&gt;
      &lt;span class="c1"&gt;;;    work.  If the beginning and ending of the region are both&lt;/span&gt;
      &lt;span class="c1"&gt;;;    the same, then the variable `string' will be empty, or nil&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;delete-and-extract-region&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

        &lt;span class="c1"&gt;;; `when' is an `if' clause that cannot take an `else-part'.&lt;/span&gt;
        &lt;span class="c1"&gt;;; Emacs normally sets the value of `last-command' to the&lt;/span&gt;
        &lt;span class="c1"&gt;;; previous command.&lt;/span&gt;
        &lt;span class="c1"&gt;;; `kill-append' concatenates the new string and the old.&lt;/span&gt;
        &lt;span class="c1"&gt;;; `kill-new' inserts text into a new item in the kill ring.&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;last-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="c1"&gt;;; if true, prepend string&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;this-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;;; 3. The third argument to `condition-case' tells the interpreter&lt;/span&gt;
    &lt;span class="c1"&gt;;;    what to do with an error.&lt;/span&gt;
    &lt;span class="c1"&gt;;;    The third argument has a conditions part and a body part.&lt;/span&gt;
    &lt;span class="c1"&gt;;;    If the conditions are met (in this case,&lt;/span&gt;
    &lt;span class="c1"&gt;;;             if text or buffer is read-only)&lt;/span&gt;
    &lt;span class="c1"&gt;;;    then the body is executed.&lt;/span&gt;
    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;buffer-read-only&lt;/span&gt; &lt;span class="nv"&gt;text-read-only&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;;; this is the if-part&lt;/span&gt;
     &lt;span class="c1"&gt;;; then...&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;copy-region-as-kill&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;kill-read-only-ok&lt;/span&gt;            &lt;span class="c1"&gt;;; usually this variable is nil&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Read only text copied to kill ring"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="c1"&gt;;; or else, signal an error if the buffer is read-only;&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;barf-if-buffer-read-only&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="c1"&gt;;; and, in any case, signal that the text is read-only.&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;signal&lt;/span&gt; &lt;span class="ss"&gt;'text-read-only&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;current-buffer&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="condition-case"&gt;condition-case&lt;/h3&gt;
&lt;p&gt;前面说过，当Emacs Lisp解释器在执行语句发生错误时，它将提供帮助信息，这被称为"signaling a error"。通常，程序将停止执行并显示错误信息。&lt;/p&gt;
&lt;p&gt;然而在一些复杂的情况下。程序不应该在出错的时候只是简单的停止程序执行。在kill-region函数中，一个典型的错误是，如果在只读缓冲区中删除文本时，文本将不会被删除。因此kill-region函数包含了处理这种情况的代码。这些代码在kill-region函数中condition-case语句的内部。&lt;/p&gt;
&lt;p&gt;condition-case的模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;condition-case&lt;/span&gt;
  &lt;span class="nv"&gt;var&lt;/span&gt;
  &lt;span class="nv"&gt;bodyform&lt;/span&gt;
  &lt;span class="nv"&gt;error-handler...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果没有发生错误，解释器将执行bodyform语句。&lt;/p&gt;
&lt;p&gt;错误发生时，函数将产生错误信息，定义一个或者多个错误条件名称（condition name）。&lt;/p&gt;
&lt;p&gt;condition-case的第三个参数是一个错误处理器。一个错误处理器包含了两个部分，一个condition-name和一个body。如果错误处理器的condition-name与发生错误时的condition-name匹配，错误处理器的body部分将执行。&lt;/p&gt;
&lt;p&gt;错误处理器中的错误条件名称（condition-name）可以是一个单一的condition name也可以是包含多个condition name的list。&lt;/p&gt;
&lt;p&gt;condition-case语句可以包含一个或多个错误处理器。当错误发生时，第一个被匹配的处理器被执行。&lt;/p&gt;
&lt;p&gt;最后，condition-case语句的第一个参数var，有时被绑定到包含错误信息的变量上。如果它为nil，比如在kill-region中，错误消息将被丢弃。&lt;/p&gt;
&lt;p&gt;简单来说，在kill-region函数中，condition-case的工作如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;If no errors, run only this code
    but, if errors, run this other code.
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="delete-and-extract-region"&gt;delete-and-extract-region&lt;/h3&gt;
&lt;p&gt;一个condition-case语句有二个部分，一个是正常时执行的，但它有可能会产生错误。另一个部分用于出错时执行。&lt;/p&gt;
&lt;p&gt;先来看kill-region中正常运行的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;delete-and-extract-region&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;last-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;this-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来比较复杂，使用了新的函数：delete-and-extract-region，kill-append和kill-new，和新的变量last-command和this-command。&lt;/p&gt;
&lt;p&gt;delete-and-extract-region函数是一个内置函数，它删除region中的文本并返回这些文本。这个函数实际上是移除（removes）文本。（当不能移除时，它给出错误信号）&lt;/p&gt;
&lt;p&gt;这里的let语句将delete-and-extract-region的返回值赋给局部变量string中。这也就是从缓冲区中删除的文本。&lt;/p&gt;
&lt;p&gt;如果变量string指向了文本，那些文本就被添加到kill ring，如果变量值为nil则表示没有文本被删除。&lt;/p&gt;
&lt;p&gt;这里使用了when来检查变量string是否指向了文本块。when语句是程序员的一种简便写法。when语句是没有else部分的if语句。可以把when理解为if。&lt;/p&gt;
&lt;p&gt;技术上来说，when是一个Lisp宏。Lisp宏允许你定义新的控制结构和其它语言功能。它告诉解释器如何计算另一个Lisp语句的值，并返回计算的结果。这里的'另一个表达式'就是一个if表达式。C语言里也提供了宏。但这是不同的，但它们同样很有用。&lt;/p&gt;
&lt;p&gt;如果string变量有内容，另一个条件表达式被执行。这是一个包含了then部分和else部分的if语句。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;last-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果前一个命令是kill-region，then部分被执行。如果不是，else部分将被执行。&lt;/p&gt;
&lt;p&gt;last-command是一个Emacs变量。通常，当一个函数被执行，Emacs将设置last-command的值为前一个命令。&lt;/p&gt;
&lt;p&gt;在这段定义中，if语句检查前一个命令是否为kill-region。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连续拷贝新文本到kill ring中前一个clipped的文本块中。如果(&amp;lt; end beg)表达式为true，kill-append添加文本到前一个被clipped的文本块中。&lt;/p&gt;
&lt;p&gt;如果yank文本，比如'粘贴'，将一次得到整个文本块。用这种方式，你可以删除一行中的两个单词，然后使用一次yank操作，重新得到这两个单词，（(&amp;lt; end beg)语句保持单词的顺序是正确的）&lt;/p&gt;
&lt;p&gt;如果前一个命令不是kill-region，kill-new函数将被执行，它将文本作为kill ring中的最后一个元素添加进去，然后将变量kill-ring-yank-pointer设置到上面。&lt;/p&gt;
&lt;h2&gt;delete-and-extract-region&lt;/h2&gt;
&lt;p&gt;zap-to-char命令使用了delete-and-extract-region函数，它使用了另外两个函数，copy-region-as-kill和del_range_1。copy-region-as-kill函数将在下节讨论；它复制了region的一份拷贝到kill ring中，因此内容可以yanked回来。&lt;/p&gt;
&lt;p&gt;delete-and-extract-region函数移除region中的内容且不能恢复。&lt;/p&gt;
&lt;p&gt;与其它代码不同，delete-and-extract-region不是用Emacs Lisp编写的；它是用C编写的，这也是Emacs的一个基础系统。&lt;/p&gt;
&lt;p&gt;与其它Emacs原生函数一样，delete-and-extract=region是C宏，宏是一个代码模板。完整宏如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;DEFUN&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"delete-and-extract-region"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;Fdelete_and_extract_region,&lt;/span&gt;
       &lt;span class="nv"&gt;Sdelete_and_extract_region,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
  &lt;span class="s"&gt;"Delete the text between START and END and return it."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start,&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="nv"&gt;Lisp_Object&lt;/span&gt; &lt;span class="nv"&gt;start,&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;{&lt;/span&gt;
  &lt;span class="nv"&gt;validate_region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;&amp;amp;start,&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
  &lt;span class="nb"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;del_range_1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;XINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;XINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DEFUN与Lisp中的defun是同样的用途。DEFUN后面括号中有七个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个部分给出了Lisp函数的名称，delete-and-extract-region&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二部分是C函数的名称，Fdelete_and_extract_region。习惯上以F开头。因为C不能在函数名中使用连字符，因此用下划线替代了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个部分是记录了供函数内部使用的信息的C常量结构。它的名称与C函数名一致但它以S开头。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四和第五个部分指定了最小和最大的参数个数。这个函数需要2个参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第六部分与Lisp编写的函数中的交互式语句类似：一个字符后跟着可选的提示信息。两者不同之处在于Lisp没有参数时不需要写参数。在这个宏里需要写成0（null string）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第七个部分是文档字符串与Lisp编写的函数中的相同。不同之处在于换行时，需要在\n后面添加一个反斜线并添加回车。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，goto-char的文档字符串的前两行如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        "Set point to POSITION, a number or marker.\n\
      Beginning of buffer is position (point-min), end is (point-max).
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在C宏中，紧接在后面是正式的参数，和参数类型语句，接下来就是宏的'body'部分。delete-and-extract-region的'body'包含了两行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;validate_region (&amp;amp;start, &amp;amp;end);
return del_range_1 (XINT (start), XINT (end), 1, 1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个函数validate_region检查传递的区域起始位置和结束位置是否是在规定的范围内，检查参数类型是否正确。第二个函数del_range_1，执行删除文本的操作。&lt;/p&gt;
&lt;p&gt;del_range_1是一个复杂的函数我们不深入研究。它修改缓冲区并执行其它操作。&lt;/p&gt;
&lt;p&gt;传递给del_range的两个参数XINT (start) and XINT (end)值得研究一下。&lt;/p&gt;
&lt;p&gt;C语言中，start和end是标记了被删除区域的开始位置和结束位置的两个整数。&lt;/p&gt;
&lt;p&gt;早期版本的Emacs中，这两个数字是32bits长，但这个代码运行比较慢。三个bit被用于指定类型信息，四个bit被用于处理内存；其它bits被作为'content'。&lt;/p&gt;
&lt;p&gt;XINT是一个C宏它从bits集合中解析出相关的数字；4个bits被丢弃。&lt;/p&gt;
&lt;p&gt;delete-and-extract-region命令看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;del_range_1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;XINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;XINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它删除start和end之间的region。&lt;/p&gt;
&lt;p&gt;从这点来看Emacs Lisp很简单；它隐藏了大量复杂的工作。&lt;/p&gt;
&lt;h2&gt;使用用defvar初始化变量&lt;/h2&gt;
&lt;p&gt;与delete-and-extract-region函数不同，copy-region-as-kill函数是用Emacs Lisp编写的。它内部有两个函数kill-append和kill-new，复制缓冲区区域中的信息到变量kill-ring中。这节讨论kill-ring变量是如何被defvar创建和初始化的。&lt;/p&gt;
&lt;p&gt;在Emacs Lisp中kill-ring之类的变量是用defvar创建和初始化的。这个名称来源于"define variable"。&lt;/p&gt;
&lt;p&gt;defvar与setq设置变量类似。与setq不同的两点：第一，它只给未赋值的变量赋值，如果变量已经有值，defvar将不会覆盖已经存在的值。第二，defvar有一个文档字符串。&lt;/p&gt;
&lt;p&gt;（另一个特别的form是defcustom，被设计为可以让用户自定义。它比defvar有更多的功能。）&lt;/p&gt;
&lt;h3 id="cha-kan-bian-liang-de-dang-qian-zhi"&gt;查看变量的当前值&lt;/h3&gt;
&lt;p&gt;可以使用describe-variable函数查看任何变量的当前值，通常可以用C-h v来调用。比如可以C-h v然后输入kill-ring将看到 当前kill ring的值，同时也能看到kill-ring的文档字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Documentation&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;killed&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;sequences&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Since&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;kill&lt;/span&gt; &lt;span class="n"&gt;ring&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;supposed&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;interact&lt;/span&gt; &lt;span class="n"&gt;nicely&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;cut&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;and&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;paste&lt;/span&gt;
&lt;span class="n"&gt;facilities&lt;/span&gt; &lt;span class="n"&gt;offered&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;window&lt;/span&gt; &lt;span class="n"&gt;systems&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;should&lt;/span&gt;
&lt;span class="n"&gt;interact&lt;/span&gt; &lt;span class="n"&gt;nicely&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;interprogram&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cut&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="s1"&gt;' and&lt;/span&gt;
&lt;span class="s1"&gt;`interprogram-paste-function'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;  &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;functions&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;kill&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="s1"&gt;',&lt;/span&gt;
&lt;span class="s1"&gt;`kill-append'&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;kill&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;supposed&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;implement&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;
&lt;span class="n"&gt;interaction&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;may&lt;/span&gt; &lt;span class="n"&gt;want&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;them&lt;/span&gt; &lt;span class="n"&gt;instead&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;manipulating&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;kill&lt;/span&gt;
&lt;span class="n"&gt;ring&lt;/span&gt; &lt;span class="n"&gt;directly&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kill ring是使用defvar按下面的方法定义的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
  &lt;span class="s"&gt;"List of killed text sequences.&lt;/span&gt;
&lt;span class="s"&gt;..."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个变量定义中，变量初始化为nil。这意味着如果没有保存任何东西，使用yank时将不会获取到任何信息。文档字符串的写法与使用defun时的文档字符串是一样的，文档字符串的第一行必须是一个完整的语句，因为一些命令，比如apropos只打印文档字符串的第一行。后面的行不应该使用缩进；否则如果用C-h v(describe-variable)查看时将会混乱。&lt;/p&gt;
&lt;h3 id="defvarshi-shi-yong-xing-hao"&gt;defvar时使用星号&lt;/h3&gt;
&lt;p&gt;以前，Emacs使用defvar来定义希望被用户修改的变量和不希望被用户修改的变量。尽管你可以用defvar定义自定义变量，但是请使用defcustom来代替。&lt;/p&gt;
&lt;p&gt;当使用defvar设定变量时，可以在文档字符串的第一个位置添加*号来来区分变量是否为可以设值的变量。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;shell-command-default-error-buffer&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
  &lt;span class="s"&gt;"*Buffer name for &lt;/span&gt;&lt;span class="ss"&gt;`shell-command'&lt;/span&gt;&lt;span class="s"&gt; ... error output.&lt;/span&gt;
&lt;span class="s"&gt;... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表示你可以使用edit-options命令临时修改shell-command-default-error-buffer的值。&lt;/p&gt;
&lt;p&gt;edit-options设置的值只在当前编辑会话中有用。新值并不会被保存。每次Emacs启动时它将读取原始值，除非你在.emacs文件中设定它。&lt;/p&gt;
&lt;h2&gt;copy-region-as-kill&lt;/h2&gt;
&lt;p&gt;这个函数从缓冲区中复制区域中的内容（使用kill-append或kill-new）并保存到kill-ring上。&lt;/p&gt;
&lt;p&gt;如果在调用kill-region后立即调用copy-region-as-kill，Emacs会将新的文本追加到前一个复制的文本中。这意味着你使用yank时将得前面两次操作的所有文本。另一方面，如果在copy-region-as-kill之前执行了一些命令，则函数复制的文本块将不会放在一起。&lt;/p&gt;
&lt;h3 id="wan-zheng-de-copy-region-as-killhan-shu-ding-yi"&gt;完整的copy-region-as-kill函数定义&lt;/h3&gt;
&lt;p&gt;下面是Emacs 21中copy-region-as-kill函数定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;copy-region-as-kill&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Save the region as if killed, but don't kill it.&lt;/span&gt;
&lt;span class="s"&gt;In Transient Mark mode, deactivate the mark.&lt;/span&gt;
&lt;span class="s"&gt;If &lt;/span&gt;&lt;span class="ss"&gt;`interprogram-cut-function'&lt;/span&gt;&lt;span class="s"&gt; is non-nil, also save&lt;/span&gt;
&lt;span class="s"&gt;the text for a window system cut and paste."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;last-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;transient-mark-mode&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;deactivate-mark&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数也可以拆分成多个部分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;copy-region-as-kill&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;argument-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数是beg、end和参数为"r"的交互式函数，因此这两个参数将指向region的开始位置和结束位置。&lt;/p&gt;
&lt;p&gt;一旦设置了一个mark，缓冲区就总会包含一个region。可以使用Transient Mark模式来高亮显示region。（没人会希望region一直处理于高亮状态，因此Transient Mark模式下只会在适当的时候才会高亮显示。许多人都关掉了Transient Mark模式，因此region从不会高亮显示）&lt;/p&gt;
&lt;p&gt;copy-region-as-kill函数体是一个以if开头的子句。这个子句区分了两种情况：这个命令的前一个命令是否是kill-region命令。第一种情况，新的region被追加到前一个被复制的文本块中。否则，它将插入一个新的文本块到kill ring中。&lt;/p&gt;
&lt;h3 id="copy-region-as-killde-bodybu-fen"&gt;copy-region-as-kill的body部分&lt;/h3&gt;
&lt;p&gt;copy-region-as-kill函数和kill-function的工作很相似。两者都是为了将同一行中的两次或多次kill操作合并到同一个块中。如果用yank回来，将一次获得所有的文本块。并且，不管是向前删除还是向后删除，文本块都保持了正确的位置。&lt;/p&gt;
&lt;p&gt;与kill-region相同，copy-region-as-kill函数也使用了last-command（它保持了对次Emacs命令调用的跟踪）变量。&lt;/p&gt;
&lt;h4 id="last-commandhe-this-command"&gt;last-command和this-command&lt;/h4&gt;
&lt;p&gt;通常，任何一个函数被执行，Emacs将在函数被挪时设置this-command为被执行的函数。同时，Emacs将last-command的值设置为this-command的前一个值。&lt;/p&gt;
&lt;p&gt;在copy-region-as-kill函数的body部分，一个if语句检查了last-command的值是否为kill-region。如果是，则if语句被执行；它使用kill-append函数将本次函数调用复制的文本合并到kill ring的第一个元素（CAR）中。如果last-command不为kill-region，则copy-region-as-kill函数将使用kill-new函数在kill ring中添加一个新的元素。&lt;/p&gt;
&lt;p&gt;这个if语句如下，它使用了eq函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;last-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; then-part&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;; else-part&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;eq函数测试它的第二个参数与第一个参数是否为相同的Lisp对象。eq函数与用于测试相等的equal函数类似，不同之处在于：eq测试两个对象是否为指向同一个对象，而equal则检查两个参数的结构和同容是否相同。&lt;/p&gt;
&lt;p&gt;如果前一个命令是kill-region，则Emacs Lisp解释器将调用kill-append函数。&lt;/p&gt;
&lt;h4 id="kill-appendhan-shu"&gt;kill-append函数&lt;/h4&gt;
&lt;p&gt;kill-append函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="nv"&gt;before-p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Append STRING to the end of the latest kill in the kill ring.&lt;/span&gt;
&lt;span class="s"&gt;If BEFORE-P is non-nil, prepend STRING to the kill.&lt;/span&gt;
&lt;span class="s"&gt;If &lt;/span&gt;&lt;span class="ss"&gt;`interprogram-cut-function'&lt;/span&gt;&lt;span class="s"&gt; is set, pass the resulting kill to&lt;/span&gt;
&lt;span class="s"&gt;it."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;before-p&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kill-append函数使用了kill-new函数。&lt;/p&gt;
&lt;p&gt;首先来看传递给kill-new的参数。它使用了concat连接新文本和kill ring的CAR。是合并到CAR元素的前面还是合并到CAR元素后面取决于if语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;before-p&lt;/span&gt;                            &lt;span class="c1"&gt;; if-part&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;     &lt;span class="c1"&gt;; then-part&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;      &lt;span class="c1"&gt;; else-part&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果被kill的region位于前一个命令kill的region的前面，那么它将被合并到前一次删除的资源的前面，如果被删除的文本在前次删除文本的后面，那它将被合并到前次删除资源的后面。if语句使用before-p决定如何放置。&lt;/p&gt;
&lt;p&gt;符号before-p是kill-append的参数。当kill-append被执行时，它被绑定到实际参数计算出来的值上。在这里是表达式(&amp;lt; end beg)。这个表达式并不能直接决定被删除的文本应该放在上个命令删除的文本的前面还是后面，它决定的是end是否小于beg。意味着用户是向前删除还是向后删除。如果(&amp;lt; end beg)则文本应该加有前一次文本的前面，否则文本应该加在前次文本的后面。&lt;/p&gt;
&lt;p&gt;新文本加到前面时，执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新文本加到后面时，执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以意识到kill-append修改了kill ring。kill ring是一个list，它的每个元素保存了文本。kill-append函数使用kill-new函数，kill-new函数使用了setcar函数。&lt;/p&gt;
&lt;h4 id="kill-newhan-shu"&gt;kill-new函数&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Make STRING the latest kill in the kill ring.&lt;/span&gt;
&lt;span class="s"&gt;Set the kill-ring-yank pointer to point to it.&lt;/span&gt;
&lt;span class="s"&gt;If &lt;/span&gt;&lt;span class="ss"&gt;`interprogram-cut-function'&lt;/span&gt;&lt;span class="s"&gt; is non-nil, apply it to STRING.&lt;/span&gt;
&lt;span class="s"&gt;Optional second argument REPLACE non-nil means that STRING will replace&lt;/span&gt;
&lt;span class="s"&gt;the front of the kill ring, rather than being added to the list."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fboundp&lt;/span&gt; &lt;span class="ss"&gt;'menu-bar-update-yank-menu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;menu-bar-update-yank-menu&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcar&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-yank-pointer&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看下面的部分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; then&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcar&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;;; else&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;;; avoid overly long kill ring&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-yank-pointer&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;条件测试(and replace kill-ring)，如果两个kill ring中有内容，并且replace变量为true则返回true。&lt;/p&gt;
&lt;p&gt;kill-append函数将replace设置为true；然后当kill ring至少有一个元素时，setcar语句被执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcar&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setcar函数将kill-ring的第一个元素修改为string的值。它替换了原来的元素。&lt;/p&gt;
&lt;p&gt;如果kill ring为空，或者replace为false，则条件语句的else部分将执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语句先通过在原来的kill ring前添加新元素string，而构造了一个新的kill ring。然后执行了第二个if子句。第二个if子名防止了kill ring增长过大。&lt;/p&gt;
&lt;p&gt;依次来看这两个语句。&lt;/p&gt;
&lt;p&gt;setq的这行将string添加到旧的kill ring组成的新list重新设置给kill-ring。&lt;/p&gt;
&lt;p&gt;第二个if子名，防止了kill ring增长得过长。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码检查kill ring的长度是否已经超过了允许的最大长度&amp;mdash;&amp;mdash;kill-ring-max（默认为60）。如果kill ring过长，则将kill ring的最后一个元素设置为nil。执行这个操作使用了两个函数：nthcdr和setcdr。&lt;/p&gt;
&lt;p&gt;setcdr设置list的CDR部分，setcar设置list的CAR部分。在这里，setcdr不会设置kill ring的CDR部分；nthcdr函数限制了设置CDR的位置。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;trees&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;maple&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;birch&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (maple oak pine birch)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;trees&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

&lt;span class="nv"&gt;trees&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (maple oak pine)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setcdr返回值为nil，是因为它设置的CDR是nil。&lt;/p&gt;
&lt;p&gt;kill-new函数中的下一行语句是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-yank-pointer&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kill-ring-yank-pointer也是一个全局变量，它被设置为kill-ring。&lt;/p&gt;
&lt;p&gt;尽管kill-ring-yank-pointer被称为pointer，实际上却是kill ring变量。但选用名字是为了帮助人们懂得这个变量起的作用。这个变量用于yank和yank-pop等函数。&lt;/p&gt;
&lt;p&gt;现在，回到函数的最前面的两行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fboundp&lt;/span&gt; &lt;span class="ss"&gt;'menu-bar-update-yank-menu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;menu-bar-update-yank-menu&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句第一个元素是函数and。&lt;/p&gt;
&lt;p&gt;and将依次对每个参数求值只到某个参数返回值为nil，这种情况下and语句将返回nil；如果没有参数返回值为nil，返回值将是最后一个参数的值。（这种情况下返回值不会为nil，在Emacs Lisp里可以作为true）。换言之，and语句只有在所有参数都返回true的情况下才返回true。&lt;/p&gt;
&lt;p&gt;在这里，语句测试了menu-bar-update-yank-menu是否是一个函数，如果是则调用它。如果测试的参数符号是一个函数定义而不是'is not void'，则fboundp返回true，如果函数未定义则我们将得到错误信息。&lt;/p&gt;
&lt;p&gt;这个and和if语句效果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;the-menu-bar-function-exists&lt;/span&gt;
  &lt;span class="nv"&gt;then&lt;/span&gt; &lt;span class="nv"&gt;execute-it&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;menu-bar-update-yank-menu函数允许用户使用'Select and Paste'菜单操作，并且可以在菜单上看到文本块。&lt;/p&gt;
&lt;p&gt;最后一个语句kill-new函数添加新的文本到窗口系统中，以便在不同的程序中进行复制粘贴操作。比如：在XWindow系统中x-select-text函数将文本存储在X系统操作的内存中，你可以在另一个程序中粘贴。&lt;/p&gt;
&lt;p&gt;语句结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果interprogram-cut-function存在，则Emacs执行funcall，它将第一个参数作为函数，并将其它参数传递给这个函数。&lt;/p&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;car&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cdr&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;car返回list的第一个元素；cdr返回list中从第二个元素开始的list。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 1&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (2 3 4 5 6 7)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;cons&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cons将第一个参数添加到第二个参数前面。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (1 2 3 4)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;nthcdr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回对list求'n'次CDR的值。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (4 5 6 7)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setcar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setcdr&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;setcar修改list中的第一个元素；setcdr修改list中第二个元素开始的list。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;triple&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcar&lt;/span&gt; &lt;span class="nv"&gt;triple&lt;/span&gt; &lt;span class="ss"&gt;'37&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;triple&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (37 2 3)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="nv"&gt;triple&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="s"&gt;"bar"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nv"&gt;triple&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (37 "foo" "bar")&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;progn&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依次执行各个参数并返回最后一个参数的值。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;save-restriction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录当前缓冲区的任何narrowing，在执行完它的参数后，恢复narrowing。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;search-forward&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找字符串，如果找到则将point设置到那个位置。&lt;/p&gt;
&lt;p&gt;它接收4个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;要查找的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，是一个缓冲区位置，它用于限制查询范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，查询失败执行的代码，返回nil或者显示错误信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询的次数，如果为负数则向前查找&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;kill-region&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete-region&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;copy-region-as-kill&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;kill-region剪切point和mark间的文本到kill ring上，可以用yanking恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete-and-extract-region移除point和mark间的文本并丢弃。不能恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;copy-region-as-kill复制point和mark间的文本到kill ring，可以用yanking恢复。这个函数并不移除原来的文本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;List的实现&lt;/h1&gt;
&lt;p&gt;Lisp中list使用了连续的指针对来保存数据，指针对的第一个指针指向一个原子或者另一个list，指针对的第二个指针指向另一个指针对，或者指向nil，以表明list的结束。&lt;/p&gt;
&lt;h2&gt;List图示&lt;/h2&gt;
&lt;p&gt;举例来说，list(rose violet buttercup)有3个元素，rose，violet和buttercup。在计算机中，rose的地址被保存在计算机内存中，通过这个地址可以知道原子violet被分配在了哪个位置；通过这个地址又可以知道原子buttercup的地址。&lt;/p&gt;
&lt;p&gt;听起来比较复杂，看图就简单多了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    ___ ___      ___ ___      ___ ___
   |___|___|--&amp;gt; |___|___|--&amp;gt; |___|___|--&amp;gt; nil
     |            |            |
     |            |            |
      --&amp;gt; rose     --&amp;gt; violet   --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个图中，每个方框代表一个保存了Lisp对象的内存块，这通常是一个内存地址。在方框中的地址是成对的。每个箭头指向了这个地址的内容，它可能是一个原子也可能是另一个地址对。第一个方框是rose的地址；第二个方框保存了下一个方框对的地址，这个地址的第一个部分指向violet第二个部分指向下一个方框对。最后一个方框指向符号nil，标明list的结束。&lt;/p&gt;
&lt;p&gt;当执行一个设置函数时比如setq，它将第一个方框的地址保存到变量中。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;bouquet&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;rose&lt;/span&gt; &lt;span class="nv"&gt;violet&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;产生的情况如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --&amp;gt; |___|___|--&amp;gt; |___|___|--&amp;gt; |___|___|--&amp;gt; nil
            |            |            |
            |            |            |
             --&amp;gt; rose     --&amp;gt; violet   --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个例子中符号bouquet保存了第一个方框对的地址。&lt;/p&gt;
&lt;p&gt;同样，list也可以被成有序的方框：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  --&amp;gt;| rose  |   o-------&amp;gt;| violet |   o-------&amp;gt;| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（符号是由地址组成的。实际上bouquet包含了一组地址，一个地址指向可打印的单词bouquet，第二个是地址绑定到该符号上的函数定义（如果存在），第三个地址是list(rose violet buttercup)的第一个地址对的地址，等等。这里只显示了第三个地址的情况。）&lt;/p&gt;
&lt;p&gt;如果符号指向list的CDR部分，这个list本身不会改变；符号将拥有从那个位置开始的list。（CAR和CDR是'non-destructive'的）因此执行下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;flowers&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;bouquet&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将产生下面的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --&amp;gt; |   |   |  --&amp;gt; |   |   |    |   |   |
       |___|___|----&amp;gt; |___|___|--&amp;gt; |___|___|--&amp;gt; nil
         |              |            |
         |              |            |
          --&amp;gt; rose       --&amp;gt; violet   --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;flowers的值是(violet buttercup)，这就是说符号flowers拥有了一个地址对的地址。&lt;/p&gt;
&lt;p&gt;这种地址对被称为cons cell或者dotted pair。&lt;/p&gt;
&lt;p&gt;函数cons添加一个新的地址对到一连串地址对的前面。例如，执行下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;bouquet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'lily&lt;/span&gt; &lt;span class="nv"&gt;bouquet&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;产生的效果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --&amp;gt; |   |   |      |   |   |  --&amp;gt; |   |   |     |   |   |
       |___|___|----&amp;gt; |___|___|----&amp;gt; |___|___|----&amp;gt;|___|___|--&amp;gt; nil
         |              |              |             |
         |              |              |             |
          --&amp;gt; lily      --&amp;gt; rose       --&amp;gt; violet    --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而这并不会改变flowers的值，你可以看到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;bouquet&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;flowers&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将返回t。&lt;/p&gt;
&lt;p&gt;到现在为止，flowers的值仍是(violet buttercup)；它拥有violet的cons cell地址。这也不会改变任何之前的cons cells；他们仍然在那里。&lt;/p&gt;
&lt;p&gt;就这样，在Lisp里获取list的CDR，将获取到连续的cons cell串中的第二个；获取list的CAR，将得到第一个。将cons将一个新元素连接到list上，你将会把新元素的cons cell添加到list的前面。&lt;/p&gt;
&lt;p&gt;cons cell串的最后一个指向什么？它指向空list，nil。&lt;/p&gt;
&lt;h2&gt;把符号看作抽屉柜&lt;/h2&gt;
&lt;p&gt;前面章节曾提示过把符号（symbol）想像成抽屉柜。函数定义放到一个抽屉里，变量放到了另一个，等等。&lt;/p&gt;
&lt;p&gt;实际上放在各个抽屉里的是值或函数定义的地址。&lt;/p&gt;
&lt;p&gt;（另外，符号有一个抽屉存放属性列表（property list），它用于记录其它信息。）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;Chest&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Drawers&lt;/span&gt;            &lt;span class="n"&gt;Contents&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Drawers&lt;/span&gt;

            &lt;span class="n"&gt;__&lt;/span&gt;   &lt;span class="n"&gt;o0O0o&lt;/span&gt;   &lt;span class="n"&gt;__&lt;/span&gt;
          &lt;span class="o"&gt;/&lt;/span&gt;                 \
         &lt;span class="o"&gt;---------------------&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;     &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;             &lt;span class="n"&gt;bouquet&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;                     &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------+&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="n"&gt;definition&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;none&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;                     &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------+&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rose&lt;/span&gt; &lt;span class="n"&gt;violet&lt;/span&gt; &lt;span class="n"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;                     &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------+&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;property&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;described&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;                     &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------+&lt;/span&gt;
        &lt;span class="o"&gt;|/&lt;/span&gt;                   &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Yanking Text Back&lt;/h1&gt;
&lt;p&gt;当使用'kill'命令剪切文本时，可以用'yank'命令恢复它。被剪切的文本被放到kill ring，yank命令可以将文本恢复。&lt;/p&gt;
&lt;p&gt;C-y（yank）命令插入kill ring中的第一个元素到缓冲区。如果C-y命令后立即跟一个M-y，则插入的文本将被替换为kill ring的第二个元素。连续的按M-y，将使用kill ring中更靠后的文本替换前一次操作插入的文本。当到达最后一个元素时，又将从第一个元素开始。（这也是kill ring被称作ring而不是list的原因）然而实际上保存了文本的数据结构是list。&lt;/p&gt;
&lt;h2&gt;Kill Ring Overview&lt;/h2&gt;
&lt;p&gt;kill ring是被删除字符串的列表。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"some text"&lt;/span&gt; &lt;span class="s"&gt;"a different piece of text"&lt;/span&gt; &lt;span class="s"&gt;"yet more text"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按C-y字符串some text将插入当前缓冲区的光标位置。&lt;/p&gt;
&lt;p&gt;yank命令也可以用于复制文本。复制文本而不从缓冲区剪切文本，文本被复制一份放到kill ring中。&lt;/p&gt;
&lt;p&gt;有三个函数可以将文本从kill ring上恢复：yank，通常被绑定在C-y上；yank-pop，通常绑定在M-y；rotate-yank-pointer它使用了另外两个函数。&lt;/p&gt;
&lt;p&gt;这些函数通过变量kill-ring-yank-pointer指向kill ring。实际上yank和yank-pop插入文本的代码都是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-yank-pointer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了弄清楚yank和yank-pop是如何工作的，先需要了解kill-ring-yank-pointer变量和rotate-yank-pointer函数。&lt;/p&gt;
&lt;h2&gt;变量kill-ring-yank-pointer&lt;/h2&gt;
&lt;p&gt;kill-ring-yank-pointer是与kill-ring类似的变量。&lt;/p&gt;
&lt;p&gt;如果kill ring的内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"some text"&lt;/span&gt; &lt;span class="s"&gt;"a different piece of text"&lt;/span&gt; &lt;span class="s"&gt;"yet more text"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kill-ring-yank-pointer将指向list第二个部分开始的list，kill-ring-yank-pointer是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"a different piece of text"&lt;/span&gt; &lt;span class="s"&gt;"yet more text"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面关于List实现的章节曾说过：计算机并不会为kill-ring和kill-ring-yank-pointer分别保存拷贝。两个Lisp变量指向同一片文本，下面是图示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---&amp;gt; |   |   |  --&amp;gt; |   |   |    |   |   |
          |___|___|----&amp;gt; |___|___|--&amp;gt; |___|___|--&amp;gt; nil
            |              |            |
            |              |            |
            |              |             --&amp;gt; "yet more text"
            |              |
            |               --&amp;gt; "a different piece of text
            |
             --&amp;gt; "some text"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量kill-ring和kill-ring-yank-pointer都是指针。kill-ring常被称作列表而不是说指向列表，而kill-ring-yank-pointer被称为指向列表。&lt;/p&gt;
&lt;p&gt;rotate-yank-pointer函数修改kill-ring-yank-pointer指向的元素；当指针指向元素的第二个元素为kill ring的结束位置时，它将自动指向kill ring的第一个元素。这也展示了如何将一个list转变为ring。rotate-yank-pointer函数虽然看起来不复杂，但它实际包含了很多细节。&lt;/p&gt;
&lt;h1&gt;循环和递归&lt;/h1&gt;
&lt;p&gt;Emacs Lisp有两种方式循环执行语句：使用while循环，或者使用递归。&lt;/p&gt;
&lt;h2&gt;while&lt;/h2&gt;
&lt;p&gt;while测试它的第一个参数的值，如果为false，解释器将不会执行语句的body部分。如果为true，解释器将执行语句的body部分，然后重新测试第一个参数的值，开始下一轮循环。&lt;/p&gt;
&lt;p&gt;while语句模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;true-or-false-test&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shi-yong-whilexun-huan_1"&gt;使用while循环&lt;/h3&gt;
&lt;p&gt;如果while语句的true-or-false返回为true则body部分被执行。&lt;/p&gt;
&lt;p&gt;对while求值的返回值是true-or-false-test的值。有趣的是while循环执行时如果没有发生错误将返回nil或false，而不管循环执行了多少次。while语句执行成功也不会返回true。&lt;/p&gt;
&lt;h3 id="whilexun-huan-he-list"&gt;while循环和list&lt;/h3&gt;
&lt;p&gt;通常使用while循环来测试一个list是否包含了元素。如果有循环就执行，如果没有了循环就结束。这是一项重要的技术，下面将举例说明。&lt;/p&gt;
&lt;p&gt;最简单的测试list是否有元素的方法是执行这个list：如果没有元素，则会返回空list，()，它与nil或false同义。如果有元素则将返回这些元素。因为Emacs Lisp把任何蜚nil值当作true，如果把有元素的list作为while的判断条件，将使循环执行。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;empty-list&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对empty-list求值将返回nil。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果把animals作为while循环的条件，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;
       &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当while检查它的第一个参数时，变量animals被执行，它将返回一个list。由于这个list不为nil，while将把这个值当作true。&lt;/p&gt;
&lt;p&gt;为了防止while进入无限循环，需要一些机制来逐渐的清空list。一个常用的方法就是将传递给while语句的list替换为原来的list的CDR。每次都使用cdr函数，这样list将变短，最后list将变为空的list。这时while循环结束。&lt;/p&gt;
&lt;p&gt;例如，上面的绑定到animals变量可以用下面的语句设置为原始list的CDR。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用while和cdr函数的模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;test-whether-list-is-empty&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;
  &lt;span class="nv"&gt;set-list-to-cdr-of-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="li-print-elements-of-list"&gt;例：print-elements-of-list&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;print-elements-of-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print each element of LIST on a line of its own."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;print-elements-of-list&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行上面的代码，回显区将显示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;giraffe

gazelle

lion

tiger
nil
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zai-xun-huan-zhong-shi-yong-zi-zeng-ji-shu-qi"&gt;在循环中使用自增计数器&lt;/h3&gt;
&lt;p&gt;模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;set-count-to-initial-value&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="nv"&gt;desired-number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="c1"&gt;; true-or-false-test&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;              &lt;span class="c1"&gt;; incrementer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="zi-zeng-ji-shu-de-li-zi"&gt;自增计数的例子&lt;/h4&gt;
&lt;p&gt;计算三角型中星号的数量，参数为层数，比如四层的三角型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;               *
              * *
             * * *
            * * * *
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-rows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;; Version with&lt;/span&gt;
                                    &lt;span class="c1"&gt;;   incrementing counter.&lt;/span&gt;
  &lt;span class="s"&gt;"Add up the number of pebbles in a triangle.&lt;/span&gt;
&lt;span class="s"&gt;The first row has one pebble, the second row two pebbles,&lt;/span&gt;
&lt;span class="s"&gt;the third row three pebbles, and so on.&lt;/span&gt;
&lt;span class="s"&gt;The argument is NUMBER-OF-ROWS."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;row-number&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nv"&gt;row-number&lt;/span&gt; &lt;span class="nv"&gt;number-of-rows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;row-number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;row-number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;row-number&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行的结果为10，第二行的结果为28。&lt;/p&gt;
&lt;h3 id="zai-xun-huan-zhong-shi-yong-zi-jian-ji-shu-qi_1"&gt;在循环中使用自减计数器&lt;/h3&gt;
&lt;p&gt;模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                    &lt;span class="c1"&gt;; true-or-false-test&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;          &lt;span class="c1"&gt;; decrementer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zi-jian-ji-shu-de-li-zi"&gt;自减计数的例子&lt;/h3&gt;
&lt;p&gt;仍以上面的三角型为例，计算1到任意层的星号总数。&lt;/p&gt;
&lt;p&gt;函数定义的第一版：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; First subtractive version.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-rows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Add up the number of pebbles in a triangle."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-pebbles-in-row&lt;/span&gt; &lt;span class="nv"&gt;number-of-rows&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number-of-pebbles-in-row&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;number-of-pebbles-in-row&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-of-pebbles-in-row&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number-of-pebbles-in-row&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，我们并不需要number-of-pebbles-in-row。&lt;/p&gt;
&lt;p&gt;当执行triangle函数时，符号number-of-rows将被绑定到初始的值上。这个数值可以在函数体内作为局部变量被修改，而不用担心会影响函数外部的值。这是Lisp中一个非常重要的特性；这意味着变量number-of-rows可以用于任何使用了number-of-pebbles-in-row的地方。&lt;/p&gt;
&lt;p&gt;函数第二版如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;; Second version.&lt;/span&gt;
  &lt;span class="s"&gt;"Return sum of numbers 1 through NUMBER inclusive."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单来说，正常情况下while循环包含三个部分：
 1. 在循环执行正确的次数后，while循环的判断语句将返回false。
 2. 被循环执行的语句，它将返回需要的值。
 3. 修改true-or-false-test返回值的语句，以便循环在执行正确的次数后停止。&lt;/p&gt;
&lt;h2&gt;使用dolist和dotimes节约时间&lt;/h2&gt;
&lt;p&gt;dolist和dotimes都是为循环提供的宏。在某些情况下比直接使用while循环简单一些。&lt;/p&gt;
&lt;p&gt;dolist与在while中循环取list的CDR的方法类似，它在每次循环中自动取CDR截短list，并将截短后的list的CAR绑定到它的第一个参数上。&lt;/p&gt;
&lt;p&gt;dotimes循环可以指定循环的次数。&lt;/p&gt;
&lt;h3 id="dolisthong"&gt;dolist宏&lt;/h3&gt;
&lt;p&gt;举例来说，如果你想将一个list倒序排列，可以用reverse函数，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reverse&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里演示了如何使用while循环实现倒序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;reverse-list-with-while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Using while, reverse the order of LIST."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; make sure list starts empty&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;reverse-list-with-while&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以用dolist宏实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;reverse-list-with-dolist&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Using dolist, reverse the order of LIST."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; make sure list starts empty&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dolist&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;element&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;element&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;reverse-list-with-dolist&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个例子中，使用已存的reverse函数当然是最好的。第一个使用while循环的例子里。while先检查list是否有元素；如果有，它将list的第一个元素添加到另一个list（它的第一个元素是nil）的第一个位置。由于添加元素的顺序是反的，因此原来的list被倒序排列了。&lt;/p&gt;
&lt;p&gt;在使用while循环的语句中，(setq list (cdr list))语句截短了list，因此while循环最后停止了。在循环体中用cons语句创建了一个新的list。&lt;/p&gt;
&lt;p&gt;dolist语句与while语句类似，dolist宏自动完成了在while语句中所写的一些工作。&lt;/p&gt;
&lt;p&gt;while循环与dolist实现的两个方法不同之处在于dolist自动截短了list。'CDRs down the list'。并且它自动将CAR截短了的list的CAR赋给dolist的第一个参数。&lt;/p&gt;
&lt;h3 id="dotimeshong"&gt;dotimes宏&lt;/h3&gt;
&lt;p&gt;dotimes宏与dolist类似，但它可以指定循环次数。&lt;/p&gt;
&lt;p&gt;dotimes的第一个参数是每次循环的计数器，第二个参数是循环次数，第三个参数是返回值。&lt;/p&gt;
&lt;p&gt;举例来说，下例将number绑定到从0开始的数字，但不包含3，然后构造出一个包含3个数字的list。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;; otherwise a value is a void variable&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="c1"&gt;;=&amp;gt; (2 1 0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dotimes的返回值是value。&lt;/p&gt;
&lt;p&gt;下面是一个使用defun和dotimes实现的triangle函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-using-dotimes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-rows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Using dotimes, add up the number of pebbles in a triangle."&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;; otherwise a total is a void variable&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="nv"&gt;number-of-rows&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-using-dotimes&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;递归&lt;/h2&gt;
&lt;p&gt;递归函数使用不同的参数来调用自身。尽管执行的代码是相同的，但它们不是在同一线程执行。（不是同一个实例）&lt;/p&gt;
&lt;h3 id="di-gui-de-zu-cheng"&gt;递归的组成&lt;/h3&gt;
&lt;p&gt;一个递归函数通常包含下面三个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个true-or-false-test决定是否再次调用函数，在这里被称为do-again-test。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数名称。当这个函数被调用时，一个新的函数实例产生了，并被分配任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个函数语句，它在每次执行时返回不同的值。这里称为next-step-expression。这样，传递到新的函数实例的参数前与传递给前一个函数实例的参数不同。这将使得在执行了正确有循环次数后，条件语句do-again-test的值为false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用递归函数的简单模式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;name-of-recursive-function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;argument-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;do-again-test&lt;/span&gt;
    &lt;span class="nv"&gt;body...&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;name-of-recursive-function&lt;/span&gt;
         &lt;span class="nv"&gt;next-step-expression&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归函数每次执行时将产生一个新的函数实例，参数告诉了实例要做什么。一个参数被绑定到next-step-expression。每个实例执行时都有一个不同的next-step-expression。&lt;/p&gt;
&lt;p&gt;next-step-expression的值被用于do-again-text。&lt;/p&gt;
&lt;p&gt;next-step-expression的返回值被传递给新的函数实例，由它来决定是否停止或继续。next-step-expression被设计为在不需要循环后它能使do-again-test返回false。&lt;/p&gt;
&lt;p&gt;do-again-test有时被称为停止条件（stop condition），因为它将在测试值为false时停止循环。&lt;/p&gt;
&lt;h3 id="zai-listshang-shi-yong-di-gui"&gt;在list上使用递归&lt;/h3&gt;
&lt;p&gt;下面的例子使用了递归打印list中的各个元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print each element of LIST on a line of its own.&lt;/span&gt;
&lt;span class="s"&gt;Uses recursion."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;                              &lt;span class="c1"&gt;; do-again-test&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;              &lt;span class="c1"&gt;; body&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt;     &lt;span class="c1"&gt;; recursive call&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;                 &lt;span class="c1"&gt;; next-step-expression&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="yong-di-gui-dai-ti-ji-shu-qi"&gt;用递归代替计数器&lt;/h3&gt;
&lt;p&gt;前面章节说过的triangle函数可以用递归修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-recursively&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return the sum of the numbers 1 through NUMBER inclusive.&lt;/span&gt;
&lt;span class="s"&gt;Uses recursion."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                    &lt;span class="c1"&gt;; do-again-test&lt;/span&gt;
      &lt;span class="mi"&gt;1&lt;/span&gt;                               &lt;span class="c1"&gt;; then-part&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;                         &lt;span class="c1"&gt;; else-part&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-recursively&lt;/span&gt;          &lt;span class="c1"&gt;; recursive call&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;               &lt;span class="c1"&gt;; next-step-expression&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-recursively&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zai-di-gui-zhong-shi-yong-cond"&gt;在递归中使用cond&lt;/h3&gt;
&lt;p&gt;前一节中的triangle-recursively使用了if。它也可以使用cond，cond是conditional的缩写。&lt;/p&gt;
&lt;p&gt;尽管cond不像if那样使用得很普遍，但它还是比较常见的。&lt;/p&gt;
&lt;p&gt;使用cond的模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
 &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;body部分是一连串的list。&lt;/p&gt;
&lt;p&gt;更完整的模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;first-true-or-false-test&lt;/span&gt; &lt;span class="nv"&gt;first-consequent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;second-true-or-false-test&lt;/span&gt; &lt;span class="nv"&gt;second-consequent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;third-true-or-false-test&lt;/span&gt; &lt;span class="nv"&gt;third-consequent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当解释器执行cond语句时，它先执行body区的第一个语句的第一个元素。&lt;/p&gt;
&lt;p&gt;如果true-or-false-test返回nil，则那个list的其它部分将不会执行。程序转到list串中的下一个list。当一个true-or-false-test的返回值不为nil，则那条语句的其它部分将会执行。如果list串包含多个list，则它们依次执行并返回最后一个语句的值被返回。&lt;/p&gt;
&lt;p&gt;如果没有一个true-or-false-test的返回值为true，则cond语句返回nil。&lt;/p&gt;
&lt;p&gt;使用cond实现的triangle函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-using-cond&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-using-cond&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="di-gui-mo-shi"&gt;递归模式&lt;/h3&gt;
&lt;p&gt;下面是3个常用的递归模式。&lt;/p&gt;
&lt;h4 id="every"&gt;every&lt;/h4&gt;
&lt;p&gt;在every模式的递归中，动作将在list的每个元素上执行。&lt;/p&gt;
&lt;p&gt;基本模型如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果list为空，则返回nil。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则，在list的首元素（list的CAR）上执行动作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过递归在list的其它部分（CDR）上执行相同的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这步是可选的使用cons将正在操作的元素和已经操作过的元素列表合并。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;square-each&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Square each of a NUMBERS LIST, recursively."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;; do-again-test&lt;/span&gt;
      &lt;span class="no"&gt;nil&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;square-each&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt; &lt;span class="c1"&gt;; next-step-expression&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;square-each&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;=&amp;gt; (1 4 9)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果number-list为空，则什么也不做。如果它有内容，则通过递归构造一个list各个元素乘方值的list。&lt;/p&gt;
&lt;p&gt;前面介绍过的print-elements-recursively函数，是另一个every模式的递归，不同的是这里使用了cons合并元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print each element of LIST on a line of its own.&lt;/span&gt;
&lt;span class="s"&gt;Uses recursion."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;                              &lt;span class="c1"&gt;; do-again-test&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;              &lt;span class="c1"&gt;; body&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt;     &lt;span class="c1"&gt;; recursive call&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;                 &lt;span class="c1"&gt;; next-step-expression&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;print-elements-recursively函数的处理流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果list为空，不执行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果list含有至少一个元素，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在list的首元素（CAR）上执行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过递归调用在其它的元素上执行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="accumulate"&gt;accumulate&lt;/h4&gt;
&lt;p&gt;accumulate递归模式，在每个元素上都执行动作，动作的执行结果与对下一个元素执行操作的结果进行累积。&lt;/p&gt;
&lt;p&gt;这与在every模式中使用cons类似，只是不是使用cons，而是使用其它的方式合并。&lt;/p&gt;
&lt;p&gt;工作模式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果list为空，返回0或其它常量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则，在list的CAR上执行动作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用+或其它操作合并当前操作的元素和已经操作过的元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归方式在list的其它部分执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;add-elements&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Add the elements of NUMBERS-LIST together."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-elements&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-elements&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="c1"&gt;;=&amp;gt; 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="keep"&gt;keep&lt;/h4&gt;
&lt;p&gt;在keep递归模式中，list中的每个元素被测试，如果被操作的元素符合要求或者对元素的计算结果符合要求则保存该元素。&lt;/p&gt;
&lt;p&gt;这与every模式也很类似，只是在这里如果元素不符合要求则被忽略。&lt;/p&gt;
&lt;p&gt;这种模式的三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果list为空，则返回nil&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果list的CAR符合要求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在元素上执行操作，并使用cons合并它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归调用处理list中的其它元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果list的CAR不符合要求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;忽略这个元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归调用处理list中的其它元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;keep-three-letter-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Keep three letter words in WORD-LIST."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
   &lt;span class="c1"&gt;;; First do-again-test: stop-condition&lt;/span&gt;
   &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

   &lt;span class="c1"&gt;;; Second do-again-test: when to act&lt;/span&gt;
   &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
    &lt;span class="c1"&gt;;; combine acted-on element with recursive call on shorter list&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;keep-three-letter-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

   &lt;span class="c1"&gt;;; Third do-again-test: when to skip element;&lt;/span&gt;
   &lt;span class="c1"&gt;;;   recursively call shorter list with next-step expression&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;keep-three-letter-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;keep-three-letter-words&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;one&lt;/span&gt; &lt;span class="nv"&gt;two&lt;/span&gt; &lt;span class="nv"&gt;three&lt;/span&gt; &lt;span class="nv"&gt;four&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="nv"&gt;six&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;=&amp;gt; (one two six)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="wu-yan-shi-de-di-gui_1"&gt;无延时的递归&lt;/h3&gt;
&lt;p&gt;这部分讲解了如何将递归函数拆分成多个函数部分（比如：初始化函数、辅助函数），减少递归函数body部分的判断，使得递归函数本身只需要处理好递归操作，提高了递归函数的执行速度。&lt;/p&gt;
&lt;p&gt;这部分显得过于详细，这里省略了该部分。&lt;/p&gt;
&lt;h1&gt;正则表达式查询&lt;/h1&gt;
&lt;p&gt;在Emacs中正则表达式查询使用得很广泛。在forward-sentence和forward-paragraph中使用了正则表达式查找定位。正则表达式'regular expression'常被写作'regexp'。&lt;/p&gt;
&lt;h2&gt;sentence-end的正则表达式&lt;/h2&gt;
&lt;p&gt;符号sentence-end被绑定到匹配名末的正则式上。&lt;/p&gt;
&lt;p&gt;句末通常是用一个句号、问号或者叹号结束的。那么这个正则表达式应该包含下面的字符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[.?!]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，在有些时候句号、问号或叹号也有可能在某个语句的中间，我们并不想在使用forward-sentence的时候跳转到这些符号上去。&lt;/p&gt;
&lt;p&gt;习惯上，你可能会在每个句子后面添加空格或者tab等等。我们可以用下面的表达式来匹配：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;\\($\\| \\|  \\)
       ^   ^^
      TAB  SPC
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;$标明行末，括号前面的两个反斜线和竖线前面的两个反斜线中第一个反斜线是转义符。&lt;/p&gt;
&lt;p&gt;语句的结束位置也可能跟了一个或者多个回车，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[
]*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;星号表明可以有零个或者多个回车。&lt;/p&gt;
&lt;p&gt;一个语句的结束位置可能不只是句号、问号或叹号。它也可能是：一个回括号或其它：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[]\"')}]*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个表达式中，第一个&lt;code&gt;]&lt;/code&gt;是表达式的第一个字符；第二个字符是&lt;code&gt;"&lt;/code&gt;，综前面加了一个转义符。最后三个字符是&lt;code&gt;',),}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;前面的表达式都是用于匹配一个语句的，如果我们对sentence-end求值，将返回下面的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sentence-end
     =&amp;gt; "[.?!][]\"')}]*\\($\\|     \\|  \\)[
]*"
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;re-search-forward函数&lt;/h2&gt;
&lt;p&gt;re-search-forward函数与search-forward函数很相似。&lt;/p&gt;
&lt;p&gt;re-search-forward函数搜索一个正则表达式。如果查找成功，它将point设置在匹配目标的最后一个字符的后面。如果是向后查找，它将point设置在匹配目标的第一个字符的前面。&lt;/p&gt;
&lt;p&gt;与search-forward一样，re-search-forward函数接收四个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一个参数是要查找的正则表达式。表达式是一个被引号包括的字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个参数是可选参数，限制搜索的范围，它是当前缓冲区中的某个位置（point）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个可选参数指定搜索失败时如何处理：如果第三个参数为nil，则导致函数在搜索失败时显示错误信息；其它值将使函数失败时返回nil，搜索成功时返回t。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，用于指定重复次数。负数表示重复的向后搜索。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;re-search-forward使用模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"regular-expression"&lt;/span&gt;
                &lt;span class="nv"&gt;limit-of-search&lt;/span&gt;
                &lt;span class="nv"&gt;what-to-do-if-search-fails&lt;/span&gt;
                &lt;span class="nv"&gt;repeat-count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二、三、四个参数是可选的。如果你想传递给最后两个参数，则必须也给前面的参数全传值。否则解释器将出错。&lt;/p&gt;
&lt;p&gt;在forward-sentence函数中，sentence-end正则表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"[.?!][]\"')}]*\\($\\|  \\|  \\)[
]*"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这限制了查询范围只到当前段落的结束位置（一个句子不可能超过段落）。如果查询失败，函数将返回nil；查询的次数可以由传递给forward-sentence函数的参数来提供。&lt;/p&gt;
&lt;h2&gt;forward-sentence函数&lt;/h2&gt;
&lt;p&gt;这个命令将光标移到下一句，是在Emacs Lisp中使用正则表达式的很好的例子。实际这个函数看起来很长很复杂；这是因为函数被设计为能向前也能向后移动。该函数通常被绑定到M-e上。&lt;/p&gt;
&lt;h3 id="forward-sentenceliao-han-shu-ding-yi"&gt;forward-sentence了函数定义&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;forward-sentence&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Move forward to next sentence-end.  With argument, repeat.&lt;/span&gt;
&lt;span class="s"&gt;With negative argument, move backward repeatedly to sentence-beginning.&lt;/span&gt;
&lt;span class="s"&gt;Sentence ends are identified by the value of sentence-end&lt;/span&gt;
&lt;span class="s"&gt;treated as a regular expression.  Also, every paragraph boundary&lt;/span&gt;
&lt;span class="s"&gt;terminates sentences as well."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;par-beg&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start-of-paragraph-text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-backward&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nv"&gt;sentence-end&lt;/span&gt; &lt;span class="s"&gt;"[^ \t\n]"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;par-beg&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;match-end&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;par-beg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;par-end&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end-of-paragraph-text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;sentence-end&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;skip-chars-backward&lt;/span&gt; &lt;span class="s"&gt;" \t\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数看起来太长了，最好是先弄清楚它的骨架，然后再了解细节。我们先从最左边开始看：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;forward-sentence&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;body-of-while-loop&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;body-of-while-loop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样看起来简单多了。函数定义由文档字符串，一个interactive语句，一个or语句和while循环组成。&lt;/p&gt;
&lt;p&gt;依次来看看各个部分。&lt;/p&gt;
&lt;p&gt;文档简单易懂。&lt;/p&gt;
&lt;p&gt;interactive函数有一个"p"参数。这表示处理前缀参（C-u）。如果没有传递这个参数将被设置为1。如果在调用forward-sentence时，不是使用的交互式模式并且没有带参数，arg将被设置为nil。&lt;/p&gt;
&lt;h3 id="whilexun-huan-bu-fen"&gt;while循环部分&lt;/h3&gt;
&lt;p&gt;or语句后面有两个while循环。第一个while循环的true-or-false-test测试前缀参数是否为负数。这决定是否向后查询。循环体与第二个while的循环体类似，但不完全相同。我们跳过第一个while循环，集中看第二个循环&lt;/p&gt;
&lt;p&gt;第二个循环将向前移动point。代码骨架如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;            &lt;span class="c1"&gt;; true-or-false-test&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;varlist&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;true-or-false-test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;then-part&lt;/span&gt;
      &lt;span class="nv"&gt;else-part&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;     &lt;span class="c1"&gt;; while loop decrementer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个while循环是一个递减循环。它的true-or-false-test检查计数器（arg）是否大于0；并每次循环中将计数器减1。&lt;/p&gt;
&lt;p&gt;如果没有前缀参数传递给forward-sentence，arg将被设置为1，while循环将只运行一次。&lt;/p&gt;
&lt;p&gt;while循环体如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;par-end&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end-of-paragraph-text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;sentence-end&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;skip-chars-backward&lt;/span&gt; &lt;span class="s"&gt;" \t\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;let语句创建了一个局部变量par-end。前面我们看过，这局部变量用于限制正则表达式搜索的范围。如果它没有找到段落中的语句的结束位置，它将段落结束位置前停止搜索。&lt;/p&gt;
&lt;p&gt;首先，我们来研究一下par-end是如何被绑定到段落结束位置的。程序使用了let语句将下面语句的结果赋给了par-end变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end-of-paragraph-text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个语句中，(end-of-paragraph-text)将point移动到段落的结束位置，(point)返回当前的point，然后用save-excursion恢复point到原来的位置。因此，let将par-end绑定到了save-excursion的返回值，即段落的结束位置。（(end-of-paragraph-text)函数使用了forward-paragraph函数）&lt;/p&gt;
&lt;p&gt;接下来Emacs继续执行let的body部分，一个if语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;sentence-end&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; if-part&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;skip-chars-backward&lt;/span&gt; &lt;span class="s"&gt;" \t\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;              &lt;span class="c1"&gt;; then-part&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;                        &lt;span class="c1"&gt;; else-part&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zheng-ze-biao-da-shi-cha-xun"&gt;正则表达式查询&lt;/h3&gt;
&lt;p&gt;re-search-forward函数根据sentence-end定义的正则表达式查找名末。如果找到，re-search-forward函数将做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;re-search-forward函数将point移到找到的目标的结束位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;re-search-forward函数返回true。这个值被if接收，表明查找成功。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当查找成功后，if语句执行then部分，这部分表达式&lt;code&gt;(skip-chars-backward "\t\n")&lt;/code&gt;这个语句向后移过任何空白字符直到遇到一个可打印字符，然后把point设置在这个字符的后面。&lt;/p&gt;
&lt;p&gt;如果re-search-forward函数找不到句末位置，则函数返回false。false将使if语句执行它的第三个参数，(goto-char par-end)：它将point移到段落末尾。&lt;/p&gt;
&lt;h2&gt;forward-paragraph函数&lt;/h2&gt;
&lt;p&gt;forward-paragraph函数将point移到段落结束位置。通常被绑定到M-}上，它使用了大量重要的函数，包括：let*，match-beginning和looking-at。&lt;/p&gt;
&lt;p&gt;forward-paragraph函数定义比forward-sentence的长很多，因为它工作于段落上，段落的每行可能以是填充前缀开头。&lt;/p&gt;
&lt;p&gt;填充前缀是放在行的开头，通常是由一些重复的字符组成的字符串。比如，在Lisp代码中通常在一大段注释的每行前面添加;;;。在文本模式下(Text mode)，四个空格标明了一个段落的缩进。&lt;/p&gt;
&lt;p&gt;这意味着在查找段落时，需要查找那些最左边的列有填充前缀的行。&lt;/p&gt;
&lt;p&gt;有些情况下需要忽略这些前缀，特别是在使用空行来分隔段落时。这更增加了这个函数的复杂性。&lt;/p&gt;
&lt;h3 id="forward-paragraphhan-shu-ding-yi-de-gu-jia"&gt;forward-paragraph函数定义的骨架&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;forward-paragraph&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;
      &lt;span class="nv"&gt;varlist&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;; backward-moving-code&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;; forward-moving-code&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一部分是常见部分：参数列表，包含一个可选参数。而后是文档字符串。&lt;/p&gt;
&lt;p&gt;interactive的参数p表示可以处理前缀参数（C-u）。这是一个数字，用于设置执行的次数。or语句处理没有传递参数时的情况。&lt;/p&gt;
&lt;h3 id="letyu-ju"&gt;let*语句&lt;/h3&gt;
&lt;p&gt;符号let*不是let。&lt;/p&gt;
&lt;p&gt;let*与let类似，不同之处在于Emacs将依次给各个变量赋值，给后面的变量赋值语句可以使用前面已经赋值的变量。&lt;/p&gt;
&lt;p&gt;在这个let*语句中，Emacs设置了两个变量：fill-prefix-regexp和paragraph-separate。变量fill-paragraph-separate的值，依赖于fill-prefix-regexp的值。&lt;/p&gt;
&lt;p&gt;依次来看，符号fill-prefix-regexp的值被设置为下面的list的返回值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;paragraph-ignore-fill-prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;regexp-quote&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在前面学习kill-new函数时，我们知道and将执行传递给它的每个参数直到有一个参数的返回值为nil，这种情况下and语句返回nil；如果没有参数返回nil，and语句将返回最后一个参数的值。简单来说，and语句在所有参数都为true时返回true。&lt;/p&gt;
&lt;p&gt;变量fill-prefix-regexp只有在上面四个语句都为true时，才会设置为一个非nil值，否则fill-prefix-regexp将被设置为nil。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;fill-prefix&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当这个变量被执行时，如果没有填充前缀，变量返回nil。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句检查填充字符串是否为一个空字符串。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;paragraph-ignore-fill-prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果paragraph-ignore-fill-prefix设了值（比如t），这个表达式将返回nil。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;regexp-quote&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是and语句的最后一个语句。如果and中所有的语句都为true，这条语句的返回值将作为and语句的返回值，这个返回值被设置到变量fill-prefix-regexp。&lt;/p&gt;
&lt;p&gt;and语句的将fill-prefix-regexp设置为被regexp-quote函数修改过的fill-prefix上。regexp-quote函数读取一个字符串并返回能精确匹配这个字符串的正则表达式。这意味着fill-prefix-regexp将被设置为通匹配填充前缀的正则表达式。&lt;/p&gt;
&lt;p&gt;let*语句设置的第二个局部变量是paragraph-separate。它被设置为下面语句的返回值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;
            &lt;span class="s"&gt;"\\|^"&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt; &lt;span class="s"&gt;"[ \t]*$"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句显示了let*与let的区别。if语句的true-or-false-test检查fill-prefix-regexp是否为nil。&lt;/p&gt;
&lt;p&gt;如果fill-prefix-regexp没有值，Emacs将执行if语句的else部分，将paragraph-separate设置为它的原始值。（paragraph-separate是一个匹配段落分隔的正则表达式）&lt;/p&gt;
&lt;p&gt;如果fill-prefix-regexp有值，Emacs将执行if语句的then部分并将paragraph-separate设置为包含fill-prefix-regepx的正则表达式。&lt;/p&gt;
&lt;p&gt;特别的是，paragraph-separate被设置为由它的原始值与fill-prefix-regexp组成的新值上。&lt;code&gt;^&lt;/code&gt;表示fill-prefix-regexp必须在行首，行末可以是空白字符，这由&lt;code&gt;"[ \t]*$"&lt;/code&gt;来定义。&lt;code&gt;\\|&lt;/code&gt;表示"或"关系。&lt;/p&gt;
&lt;p&gt;接下来进入let&lt;em&gt;语句的body部分。let&lt;/em&gt;语句的第一部分处理给定的参数为负数，需要向后移动的情况。我们跳过这一部分。&lt;/p&gt;
&lt;h3 id="whilexun-huan-zhong-de-xiang-qian-yi-dong"&gt;while循环中的向前移动&lt;/h3&gt;
&lt;p&gt;let*的body的第二部分处理向前移动。由于个while循环执行arg参数指定的循环次数。通常情况下参数被设置为1，循环只执行一次，光标向前移动一个段落。&lt;/p&gt;
&lt;p&gt;这个部分共处理了三种情况：当point在段落中间时，当point在有填充前缀的段落内部时，当point在没有段落前缀的段落内部时。&lt;/p&gt;
&lt;p&gt;while循环部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;;; between paragraphs&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="c1"&gt;;; within paragraphs, with a fill prefix&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
      &lt;span class="c1"&gt;;; There is a fill prefix; it overrides paragraph-start.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;;; within paragraphs, no fill prefix&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;paragraph-start&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;match-beginning&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们马上就可以看出这是一个递减的while循环，使用了&lt;code&gt;(setq arg (1- arg))&lt;/code&gt;作为递减语句。&lt;/p&gt;
&lt;p&gt;循环体包含了三个语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; between paragraphs&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;
    &lt;span class="nv"&gt;body-of-while&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;; within paragraphs, with fill prefix&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;true-or-false-test&lt;/span&gt;
    &lt;span class="nv"&gt;then-part&lt;/span&gt;

&lt;span class="c1"&gt;;; within paragraphs, no fill prefix&lt;/span&gt;
  &lt;span class="nv"&gt;else-part&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当解释器执行while循环体时，第一件事就是执行(begion-of-line)语句将point移到行首位置。接下来是一个内部的while循环。这个while循环被设计为将光标从段落间的空白部分移出。最后是一个if语句将point移到段落的结束位置。&lt;/p&gt;
&lt;h3 id="duan-luo-zhi-jian"&gt;段落之间&lt;/h3&gt;
&lt;p&gt;首先，我们来看内部的while循环。这个循环处理point位于段落之间的情况；它使用了三个新的函数：prog1, eobp 和 looking-at。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;prog1与progn类似，但是progn1返回的是它的第一个参数的值。（progn返回它的最后一个参数的值）后面的语句也将被执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eobp是End Of Buffer P的缩写，检查point是否在缓冲区的结束位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;looking-at函数检查point后面的文本是否与传递给它的正则表达式参数匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个while循环部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个没有循环体的while循环！true-or-false-test部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;prog1的第一个参数是一个and语句。它检查point是否到了缓冲区的结束位置，也检查point后面的文本是否与正则表达式paragraph-separate匹配。&lt;/p&gt;
&lt;p&gt;如果光标不在缓冲区结束位置且光标后面的文本是一个段落分隔，则and语句返回true。执行完and语句后，解释器执行prog1的第二个参数forward-line。它将光标向前移动一行。由于prog1的返回值是它的第一个参数，因此while循环将在point不在缓冲区结束位置或位于段落之间时继续执行。最后，point将在and语句测试为false时被移到一个新段落，由于这时forward-line已经被执行了。这意味着point已经从段落之间的位置移到了段落中，它停留在新段落第二行的开始位置。&lt;/p&gt;
&lt;h3 id="duan-luo-nei-bu"&gt;段落内部&lt;/h3&gt;
&lt;p&gt;外部while循环的第二个部分是一个if语句。解释器将在fill-prefix-regexp不为nil时执行它的then部分，如果fill-prefix-regexp为nil，它将执行else部分（当段落没有填充前缀时）。&lt;/p&gt;
&lt;h3 id="mei-you-tian-chong-qian-zhui"&gt;没有填充前缀&lt;/h3&gt;
&lt;p&gt;代码包含了一个if语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;paragraph-start&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;match-beginning&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它查找一个正则表达式，直到下一个段落的开始位置，如果找到，就将point设置到那时在，如果下一个段落的开始位置未找到，则将point移到当前缓冲区可访问区域的结束位置。&lt;/p&gt;
&lt;p&gt;这段代码里只有match-beginning比较陌生。它返回一个数字，这个数字标明了上一个正则表达式所匹配位置。&lt;/p&gt;
&lt;p&gt;在这里使用match-beginning函数是由于forward search的一个特性：forward search查找成功时不管理普通查找还是正则表达式查找，它都会将point移到查找到的文本的结束位置。在这里，这样操作将使point移动到下一个段落的开始位置，而不是当前段落的结束位置。而这两个位置可能是不同的，因为段落之间可能有空行&lt;/p&gt;
&lt;p&gt;当传的参数为0时，match-beginning函数返回的位置是最近一次匹配正则表达式的文本的开始位置。在这里，最近一次使用正则表达式查找的就是paragraph-start，因此match-begnning返回匹配的开始位置，而不是匹配的结束位置。这个开始位置即段落的结束位置。&lt;/p&gt;
&lt;h3 id="you-tian-chong-qian-zhui-shi-de-qing-kuang"&gt;有填充前缀时的情况&lt;/h3&gt;
&lt;p&gt;前面讨论了if语句的else部分。如果if语句检测到有填充前缀，它将执行then部分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当下面三个条件都为true时，它将point向前移动一行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;point不是位于缓冲区结束位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;point后面的文本不是段落分隔符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;point后面的文本与填充前缀的正则表达式匹配&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;在向前移动时，forward-paragraph函数执行了下面三个操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将point移到行首&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;忽略段落之间的行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查是否有填充前缀，如果有：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向前移动一行直到该行不为段落分隔行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有填充前缀：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查找下个段落的开始位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转到下个段落的开始位置，也就是前一个段落的结束位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者转到缓冲区的结束的位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是格式化过的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;paragraph-ignore-fill-prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;regexp-quote&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;
                    &lt;span class="s"&gt;"\\|^"&lt;/span&gt;
                    &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
                    &lt;span class="s"&gt;"[ \t]*$"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="nv"&gt;omitted-backward-moving-code&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;; forward-moving-code&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;; then-part&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                                  &lt;span class="c1"&gt;; else-part: the inner-if&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;paragraph-start&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;match-beginning&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;        &lt;span class="c1"&gt;; decrementer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的代码不光有向前移动的代码，也包括了向后移动的代码。&lt;/p&gt;
&lt;p&gt;在Emacs中可以用C-h f(describe-function)和函数名来查看整个函数。&lt;/p&gt;
&lt;p&gt;可以使用M-.(find-tag)并输入函数名来查找函数定义。&lt;/p&gt;
&lt;h2&gt;创建自己的TAGS文件&lt;/h2&gt;
&lt;p&gt;M-.命令可以查看函数源码，变量或其它的源码。这个函数依赖于tags表告诉他该到哪里查找源码。&lt;/p&gt;
&lt;p&gt;经常会需要自己创建tags表。tags表被称为TAGS文件。&lt;/p&gt;
&lt;p&gt;可以用Emacs发行版中的etags程序来创建TAGS文件。通常etags不是Emacs Lisp函数，而是一个C程序。&lt;/p&gt;
&lt;p&gt;创建TAGS文件前，先进入要创建这个文件的目录。在Emacs中可以用M-x cd命令，或者直接访问某个目录C-x d(dired)。然后运行编译命令并执行etags *.el。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x compile RET etags *.el RET
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;etags命令支持通配符。如果你有两个目录，你可以使用一个TAGS文件，输入&lt;code&gt;*.el ../elisp/*.el&lt;/code&gt;，在这里&lt;code&gt;../elisp/&lt;/code&gt;是第二个目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x compile RET etags *.el ../elisp/*.el RET
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x compile RET etags --help RET
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看etags支持的选项列表。&lt;/p&gt;
&lt;p&gt;etags程序支持20多种语言，包括：Emacs Lisp、Common Lisp、Scheme、C、C++、Ada、Fortran、Java、Latex、Pascal、Perl、Python、Texinfo、makefiles等等。程序没有开关指定语言；它会根据输入的文件名和文件内容来识别语言的种类。&lt;/p&gt;
&lt;p&gt;使用：&lt;code&gt;M-x locate RET TAGS RET&lt;/code&gt;Emacs将列出你的所有TAGS文件的完整路径。&lt;/p&gt;
&lt;p&gt;如果你想访问你创建的TAGS文件，可以使用&lt;code&gt;M-x visit-tags-table&lt;/code&gt;命令。&lt;/p&gt;
&lt;h3 id="chuang-jian-emacsyuan-ma-de-tagswen-jian"&gt;创建Emacs源码的TAGS文件&lt;/h3&gt;
&lt;p&gt;GNU Emacs的源码中的Makefile文件包含了复杂的etags命令，它创建，合并所有Emacs源码中的tags放到src顶层目录中的一个TAGS文件中。&lt;/p&gt;
&lt;p&gt;你可以在Emacs源码的顶层目录中执行下面的命令来创建TAGS文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x compile RET make tags RET
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;while
循环执行直到传递给它的第一个参数为true。然后返回nil。
例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;format&lt;/span&gt; &lt;span class="s"&gt;"foo is %d.\n"&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

     &lt;span class="c1"&gt;;=&amp;gt;      foo is 2.&lt;/span&gt;
             &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="mi"&gt;1.&lt;/span&gt;
             &lt;span class="no"&gt;nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（insert函数插入它的参数到point所在的位置；format函数格式化它的参数；&lt;code&gt;\n&lt;/code&gt;产生新行。
）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;re-search-forward&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找一个正则表达式，如果找到了就将point设置到目标位置的后面。&lt;/p&gt;
&lt;p&gt;与search-forward类似，它接收四个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;要查找的正则表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，限制查询范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，查找失败时如何处理，返回nil或者显示错误信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，查找的重复数次；如果为负数，则向后查找&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;let*&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将变量值绑定到各个变量上，并执行其它的参数，返回最后一个的值。在设置变量时，可以使用前面已经设置过的局部变量。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;bar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;`bar'&lt;/span&gt;&lt;span class="s"&gt; is %d."&lt;/span&gt; &lt;span class="nv"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; `bar' is 21.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;match-beginning&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回上一次正则表达式查找时查找的文本的开始位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;looking-at&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果point后面的文本与函数的参数（是一个正则表达式）匹配则返回t。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eobp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果point在可访问的缓冲区的结束位置则返回t。如果缓冲区未被narrowed，则可访问缓冲区结束位置是缓冲区的结束位置。如果缓冲区被narrowed，则结束位置为narrowed部分的结束位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prog1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依次执行各个参数并返回第一个参数的值。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;计数：重复和正则表达式&lt;/h1&gt;
&lt;p&gt;重复执行和正则表达式是Emacs Lisp中非常强大的工具。这章讲解使用while循环和递归结合正则表达式进行查找进行字数统计。&lt;/p&gt;
&lt;h2&gt;字数统计&lt;/h2&gt;
&lt;p&gt;标准的Emacs发行版中包含了一个统计region中行数的函数。但没有统计字数的函数。&lt;/p&gt;
&lt;h2&gt;count-words-region 函数&lt;/h2&gt;
&lt;p&gt;字数统计函数可以统计行、段落、region、或者整个缓冲区。到覆盖范围该多大？Emacs的鼓励使用弹性的方式。可以将函数设计为处理region。这样即使需要统计整个缓冲区，也可以先用C-x h(mark-whole-buffer)先选定整个缓冲区。&lt;/p&gt;
&lt;p&gt;统计字数是一个重复的动作：从region的开始位置，开始统计第一个词，然后是第二个，然后第三个，如此继续直到缓冲区的结束位置。这意味着单词统计的工作适合于使用递归或者while循环。&lt;/p&gt;
&lt;h3 id="she-ji-count-words-regionhan-shu"&gt;设计count-words-region函数&lt;/h3&gt;
&lt;p&gt;首先，我们将使用while循环实现单词统计，然后是递归。当然，这个命令需要交互。&lt;/p&gt;
&lt;p&gt;交互式函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;name-of-function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;argument-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;interactive-expression...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们所要做的就是填空。&lt;/p&gt;
&lt;p&gt;函数名应该是自描述的与已存在的count-lines-region类似。这可以让命令名容易被记住。count-words-region是一个较好的名称。&lt;/p&gt;
&lt;p&gt;这个函数统计region中的字数。这说明参数列表中需要两个符号，分别绑定到region的开始位置和结束位置。这两个位置可以被称为beginning和end。文档字符串的第一行必须是一个完整的句子，因为有些命令将只打印文档的第一行，比如apropos命令。交互式语句(interactive "r")将把缓冲区开始位置和结束位置放到参数列表中。&lt;/p&gt;
&lt;p&gt;函数体需要完成三个任务：第一，设置条件，在这个条件下while循环可以统计字数。第二，执行while循环。第三，向用户显示信息。&lt;/p&gt;
&lt;p&gt;当用户调用count-words-region时point可能位于region的开始位置或结束位置。但是，计数处理只能从region的开始位置到结束位置计数。这意味着如果point没有在region的开始位置，则我们需要将point设置到region的开始位置，执行(goto-char beginning)。为了保证在函数执行完后，point可以恢复原来的位置，将需要用到save-excursion语句。&lt;/p&gt;
&lt;p&gt;函数体的中心部分是由一个while循环组成，它内部有一个每次向前跳转一个单词的语句，另一个语句负责计数。while语句的true-or-false-test应该在point达到region结束位置时返回false，在此之前返回true。&lt;/p&gt;
&lt;p&gt;我们可以使用(forward-word 1)作为向前移动一个单词的语句，如果我们使用正则表达式搜索就很容易明白Emacs中对于'word'的界定。&lt;/p&gt;
&lt;p&gt;通过一个正则表达式查找到那个位置并把point设置在最后一个字符的后面。这表示成功的向前移了一个单词。&lt;/p&gt;
&lt;p&gt;实际上还有一个问题，我们需要这个正则表达式跳过单词间的空格和标点符号。这表明正则表达式需要能匹配单词后面的空白和标点符号。（一个单词后面也可能没有空白和标点,因此正则表达式的这一部分应该是可选的）&lt;/p&gt;
&lt;p&gt;因此，我们需要的正则表达式，要能匹配一个或多个构词字符（能构成单词的字符），后面跟一个可选的由一个或多个非构词字符（不能用于构成单词的字符）。正则表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;\w+\W*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缓冲区的语法表决定了哪些是构词字符。&lt;/p&gt;
&lt;p&gt;查找语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（注意w和W前面的双斜线。单个斜线对于Emacs Lisp解释器来说有特殊意义。它表明后面一个字符需要不同的处理。比如，&lt;code&gt;\n&lt;/code&gt;表示换行。两个斜线表示斜线）&lt;/p&gt;
&lt;p&gt;我们还需要一个计数器用于计数；这个变量初始时必须为0，然后在每次执行while循环体时增加。这个语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后我们需要告诉用户region中有多少个字符。message函数用于向用户显示信息。显示信息只需要一个短语，我们并不需要很复杂。到底是简单还是复杂。我们可以用一个条件语句来解决定个问题。共有三种可能：region中没有单词，region只有一个单词，或者有多个单词。这时crond比较合适。&lt;/p&gt;
&lt;p&gt;初步的函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; First version; has bugs!&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print number of words in the region.&lt;/span&gt;
&lt;span class="s"&gt;Words are defined as at least one word-constituent&lt;/span&gt;
&lt;span class="s"&gt;character followed by at least one character that&lt;/span&gt;
&lt;span class="s"&gt;is not a word-constituent.  The buffer's syntax&lt;/span&gt;
&lt;span class="s"&gt;table determines which characters these are."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Counting words in region ... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. Set up appropriate conditions.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;beginning&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. Run the while loop.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. Send a message to the user.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zerop&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region does NOT have any words."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has 1 word."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has %d words."&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数能够工作，但并不是在所有的情况下。&lt;/p&gt;
&lt;h3 id="count-words-regionhan-shu-zhong-kong-bai-chu-li-de-bug"&gt;count-words-region函数中空白处理的Bug&lt;/h3&gt;
&lt;p&gt;前面描述的count-words-region命令有两个Bug，或者说一个Bug的两个表现。首先，如果region中只在某些文本间有空白，count-words-region命令将告诉你region中只包含了一个单词。第二，如果region中只有缓冲区结束位置或者narrowed缓冲区的可访问域的结束位置有空白，命令在执行时将显示错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Search failed: "\\w+\\W*"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以在Emacs中先安装这个函数，然后将它绑定到按键上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-c="&lt;/span&gt; &lt;span class="ss"&gt;'count-words-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以在设置region后按&lt;code&gt;C-c =&lt;/code&gt;执行（如果没有绑定按键，可以用M-x count-words-region执行）。&lt;/p&gt;
&lt;p&gt;对下面的内容执行时Emacs将告诉你，region有3个单词。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    one   two  three
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果把mark设置在这行的开头位置，point放在&lt;code&gt;one&lt;/code&gt;的前面。重新执行&lt;code&gt;C-c =&lt;/code&gt;。Emacs应该要告诉你region中没有单词，因为region只有空白。但是，Emacs告诉你region中只有一个单词。&lt;/p&gt;
&lt;p&gt;第三个测试，复制上面例的整行到&lt;em&gt;scratch&lt;/em&gt;缓冲区中并在行的结束位置输入一些空格。将mark设置在单词&lt;code&gt;three&lt;/code&gt;的后面，然后point设置在行的结束位置（在这里即缓冲区的结束位置）。输入&lt;code&gt;C-c =&lt;/code&gt;。这次Emacs应该告诉你region中没有单词。但是Emacs这次却显示了一个错误信息&lt;code&gt;Search failed&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这两个bug来自于同一个问题。&lt;/p&gt;
&lt;p&gt;思考这个Bug的第一个表现，命令告诉你行的开始位置的空白包含一个单词。它是这样产生的：count-words-region命令先将point移到region的开始位置。然后测试当前point的位置是否小于end变量的值。结果为true。接下来，通过表达式查找第一个单词。它将point设置在第一个单词的后面。count被设置为1。while循环重复，但这时point已经大于end的值了，循环退出；函数显示信息说在region中有一个单词。简单来说就是由于正则表达式查询时，它查找到的单词的结束位置超过了region的区域。&lt;/p&gt;
&lt;p&gt;Bug的第二个表现中，region是缓冲区结束位置的空白。Emacs说Search failed。这是由于在while的true-or-false-test返回true，search语句被执行。但是由于没找到匹配项，因此查询失败。&lt;/p&gt;
&lt;p&gt;这两种情况都是由于查询时扩展或者试图扩展到region的外部。&lt;/p&gt;
&lt;p&gt;解决办法就是限制查询的区域，一个很简单的动作，但并没有想像的那么简单。&lt;/p&gt;
&lt;p&gt;前面在讲re-search-forward函数时，它接收四个参数。第一个参数是必需的，其它三个是可选参数。它的第二个参数是用于限定查询范围的。第三个可选参数，如果为t，则函数将在查询失败时返回nil，而不显示错误信息。第四个可选参数是重复次数。（可以用C-h f查找函数的文档）&lt;/p&gt;
&lt;p&gt;在count-words-region函数定义中，region的结束位置被以设置到end参数上，它将作为函数参数传入。因此我们可以把end作为正则表达式查询时的参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果只对count-words-region的定义作上面的修改，在遇到一些空白字符时，仍将得到Search failed的错误。&lt;/p&gt;
&lt;p&gt;这是因为，有可能在限制的范围内，搜索不到构词字符。搜索将失败，并显示错误信息。但我们在这时并不想要获取错误信息，我们需要显示"The region does NOT have any words."。&lt;/p&gt;
&lt;p&gt;解决这一问题的办法就是将re-search-forward的第三个参数设置为t，这样在函数在搜索失败时将返回nil。&lt;/p&gt;
&lt;p&gt;如果你尝试运行程序，你将看到信息"Couting words in region..."并一直看到这条消息，直到你输入C-g(keyboard-quit)。&lt;/p&gt;
&lt;p&gt;当在限制查询范围的region中搜索时，和前面一样，如果region中没有构词字符，搜索将失败。re-search-forward语句返回nil。这时point也不会被移动，而循环中的下一条语句将被执行。这条语句将计数增加。然后循环继续。true-or-false-test将一直返回true，因为point仍小于end参数，程序将陷入死循环。&lt;/p&gt;
&lt;p&gt;count-words-region的定义还需要一些修改，以便在搜索失败时让true-or-false-test返回false。可以在true-or-false-test中增加一个条件，true-or-false-test在增加计数前需要满足下面的条件：point必须在region之内，且查询的语句必须找到了一个单词。&lt;/p&gt;
&lt;p&gt;因为两个条件都必须为true。所以区域范围检查和搜索语句可以用and连接起来，都作为while循环的true-or-false-test：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;re-search-forward在成功搜索到单词后将返回t，并移动point，只要能找到单词，point将继续移动。当搜索失败或者point达到region的结束位置时，true-or-false-test将返回false。while循环退出，count-words-region函数显示一个或多个信息。&lt;/p&gt;
&lt;p&gt;修改完后的count-words-region函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Final version: while&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print number of words in the region."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Counting words in region ... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. Set up appropriate conditions.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;beginning&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. Run the while loop.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. Send a message to the user.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zerop&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region does NOT have any words."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has 1 word."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has %d words."&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;递归方式统计单词数量&lt;/h2&gt;
&lt;p&gt;上一节已经编写过了通过while循环进行计数的函数。&lt;/p&gt;
&lt;p&gt;在这个函数中，count-words-region函数完成了三个工作：为计数设置适当的条件；计算region中的字数；将字数显示给用户。&lt;/p&gt;
&lt;p&gt;如果我们在一个递归函数中执行所有的操作，则我们将在每次递归调用时都会得到字数的消息。如果region中包含了13个单词，消息将显示13次。这并不是我们需要的，我们需要写两个函数来做这个工作，一个函数（递归函数）将在另一个函数内部被使用。一个设置条件和显示信息，国一个返回字数。&lt;/p&gt;
&lt;p&gt;开始编写函数。我们仍把这个函数叫作count-words-region。&lt;/p&gt;
&lt;p&gt;根据前一个版本，我们可以描述出这个程序的结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Recursive version; uses regular expression search&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;interactive-expression...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. Set up appropriate conditions.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;explanatory&lt;/span&gt; &lt;span class="nf"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-up&lt;/span&gt; &lt;span class="nv"&gt;functions...&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. Count the words.&lt;/span&gt;
    &lt;span class="nv"&gt;recursive&lt;/span&gt; &lt;span class="nv"&gt;call&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. Send a message to the user.&lt;/span&gt;
    &lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="nv"&gt;providing&lt;/span&gt; &lt;span class="nv"&gt;word&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义很直接，不同的地方是递返回的数字必须传递给message来显示。这可以用let语句来完成：我们可以用let语句把字数赋给一个变量，并把这个值作为递归部分的返回值。使用cond语句，用于设置变量和显示信息给用户。&lt;/p&gt;
&lt;p&gt;通常let语句总被作为函数的'次要工作'。但在这里，let将作为函数的主要工作，统计字数的工作就是在let语句中。&lt;/p&gt;
&lt;p&gt;使用let时函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print number of words in the region."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. Set up appropriate conditions.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Counting words in region ... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;beginning&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. Count the words.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. Send a message to the user.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zerop&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region does NOT have any words."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has 1 word."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has %d words."&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们需要编写递归计数函数。&lt;/p&gt;
&lt;p&gt;递归函数至少有三个部分：'do-again-test'，'next-step-expresssion'和递归调用。&lt;/p&gt;
&lt;p&gt;do-again-test决定函数是否继续调用。因为我们在统计region中的单词时我们使用了移动point的函数，do-again-test可以检查point是否位于region中。do-again-test需要检查point是位于region结束位置的前面还是后面。我们可以使用point函数获取point的位置信息，我们还需要传递将region的结束位置作为参数传递到递归计数函数里。&lt;/p&gt;
&lt;p&gt;另外，do-again-test还需要检查是否找到了一个单词。如果没有，函数就不再需要继续调用它自己了。&lt;/p&gt;
&lt;p&gt;next-step-expression修改某个值以便递归函数能在适当的时候停止递归调用。在这里next-step-expression可以是移动point的语句。&lt;/p&gt;
&lt;p&gt;递归函数的第三个部分是递归调用。&lt;/p&gt;
&lt;p&gt;在这个函数中我们也需要在某个地方执行计数工作。&lt;/p&gt;
&lt;p&gt;这样，我们有了一个递归计数函数的原型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
   &lt;span class="nv"&gt;do-again-test&lt;/span&gt;
   &lt;span class="nv"&gt;next-step-expression&lt;/span&gt;
   &lt;span class="nv"&gt;recursive&lt;/span&gt; &lt;span class="nv"&gt;call&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们需要填空。首先我们从最简单的一种情况开始：point位于region结束位置或位于region之外，region中没有单词，因此函数需要返回0。同样，如果搜索失败，函数也需要返回0。&lt;/p&gt;
&lt;p&gt;另一方面，如果point在region内部，并且搜索成功，函数应该再次调用它自己。&lt;/p&gt;
&lt;p&gt;这样，do-again-test应该如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，查找语句是do-again-test函数的一部分，在搜索成功时返回t，失败时返回nil。&lt;/p&gt;
&lt;p&gt;do-again-test是if语句的true-or-false子句。如果do-again-test成功，则if语句的then部分执行，如果失败，则应该返回0，因为不管point是位于region的外面还是搜索失败都表示region中没有单词。&lt;/p&gt;
&lt;p&gt;另外，do-again-test返回t或nil时，re-search-forward将在搜索成功时移动point。这是修改point的值并让递归函数在point移出region后停止递归调用的操作。因此，re-earch-foreard语句就是next-step-expression。&lt;/p&gt;
&lt;p&gt;recursive-count-words函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;do-again-test-and-next-step-combined&lt;/span&gt;
    &lt;span class="c1"&gt;;; then&lt;/span&gt;
    &lt;span class="nv"&gt;recursive-call-returning-count&lt;/span&gt;
  &lt;span class="c1"&gt;;; else&lt;/span&gt;
  &lt;span class="nv"&gt;return-zero&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怎样加入计数机制呢？&lt;/p&gt;
&lt;p&gt;我们知道计数机制应该与递归调用联合起来。由于next-step-expression将point一个个单词的移动，因此，针对每个单词都会调用一次递归函数，计数机制必须有一个语句将recursive-count-words的返回值加1。&lt;/p&gt;
&lt;p&gt;思考下面几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果region中有两个单词，函数在遇到第一个单词时，需要返回region中其它单词数量（这里为1）加1的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果region中只有一个单词，函数在遇到第一个单词时，需要返回region中其它单词数量（这里为0）加1的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果region中没有单词，函数需要返回0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的描述中可以看出if语句的else部分在没有单词时返回0。而if语句的then部分必须返回1加上region中其它单词数量的值。&lt;/p&gt;
&lt;p&gt;语句如下，使用了函数1+使它的参数加1。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个recursive-count-words函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. do-again-test&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. then-part: the recursive call&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. else-part&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;研究一下它是如何工作的：&lt;/p&gt;
&lt;p&gt;当region中没有单词时，if语句的else部分被执行，函数返回0。&lt;/p&gt;
&lt;p&gt;如果region中有一个单词，point的值小于region-end并且搜索成功。这时，if语句的true-or-false-test为true，if语句的then部分被执行。计数语句被执行。这个语句将返回（整个函数的返回值）递归调用的返回值加1的结果。&lt;/p&gt;
&lt;p&gt;与此同时，next-step-expression将使point跳过region中的第一个单词。这表示当(recursive-count-words region-end)在第二次时被执行，并作为递归调用的结果，point的值将等于或大于region的结束位置。这样，recursive-count-words将返回0。最初的recursive-count-words将返回0+1，计数正确。&lt;/p&gt;
&lt;p&gt;如果region中有两个单词，第一次调用recursive-count-words将返回1加上在包含其它单词的region上调用recursive-count-words的返回值，这里将是1加1，2是正确的返回值。&lt;/p&gt;
&lt;p&gt;类似地，如果region中包含有3个单词，第一次调用recursive-count-words将返回1加上在包含其它单词的region上调用recursive-count-words的返回值，如此继继续。&lt;/p&gt;
&lt;p&gt;整个程序包含了两个函数：&lt;/p&gt;
&lt;p&gt;递归函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Number of words between point and REGION-END."&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. do-again-test&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. then-part: the recursive call&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. else-part&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;包装函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Recursive version&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print number of words in the region.&lt;/span&gt;

&lt;span class="s"&gt;Words are defined as at least one word-constituent&lt;/span&gt;
&lt;span class="s"&gt;character followed by at least one character that is&lt;/span&gt;
&lt;span class="s"&gt;not a word-constituent.  The buffer's syntax table&lt;/span&gt;
&lt;span class="s"&gt;determines which characters these are."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Counting words in region ... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;beginning&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zerop&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region does NOT have any words."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"The region has 1 word."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has %d words."&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;统计defun中的单词数量&lt;/h1&gt;
&lt;p&gt;我们的下一个计划是统计函数定义中的单词数量。我们可以使用count-word-region函数的一些变种（正则表达式方式）来完成这个工作。如果我们只是需要统计定义中的单词数量的话，可以简单的使用C-M-h(mark-defun)命令，然后调用count-word-region。&lt;/p&gt;
&lt;p&gt;但我们要进行的是一项雄心勃勃的计划：我们需要统计Emacs源码中所有的函数和符号并打印出各个长度的函数分别有多少个：包含40至49个单词或符号的有多少，包含50到59个单词或符号的有多少，等等。&lt;/p&gt;
&lt;h2&gt;分割任务&lt;/h2&gt;
&lt;p&gt;这个任务目标使人畏惧；但如果将它分割成多个小的步骤，每次我们只处理其中的一部分，这样这个目标将不那么令人畏惧。先来思考一下有哪些步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写一个用于统计函数定义中字数的函数。这也包括了把符号当作单词的处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写一个能列出一个文件中各个函数各有多少单词的函数。这个函数将调用count-words-in-defun函数（第1中定义的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写一个能列出多个文件中各个函数各有多少单词的函数。负责自动查找多个文件，然后切换到这些文件中，并统计这些文件内的函数定义中的单词数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写一个函数将第3步中得到的数据列表转换为适合打印的形式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写函数打印结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;统计什么？&lt;/h2&gt;
&lt;p&gt;在上节所说的几个步骤中，首先就是需要决定哪些是需要进行统计的？当我们针对Lisp函数定义说'单词'('word')时，我们实际上很大程序上是在说'符号'（'symbols'）。举例来说，multiply-by-seven函数包含了5个符号defun,multiply-by-seven,number,*,和7。另外，文档字符串包含了四个单词Multiply,Number,by,和seven。符号number是重复的，因此定义包含了十个单词和符号。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Multiply NUMBER by seven."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，如果我们对上面的函数定义执行C-M-h(mark-defun)，然后调用count-words-region，count-words-region将报告定义中有11个单词，而不是10。哪里出错了！&lt;/p&gt;
&lt;p&gt;原因有两个：count-words-region不把*当作一个单词。把符号multiply-by-seven当作三个单词。连字符被作为单词间的空白。&lt;/p&gt;
&lt;p&gt;这是由于count-words-region定义中的正则表达式引起的。在一个典型的count-words-region函数定义中，正则表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"\\w+\\W*"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个正则表达式匹配一个或多个构词字符被一个或多个非构词字符包围。&lt;/p&gt;
&lt;h2&gt;单词和符号由什么组成？&lt;/h2&gt;
&lt;p&gt;Emacs把不同的字符归属到不同的语法分类中。比如，正则表达式&lt;code&gt;\\w+&lt;/code&gt;匹配一个或多个构词字符。构词字符是一个语法分类中的成员。另一个语法分类包含了标点符号，例如：句号和逗号，空白符号，空白字符和tab。&lt;/p&gt;
&lt;p&gt;语法名指定了字符属于哪个分类。通常，连字符号不被当作构词字符。而是被作为'符号的一部分但不是单词'('class of characters that are part of symbol names but not words.')的一类。这意味着count-words-region函数将把它当作词间的空白一样对侍，这也说明了为什么count-words-region会把multiply-by-seven当作3个单词处理。&lt;/p&gt;
&lt;p&gt;有两种办法让Emacs把multiply-by-sevn当作一个符号来处理：修改语法表或修改正则表达式。&lt;/p&gt;
&lt;p&gt;我们可以重新在语法表中将连字符定义为构词字符，Emacs将在每个mode中保持这个设置。这个操作能达到我们的目的，除了连字符不是一个典型的构词字符外..&lt;/p&gt;
&lt;p&gt;另外，我们也可以重新定义count-words函数中的正则表达式以包含连字符。这种处理的优点是比较明确，但任务有点刁。&lt;/p&gt;
&lt;p&gt;这个正则表达式的第一个部分简单：必须匹配"至少由一个字符或符号构成"：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"\\(\\w\\|\\s_\\)+"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表达式的第一部分是&lt;code&gt;\\(&lt;/code&gt;,括号中包含了两个部分&lt;code&gt;\\w&lt;/code&gt;和&lt;code&gt;\\s_&lt;/code&gt;，两者之间用&lt;code&gt;\\|&lt;/code&gt;分隔表示或关系。&lt;code&gt;\\w&lt;/code&gt;匹配任何构词字符，&lt;code&gt;\\s_&lt;/code&gt;符号中的所有非构词字符。括号外面的+号表示单词或者构成符号的字符至少要出现一次。&lt;/p&gt;
&lt;p&gt;表达式的第二个部分更难设计。我们需要在第一个部分后可以有一个非构词字符。首先，我想可以定义成下面的形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"\\(\\W\\|\\S_\\)*"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大写的W和S匹配非构词和非符号字符。&lt;/p&gt;
&lt;p&gt;然后我们注意到region中每个单词或符号后面有空白字符（空格、tab、或空行）。因此我们需要让表达式匹配一个或多个构词（或构成符号）字符后面跟一个或多个空白字符，但实际单词和符号有可能紧跟在括号或标点的后面。最后，我们设计的正则表达式匹配将单词或符号后面跟有可选的非空白字符，然后跟可选的空白。&lt;/p&gt;
&lt;p&gt;完整的表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;count-words-in-defun函数&lt;/h2&gt;
&lt;p&gt;前面已经看到过，有多个方法实现count-word-region函数。我们只选用其中一个合适的方式来实现count-words-in-defun。&lt;/p&gt;
&lt;p&gt;使用while循环的版本容易理解，因此我们准备采用。因为count-words-in-defun函数将变成更复杂的函数的一部分，它不需要交互也不要显示信息，只需要返回数量。&lt;/p&gt;
&lt;p&gt;另外，count-words-in-defun将被用于包含函数定义的缓冲区。因此，需要函数决定当point位于函数定义内部时是否能被调用，如果point位于函数定义内，它需要返回当前所在的函数定义的单词数量。这增加了这个函数的性。&lt;/p&gt;
&lt;p&gt;根据上面的需求，我们准备了下面的模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-in-defun&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;up...&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;loop...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="nb"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与之前一样，我们的工作就是填空。&lt;/p&gt;
&lt;p&gt;函数有可能在包含函数定义的缓冲区中。Point有可能位于某个函数定义的内部。count-words-in-defun必须先将point移到这个函数定义的起始位置，计数器置0，计数循环必须在到达函数定义结束位置时停止。&lt;/p&gt;
&lt;p&gt;beginning-of-defun函数向后查找左括号。比如行开始位置的&lt;code&gt;(&lt;/code&gt;，并将point移到那个位置或到达查询的限制的边界。实际上，beginning-of-defun将point移到左括号前面或者函数定义的前面，或者缓冲区的开始位置。我们可以使用beginning-of-defun将point放到我们希望有开始位置。&lt;/p&gt;
&lt;p&gt;while循环部分需要一个计数器来保存计数。可以使用let语句创建局部变量，并将局部变量初始化为0，来达到这个目的。&lt;/p&gt;
&lt;p&gt;end-of-defun函数与beginning-of-defun类似，它将point移到定义的结束位置。end-of-defun可以用于检查是否位于函数定义的结束位置。&lt;/p&gt;
&lt;p&gt;count-words-in-defun的开始部分：首先，将point移到定义的开始位置，然后创建一个局部变量保存计数器，最后，记录下定义结束的位置以便while循环知道什么时候停止循环。&lt;/p&gt;
&lt;p&gt;代码结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning-of-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end-of-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码比较简单，唯一复杂点的是"end"部分：它将end设置为save-excursion语句的返回值，这个语句返回end-of-defun（它将point移到定义的结束位置）执行后point的位置。&lt;/p&gt;
&lt;p&gt;在初始化工作完成后，count-words-in-defun的第二个部分就是while循环。&lt;/p&gt;
&lt;p&gt;这个循环必须包含按单词或符号向前移动的语句，另一个语句则用于统计移动的次数。while循环的true-or-false-test应该跳到定义结束位置时返回false。在这里我们可以使用前面讨论过的正则表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt;
             &lt;span class="s"&gt;"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数定义的第三个部分返回符号或单词的数量。这个部分是函数内部的let语句的最后一个表达式。很简单，返回局部变量count。&lt;/p&gt;
&lt;p&gt;这几个部分放在一起就构成了count-words-in-defun：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-in-defun&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Return the number of words and symbols in a defun."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning-of-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end-of-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt;
              &lt;span class="s"&gt;"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"&lt;/span&gt;
              &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怎样测试它呢？这个函数是非交互式的函数，但我们可以很容易的将它包装成一个交互式的函数；可以使用与count-words-region中类似的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Interactive version.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-defun&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Number of words and symbols in a function definition."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
   &lt;span class="s"&gt;"Counting words and symbols in function definition ... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-words-in-defun&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
     &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zerop&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
       &lt;span class="s"&gt;"The definition does NOT have any words or symbols."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
       &lt;span class="s"&gt;"The definition has 1 word or symbol."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
       &lt;span class="s"&gt;"The definition has %d words or symbols."&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以将它绑定到&lt;code&gt;C-c =&lt;/code&gt;上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-c="&lt;/span&gt; &lt;span class="ss"&gt;'count-words-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们可以试试count-words-defun：安装count-words-in-defun和count-words-defun，设置按键绑定，然后将光标放到下面的定义中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Multiply NUMBER by seven."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将显示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Success! The definition has 10 words and symbols.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下一个问题就是如何统计同一个文件中的多个定义中的单词和符号。&lt;/p&gt;
&lt;h2&gt;统计一个文件中的多个defun&lt;/h2&gt;
&lt;p&gt;文件simple.el可能包含超过80个函数定义。我们的终极目标是要对很多的文件进行统计，但第一步，我们当前的目标是要对一个文件进行统计。&lt;/p&gt;
&lt;p&gt;这个信息将会是一连串的数字，每个数字是一个函数定义的长度。我们可以将这些数字保存到一个list中。&lt;/p&gt;
&lt;p&gt;我们需要将多个文件的信息合并到一起，因此统计对一个文件进行统计时不需要显示信息，只需要返回长度信息。&lt;/p&gt;
&lt;p&gt;在字数统计命令包含了一个语句用于按单词向前移动另一个语句计数。这个返回函数定义长度的函数同样可以使用这种方式，一个语句用于向前跳转一个函数定义，另一个语句用于计数。&lt;/p&gt;
&lt;p&gt;编写函数字义。我们需要从文件开始位置计数，因此第一个命令使用(goto-char (point-min))。接下来，我们开始while循环，循环的true-or-false-test可以是一个查询下一个函数定义的正则表达式查询，如果查询成功，则将point向前移动，循环体被执行。循环体需要一个语句构造包含长度的list。&lt;/p&gt;
&lt;p&gt;代码片段如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"^(defun"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;lengths-list&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-words-in-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还少了缺少查找函数定义文件的机制。&lt;/p&gt;
&lt;h2&gt;查找文件&lt;/h2&gt;
&lt;p&gt;在Emacs中可以使用C-x C-f(find-file)命令。这个命令并不是很符合处理当前问题。&lt;/p&gt;
&lt;p&gt;先来看find-file的源码（可以使用find-tag命令C-h f(describe-functin)来查找源文件）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;find-file&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Edit file FILENAME.&lt;/span&gt;
&lt;span class="s"&gt;Switch to a buffer visiting file FILENAME,&lt;/span&gt;
&lt;span class="s"&gt;creating one if none already exists."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"FFind file: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;switch-to-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;find-file-noselect&lt;/span&gt; &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义很短，一个interactive用于执行命令时的交互。定义的body部分包含个函数，find-file-noselect和switch-to-buffer。&lt;/p&gt;
&lt;p&gt;使用C-h f（describe-function命令）查看find-file-noselect函数的文档，这个函数读取指定的文件到缓冲区中，并返回这个缓冲区。但是这个缓冲区未被选中。Emacs并不会将焦点转移到它。这个工作由switch-to-buffer完成，它将Emacs焦点转到指定的缓冲区，并将这个缓冲区在窗口中显示出来。&lt;/p&gt;
&lt;p&gt;在这个工程中，我们并不需要在屏幕上显示每个文件。因此我们使用set-buffer来替代switch-to-buffer，它将程序的焦点转移到另一个缓冲区，但不会改变屏幕显示。因此，我们不调用find-file，而是需要自己编写一个。&lt;/p&gt;
&lt;p&gt;可以使用find-file-noselect和set-buffer来完成这个工作。&lt;/p&gt;
&lt;h2&gt;lengths-list-file函数的细节&lt;/h2&gt;
&lt;p&gt;lengths-list-file函数的核心是一个while循环，它包含了将point向前（'defun by defun'）移动的函数和用于统计每个defun中符号或单词数量的函数。这个核心将被包含在执行各种任务的函数中，包括文件查找，确保point位于文件的开始位置。这个函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;lengths-list-file&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return list of definitions' lengths within FILE.&lt;/span&gt;
&lt;span class="s"&gt;The returned list is a list of numbers.&lt;/span&gt;
&lt;span class="s"&gt;Each number is the number of words or&lt;/span&gt;
&lt;span class="s"&gt;symbols in one function definition."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Working on &lt;/span&gt;&lt;span class="ss"&gt;`%s'&lt;/span&gt;&lt;span class="s"&gt; ... "&lt;/span&gt; &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;find-file-noselect&lt;/span&gt; &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;buffer-read-only&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;widen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"^(defun"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;lengths-list&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-words-in-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;kill-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数有一个参数，需要处理的文件名。有4行文档字符串，但没有交互式语句。body部分的第一行是一个message，用于提示用户机器正在执行操作。&lt;/p&gt;
&lt;p&gt;下一行包括了一个save-excursion它将在函数结束时，将Emacs焦点恢复到当前缓冲区。这通常用于将一个函数嵌入另一个函数时，可以恢复原缓冲区中的point。&lt;/p&gt;
&lt;p&gt;在let语句的变量列表中，Emacs打开文件，并将包含该文件缓冲区设置到buffer变量。同时，Emacs创建了局部变量lengths-list。&lt;/p&gt;
&lt;p&gt;接下来，Emacs将焦点转到这个缓冲区。&lt;/p&gt;
&lt;p&gt;在下一行中，Emacs将缓冲区设置为只读。理想情况下，这行是不必要的。没有哪个计数函数需要修改缓冲区。并且，即使我们修改了缓冲区，缓冲区也不会被保存。这主要是防止不小心修改了Emacs的源码造成麻烦。&lt;/p&gt;
&lt;p&gt;接下来，如果缓冲区被narrowed，则调用widen。这个函数在Emacs创建一个新的缓冲区时不需要，但如果文件已经在缓冲区中时，有可能缓冲区被narrowed了，这时必须调用widen。如果我们要完全的"user-friendly"，我们还需要保存point的位置，但我们不需要。&lt;/p&gt;
&lt;p&gt;(goto-char (point-min))语句将point移到缓冲区的开始位置。&lt;/p&gt;
&lt;p&gt;后面的while循环中，Emacs决定每个定义的长度并构造一个包含长度信息的列表。&lt;/p&gt;
&lt;p&gt;然后，Emacs关闭缓冲区，继续后面的操作。这是为了保存Emacs的空间。在Emacs 19中包含了超过300个源码文件；Emacs 21包含了超过800个源码文件。另一个函数将在每个文件上执行length-list-file。&lt;/p&gt;
&lt;p&gt;你可以安装并测试一下这个文件。将光标放在下面的语句的后面，执行C-x C-e(eval-last-sexp)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt;
 &lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/lisp/emacs-lisp/debug.el"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;统计不同文件中的defun中的单词&lt;/h2&gt;
&lt;p&gt;前一节，我们创建了一个可以返回单个文件中各个函数长度列表的函数。现在我们需要定一个函数返回文件列表中所有定义长度的函数。&lt;/p&gt;
&lt;p&gt;使用while循环或递归在每个文件上执行相同的操作。&lt;/p&gt;
&lt;h3 id="jue-ding-defunde-chang-du"&gt;决定defun的长度&lt;/h3&gt;
&lt;p&gt;使用while循环作为程序主干。传递给函数的是一个文件列表。前面看过，可以写一个while循环，如果列表中包含了元素，则执行循环，否则退出循环。循环体必须在每次执行时缩短list的长度，直到list为空退出循环。通常的技巧是将list设置为原来的list的CDR。&lt;/p&gt;
&lt;p&gt;模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;test-whether-list-is-empty&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;
  &lt;span class="nv"&gt;set-list-to-cdr-of-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;while循环将返回nil（true-or-false-test的返回值），而不是循环体的执行结果。因此我们需要将while循环包含在let语句中，并让let语句的最后一个语句包含要返回的list。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Use while loop.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;lengths-list-many-files&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return list of lengths of defuns in LIST-OF-FILES."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; true-or-false-test&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;lengths-list&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt;
             &lt;span class="nv"&gt;lengths-list&lt;/span&gt;

&lt;span class="c1"&gt;;;; Generate a lengths' list.&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;expand-file-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="c1"&gt;;;; Make files' list shorter.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;;; Return final value of lengths' list.&lt;/span&gt;
    &lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;expand-file-name是一个内置函数，它将文件名转换为绝对路径。&lt;/p&gt;
&lt;p&gt;如果在debug.el上执行expand-file-nameEmacs将得到&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/usr/local/share/emacs/21.0.100/lisp/emacs-lisp/debug.el
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数定义的中的另一个新元素是未学习过的函数append。&lt;/p&gt;
&lt;h3 id="appendhan-shu"&gt;append函数&lt;/h3&gt;
&lt;p&gt;append函数将一个list添加到另一个list，如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将产生list&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这恰好是我们需要结果。如果使用cons，
&amp;lt;src lang="emacs-lisp"
(cons '(1 2 3 4) '(5 6 7 8))&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;则，将得到：
```emacs-lisp
((1 2 3 4) 5 6 7 8)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;递归统计不同文件中的单词数量&lt;/h2&gt;
&lt;p&gt;除了while循环，你可以在文件列表中使用递归处理。递归版本的lengths-list-many-files简洁一些。&lt;/p&gt;
&lt;p&gt;递归函数通常有这些部分：'do-again-test'，'next-step-expression'和递归调用。'do-again-test'决定是否再次调用自身，它需要检查list-of-files是否还包含有元素；'next-step-expression'将list-of-files重新设置为它的CDR部分，因此，最后这个list将变为空；递归调用则在缩短后的list上调用它自身。代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-lengths-list-many-files&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return list of lengths of each defun in LIST-OF-FILES."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;                     &lt;span class="c1"&gt;; do-again-test&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;expand-file-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-lengths-list-many-files&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单来说，函数将第一次返回的list-of-files追加到其它次调用返回的list-of-files中。&lt;/p&gt;
&lt;p&gt;这里是一个recursive-lengths-list-many-files的测试。&lt;/p&gt;
&lt;p&gt;安装recursive-lengths-list-many-files和lengths-list-file。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cd&lt;/span&gt; &lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt; &lt;span class="s"&gt;"./lisp/macros.el"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (273 263 456 90)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt; &lt;span class="s"&gt;"./lisp/mail/mailalias.el"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (38 32 26 77 174 180 321 198 324)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt; &lt;span class="s"&gt;"./lisp/makesum.el"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (85 181)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-lengths-list-many-files&lt;/span&gt;
 &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"./lisp/macros.el"&lt;/span&gt;
   &lt;span class="s"&gt;"./lisp/mail/mailalias.el"&lt;/span&gt;
   &lt;span class="s"&gt;"./lisp/makesum.el"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="c1"&gt;;=&amp;gt; (273 263 456 90 38 32 26 77 174 180 321 198 324 85 181)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;recursive-lengths-list-many-files函数产生了我们想要的输出。&lt;/p&gt;
&lt;p&gt;下一步是准备显示图表的数据。&lt;/p&gt;
&lt;h2&gt;准备显示图表的数据&lt;/h2&gt;
&lt;p&gt;recursive-lengths-list-many-files函数返回了一个包含计数的列表。每个数字记录了一个函数定义的长度。我们需要将数据转换到适于生成图表的list中。新的list将告诉我们有多少个定义包含少于10个单词或符号，多少个处于10到19个单词或符号之间，等等。&lt;/p&gt;
&lt;p&gt;我们需要遍历recursive-lengths-list-many-files函数返回的list中的值，并计算处于各个范围中的数量，并产生包含这些数量的list。&lt;/p&gt;
&lt;p&gt;基于之前我们所做的，我们可以预想到编写这个函数并不难。可以用截取CDR的方式遍历各个元素，决定这个长度位于哪个范围，并增加这个范围的计数。&lt;/p&gt;
&lt;p&gt;但是，在编写这个函数前，我们需要思考对list排序的优点，数字按从小到大的顺序排列。首先，排序将使计数容易一些，因为相信的数字将会处于同一个范围中。第二，检查排序后的list，可以知道最大的数字和最小的数字，便于决定我们所需要的最大和最小的范围。&lt;/p&gt;
&lt;h3 id="listpai-xu"&gt;List排序&lt;/h3&gt;
&lt;p&gt;Emacs包含了一个排序函数sort。sort带两个参数，被排序的list和一个决定list元素大小关系的参数。&lt;/p&gt;
&lt;p&gt;sort函数可以基于任意的属性进行排序；这意味着sort可以用于对非数字进行排序，比如按字母。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;函数用于对数字类型的list排序。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sort&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ss"&gt;'&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;produces&lt;/span&gt; &lt;span class="nv"&gt;this:&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，两个参数前都使用了单引号，表示不需要对它们求值。&lt;/p&gt;
&lt;p&gt;也可以使用&lt;code&gt;&amp;lt;&lt;/code&gt;对recursive-lengths-list-many-files函数的返回值排序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sort&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-lengths-list-many-files&lt;/span&gt;
  &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"../lisp/macros.el"&lt;/span&gt;
    &lt;span class="s"&gt;"../lisp/mailalias.el"&lt;/span&gt;
    &lt;span class="s"&gt;"../lisp/makesum.el"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="ss"&gt;'&amp;lt;&lt;/span&gt;

&lt;span class="nv"&gt;which&lt;/span&gt; &lt;span class="nv"&gt;produces:&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;85&lt;/span&gt; &lt;span class="mi"&gt;86&lt;/span&gt; &lt;span class="mi"&gt;116&lt;/span&gt; &lt;span class="mi"&gt;122&lt;/span&gt; &lt;span class="mi"&gt;154&lt;/span&gt; &lt;span class="mi"&gt;176&lt;/span&gt; &lt;span class="mi"&gt;179&lt;/span&gt; &lt;span class="mi"&gt;265&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（注意，这个例子中第一个参数没加单引号，因为它在传递给sort前需要被执行。）&lt;/p&gt;
&lt;h3 id="chan-sheng-wen-jian-lie-biao"&gt;产生文件列表&lt;/h3&gt;
&lt;p&gt;recursive-lengths-list-many-files函数需要一个文件列表作为参数。在测试的例子中，我们手工构造了一个文件列表；但Emacs List源码目录太大了。我们需要编写函数来完成这个工作。在这个函数中，我们将要同时使用while循环和递归调用。&lt;/p&gt;
&lt;p&gt;在旧版本的GNU Emacs中我们不需要编写这样的函数，因为它将所有的.el文件放在同一个目录中。我们可以使用directory-files函数，它将返回单个目录中匹配指定表达式的文件名的列表。&lt;/p&gt;
&lt;p&gt;但是，在新版本的Emacs中Emacs将Lisp文件放到了顶级lisp目录的子目录中。比如所有mail相关的文件放到了mail子目录中。&lt;/p&gt;
&lt;p&gt;我们可以创建函数files-in-below-directory，使用car，nthcdr和substring连接已经存在的函数调用directory-files-and-attributes。这个函数不只是返回目录中的文件名列表，还将返回子目录的名称，和它们的属性。&lt;/p&gt;
&lt;p&gt;重新描述我们的目标：创建一个函数能传递下面结构的参数给recursive-lengths-list-many-files函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"../lisp/macros.el"&lt;/span&gt;
 &lt;span class="s"&gt;"../lisp/mail/rmail.el"&lt;/span&gt;
 &lt;span class="s"&gt;"../lisp/makesum.el"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;directory-files-and-attributes函数返回包含list的list。list中的每个元素是一个包含了13的元素的子list。第一个元素是包含了文件名，在GNU/Linux中，它可能是一个'directory file'，也就是说，它是一个有特殊属性的目录文件。第二个元素为t的表示是一个目录，为字符串时表示是一个符号文件（该字符串表示连接的目标文件），或者为nil。&lt;/p&gt;
&lt;p&gt;比如，&lt;code&gt;lisp/&lt;/code&gt;目录中第一个&lt;code&gt;.el&lt;/code&gt;文件是abbrev.el。它的文件名是&lt;code&gt;/usr/local/share/emacs/21.0.100/lisp/abbrev.el&lt;/code&gt;它不是一个目录也不是一个链接。&lt;/p&gt;
&lt;p&gt;下面是directory-files-and-attributes返回的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/lisp/abbrev.el"&lt;/span&gt;
&lt;span class="no"&gt;nil&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;1000&lt;/span&gt;
&lt;span class="mi"&gt;100&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15019&lt;/span&gt; &lt;span class="mi"&gt;32380&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;14883&lt;/span&gt; &lt;span class="mi"&gt;48041&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15214&lt;/span&gt; &lt;span class="mi"&gt;49336&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;11583&lt;/span&gt;
&lt;span class="s"&gt;"-rw-rw-r--"&lt;/span&gt;
&lt;span class="no"&gt;t&lt;/span&gt;
&lt;span class="mi"&gt;341385&lt;/span&gt;
&lt;span class="mi"&gt;776&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而表示&lt;code&gt;mail/&lt;/code&gt;目录下的&lt;code&gt;mail/&lt;/code&gt;目录的list如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/lisp/mail"&lt;/span&gt;
&lt;span class="no"&gt;t&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（查看file-attributes的文档可以了解这些属性。记住，file-attributes函数不会列出文件名，它的第一个元素是directory-files-and-attributes的第二个元素。）&lt;/p&gt;
&lt;p&gt;我们需要让新函数，files-in-below-directory列出目录及其子目录中的&lt;code&gt;.el&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;这为我们构造files-in-below-directory给出了提示：在一个目录中，函数需要添加&lt;code&gt;.el&lt;/code&gt;文件名到一个list中；如果是一个目录，则要进入这个子目录重复上面的操作。&lt;/p&gt;
&lt;p&gt;但是，我们不需要进入表示目录自身的"."目录，也不需要进入上级目录".."。&lt;/p&gt;
&lt;p&gt;因此，我们的files-in-below-directory函数必须完成这些任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检查是否有文件以.el尾；如果是则添加到list。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查是否有文件名是一个目录，如果是，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查它是否为&lt;code&gt;.&lt;/code&gt;或&lt;code&gt;..&lt;/code&gt;；如果是则跳过，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不是则进入那个目录重复上面的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们将使用while循环在同一个目录中从一个文件移到另一个文件，检查文件是否是需要的；如果是一个子目录则递归调用。递归使用"acumulate"模式，使用append合并结果。&lt;/p&gt;
&lt;p&gt;这里是函数定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;files-in-below-directory&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;directory&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"List the .el files in DIRECTORY and in its sub-directories."&lt;/span&gt;
  &lt;span class="c1"&gt;;; Although the function will be used non-interactively,&lt;/span&gt;
  &lt;span class="c1"&gt;;; it will be easier to test if we make it interactive.&lt;/span&gt;
  &lt;span class="c1"&gt;;; The directory will have a name such as&lt;/span&gt;
  &lt;span class="c1"&gt;;;  "/usr/local/share/emacs/21.0.100/lisp/"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"DDirectory name: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;el-files-list&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;current-directory-list&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;directory-files-and-attributes&lt;/span&gt; &lt;span class="nv"&gt;directory&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="c1"&gt;;; while we are in the current directory&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
       &lt;span class="c1"&gt;;; check to see whether filename ends in `.el'&lt;/span&gt;
       &lt;span class="c1"&gt;;; and if so, append its name to a list.&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="s"&gt;".el"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mi"&gt;-3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;el-files-list&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;el-files-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="c1"&gt;;; check whether filename is that of a directory&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
        &lt;span class="c1"&gt;;; decide whether to skip or recurse&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="s"&gt;"."&lt;/span&gt; &lt;span class="s"&gt;".."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="c1"&gt;;; then do nothing if filename is that of&lt;/span&gt;
            &lt;span class="c1"&gt;;;   current directory or parent&lt;/span&gt;
            &lt;span class="p"&gt;()&lt;/span&gt;
          &lt;span class="c1"&gt;;; else descend into the directory and repeat the process&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;el-files-list&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;files-in-below-directory&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                 &lt;span class="nv"&gt;el-files-list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
      &lt;span class="c1"&gt;;; move to the next filename in the list; this also&lt;/span&gt;
      &lt;span class="c1"&gt;;; shortens the list so the while loop eventually comes to an end&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="c1"&gt;;; return the filenames&lt;/span&gt;
    &lt;span class="nv"&gt;el-files-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;files-in-below-directory directory-files函数需要一个参数，目录名称。&lt;/p&gt;
&lt;p&gt;在我的系统上，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;files-in-below-directory&lt;/span&gt; &lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/lisp/"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我的版本是12.0.100，Lisp源码目录包含754个&lt;code&gt;.el&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;files-in-below-directory返回的list是按字母逆序排列的，可以用一个语句来按字母顺序排列：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sort&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;files-in-below-directory&lt;/span&gt; &lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/lisp/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="ss"&gt;'string-lessp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="tong-ji-han-shu-ding-yi-de-shu-liang"&gt;统计函数定义的数量&lt;/h3&gt;
&lt;p&gt;我们当前的目标是产生一个list告诉我们有多少个函数定义包含少于10个单词和符号，多少个函数包含10到19个单词和符号，等等。&lt;/p&gt;
&lt;p&gt;对于一个排了序的list这很简单：统计list中有多少个元素小于10，然后计算有多少个小于20，如些继续。每个范围的数字，我们可以用一个列表top-of-ranges来定义。&lt;/p&gt;
&lt;p&gt;如果需要，我们可以自动生成这个list，手写也比较简单。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;
 &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="mi"&gt;20&lt;/span&gt;  &lt;span class="mi"&gt;30&lt;/span&gt;  &lt;span class="mi"&gt;40&lt;/span&gt;  &lt;span class="mi"&gt;50&lt;/span&gt;
   &lt;span class="mi"&gt;60&lt;/span&gt;  &lt;span class="mi"&gt;70&lt;/span&gt;  &lt;span class="mi"&gt;80&lt;/span&gt;  &lt;span class="mi"&gt;90&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
  &lt;span class="mi"&gt;110&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt; &lt;span class="mi"&gt;130&lt;/span&gt; &lt;span class="mi"&gt;140&lt;/span&gt; &lt;span class="mi"&gt;150&lt;/span&gt;
  &lt;span class="mi"&gt;160&lt;/span&gt; &lt;span class="mi"&gt;170&lt;/span&gt; &lt;span class="mi"&gt;180&lt;/span&gt; &lt;span class="mi"&gt;190&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;
  &lt;span class="mi"&gt;210&lt;/span&gt; &lt;span class="mi"&gt;220&lt;/span&gt; &lt;span class="mi"&gt;230&lt;/span&gt; &lt;span class="mi"&gt;240&lt;/span&gt; &lt;span class="mi"&gt;250&lt;/span&gt;
  &lt;span class="mi"&gt;260&lt;/span&gt; &lt;span class="mi"&gt;270&lt;/span&gt; &lt;span class="mi"&gt;280&lt;/span&gt; &lt;span class="mi"&gt;290&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="s"&gt;"List specifying ranges for &lt;/span&gt;&lt;span class="ss"&gt;`defuns-per-range'&lt;/span&gt;&lt;span class="s"&gt;."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要修改范围，我们只需要编辑这个list。&lt;/p&gt;
&lt;p&gt;接下来我们需要编写函数创建一个包含各个范围数量的列表。这个函数必须传递两个参数，sorted-lengths和top-of-ranges。&lt;/p&gt;
&lt;p&gt;defuns-per-range函数必须重复做两件事：它必须统计当前top-of-range值范围内的数字的数量；在一个范围内的数字统计完成后，它必须移到top-of-ranges的下一个值。由于，每个操作都是重复的，我们可以使用while循环来完成这个工作。一个循环统计一个top-of-ranges中当前范围中定义的数量，另一个循环依次取top-of-range的下一个值。&lt;/p&gt;
&lt;p&gt;sorted-lengths列表需要在各个范围内进行多次计数，因此处理sorted-lengths的循环应该在处理top-of-ranges列表的循环的内部。&lt;/p&gt;
&lt;p&gt;内部的循环统计一定范围内的数量。可以用一个简单的循环。循环的true-or-false-test检查sorted-lengths列表是否小于top-of-range的当前值。如果是，则函数将计数器加1，然后检查sorted-lengths列表的下一个值。&lt;/p&gt;
&lt;p&gt;内部的循环如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;length-element-smaller-than-top-of-range&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;外部的循环从top-of-ranges列表的最小值开始，依次设置为更大的值。循环如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;
  &lt;span class="nv"&gt;body-of-loop...&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个循环放在一起如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;

  &lt;span class="c1"&gt;;; Count the number of elements within the current range.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;length-element-smaller-than-top-of-range&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="c1"&gt;;; Move to next range.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，每上外部循环，Emacs都要在一个list中记录这个范围内的数量(number-within-range)。我们可以使用cons来达到这个目的。&lt;/p&gt;
&lt;p&gt;cons函数工作得很好，它构造的list中，最大范围的将位于开始位置，小范围的位于结束位置。这是因为cons将新元素添加到list的开始位置，在两个循环中将从小到大的顺序执行，defuns-per-range-list将以最大的数字开始。但我们打印的图表需要以小数字开始。解决的办法是逆序排列。使用nreverse函数。&lt;/p&gt;
&lt;p&gt;举例来说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nreverse&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nv"&gt;produces:&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，nreverse函数是一个"destructive"（破坏性的函数）类型的函数，它将修改所操作的list；相反的函数是car和cdr函数，它们是"非破坏性的"。在这里，我们不需要原始的defun-per-range-list，因此不必担心破坏性的问题。（reverse函数担任了逆序复制list的功能，它也不修改原始的list。）&lt;/p&gt;
&lt;p&gt;整个defuns-per-range函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;defuns-per-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;sorted-lengths&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"SORTED-LENGTHS defuns in each TOP-OF-RANGES range."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;top-of-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;;; Outer loop.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;

      &lt;span class="c1"&gt;;; Inner loop.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt;
              &lt;span class="c1"&gt;;; Need number for numeric test.&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;top-of-range&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

        &lt;span class="c1"&gt;;; Count number of definitions within current range.&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

      &lt;span class="c1"&gt;;; Exit inner loop but remain within outer loop.&lt;/span&gt;

      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;; Reset count to zero.&lt;/span&gt;

      &lt;span class="c1"&gt;;; Move to next range.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="c1"&gt;;; Specify next top of range value.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;top-of-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Exit outer loop and count the number of defuns larger than&lt;/span&gt;
    &lt;span class="c1"&gt;;;   the largest top-of-range value.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Return a list of the number of definitions within each range,&lt;/span&gt;
    &lt;span class="c1"&gt;;;   smallest to largest.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nreverse&lt;/span&gt; &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个函数很直观，除了一个地方。内部循环的true-or-false-test：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;top-of-range&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被替换为了
&amp;lt;src lang="emacs-lisp"
(and (car sorted-lengths)
     (&amp;lt; (car sorted-lengths) top-of-range))&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;这个测试的目的是为了决定sorted-lengths列表的第一个元素是否小于范围的值。

简单版本的test在sorted-lengthslist有一个nil值时可以工作。在那种情况下，(car sorted-lengths)将返回nil。而`&amp;lt;`函数不能比较数字和nil，因此Emacs将产生错误信息并停止执行。

在统计到list的结束位置时，sorted-lengths列表将变为nil。这样如果使用简单版本的函数在test时也将出错。

解决这个问题的办法就是使用(car sorted-length)语句和and语句。(car sorted-lengths)语句在list中有至少一个值时，会返回一个non-nil值，但如果list为空时将返回nil。and语句先执行(car sorted-lengths)，如果它返回nil，则返回false而不执行`&amp;lt;`语句。如果(car sorteed-lengths)语句返回的是non-nil值，and语句将执行`&amp;lt;`语句，返回值将是and语句的值。

这样，我们避免了一个错误。

这里有一个简短版本的defuns-per-range函数。首先，将top-of-ranges设置为一个list，然后设置sorted-lengths，执行defuns-per-range函数
```emacs-lisp
;; (Shorter list than we will use later.)
(setq top-of-ranges
 '(110 120 130 140 150
   160 170 180 190 200))

(setq sorted-lengths
      '(85 86 110 116 122 129 154 176 179 200 265 300 300))

(defuns-per-range sorted-lengths top-of-ranges)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回的list如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上，sorted-lengths中有两个元素小于110，两个元素在110和119之间，两个元素在120和129之间，等等。有四个元素大于或等于200。&lt;/p&gt;
&lt;h1&gt;准备图表&lt;/h1&gt;
&lt;p&gt;我们的目标是构造一个图表显示Emacs lisp源码中所有函数定义的长度范围。&lt;/p&gt;
&lt;p&gt;在实际应用中，如果你要创建一个图表，你可能会使用gnuplot之类的程序来完成这个工作。（gnuplot与GNU Emacs集成得很好。）但在这里，我们将使用前面我们所学的知识来完成这个工作。&lt;/p&gt;
&lt;p&gt;在这章，我们将先编写一个简单的图表打印函数。第一个版本将作为原型，在此基础上来增强。&lt;/p&gt;
&lt;h2&gt;打印图表列&lt;/h2&gt;
&lt;p&gt;由于Emacs被设计为能在各种终端上工作，包括字符终端，图表需要是可打印字符。我们可以使用星号来打印图表。&lt;/p&gt;
&lt;p&gt;我们把这个函数命名为graph-body-print；它使用numbers-list作为参数。&lt;/p&gt;
&lt;p&gt;graph-body-print函数根据numbers-list中的每个原素，分别插入垂直方向的星号列。每一列的高度取决于numbers-list上元素值的大小。&lt;/p&gt;
&lt;p&gt;插入列是一个重复动作，因此函数可以用while循环或递归实现。&lt;/p&gt;
&lt;p&gt;我们面临的第一个挑战就是如何打印星号列。通常，在Emacs我们打印字符的时候是横向打印的，一行一行的打印。我们有两个办法来实现：编写我们自己的列插入函数或者查找Emacs中是否有现成的方法。&lt;/p&gt;
&lt;p&gt;为查找Emacs中的函数，我们可以使用M-x apropos命令。这个命令与C-h a(command-apropos)命令类似，但后者只查找作为命令的函数。而M-x apropos命令将列出所有匹配正则表达式的符号，包括那些非交互式的函数。&lt;/p&gt;
&lt;p&gt;我们想找到那些可以打印或插入纵向列的命令。这个函数的名称肯定包含有'print'或'insert'或'column'等单词。因此，我们只要输入&lt;code&gt;M-x apropos RET print\|insert\|column RET&lt;/code&gt;并查看结果。在我们系统上，这个命令执行需要一些时间，结果包含有79个函数和变量。查找这个列表，我们看到有个insert-rectangle函数有可能能完成这个工作。&lt;/p&gt;
&lt;p&gt;这个函数文档如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;insert-rectangle:
Insert text of RECTANGLE with upper left corner at point.
RECTANGLE's first line is inserted at point,
its second line is inserted at a point vertically under point, etc.
RECTANGLE should be a list of strings.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以测试一下，以确认它是否如我们期望的那样工作。&lt;/p&gt;
&lt;p&gt;把光标放在insert-rectange语句的后面按C-u C-x C-e(eval-last-sexp)。这个函数将在point的下面插入"first","second","third"。函数返回值为nil。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;insert-rectangle&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"first"&lt;/span&gt; &lt;span class="s"&gt;"second"&lt;/span&gt; &lt;span class="s"&gt;"third"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="nv"&gt;first&lt;/span&gt;
                                              &lt;span class="nv"&gt;second&lt;/span&gt;
                                              &lt;span class="nv"&gt;third&lt;/span&gt;
&lt;span class="no"&gt;nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在绘制图表的程序中使用这上函数。我们需要先确保point位于需要插入的位置，然后用insert-rectangle函数插入列。&lt;/p&gt;
&lt;p&gt;如果你是在Info中读取这个文档，你可以切换到另一个缓冲区，比如&lt;code&gt;*scratch*&lt;/code&gt;，将point放在任何地方，输入&lt;code&gt;M-:&lt;/code&gt;，在提示区输入insert-rectangle语句，然后回车。Emacs将执行输入的语句，交把&lt;code&gt;*scratch*&lt;/code&gt;缓冲区中的point位置作为point的值。（&lt;code&gt;M-:&lt;/code&gt;被绑定到eval-expression上。）&lt;/p&gt;
&lt;p&gt;我们将发现当执行完成插入后，point被设置在了最后插入的那行，也就是说这个函数移动了point。如果我们重复执行这个命令，下次插入的内容将在上次插入内容的下面。我们并不需要这样，我们需要的是一个柱状图表，一列挨着一列。&lt;/p&gt;
&lt;p&gt;我们看出每次while循环插入列时必须重新设置point的位置，这个位置必须在列的顶部，而不是在底部。并且，我们打印图表时，并不需要每个列都一样高。这意味着每个列的顶部并不是一样高的。我们不能简单在一同一行上执行同一个操作，而是需要先将point移到正确的位置。&lt;/p&gt;
&lt;p&gt;我们准备用星号来描述柱状图。星号的数量取决于当前numbers-list中元素的值。我们需要构造一个包含星号的列表以便insert-rectangle来画出正确高度的列。如果这个list只包含一定数量的星号，那我们就必须在绘制前将point设置到正确的高度。这比较困难。&lt;/p&gt;
&lt;p&gt;我们可以想出另外一种方式，每次传递给insert-rectangle一个同样长度的list，它们可以在同一行插入，每次插入时只需要向右移动一列。比如，如果最高的高度为5，但实际高度只有3，则insert-rectangle需要的参数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一个需求不是很难，我们需要决定列的高度。有两种方法：我们可以使用任意的值或使用整个list中最大的数字作为最大高度值。Emacs中提供了内置的函数检查参数中的最大值。我们可以使用这个函数。这个函数被称为max它返回它所有参数中的最大值。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;max&lt;/span&gt;  &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将返回7。（相反的函数是min它返回参数中最小的值）&lt;/p&gt;
&lt;p&gt;但是，我们不能简单的在numbers-list上调用max；max函数需要数字类型的参数，而不是包含数字的list。因此，下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;max&lt;/span&gt;  &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将出错：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Wrong type of argument:  number-or-marker-p, (3 4 6 5 7 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要一个函数将list拆开作为参数传递给函数。这个函数是apply。这个函数将其它的参数传递给它的第一个参数，它的最后一个参数可以是一个list。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply&lt;/span&gt; &lt;span class="ss"&gt;'max&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将返回8。&lt;/p&gt;
&lt;p&gt;（顺便说一句，我不知道你如何学习书本上没有介绍过的函数。可以根据函数名称，比如search-forward或insert-rectangle，根据他们的部分名称使用apropos查找函数的相关信息。）&lt;/p&gt;
&lt;p&gt;传递给apply的第二个参数是可选参数，我们可以使用aplly调用一个函数并将list中的元素传递给这个函数，比如下面的代码也将返回8：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply&lt;/span&gt; &lt;span class="ss"&gt;'max&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面我们将使用apply。函数recursive-lengths-list-many-files返回包含数字的list，我们对其调用max。&lt;/p&gt;
&lt;p&gt;这样，查找图表中的最大数量的代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;max-graph-height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply&lt;/span&gt; &lt;span class="ss"&gt;'max&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们回到如何构造包含列图表字符串的list的问题上。知道图表的最大高度和星号的数量后，函数应该可以返回一个传递给insert-rectangle的list了。&lt;/p&gt;
&lt;p&gt;每一列由星号或空格构成。因为函数传递了列高度和列中的星号数量两个参数，空白的数量应该是高度减去星号数量。给出空白数量和星号数量后，两个循环可以构造出这个list：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; First version.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;column-of-graph&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;max-graph-height&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return list of strings that is one column of a graph."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;max-graph-height&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Fill in asterisks.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Fill in blanks.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Return whole list.&lt;/span&gt;
    &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装这个函数后，执行下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;column-of-graph&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将返回：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面所写，column-of-graph包含一个瑕疵：用于标识空白和列的符号是硬编码的，使用了空白和星号。这是一个很好的原型，如果其它人想换成其它的符号。比如用逗号代替空白，用加号代替星号等。程序应该更具弹性一些。应该使用两个变量来代替空白和星号：将graph-blank和graph-symbol定义为两个独立的变量。&lt;/p&gt;
&lt;p&gt;上面也没有编写文档。我们可以编写这个函数的第二个版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;graph-symbol&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt;
  &lt;span class="s"&gt;"String used as symbol in graph, usually an asterisk."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;graph-blank&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt;
  &lt;span class="s"&gt;"String used as blank in graph, usually a blank space.&lt;/span&gt;
&lt;span class="s"&gt;graph-blank must be the same number of columns wide&lt;/span&gt;
&lt;span class="s"&gt;as graph-symbol."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;(For an explanation of defvar, see Initializing a Variable with defvar.)&lt;/span&gt;

&lt;span class="c1"&gt;;;; Second version.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;column-of-graph&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;max-graph-height&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph-symbols.&lt;/span&gt;
&lt;span class="s"&gt;The graph-symbols are contiguous entries at the end&lt;/span&gt;
&lt;span class="s"&gt;of the list.&lt;/span&gt;
&lt;span class="s"&gt;The list will be inserted as one column of a graph.&lt;/span&gt;
&lt;span class="s"&gt;The strings are either graph-blank or graph-symbol."&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;max-graph-height&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Fill in graph-symbols.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;graph-symbol&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Fill in graph-blanks.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;graph-blank&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Return whole list.&lt;/span&gt;
    &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要，我们可以再次重写column-of-graph，使用线型图表代替柱状图表。这不会很困难。其中一个办法就是让柱状图中第一个星号以下的显示为空白。在构造线型图表的一个列时，函数首先构造一个空的list，长度比元素的值小1，然后用cons将符号和列表连接；然后再次使用cons将顶部用空白填充。&lt;/p&gt;
&lt;p&gt;现在，我们终于完成第一个打印图表的函数。它只打印了图表的body部分，而没有水平和垂直方向的轴，因此我们把这个函数称为graph-body-print。&lt;/p&gt;
&lt;h2&gt;graph-body-print函数&lt;/h2&gt;
&lt;p&gt;上一节，graph-body-print函数完成了打印图表列的功能。这应该是一个重复执行的动作。我们可以使用递减的while循环或递归函数来完成这些操作。这节，我们使用while循环来编写函数定义。&lt;/p&gt;
&lt;p&gt;column-of-graph函数需要图表高度作为参数，因此我们需要决定图表高度并将它保存到一个局部变量中。&lt;/p&gt;
&lt;p&gt;我们的使用while循环的函数模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;graph-body-print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;height&lt;/span&gt;  &lt;span class="o"&gt;...&lt;/span&gt;
         &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;
      &lt;span class="nv"&gt;insert-columns-and-reposition-point&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要填空。&lt;/p&gt;
&lt;p&gt;我们可以用&lt;code&gt;(apply 'max numbers-list)&lt;/code&gt;获取图表的高度。&lt;/p&gt;
&lt;p&gt;while循环遍历numbers-list。并用&lt;code&gt;(setq numbers-list (cdr numbers-list))&lt;/code&gt;截短它。每次list的CAR值，就是传递给column-of-graph的参数。&lt;/p&gt;
&lt;p&gt;每个循环周期中，insert-rectangle函数使用column-of-graph插入list。由于insert-rectangle函数将point移到了插入的矩形区域的右下解，我们需要保存当前point的位置，在插入矩形区域后恢复point的位置，然后将point水平移动到下一个列，并再次调用insert-rectangle。&lt;/p&gt;
&lt;p&gt;如果被插入的列是一个字符宽（比如星号或一个空格），这个命令比较简单&lt;code&gt;(forward-char 1)&lt;/code&gt;；但如果列宽超过1。这时命令需要写为&lt;code&gt;(forward-char symbol-width)&lt;/code&gt;symbol-width是graph-blank的长度，可以使用&lt;code&gt;(length graph-blank)&lt;/code&gt;。可以在let语句的变量列表中设置symbol-width变量。&lt;/p&gt;
&lt;p&gt;函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;graph-body-print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print a bar graph of the NUMBERS-LIST.&lt;/span&gt;
&lt;span class="s"&gt;The numbers-list consists of the Y-axis values."&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply&lt;/span&gt; &lt;span class="ss"&gt;'max&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;symbol-width&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;graph-blank&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;from-position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;from-position&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;insert-rectangle&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;column-of-graph&lt;/span&gt; &lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;from-position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-char&lt;/span&gt; &lt;span class="nv"&gt;symbol-width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Draw graph column by column.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;sit-for&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="c1"&gt;;; Place point for X axis labels.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="nv"&gt;height&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里出现了一个新的函数&lt;code&gt;(sit-for 0)&lt;/code&gt;。这个语句将使Emacs重绘屏幕。放在这里，Emacs将一列列的绘制。如果没有，Emacs在函数退出前都不会绘制。&lt;/p&gt;
&lt;p&gt;我们可以使用一个较短的包含数字的list来测试graph-body-print。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装graph-symbol,graph-blank,column-of-graph，graph-body-print。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制下面的语句：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;graph-body-print&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;切换到&lt;code&gt;*scratch*&lt;/code&gt;缓冲区并把光标放置在要绘制的开始位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入&lt;code&gt;M-:(eval-expresion)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Yank(C-Y) graph-body-print语句到缓冲区中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;6.　回车执行graph-body-print语句。&lt;/p&gt;
&lt;p&gt;Emacs将打印出下面的图表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                    *
                *   **
                *  ****
               *** ****
              ********* *
             ************
            *************
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;recursive-graph-body-print函数&lt;/h2&gt;
&lt;p&gt;graph-body-print函数也可以用递归来编写。递归分解为两个部分：外部使用let包装，决定几个变量的值，比如图表最大高度，内部的函数调用是递归调用，用于打印图表，&lt;/p&gt;
&lt;p&gt;包装部分不复杂：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-graph-body-print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print a bar graph of the NUMBERS-LIST.&lt;/span&gt;
&lt;span class="s"&gt;The numbers-list consists of the Y-axis values."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply&lt;/span&gt; &lt;span class="ss"&gt;'max&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;symbol-width&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;graph-blank&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;from-position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-graph-body-print-internal&lt;/span&gt;
     &lt;span class="nv"&gt;numbers-list&lt;/span&gt;
     &lt;span class="nv"&gt;height&lt;/span&gt;
     &lt;span class="nv"&gt;symbol-width&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归函数部分有点复杂。它有四个部分：'do-again-test'打印操作的代码，递归调用，'next-step-expression'。'do-again-test'是一个if语句用于检查numbers-list是否还有元素，如果有函数将使用打印操作的代码打印一个列，并再次调用自身。函数调用自身时'next-step-expressin'将截短numbers-list。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-graph-body-print-internal&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt; &lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="nv"&gt;symbol-width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print a bar graph.&lt;/span&gt;
&lt;span class="s"&gt;Used within recursive-graph-body-print function."&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;from-position&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;insert-rectangle&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;column-of-graph&lt;/span&gt; &lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;from-position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-char&lt;/span&gt; &lt;span class="nv"&gt;symbol-width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;sit-for&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;; Draw graph column by column.&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-graph-body-print-internal&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="nv"&gt;symbol-width&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在安装这个函数后，可以用下面的例子测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-graph-body-print&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                *
               **   *
              ****  *
              **** ***
            * *********
            ************
            *************
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;.emacs文件&lt;/h1&gt;
&lt;h2&gt;Emacs的缺省配置&lt;/h2&gt;
&lt;p&gt;Emacs缺省配置的优点。Emacs在你编辑C文件时将启动C mod，编写Fortan源文件时启动Fortran mode，编写未知文件时使用Fundamental mod。这些都是自动检测的，不需要干预。&lt;/p&gt;
&lt;p&gt;可以通过~/.emacs对Emacs进行定制。这是你个人的初始化文件；它的内容是Emacs Lisp代码。&lt;/p&gt;
&lt;h2&gt;全局初始化文件&lt;/h2&gt;
&lt;p&gt;除了个人初始化文件外，Emacs将自动加载全局初始化文件，这与.emacs文件一样，但它将被所有的用户加载。&lt;/p&gt;
&lt;p&gt;有两个全局初始化文件site-load.el和site-init.el，在被加载到Emacs后被'dumped'（如果Emacs 'dumped'版本被创建，Dumped的Emacs复制版本加载更快）。但是，一旦文件被加载并被dumped，对文件的修改将不会影响Emacs除非你re-dump Emacs（详情，请查找INSTALL文件）。&lt;/p&gt;
&lt;p&gt;有3个全局文件在每次启动Emacs时被执行（如果他们存在）。site-start.el在.emacs文件执行前执行，default.el和终端类型文件，这两上在.emacs加载后执行。&lt;/p&gt;
&lt;p&gt;.emacs中的设置将覆盖site-start.el中的设置。default.el或终端类型文件将覆盖.emacs文件。（可以通过设置term-file-prefix为nil来防止与终端类型文件冲突）&lt;/p&gt;
&lt;p&gt;发行版本中的INSTALL文件描述了site-init.el和site-load.el文件。&lt;/p&gt;
&lt;p&gt;loadup.el,startup.el,loaddefs.el文件控制加载的过程。这些文件在Emacs发行版本的lisp目录中，值得精读。&lt;/p&gt;
&lt;p&gt;loaddefs.el包含了大量设置.emacs文件或全局初始化文件的建议。&lt;/p&gt;
&lt;h2&gt;使用defcustom设置变量&lt;/h2&gt;
&lt;p&gt;可以使用defcustom以使用使用Emacs的customize功能设置变量的值。（不可以将customize用于函数定义；但可以在.emacs中使用defuns）实际上，可以在.emacs中写任何的Lisp语句。&lt;/p&gt;
&lt;p&gt;customize功能取决于defcustom。忙乎你可以使用defvar或setq来设置变量，但defcustom是被设计为做此项工作的。&lt;/p&gt;
&lt;p&gt;你可以将defvar的知识运用到defcustom的3个参数中。第一个参数是变量名称。第二个参数如果存在则表示变量实始值，并且这个值只会在变量未设置值时设置。第三个参数是文档字符串。&lt;/p&gt;
&lt;p&gt;第四个和后面的参数是为defcustom设置类型和选项的；这些是defvar所没有的功能。(这些参数是可选的)&lt;/p&gt;
&lt;p&gt;这些参数的每个值由键值对组成。每个键以一个字母开头：&lt;/p&gt;
&lt;p&gt;举例来说，用户自定义变量text-mode-hook如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defcustom&lt;/span&gt; &lt;span class="nv"&gt;text-mode-hook&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
  &lt;span class="s"&gt;"Normal hook run when entering Text mode and many related modes."&lt;/span&gt;
  &lt;span class="nb"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;'hook&lt;/span&gt;
  &lt;span class="nb"&gt;:options&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;turn-on-auto-fill&lt;/span&gt; &lt;span class="nv"&gt;flyspell-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;:group&lt;/span&gt; &lt;span class="ss"&gt;'data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量text-mode-hook；没有缺省值；并且它的文档字符串告诉你它起什么作用。&lt;/p&gt;
&lt;p&gt;:type关键字告诉Emacs应该给text-mode-hook设置什么样的数据，在一个自定义缓冲区中如何显示它的值。&lt;/p&gt;
&lt;p&gt;:options关键词，指定了一个备选值的列表。可以用于这个hook的:options。列表中的仅是建议值，并不是唯一备选值；人们可以设置为其它的任意值；:options关键字给用户提出了最合适的建议。&lt;/p&gt;
&lt;p&gt;最后是:group关键字，它告诉Emacs的自定义命令将这个变量分到哪个组，以便于查找这个变量。&lt;/p&gt;
&lt;p&gt;以text-mode-hook为例。&lt;/p&gt;
&lt;p&gt;有两种方式来定制这个变量。你可以使用自定义变量的命令或者编写适当的语句。&lt;/p&gt;
&lt;p&gt;使用自定义变量命令，可以输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x customize
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找到对就的分组'data'。进入这个分组。TextMode Hook是第一个成员。你可以点击它的选项来设置它的值。最后点击下面的按钮&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Save for Future Sessions
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Emacs将会向.emacs文件中写入下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;custom-set-variables&lt;/span&gt;
  &lt;span class="c1"&gt;;; custom-set-variables was added by Custom --&lt;/span&gt;
  &lt;span class="c1"&gt;;;                           don't edit or cut/paste it!&lt;/span&gt;
  &lt;span class="c1"&gt;;; Your init file should contain only one such instance.&lt;/span&gt;
 &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;text-mode-hook&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;turn-on-auto-fill&lt;/span&gt; &lt;span class="nv"&gt;text-mode-hook-identify&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（text-mode-hook-identify函数告诉toggle-text-mode-auto-fill哪个缓冲区处于Text mode。）&lt;/p&gt;
&lt;p&gt;你可以不用管警告信息来修改这些语句。警告的目的是为了恐吓那些不明白自己在做什么的人。&lt;/p&gt;
&lt;p&gt;custom-set-variables的工作与setq不同。我从不去了解这些不同，我不手工修改.emacs中的custom-set-variables语句。&lt;/p&gt;
&lt;p&gt;另一个custom-set-...函数是custom-set-faces。这个函数设置字体外观。&lt;/p&gt;
&lt;p&gt;第二种定制text-mode-hook的方法是在.emacs中编写代码，与custom-set-...函数无关。&lt;/p&gt;
&lt;h2&gt;开始编写一个.emacs文件&lt;/h2&gt;
&lt;p&gt;启动Emacs时，将加载你的.emacs文件，除非你在命令行使用了-q命令（emacs -q）。&lt;/p&gt;
&lt;p&gt;.emacs文件包含了Lisp语句。通常是设值语句，有时有函数定义。&lt;/p&gt;
&lt;p&gt;这章将以作者的.emacs文件为例。&lt;/p&gt;
&lt;p&gt;文件的第一个部分是注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;;; Bob's .emacs file&lt;/span&gt;
&lt;span class="c1"&gt;;; Robert J. Chassell&lt;/span&gt;
&lt;span class="c1"&gt;;; 26 September 1985&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看看时间，在很久以前加的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Each section in this file is introduced by a&lt;/span&gt;
&lt;span class="c1"&gt;;; line beginning with four semicolons; and each&lt;/span&gt;
&lt;span class="c1"&gt;;; entry is introduced by a line beginning with&lt;/span&gt;
&lt;span class="c1"&gt;;; three semicolons.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段描述是Emacs Lisp的习惯性注释方式。分号后面是注释。两个、三个或四个分号用于区分章节。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;;; The Help Key&lt;/span&gt;
&lt;span class="c1"&gt;;; Control-h is the help key;&lt;/span&gt;
&lt;span class="c1"&gt;;; after typing control-h, type a letter to&lt;/span&gt;
&lt;span class="c1"&gt;;; indicate the subject about which you want help.&lt;/span&gt;
&lt;span class="c1"&gt;;; For an explanation of the help facility,&lt;/span&gt;
&lt;span class="c1"&gt;;; type control-h two times in a row.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记住：输入C-h两次显示帮助。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; To find out about any mode, type control-h m&lt;/span&gt;
&lt;span class="c1"&gt;;; while in that mode.  For example, to find out&lt;/span&gt;
&lt;span class="c1"&gt;;; about mail mode, enter mail mode and then type&lt;/span&gt;
&lt;span class="c1"&gt;;; control-h m.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;'Mode help'非常有用，它告诉你所有你需要知道的。&lt;/p&gt;
&lt;p&gt;当然你不需要在你的.emacs文件包含这些。我添加这些只是为了记住Model help或者注释约定。&lt;/p&gt;
&lt;h2&gt;Text 和 Auto Fill Mode&lt;/h2&gt;
&lt;p&gt;接下来到'tuns on' Text mode和Auto Fill mode。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Text mode and Auto Fill mode&lt;/span&gt;
&lt;span class="c1"&gt;;; The next three lines put Emacs into Text mode&lt;/span&gt;
&lt;span class="c1"&gt;;; and Auto Fill mode, and are for writers who&lt;/span&gt;
&lt;span class="c1"&gt;;; want to start writing prose rather than code.&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;default-major-mode&lt;/span&gt; &lt;span class="ss"&gt;'text-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook-identify&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook&lt;/span&gt; &lt;span class="ss"&gt;'turn-on-auto-fill&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面两行告诉Emacs在打开文件时，如果找不到对应的mode就打开Text mode。&lt;/p&gt;
&lt;p&gt;当Emacs读取一个文件时，它查找文件的扩展名，如果有，如果以.c或.h结尾，Emacs开启C mode。Emacs也会检查文件的第一个非空白行；如果行上有&lt;code&gt;-*- C -*-&lt;/code&gt;，Emacs也会开启C mode。Emacs处理了一个扩展名列表。In addition, Emacs looks near the last page for a per-buffer, "local variables list",if any.&lt;/p&gt;
&lt;p&gt;现在，回到.emacs文件。&lt;/p&gt;
&lt;p&gt;又出现了这行；它是如何工作的？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;default-major-mode&lt;/span&gt; &lt;span class="ss"&gt;'text-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这行是一个完整的Emacs Lisp语句。&lt;/p&gt;
&lt;p&gt;它使用了我们早已经熟悉的setq。它设置变量default-major-mode为text-mode。单引号告诉Emacs把text-mode直接作为变量。&lt;/p&gt;
&lt;p&gt;接下来的两行是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook-identify&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook&lt;/span&gt; &lt;span class="ss"&gt;'turn-on-auto-fill&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两行中，add-hook首先添加了text-mode-hook-identify到变量text-mode-hook中，然后添加了turn-on-auto-fill到这个变量中。&lt;/p&gt;
&lt;p&gt;turn-on-auto-fill是程序名称，它开启Auto Fill mode。text-mode-hook-identify是一个函数，它告诉toggle-text-mode-auto-fill哪个缓冲区处于Text mode。&lt;/p&gt;
&lt;p&gt;每次Emacs进入Text mode，Emacs将会执行'hooked'命令。因此，每次Emacs开启Text mode时，Emacs也将开启Auto Fill mode。&lt;/p&gt;
&lt;p&gt;简单来说，第一行让Emacs在编辑文件时自动进入Text mode，除非文件扩展名或第一个非空行或局部变量能告诉Emacs该进入哪种mode。&lt;/p&gt;
&lt;p&gt;Text mode中有其它动作，设置语法表以便于编写。在Text mode中，Emacs像处理信件一样把省略号当作单词的一部分；但Emacs不会把逗号或空白当作单词的一部分。因此M-f将移过it's。另一方面，在C mode中，M-f将在it's中t的后面停止。&lt;/p&gt;
&lt;p&gt;第二和第三行将使Emacs在进入Text mode时开启Auto Fill mode。在Auto Fill mode中，Emacs自动换行，并将过长的部分移到下一行。Emacs会在单词之间换行，而不会把单词截断。&lt;/p&gt;
&lt;p&gt;当Auto Fill mode关闭时，文件中的行将与输入时保持一致。取决于trucate-lines变量的值，你输入的单词有可能消失在屏幕的右边，也有可以显示以非常乱的方式显示，也有可能显示为一个非常长的行。&lt;/p&gt;
&lt;p&gt;另外，在我的.emacs文件的这一部分，我告诉Emacs在分号后添加两个空格：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;colon-double-space&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;邮件别名&lt;/h2&gt;
&lt;p&gt;这里使用setq开启邮件别名，也有一些用于提醒的注释。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Mail mode&lt;/span&gt;
&lt;span class="c1"&gt;;; To enter mail mode, type `C-x m'&lt;/span&gt;
&lt;span class="c1"&gt;;; To enter RMAIL (for reading mail),&lt;/span&gt;
&lt;span class="c1"&gt;;; type `M-x rmail'&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;mail-aliases&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setq命令设置变量mail-aliases为t。因为t表示true，这行就是在说"Yes,use mail aliases."&lt;/p&gt;
&lt;p&gt;邮件别名是一种email地址的缩写。别名保存在~/.mailrc中。你可以这样书写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alias geo george@foobar.wiz.edu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当你给George发邮件时，地址可以输入geo；邮件发送者将自动将geo展开为完整的邮箱地址。&lt;/p&gt;
&lt;h2&gt;Indent Tabs Mode&lt;/h2&gt;
&lt;p&gt;缺省情况下，Emacs在格式化一个区域时会在需要空白的位置插入tab。（比如在需要缩进时）。Tab在使用终端或普通打印机时看起来很正常，但如果是在TeX或Texinfo中就会不正常。因为TeX将忽略tab。&lt;/p&gt;
&lt;p&gt;下面的代码关闭Tabs mode：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Prevent Extraneous Tabs&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq-default&lt;/span&gt; &lt;span class="nv"&gt;indent-tabs-mode&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，这里使用了setq-default而不是使用setq。setq-default命令只会在局部变量没有值时设置这个变量的值。&lt;/p&gt;
&lt;h2&gt;一些按键绑定&lt;/h2&gt;
&lt;p&gt;下面是一些个性化的按键绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Compare windows&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-cw"&lt;/span&gt; &lt;span class="ss"&gt;'compare-windows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;compare-window将比较当前窗口中的文本和下一个窗口中的文本。&lt;/p&gt;
&lt;p&gt;这里也显示了如何设置一个全局按键绑定，它在任何mode下都有效。&lt;/p&gt;
&lt;p&gt;命令global-set-key后面跟按键绑定。在.emacs文件中，按键绑定被书写为：&lt;code&gt;\C-c&lt;/code&gt;表示'control-c'，表示'按住control键的同时按c键'。w表示'按w键'。按键设置用双引号包含。在编写文档的时候，你可以写成C-c w。（如果绑定的键是&lt;meta/&gt;键，比如M-c则书写为&lt;code&gt;\M-c&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;这个按键组成将调用compare-windows命令。注意，compare-windows前面有一个单引号；如果不加Emacs将对它求值。&lt;/p&gt;
&lt;p&gt;三件事：双引号，C前面的反余线和单引号。&lt;/p&gt;
&lt;p&gt;这里还有另一个按键绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Keybinding for `occur'&lt;/span&gt;
&lt;span class="c1"&gt;;; I use occur a lot, so let's bind it to a key:&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-co"&lt;/span&gt; &lt;span class="ss"&gt;'occur&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;occur命令显示当前缓冲区中匹配某个正则表达式的所有行。匹配的行被显示在&lt;code&gt;*Occur*&lt;/code&gt;缓冲区中。&lt;/p&gt;
&lt;p&gt;下面演示了如何取消一个按键绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Unbind `C-x f'&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-unset-key&lt;/span&gt; &lt;span class="s"&gt;"\C-xf"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取消这个绑定的原因是：我经常在需要输入C-x C-f时输入了C-x f。&lt;/p&gt;
&lt;p&gt;下面的语句重新设置了一个已经存在的绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Rebind `C-x C-b' for `buffer-menu'&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-x\C-b"&lt;/span&gt; &lt;span class="ss"&gt;'buffer-menu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缺省情况下C-x C-b执行list-buffer命令。这个命令在另一个window中列出缓冲区。因为我几乎一直都需要在那个窗口中做一些操作，我比较喜欢buffer-menu命令，它不只是列出缓冲区，也会将point移到那个窗口中。&lt;/p&gt;
&lt;h2&gt;Keymaps&lt;/h2&gt;
&lt;p&gt;Emacs使用keymaps记录按键与命令的对应关系。当使用global-set-key设置按键绑定时，就是在current-global-map中指定了一个按键绑定。&lt;/p&gt;
&lt;p&gt;特殊的模式下，比如C mode或Text mode，有他们自己的按键绑定；它将覆盖全局keymap。&lt;/p&gt;
&lt;p&gt;global-set-key函数用于绑定或重新绑定全局keymap。比如，下面的代码将C-x C-b绑定到buffer-menu函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-x\C-b"&lt;/span&gt; &lt;span class="ss"&gt;'buffer-menu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特殊模式下的keymap用defin-key设置，它接收一个指定的keymap作为参数，还有按键组合和命令。比如，我的.emacs文件包含下面的语句绑定textinfo-insert-@group命令到C-c C-c g：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-key&lt;/span&gt; &lt;span class="nv"&gt;texinfo-mode-map&lt;/span&gt; &lt;span class="s"&gt;"\C-c\C-cg"&lt;/span&gt; &lt;span class="ss"&gt;'texinfo-insert-@group&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;text-info-insert-@group函数是一个Texinfo mode下的扩展，它用于在Texinfo文件中插入@group标记。我可以用三次按键C-c C-c g来输入，而不需要按六个键@ g r o u p。（@group与@end匹配，group命令用于保持它所包含的文本被放在同一页上）&lt;/p&gt;
&lt;p&gt;下面是texinfo-insert-@group函数的定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;texinfo-insert-@group&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Insert the string @group in a Texinfo buffer."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"@group\n"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（当然，我也可以用Abbrev来完成类似工作，而不需要编写一个函数来插入单词；但是我更喜欢与Texinfo mode的其它按键保持一致。）&lt;/p&gt;
&lt;p&gt;在loaddefs.el中你可以在各种mode中看到无数多的define-key语句，比如cc-mode.el和lisp-mode.el中。&lt;/p&gt;
&lt;h2&gt;加载文件&lt;/h2&gt;
&lt;p&gt;很多GNU Emacs社区的人们都自己编写Emacs的扩展。随着时间的推移，这些扩展通常都会出现新的版本。比如，Calendar和Diary包现在已经变成了GNU Emacs标准发行包中的一部分了。&lt;/p&gt;
&lt;p&gt;可以使用load命令来执行整个文件，而将文件中的函数和变量设置安装到Emacs中。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;load&lt;/span&gt; &lt;span class="s"&gt;"~/emacs/slowsplit"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它个语句执行，或者说加载了slowsplit.el这个文件（如果文件存在），或者加载编译过的slowsplit.elc文件。这个文件包含了split-window-quietly函数，它是John Robinson于1989年编写的。&lt;/p&gt;
&lt;p&gt;split-window-quietly函数在分隔窗口时，只使用了少量的重绘。我在1989年安装了它因为它与当时我使用的慢速的1200 baud终端工作得很好。现在很少遇到这种慢速连接了，但我仍然使用这个函数，因为我喜欢这种方式：缓冲区的下半部分在下面的新窗口中，而缓冲区的上半部分在上面的窗口中。&lt;/p&gt;
&lt;p&gt;为了替换split-window-vertically的缺省按键绑定，你需要先取消split-window-quietly的按键绑定，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-unset-key&lt;/span&gt; &lt;span class="s"&gt;"\C-x2"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-x2"&lt;/span&gt; &lt;span class="ss"&gt;'split-window-quietly&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要加载很多扩展，你需要指定扩展文件所在的位置，需要将扩展所在目录添加到Emacs的load-path中。在Emacs加载文件时，它将搜索这个目录列表中的目录。（缺省的列表在Emacs构建时在paths.h中指定。）&lt;/p&gt;
&lt;p&gt;下面的命令将你的~/emacs目录添加到load-path中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Emacs Load Path&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;load-path&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="s"&gt;"~/emacs"&lt;/span&gt; &lt;span class="nv"&gt;load-path&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;load-library是一个交互式的load函数。完整的函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;load-library&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;library&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Load the library named LIBRARY.&lt;/span&gt;
&lt;span class="s"&gt;This is an interface to the function &lt;/span&gt;&lt;span class="ss"&gt;`load'&lt;/span&gt;&lt;span class="s"&gt;."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"sLoad library: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;load&lt;/span&gt; &lt;span class="nv"&gt;library&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;load-library函数的名称来自于将'file'称为'library'。load-library命令在files.el中。&lt;/p&gt;
&lt;p&gt;另一个交互式命令load-file完成的工作有些许不同。&lt;/p&gt;
&lt;h2&gt;自动加载&lt;/h2&gt;
&lt;p&gt;与通过加载文件的方式或者执行函数定义等方式加载函数不同，可以使用函数在被调用时自动加载。这被称作自动加载（autoloading）。&lt;/p&gt;
&lt;p&gt;当执行自动加载函数时，Emacs自动执行文件中包含定义然后调用这个函数。&lt;/p&gt;
&lt;p&gt;使用自动加载可以使Emacs启动得更快一些，因为库没有被立即加载；但是在第一次执行函数时，在加载对应的文件时需要稍等一下。&lt;/p&gt;
&lt;p&gt;那些使用得较少的函数通常使用自动加载。loaddefs.el库包含了数百个自动加载函数，从bookmark-set到wordstar-mode。当然，如果有可能经常需要使用一些'罕见'的函数，可以在.emacs文件中使用load语句加载它。&lt;/p&gt;
&lt;p&gt;autoload是一个内置函数可以传递5个参数，最后三个是可选的。第一个参数是需要自动加载的函数名称；第二个参数是要加载的文件名。第三个参数是函数的文档，第四个用于说明这个函数是否可以以交互的方式运行。第五个参数说明对象的类型&amp;mdash;&amp;mdash;autoload可以处理按键或者宏或者函数（缺省是函数）。&lt;/p&gt;
&lt;p&gt;下面是一个典型的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;autoload&lt;/span&gt; &lt;span class="ss"&gt;'html-helper-mode&lt;/span&gt;
  &lt;span class="s"&gt;"html-helper-mode"&lt;/span&gt; &lt;span class="s"&gt;"Edit HTML documents"&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（html-helper-mode是html-mode的另一选择，它是标准发行版的一部分）&lt;/p&gt;
&lt;p&gt;自动加载html-helper-mode函数。它将从html-helper-mode.el（或从编译过的html-helper-mode.elc）加载。这个文件必须位于load-path指定的目录列表中。文档字符串说明这个mode是用于编辑html文件的。你可以以交互的方式输入M-x html-helper-mode来执行。（你需要在这里提供文档字符串，虽然函数定义中有，但在这里函数还没有加载，它的文档字符串还不可用）&lt;/p&gt;
&lt;h2&gt;一个简单的扩展：line-to-top-of-window&lt;/h2&gt;
&lt;p&gt;这里是一个简单的Emacs扩展它将point移到窗口的顶部。&lt;/p&gt;
&lt;p&gt;你可以将下面的代码放到独立的文件中，然后在.emacs文件中加载，或者你可以在.emacs文件中直接包含这些代码。&lt;/p&gt;
&lt;p&gt;定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Line to top of window;&lt;/span&gt;
&lt;span class="c1"&gt;;;; replace three keystroke sequence  C-u 0 C-l&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;line-to-top-of-window&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Move the line point is on to top of window."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recenter&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在设置按键绑定。&lt;/p&gt;
&lt;p&gt;现在，功能键和鼠标按键事件和非ASCII字符写在方括号中，不需要使用引号。（在Emacs 18或以前的版本中，你需要为不同的终端编写不同的功能键绑定）&lt;/p&gt;
&lt;p&gt;我们将line-to-top-of-window绑定到&lt;f6&gt;功能键上。&lt;/f6&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;f6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ss"&gt;'line-to-top-of-window&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你运行有两个版本的GNU Emacs，比如20和21，并使用同一个.emacs文件，你可以使用下面的方法选择执行不同的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
 &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;string-equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;number-to-string&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;emacs-version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;;; evaluate version 20 code&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;string-equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;number-to-string&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;emacs-version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;;; evaluate version 21 code&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如，在21版中光标缺省是闪烁的。我不喜欢这种效果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-equal&lt;/span&gt; &lt;span class="s"&gt;"21"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;emacs-version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;blink-cursor-mode&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Insert newline when you press `C-n' (next-line)&lt;/span&gt;
      &lt;span class="c1"&gt;;; at the end of the buffer&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;next-line-add-newlines&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Turn on image viewing&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;auto-image-file-mode&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Turn on menu bar (this bar has text)&lt;/span&gt;
      &lt;span class="c1"&gt;;; (Use numeric argument to turn on)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;menu-bar-mode&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Turn off tool bar (this bar has icons)&lt;/span&gt;
      &lt;span class="c1"&gt;;; (Use numeric argument to turn on)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;tool-bar-mode&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Turn off tooltip mode for tool bar&lt;/span&gt;
      &lt;span class="c1"&gt;;; (This mode causes icon explanations to pop up)&lt;/span&gt;
      &lt;span class="c1"&gt;;; (Use numeric argument to turn on)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;tooltip-mode&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; If tooltips turned on, make tips appear promptly&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;tooltip-delay&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; default is one second&lt;/span&gt;
       &lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（注意这里没有使用&lt;code&gt;(number-to-string 21)&lt;/code&gt;，没有使用函数将整数转化为字符串。短的表达式比长的更好，但&lt;code&gt;(number-to-string 21)&lt;/code&gt;更通用。然而如果你不知道前面返回值的类型时，就需要使用number-to-string函数了。）&lt;/p&gt;
&lt;h2&gt;X11颜色&lt;/h2&gt;
&lt;p&gt;在MIT X Windowing系统上使用Emacs时可以指定颜色。&lt;/p&gt;
&lt;p&gt;我不喜欢缺省的颜色而指定了自己的颜色。&lt;/p&gt;
&lt;p&gt;.emacs中的这些语句指定了这些值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Set cursor color&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-cursor-color&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;; Set mouse color&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-mouse-color&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;; Set foreground and background&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-foreground-color&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-background-color&lt;/span&gt; &lt;span class="s"&gt;"darkblue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; Set highlighting colors for isearch and drag&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-foreground&lt;/span&gt; &lt;span class="ss"&gt;'highlight&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-background&lt;/span&gt; &lt;span class="ss"&gt;'highlight&lt;/span&gt; &lt;span class="s"&gt;"blue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-foreground&lt;/span&gt; &lt;span class="ss"&gt;'region&lt;/span&gt; &lt;span class="s"&gt;"cyan"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-background&lt;/span&gt; &lt;span class="ss"&gt;'region&lt;/span&gt; &lt;span class="s"&gt;"blue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-foreground&lt;/span&gt; &lt;span class="ss"&gt;'secondary-selection&lt;/span&gt; &lt;span class="s"&gt;"skyblue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-background&lt;/span&gt; &lt;span class="ss"&gt;'secondary-selection&lt;/span&gt; &lt;span class="s"&gt;"darkblue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;; Set calendar highlighting colors&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;calendar-load-hook&lt;/span&gt;
      &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-foreground&lt;/span&gt; &lt;span class="ss"&gt;'diary-face&lt;/span&gt;   &lt;span class="s"&gt;"skyblue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-background&lt;/span&gt; &lt;span class="ss"&gt;'holiday-face&lt;/span&gt; &lt;span class="s"&gt;"slate blue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-foreground&lt;/span&gt; &lt;span class="ss"&gt;'holiday-face&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不同色调的蓝色防止人感觉屏幕的闪烁。&lt;/p&gt;
&lt;p&gt;另一种选择是在X初始化文件中指定彩色。比如，可以在~/.Xresources文件中设置前景色、背景色、光标和指针颜色等：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Emacs*foreground:   white
Emacs*background:   darkblue
Emacs*cursorColor:  white
Emacs*pointerColor: white
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这并不是Emacs的一部分，还可以在~/.xinitrc文件中指定X window根窗口的颜色：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# I use TWM for window manager.
xsetroot -solid Navy -fg white &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;.emacs中的杂项设置&lt;/h2&gt;
&lt;p&gt;一些杂项设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置鼠标光标的颜色和外观：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Cursor shapes are defined in&lt;/span&gt;
&lt;span class="c1"&gt;;; `/usr/include/X11/cursorfont.h';&lt;/span&gt;
&lt;span class="c1"&gt;;; for example, the `target' cursor is number 128;&lt;/span&gt;
&lt;span class="c1"&gt;;; the `top_left_arrow' cursor is number 132.&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;mpointer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;x-get-resource&lt;/span&gt; &lt;span class="s"&gt;"*mpointer"&lt;/span&gt;
                                &lt;span class="s"&gt;"*emacs*mpointer"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="c1"&gt;;; If you have not set your mouse pointer&lt;/span&gt;
  &lt;span class="c1"&gt;;;     then set it, otherwise leave as is:&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;mpointer&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;mpointer&lt;/span&gt; &lt;span class="s"&gt;"132"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; top_left_arrow&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;x-pointer-shape&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;string-to-int&lt;/span&gt; &lt;span class="nv"&gt;mpointer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-mouse-color&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;状态栏(Modified Mode Line)&lt;/h2&gt;
&lt;p&gt;当我在网络中工作时，会忘记使用的是哪台机器。也有可能忘记point位于什么位置。&lt;/p&gt;
&lt;p&gt;因此我重置了mode line：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s s-Atom"&gt;-:--&lt;/span&gt; &lt;span class="s s-Atom"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;texi&lt;/span&gt;   &lt;span class="nn"&gt;rattlesnake&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bob&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;  &lt;span class="nv"&gt;Line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;Texinfo&lt;/span&gt; &lt;span class="nv"&gt;Fill&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;Top&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示访问的文件名为foo.texi，在rattlesnake这台机器的/home/bob缓冲区中。位于第一行，处于Texinfo mode，位于缓冲区的顶部。&lt;/p&gt;
&lt;p&gt;.emacs文件中有如下的部分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Set a Mode Line that tells me which machine, which directory,&lt;/span&gt;
&lt;span class="c1"&gt;;; and which line I am on, plus the other customary information.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;default-mode-line-format&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;help-echo&lt;/span&gt;
      &lt;span class="s"&gt;"mouse-1: select window, mouse-2: delete others ..."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="nv"&gt;mode-line-mule-info&lt;/span&gt;
   &lt;span class="nv"&gt;mode-line-modified&lt;/span&gt;
   &lt;span class="nv"&gt;mode-line-frame-identification&lt;/span&gt;
   &lt;span class="s"&gt;"    "&lt;/span&gt;
   &lt;span class="nv"&gt;mode-line-buffer-identification&lt;/span&gt;
   &lt;span class="s"&gt;"    "&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;:eval&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;system-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-match&lt;/span&gt; &lt;span class="s"&gt;"\\..+"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;system-name&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
   &lt;span class="s"&gt;":"&lt;/span&gt;
   &lt;span class="nv"&gt;default-directory&lt;/span&gt;
   &lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;help-echo&lt;/span&gt;
      &lt;span class="s"&gt;"mouse-1: select window, mouse-2: delete others ..."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;line-number-mode&lt;/span&gt; &lt;span class="s"&gt;" Line %l "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="nv"&gt;global-mode-string&lt;/span&gt;
   &lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;"   %[("&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;help-echo&lt;/span&gt;
      &lt;span class="s"&gt;"mouse-1: select window, mouse-2: delete others ..."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;:eval&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mode-line-mode-name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="nv"&gt;mode-line-process&lt;/span&gt;
   &lt;span class="nv"&gt;minor-mode-alist&lt;/span&gt;
   &lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;"%n"&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;help-echo&lt;/span&gt; &lt;span class="s"&gt;"mouse-2: widen"&lt;/span&gt; &lt;span class="nv"&gt;local-map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;keymap&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
   &lt;span class="s"&gt;")%] "&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;-3&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"%P"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="c1"&gt;;;   "-%-"&lt;/span&gt;
   &lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里重定义了缺省的mode line。多数设置来自于原始值；但作了一些修改。设置了default mode line format以便支持多种mode，比如Info。&lt;/p&gt;
&lt;p&gt;列表中的很多元素是自描述的：mode-line-modified是一个变量，它说明了缓冲区是否被修改了，mode-name说明mode的名称，等等。format看起来复杂一些，因为它使用了两个我们没有讨论过的功能。&lt;/p&gt;
&lt;p&gt;mode line字符串的第一行是一个短线-。在原来，它只能是一个简单的"-"。但现在，Emacs允许给字符串添加属性，比如高亮，或者像这里一样，是一个帮助功能。如果你将鼠标光标放在短线上，一些帮助信息将会显示出来。（缺省情况下，你需要等1秒。你也可以通过修改tooltip-delay变量来修改这个时间。）&lt;/p&gt;
&lt;p&gt;新的字符串有一个特定的格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#("-" 0 1 (help-echo "mouse-1: select window, ..."))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;#(&lt;/code&gt;开头的list。第一个元素是字符串本身，只有一个"-"。第二个和第三个元素指定第四个元素的应用范围。范围从一个字符后面开始，0表示从第一个字符之前开始；1表示范围在第一个字符后面结束。第三个元素是范围的属性。它包含了一个属性列表，属性名help-echo，后面跟了一个属性值，是一个字符串。第二、三和四个元素可以重复出现。&lt;/p&gt;
&lt;p&gt;mode-line-buffer-identification显示当前缓冲区名称。它是以&lt;code&gt;(#("%12b" 0 4 ....&lt;/code&gt;开头的list。&lt;/p&gt;
&lt;p&gt;"%12b"显示缓冲区的名称，使用buffer-name函数；'12'设置了最大显示的字符数量。当名称的长度小于这个长度时会将空白添加到字符串中。（缓冲区名称通常大于12个字符，这个长度在典型的80列的窗口中工作得很好）&lt;/p&gt;
&lt;p&gt;:eval是GNU Emacs 21中的新功能。它执行后面的语句交把结果作为字符串显示。在这里，这个语句显示完整的系统名称的第一个部分。第一个部分的结束位置是一个'.'，因此使用了string-match函数计算第一个部分的长度。substring取从0到那个位置的字符串。&lt;/p&gt;
&lt;p&gt;语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;:eval&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;system-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-match&lt;/span&gt; &lt;span class="s"&gt;"\\..+"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;system-name&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;%[和%]这对括号显示每个递归编辑的层次。%n表示'Narrow'（在narrowed时）。%P表示窗口底部上缓冲区的百分比，或者'Top'或'Bottom'或'All'。（小写的p表示离窗口顶部上的百分比。）%-插入用于填充的连字符。&lt;/p&gt;
&lt;p&gt;如果想要在启动时不加载~/.emacs，可以使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;emacs -q
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;调试&lt;/h1&gt;
&lt;p&gt;GNU Emacs中有两个高度器，debug和edebug。第一个是Emacs内建的可以随时使用它；第二个需要借助一些函数才能使用。&lt;/p&gt;
&lt;h2&gt;debug&lt;/h2&gt;
&lt;p&gt;假设你编写了用于加1的函数。但函数有个bug。你误将1-输入为1=了。函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-bugged&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return sum of numbers 1 through NUMBER inclusive."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;      &lt;span class="c1"&gt;; Error here.&lt;/span&gt;
    &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当传递4给这个函数时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-bugged&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Emacs 21中，将产生一个&lt;em&gt;Backtrace&lt;/em&gt;缓冲区，并进入这个缓冲区：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
  (1= number)
  (setq number (1= number))
  (while (&amp;gt; number 0) (setq total (+ total number))
        (setq number (1= number)))
  (let ((total 0)) (while (&amp;gt; number 0) (setq total ...)
    (setq number ...)) total)
  triangle-bugged(4)
  eval((triangle-bugged 4))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（重新格式化了一下；调试不会自动折行。可以用q退出调试器）&lt;/p&gt;
&lt;p&gt;实际上，像这样简单的bug，'Lisp error'这行告诉了我们如何修改定义。函数1=为'void'。&lt;/p&gt;
&lt;p&gt;在Emacs 20中，你将看到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Symbol's function definition is void: 1=
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这与21版中的&lt;em&gt;Backtrace&lt;/em&gt;缓冲区中的意思是一样的。&lt;/p&gt;
&lt;p&gt;假设你还不是很清楚要如何做？你可以阅读完整的回溯信息。&lt;/p&gt;
&lt;p&gt;在GNU Emacs 21中，它将自动启动调试器，并将信息放到&lt;em&gt;Backtrace&lt;/em&gt;缓冲区中；如果有使用Emacs21，可能需要按下面的方法手工启动调试器。&lt;/p&gt;
&lt;p&gt;在&lt;em&gt;Backtrace&lt;/em&gt;中从下向上读；它说明了Emacs是如何出错的。Emacs执行了一个交互式命令C-x C-e(eval-last-sexp)，它执行了triangle-bugged语句。上面的每一行显示了Lisp解释器执行内容。&lt;/p&gt;
&lt;p&gt;缓冲区的顶部是:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Emacs试图执行这个语句；依次来执行，它首先执行内部的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里发生了错误，如错误信息所说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Debugger entered--Lisp error: (void-function 1=)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以修正这个错误，然后重新执行函数定义，再运行测试代码。&lt;/p&gt;
&lt;h2&gt;debug-on-entry&lt;/h2&gt;
&lt;p&gt;GNU Emacs 21在函数出错时自动启动了调试器。GNU Emacs 20不会这样做；它只显示一条出错信息。你需要手工启动调试器。&lt;/p&gt;
&lt;p&gt;手工启动的好处是在程序没有bug的时候也可以调试。&lt;/p&gt;
&lt;p&gt;你可以调用debug-on-entry函数进入调试器。&lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x debug-on-entry RET triangle-bugged RET
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，执行下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-bugged&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有版本的Emacs都将产生一个&lt;em&gt;Backtrace&lt;/em&gt;缓冲区告诉你它将执行triangle-debugged函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;em&gt;Backtrace&lt;/em&gt;缓冲区中输入d。Emacs将执行triangle-bugged的第一行语句；缓冲区看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (let ((total 0)) (while (&amp;gt; number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，再次输入d，连续8次慢慢的输入d，Emacs将执行函数定义的另一个语句。&lt;/p&gt;
&lt;p&gt;最后缓冲区看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (&amp;gt; number 0) (setq total (+ total number))
        (setq number (1= number)))
* (let ((total 0)) (while (&amp;gt; number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后再输入两次d，Emacs将到达错误的位置，&lt;em&gt;Backtrace&lt;/em&gt;缓冲区顶部的两行将显示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
...
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入d可以单步执行函数。&lt;/p&gt;
&lt;p&gt;可以输入q退出&lt;em&gt;Backtrace&lt;/em&gt;缓冲区；这将退出跟踪，但并不会退出debug-on-entry。&lt;/p&gt;
&lt;p&gt;要退出debug-on-entry，需要调用cancel-debug-on-entry并输入函数名称：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x cancel-debug-on-entry RET triangle-bugged RET
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;debug-on-quit和(debug)&lt;/h2&gt;
&lt;p&gt;除了debug-on-error或调用debug-on-entry，还有另外两种方法启动debug。&lt;/p&gt;
&lt;p&gt;可以通过将变量debug-on-quit设置为t，随时输入C-g(keyboard-quit)来启动debug。这在调试无限循环时很用效。&lt;/p&gt;
&lt;p&gt;或者，你可以在代码中插入(debug)以启动调试器，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-bugged&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return sum of numbers 1 through NUMBER inclusive."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                         &lt;span class="c1"&gt;; Start debugger.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;      &lt;span class="c1"&gt;; Error here.&lt;/span&gt;
    &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;edebug源码级的调试器&lt;/h2&gt;
&lt;p&gt;Edebug是一个源码级的调试器。Edebug通常显示你要调试的源码，并在左边用箭头指出当前执行的行。&lt;/p&gt;
&lt;p&gt;你可以单步执行函数，或者快速的执行到断点位置。&lt;/p&gt;
&lt;p&gt;下面是tringle-recursively的调试函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-recursively-bugged&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return sum of numbers 1 through NUMBER inclusive.&lt;/span&gt;
&lt;span class="s"&gt;Uses recursion."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-recursively-bugged&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;               &lt;span class="c1"&gt;; Error here.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，你可以在函数定义后面使用C-x C-e(eval-last-sexp)安装函数，或者将光标放到定义的内部输入C-M-x(eval-defun)。（缺省情况下，eval-defun命令只在Emacs Lisp或Lisp交互模式下才可以工作。）&lt;/p&gt;
&lt;p&gt;但是，为了使用Edebug调试函数，你必须使用另一个命令。可以将停留在函数内部然后输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x edebug-defun RET
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将使Emacs自动加载Edebug。在加载完成后，可以将光标放在下面语句的后面输入C-x C-e(eval-last-sexp):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-recursively-bugged&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将跳到triangle-recursively-bugged的源码，光标被设置在函数if语句所在的开始行。并且，可以在这行的左边看到一个箭头。箭头标明了函数当前执行的位置。（在例子中，我们使用=&amp;gt;代替；在窗口系统中，你可以看到一个实心的三角形）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;=&amp;gt;-!-(if (= number 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，point的位置显示为-!-。&lt;/p&gt;
&lt;p&gt;如果你输入&lt;spc&gt;，point将移到下一个语句；这行将显示如下：&lt;/spc&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;=&amp;gt;(if -!-(= number 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果继续输入&lt;spc&gt;，point将继续从一个语句移到另一个语句。每次只要语句返回了值，它都会显示到回显区。比如，在point移过number时，你将看到：&lt;/spc&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表示number的值为3，它的ASCII值是'control-c'。&lt;/p&gt;
&lt;p&gt;你可以继续执行，直到错误的位置。在执行之前，这行如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;=&amp;gt;        -!-(1= number)))))               ; Error here.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当再次输入&lt;spc&gt;时，将产生错误信息：&lt;/spc&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Symbol's function definition is void: 1=
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入q退出Edebug。&lt;/p&gt;
&lt;p&gt;要从函数上移除调试的机制，可以重新使用C-x C-e执行函数定义。&lt;/p&gt;
&lt;p&gt;Edebug除了跟踪执行外可以做更多的工作。你可以设置它在遇到错误时停止；可以让它显示或修改变量的值；你可以查找出函数被执行了多少次，等等。&lt;/p&gt;
&lt;h1&gt;终结&lt;/h1&gt;</content><category term="emacs"></category></entry><entry><title>Emacs Tips</title><link href="/emacs-tips.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/emacs-tips.html</id><summary type="html">&lt;h1&gt;一 基本概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.常见的按键组合：
    a.最常见的命令都被绑定到了"C-n"(n可以是任意符号)&lt;/p&gt;
&lt;p&gt;b.次常见的命令被绑定到了"ESC n"形式&lt;/p&gt;
&lt;p&gt;c.其它常见的命令被绑定到了"C-x something"&lt;/p&gt;
&lt;p&gt;d.某些特殊命令被绑定到了&amp;ldquo;C-c something"的形式。这些命令通常都与某些特殊的编辑模式有关&lt;/p&gt;
&lt;p&gt;e.有些命令没有被绑定到按钮上。而是通过"ESC x long-command-nam RETURN&amp;rdquo;命令方式执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.如果用F10无法打开菜单,可以用"ESC `"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3."C-x C-v"读错文件时修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4."C-x i"插件文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.使用"C-s"保存时遇到麻烦时,试试使用"C-x C-w …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;一 基本概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.常见的按键组合：
    a.最常见的命令都被绑定到了"C-n"(n可以是任意符号)&lt;/p&gt;
&lt;p&gt;b.次常见的命令被绑定到了"ESC n"形式&lt;/p&gt;
&lt;p&gt;c.其它常见的命令被绑定到了"C-x something"&lt;/p&gt;
&lt;p&gt;d.某些特殊命令被绑定到了&amp;ldquo;C-c something"的形式。这些命令通常都与某些特殊的编辑模式有关&lt;/p&gt;
&lt;p&gt;e.有些命令没有被绑定到按钮上。而是通过"ESC x long-command-nam RETURN&amp;rdquo;命令方式执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.如果用F10无法打开菜单,可以用"ESC `"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3."C-x C-v"读错文件时修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4."C-x i"插件文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.使用"C-s"保存时遇到麻烦时,试试使用"C-x C-w"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6.帮助系统：
    a."C-h t"启动教程&lt;/p&gt;
&lt;p&gt;b."C-h k"获取按键描述&lt;/p&gt;
&lt;p&gt;c."C-h f"获取函数的描述&lt;/p&gt;
&lt;p&gt;d."C=h"进入帮助系统&lt;/p&gt;
&lt;p&gt;e."C-h i"启动Info页阅读器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;7.看不到菜单时可以使用"ESC x menu-bar-mode"&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;二 文件编辑&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1."ESC x auto-fill-mode RETURN"切换自动换行模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2."ESC G g"中转到指定的行号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3."ESC }"前一段,"ESC {"后一段。"ESC ]"前一页,"ESC ["后一页&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4."ESC n"或"C-u n"重复执行命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5."ESC DEL"向后删除一个单词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6."C-x C-x"在选择区首尾切换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;7."ESC h"标记段落,"C-x h"标记整个文件,"C-x C-p"标记整页&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;8."ESC q"段落重排&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;9."C-t"交换两个字符的位置,"ESC t"交换两个单词的位置,"C-x C-t"交换两个文本行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;10."ESC c"把单词的首字母改为大写,"ESC u"将整个单词修改为大写,"ESC l"将整个单词修改为小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;11."C-x u","C-_","C-/"都是撤销命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;12."ESC x recover-file RETURN"从自动保存的文件中恢复文本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;13.Emacs的自动保存文件有一个重要的注意事项:如果在一个文件里进行了一次大规模的删除操作,Emacs将停止自动保存这个文件并显示一条消息通知用户,要想让Emacs再次开始自动保存这个文件,用"C-x C-s"保存一次,或者输入"ESC 1 ESC x auto-save RETURN"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;14."ESC %"查找替换&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="emacs"></category></entry><entry><title>Xah的Emacs Lisp 教程学习笔记</title><link href="/xahde-emacs-lisp-jiao-cheng-xue-xi-bi-ji.html" rel="alternate"></link><published>2008-03-10T00:00:00+08:00</published><updated>2008-03-10T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-03-10:/xahde-emacs-lisp-jiao-cheng-xue-xi-bi-ji.html</id><summary type="html">&lt;h1&gt;例子&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-open-directory-with-explorer&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"在windows中用explorer浏览当前目录"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;shell-command&lt;/span&gt; &lt;span class="s"&gt;"explorer.exe ."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;browse-url&lt;/span&gt; &lt;span class="s"&gt;"www.google.cn"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-display-directory-files&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"执行shell命令并处理它的输出。这里为显示当前目录下的文件"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;shell-command-to-string&lt;/span&gt; &lt;span class="s"&gt;"ls -l"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-display-current-major-mode&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"如果当前为emacs-lisp-mode则显示当前主模式"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="ss"&gt;'emacs-lisp-mode&lt;/span&gt; &lt;span class="nv"&gt;major-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"emacs-lisp-mode"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-regexp-match&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"正则表达式匹配"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;test-string&lt;/span&gt; &lt;span class="s"&gt;"aaaaaaaaaaaa123sfdsfs456"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;regexp-string&lt;/span&gt; &lt;span class="s"&gt;"\\([0-9]+\\)[a-z]+\\([0-9]+\\)"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-match&lt;/span&gt; &lt;span class="nv"&gt;regexp-string&lt;/span&gt; &lt;span class="nv"&gt;test-string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;match-string&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;test-string …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;例子&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-open-directory-with-explorer&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"在windows中用explorer浏览当前目录"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;shell-command&lt;/span&gt; &lt;span class="s"&gt;"explorer.exe ."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;browse-url&lt;/span&gt; &lt;span class="s"&gt;"www.google.cn"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-display-directory-files&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"执行shell命令并处理它的输出。这里为显示当前目录下的文件"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;shell-command-to-string&lt;/span&gt; &lt;span class="s"&gt;"ls -l"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-display-current-major-mode&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"如果当前为emacs-lisp-mode则显示当前主模式"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="ss"&gt;'emacs-lisp-mode&lt;/span&gt; &lt;span class="nv"&gt;major-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"emacs-lisp-mode"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-regexp-match&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"正则表达式匹配"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;test-string&lt;/span&gt; &lt;span class="s"&gt;"aaaaaaaaaaaa123sfdsfs456"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;regexp-string&lt;/span&gt; &lt;span class="s"&gt;"\\([0-9]+\\)[a-z]+\\([0-9]+\\)"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-match&lt;/span&gt; &lt;span class="nv"&gt;regexp-string&lt;/span&gt; &lt;span class="nv"&gt;test-string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;match-string&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;test-string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"--"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;match-string&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;test-string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;dos2unix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;file-path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"dos换行转unix换行"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mybuffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;mybuffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;find-file&lt;/span&gt; &lt;span class="nv"&gt;file-path&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;replace-string&lt;/span&gt; &lt;span class="s"&gt;"\r\n"&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;save-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;kill-buffer&lt;/span&gt; &lt;span class="nv"&gt;mybuffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-insert-p&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"在光标位置插入&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;backward-char&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-wrap-paragraph&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"在区域前后加&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;/p&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;inster&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;p&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-replace-html-chars-in-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"将特殊字符转成html中的符号"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-restriction&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;narrow-to-region&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;replace-match&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;replace-match&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;replace-match&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-hash-test&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"hash table 测试"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;myhash&lt;/span&gt; &lt;span class="nv"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;;; 创建hash table并告诉elips用equal来测试key是否存在&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-hash-table&lt;/span&gt; &lt;span class="nb"&gt;:test&lt;/span&gt; &lt;span class="ss"&gt;'equal&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;;; 添加数据&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;puthash&lt;/span&gt; &lt;span class="s"&gt;"mary"&lt;/span&gt; &lt;span class="s"&gt;"19"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;puthash&lt;/span&gt; &lt;span class="s"&gt;"jane"&lt;/span&gt; &lt;span class="s"&gt;"19"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;puthash&lt;/span&gt; &lt;span class="s"&gt;"liz"&lt;/span&gt; &lt;span class="s"&gt;"19"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;puthash&lt;/span&gt; &lt;span class="s"&gt;"zj"&lt;/span&gt; &lt;span class="s"&gt;"19"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


    &lt;span class="c1"&gt;;; 修改数据&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;puthash&lt;/span&gt; &lt;span class="s"&gt;"zj"&lt;/span&gt; &lt;span class="s"&gt;"27"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;;; 删除数据&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;remhash&lt;/span&gt; &lt;span class="s"&gt;"liz"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;;; 获取数据&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;val&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gethash&lt;/span&gt; &lt;span class="s"&gt;"zj"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="nv"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="emacs"></category></entry><entry><title>Emacs Muse标记规则学习</title><link href="/emacs-musebiao-ji-gui-ze-xue-xi.html" rel="alternate"></link><published>2007-06-19T00:00:00+08:00</published><updated>2007-06-19T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-06-19:/emacs-musebiao-ji-gui-ze-xue-xi.html</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* 段落
在Muse中段落必须通过一个空行来隔开

这是一个新段落

      六个或更多空白字元(tab或空格)开始的一行表示一个居中的段落

* 标题
&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
* First level

** Second level

*** Third level
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;
* 水平线
四个或者更多破折号表示一个水平线，确保其前后都是空行，否则它将被段看作段落的一部分

----


* 强调文本

使用某些特别地认可的字符包围文本以强调文本：

&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
*emphasis*
**strong emphasis**
***very strong emphasis***
_underlined_
=verbatim and monospace=
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;

上面的列表生成：
*emphasis*

**strong emphasis**

***very strong emphasis***

_underlined_

=verbatim and monospace=

* 添加脚注

A footnote reference is simply …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* 段落
在Muse中段落必须通过一个空行来隔开

这是一个新段落

      六个或更多空白字元(tab或空格)开始的一行表示一个居中的段落

* 标题
&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
* First level

** Second level

*** Third level
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;
* 水平线
四个或者更多破折号表示一个水平线，确保其前后都是空行，否则它将被段看作段落的一部分

----


* 强调文本

使用某些特别地认可的字符包围文本以强调文本：

&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
*emphasis*
**strong emphasis**
***very strong emphasis***
_underlined_
=verbatim and monospace=
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;

上面的列表生成：
*emphasis*

**strong emphasis**

***very strong emphasis***

_underlined_

=verbatim and monospace=

* 添加脚注

A footnote reference is simply a number in square
brackets&lt;span class="nt"&gt;&amp;lt;verbatim&amp;gt;&lt;/span&gt;[1]&lt;span class="nt"&gt;&amp;lt;/verbatim&amp;gt;&lt;/span&gt;.[1] To define the footnote, place
this definition at the bottom of your file.  =footnote-mode= can be
used to greatly facilitate the creation of these kinds of footnotes.

&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
 Footnotes:
 [1]  Footnotes are defined by the same number in brackets
      occurring at the beginning of a line.  Use footnote-mode's
      C-c ! a command, to very easily insert footnotes while
      typing.  Use C-x C-x to return to the point of insertion.
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;

* 诗章
诗要求空白字符被保留，使用下面的格式
&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
&amp;gt;A line of Emacs verse;
&amp;gt;   forgive its being so terse.
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;

&amp;gt; A line of Emacs verse;
&amp;gt;   forgive its being so terse.

* 抄录段落

脚注:
[1]这是一条脚注
&lt;/pre&gt;&lt;/div&gt;</content><category term="emacs"></category></entry><entry><title>gawk笔记</title><link href="/gawkbi-ji.html" rel="alternate"></link><published>2007-06-19T00:00:00+08:00</published><updated>2007-06-19T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-06-19:/gawkbi-ji.html</id><summary type="html">&lt;h1&gt;I.简介&lt;/h1&gt;
&lt;p&gt;gawk的主要功能是针对档案的第一行搜寻指令的patterns。当一行里有符合指定的patterns，gawk就会在此行执行指定的actions。gawk依此方式处理输入档案的每一行直到输入档案结束。
gawk程序由很多的pattern与action所组成，action写在大括号{}里面。一个pattern后面就跟着一个action。整个gawk程序像下面的样子：
pattern {action}
pattern {action}
在gawk程序里面，pattern和action都能被省略，但是不能两个同时省略。如果pattern被省略，对于文件中的每一行，action都会被执行。如果action被省略，内定的action则会打印出所有符合pattern的输入行。&lt;/p&gt;
&lt;h2&gt;1.执行gawk程序&lt;/h2&gt;
&lt;p&gt;有两种方式&lt;/p&gt;
&lt;h3 id="axie-zai-ming-ling-xing"&gt;a.写在命令行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'program' input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bxie-zai-dan-du-de-cheng-xu-wen-jian-zhong"&gt;b.写在单独的程序文件中&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk -f program-file input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当程序文件不止一个时，可以写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk -f program-file1 -f program-file2 ... input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.一个简单的例子 …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;I.简介&lt;/h1&gt;
&lt;p&gt;gawk的主要功能是针对档案的第一行搜寻指令的patterns。当一行里有符合指定的patterns，gawk就会在此行执行指定的actions。gawk依此方式处理输入档案的每一行直到输入档案结束。
gawk程序由很多的pattern与action所组成，action写在大括号{}里面。一个pattern后面就跟着一个action。整个gawk程序像下面的样子：
pattern {action}
pattern {action}
在gawk程序里面，pattern和action都能被省略，但是不能两个同时省略。如果pattern被省略，对于文件中的每一行，action都会被执行。如果action被省略，内定的action则会打印出所有符合pattern的输入行。&lt;/p&gt;
&lt;h2&gt;1.执行gawk程序&lt;/h2&gt;
&lt;p&gt;有两种方式&lt;/p&gt;
&lt;h3 id="axie-zai-ming-ling-xing"&gt;a.写在命令行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'program' input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bxie-zai-dan-du-de-cheng-xu-wen-jian-zhong"&gt;b.写在单独的程序文件中&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk -f program-file input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当程序文件不止一个时，可以写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk -f program-file1 -f program-file2 ... input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.一个简单的例子&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '/foo/{print $0}' BBS-list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际的gawk程序为/foo/{print $0}，/foo/为pattern，意为搜索文件里的每一行是否含有子字串'foo'，如果含有'foo'则执行action。action为print $0，表示将现在这一行的内容打印出来。BBS-list是要处理的文件名。&lt;/p&gt;
&lt;h2&gt;3.一个较复杂的例子&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '$1 == "Feb" {sum=$2+$3}END{print sum}' shipped
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子会将输入文件shipped的第一个栏位与"Feb"做比较，如果相等，则其对应的第2栏位与第3栏位的值会被加到变量sum。对于输入文件中的每一行重复上述动作，直到输入文件的每一行都被处理过为止。最后将sum的值打印出来。END{print sum}的意思为在所有的输入读完之后，执行一次print sum的动作，也就是把sum的值打印出来。&lt;/p&gt;
&lt;h1&gt;II.读入输入文件&lt;/h1&gt;
&lt;p&gt;gawk的输入可以从标准输入或指定的文件里读取。输入的读取单位被称为"记录"(records)，gawk在做处理时，是一个记录一个记录地处理。每个记录的内定值是一行(line)，一个记录又被分为多个栏位(fields)。&lt;/p&gt;
&lt;h2&gt;1.如何将输入分解成记录(records)&lt;/h2&gt;
&lt;p&gt;gawk语言会把输入分解成记录(records)。记录与记录之间是以record separator隔开，record separator的内定值是表示新一行的字符(newline character)，因此内定的record separator使得文字的每一行是一个记录。
record separator随着内置的缺省变量RS的改变而改变。RS是一个字符串，它的内定值是"\n"。仅有RS的第一个字符是有效的，它被当作record separator，而RS的其它字符将被忽略。
内置变量FNR会储存当前的输入文件已经被读取的记录数量。内置变量NR会存储
目前为止所有的输入文件
已经被读取的记录个数。&lt;/p&gt;
&lt;h2&gt;2.栏位(field)&lt;/h2&gt;
&lt;p&gt;gawk会自动将每个记录分解成多个栏位(field)。类似于字母在一行里面，gawk的内定动作会认为栏位之间是以whitespace分开。在gawk里，whitespace的意思是一个或多个空白或者tabs。
在gawk程序里面，以'&lt;span class="math"&gt;\(1'表示第一个栏位，'\)&lt;/span&gt;2'表示第二个栏位，依次类推。举例来说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;This seems like a pretty nice example.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个栏位或&lt;span class="math"&gt;\(1是"This"，第二个栏位或\)&lt;/span&gt;2是"seems"，依次类推。特别要注意的是第七个栏位或&lt;span class="math"&gt;\(7是'example.'，而非'example'。
不论有多少个栏位，\)&lt;/span&gt;NF可以用来表示一个记录的最后一个栏位。上面的例子中&lt;span class="math"&gt;\(NF与\)&lt;/span&gt;7相同，也就是'example.'。
NF是一个内置变量，它的值表示目前这个记录的栏位个数。
$0，是一个特例，它表示整个记录不。
一个比较复杂的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '$1~/foo/{print $0}' BBS-list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子是把输入文件BBS-list的每个记录的第一个栏位检查，如果它含有字符串'foo'，则这一个记录会被打印出来。&lt;/p&gt;
&lt;h2&gt;3.如何将记录分解成栏位&lt;/h2&gt;
&lt;p&gt;gawk根据field separator将一个记录分解成栏位。field separator以内置变量FS表示。
举例来说，假如field separator是'foo'，则下面的行:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;moo goo gai pan
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会被分成三个栏位：'m'、'g'、'gai pan'。
在gawk程序里，可以使用&lt;code&gt;'='&lt;/code&gt;来改变FS的值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'BEGIN{FS=","};{print $2}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入行如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;John Q.Smith,29 Oak St.,Walamazoo,MI 42139
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行gawk的结果将打印出子串'29 Oak st.'。BEGIN后面的action会在第一个记录被读取之前执行一次。&lt;/p&gt;
&lt;h1&gt;III.打印&lt;/h1&gt;
&lt;p&gt;在gawk程序里，actions最常做的事情就是打印(printing)。简单的打印，使用print。复杂格式的打印，使用printf。
a.print用在简单、标准的输出格式。格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print item1,item2,...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出时，各个item之间会以一个空白分开，最后会换行(newline)。
如果'print'之后没有跟任务参数，它与'print $0'的效果一样，它会打印出现在的记录(record)。要打印出空白行可以使用'print ""'。打印出一段固定的文字，可以用双引号将文字的两边括起来，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;'print "Hello there"'。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下例，会把每个输入记录的前两个栏位打印出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{print $1,$2}' shipped
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.输出分隔符&lt;/h2&gt;
&lt;p&gt;前面说过如果print时包含有多个item，item之间用逗号分开，则打印出时各个item会被一个空白隔开。你可以使用任务字符串作为output field separator，可以经由内置参数OFS的设定值来更改output field separator。OFS的初始值为" "，即一个空格。
整个print的输出被称为output record。print输出output record之后，会接着输出一个之串，此字符串称为output record separator。内置参数ORS来指定此字符串。ORS的初始值为"\n"，也就是换行。
下面这个例子会打印出每个记录的第一个栏位和第二个栏位，此二个栏位之间以分号';'分开，每行输出之后会加入一个空白行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'BEGIN {OFS=";"; ORS="\n\n"}{print $1,$2}' BBS-list
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.printf&lt;/h2&gt;
&lt;p&gt;printf会使得输出格式容易精确地控制。printf可以指定每个item打印出的宽度，也可以指定数字的各种型式。
printf的格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;printf format,item1,item2,...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;print与printf的差别是在于format，printf的参数比print多了字符串format。format的型式与ANSI C的printf的格式相同。
printf并不会做自动换行动作。内置变量OFS与ORS对printf无效。&lt;/p&gt;
&lt;h1&gt;IV.pattern的种类&lt;/h1&gt;
&lt;p&gt;这里对gawk的各种pattern形式作一次整理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/regular expression/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个正则表达式当作一个pattern。每当输入记录(record)含有regulare expression就视为符合。&lt;/p&gt;
&lt;p&gt;expression
一个单一的expression。当一个值不为0或者一个字符串不是空的则可视为符合。&lt;/p&gt;
&lt;p&gt;pat1,pat2
一对patterns以逗号分开，指定记录的范围。&lt;/p&gt;
&lt;p&gt;BEGIN
END
这是特别的pattern，gawk在开始执行或要结束时会分别执行相对就于BEGIN或END的action。&lt;/p&gt;
&lt;p&gt;null
这是一个空的pattern，对于每个输入记录都视为符合pattern。&lt;/p&gt;
&lt;h2&gt;1.Regular Expression当作Patterns&lt;/h2&gt;
&lt;p&gt;一个regular expression可简写为regexp，是一种描述字串的方法。一个regular expression以斜线('/')包围当作gawk的pattern。
如果输入记录含有regexp就视为符合。例如：pattern为/foo/，对于任何输入记录含有'foo'则视为符合。
下例会将含有'foo'的输入记录的第2上栏位打印出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '/foo/{print $2}' BBS-list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;regexp也能使用在比较运算中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;exp ~ /regexp/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果exp符合regexp，则结果为真(true)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;exp !~ /regexp/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果exp不符合regexp，则结果为真。&lt;/p&gt;
&lt;h2&gt;2.比较运算当作Patterns&lt;/h2&gt;
&lt;p&gt;比较的pattern用来测试两个数字或字符串的关系诸如大于、等于、小于。下面列出一些比较的pattern：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x&amp;lt;y
x&amp;lt;=y
x&amp;gt;y
x&amp;gt;=y
x==y
x!=y
x~y
x!~y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面提到的x与y，如果二者皆是数字则视为数字之间的比较，否则它们会被转换成字符串且以字符串的形式做比较。两个字符串比较，会先比较第一个字符，然后比较第二个字符，依此类推，直到有不同的地方出现为止。如果两个字符串在较短的一个结束之前是相等，则视为长的字符串比短的字符串大。例如"10"比"9"小，"abc"比"abcd"小。&lt;/p&gt;
&lt;h2&gt;3.使用布尔运算的Patterns&lt;/h2&gt;
&lt;p&gt;一个布尔pattern是使用布尔运算"||"、"&amp;amp;&amp;amp;"、"!"来组合其它的pattern。
例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '/2400/&amp;amp;&amp;amp;/foo/' BBS-list
gawk '/2400/||/foo/' BBS-list
gawk '! /foo/' BBS-list
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;V.表达式(Expression)作为Action&lt;/h1&gt;
&lt;p&gt;表达式(Expression)是gawk程序里action的基本构成者。&lt;/p&gt;
&lt;h2&gt;1.算术运算&lt;/h2&gt;
&lt;p&gt;gawk里的算术运算如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x+y
x-y
-x
+x
x*y
x/y
x%y
x^y
x**y
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.比较表达式与布尔运算&lt;/h2&gt;
&lt;p&gt;比较运算(Comparison expression)用来比较字符串或数字的关系，运算符号与C语言相同。列表如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x&amp;lt;y
x&amp;lt;=y
x&amp;gt;=y
x==y
x!=y
x~y
x!~y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较结果为真(true)则其值是1，否则为0。
布尔运算(boolean expression)有下面三种：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;boolean1 &amp;amp;&amp;amp; boolean2
boolean1 || boolean2
! boolean
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.条件表达式(Conditional Expressions)&lt;/h2&gt;
&lt;p&gt;一个条件运算式是一种特别的算式，它含有3个运算符，条件式运算与C语言的三目运算相同：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;selector ? if-true-exp : if-flase-exp
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;VI.Actions里面的流程控制&lt;/h1&gt;
&lt;p&gt;在gawk程序里，流程控制如：if、while等与C语言类似。
很多的控制语句会包括其它的语句，被包括的语句被称为body。假如body里包括一个以上的语句，必须以大括号{}将这些语句括冬候鸟来，而各个语句之间需要以换行(newline)或分号隔开。&lt;/p&gt;
&lt;h2&gt;1.if语句&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (condition) then-body [else else-body]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果condition为真，则执行then-body，否则执行else-body
例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if(x % 2 == 0)
print "x is even"
else
print "x is odd"
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.while语句&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;while(condition)
body
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;while语句做的第一件事就是测试condition，假如condition为真则执行body中的语句，执行完后再测试condition，直到为false。如果第一次测试时condition就为false，则body中的语句从不会被执行。
下面的例子打印出每个输入记录(record)的前三个栏位。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{i=1
while(i&amp;lt;=3){
print $i
i++
}
}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.do-while语句&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;do
body
while(condition)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个do loop执行body一次，然后只要condition是true则会重复执行body。即使开始时conditon为false，body也会执行一次。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{i=1
do{
print $0
i++
}while(i&amp;lt;=10)
}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.for语句&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for(initialization;condition;increment)
body
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此语句开始时会执行initialization，然后只要condition是true，它会重复执行body与做increment。
下面的例子会打印出每个输入记录的前三个栏位：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{for(i=1;i&amp;lt;=3;i++)
print $i
}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.break语句&lt;/h2&gt;
&lt;p&gt;break语句会跳出包含它的for,while,do-while循环的最内层。
下面的例子会找出任何整数的最小除数，它也会判断是否为质数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '# find smallest divisor of num
{ num=$1
for(div=2;div*div&amp;lt;num;div++)
if(num % div == 0)
break
if(num % div == 0)
printf "Smallest divisor of %d is %d\n",num,div
else
printf "%d is prime\n",num}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.continue语句&lt;/h2&gt;
&lt;p&gt;continue语句用于for,while,do-while循环内部，它会跳过循环body中其余的部分，使得它立即进入下一次循环。
下面的例子会打印出0至20的全部数字，但是5并不会被打印出来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'BEGIN{
for(x=0;x&amp;lt;=20;x++){
if(x==5)
continue
printf ("%d",x)
}
print ""
}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7.next，next file，exit语句&lt;/h2&gt;
&lt;p&gt;next语句强迫gawk立即停止处理目前的记录(record)而继续下一个记录。
next file语句类似next。然而，它强迫gawk立即停止处理当前的文件。
exit语句会使得gawk程序立即停止执行而跳出。而且如果END出现，它会去执行END的actions。&lt;/p&gt;
&lt;h1&gt;VII.内置函数&lt;/h1&gt;
&lt;p&gt;内置函数是gawk内置的函数，可以在gawk程序的任何地方调用内置函数。&lt;/p&gt;
&lt;h2&gt;1.数值方面的内置函数&lt;/h2&gt;
&lt;p&gt;int(x)求x的整数部分，朝向0的方向做舍去。例如:int(3.9)是3，int(-3.9)是-3。&lt;/p&gt;
&lt;p&gt;sqrt(x)求x的平方根值。&lt;/p&gt;
&lt;p&gt;exp(x)求x的次方。&lt;/p&gt;
&lt;p&gt;log(x)求x的自然对数。&lt;/p&gt;
&lt;p&gt;sin(x)求x的sine值，x是经度量。&lt;/p&gt;
&lt;p&gt;cos(x)求x的cosine值，x是经度量。&lt;/p&gt;
&lt;p&gt;atan2(y,x)求y/x的arctangent值，所求出的值其单位是经度量。&lt;/p&gt;
&lt;p&gt;rand()得出一个伪随机数。此数值在0和1之间，但不等于0或1。
每次执行gawk，rand开始产生数字从相同点或seed。&lt;/p&gt;
&lt;p&gt;srand(x)设定产生随机数的开始点或者seed为x。如果在第二次你设定相同的seed值，你将再度得到相同序列的随机数。如果参数x被省略，则现在日期、时间会被当成seed。这个方法可以使得产生的随机数是真正不可预测的。srand的返回值是前次所设定的seed值。&lt;/p&gt;
&lt;h2&gt;2.字符串方面的内置函数&lt;/h2&gt;
&lt;p&gt;index(in,find)
它会在字符串in里面，寻找字符串find第一次出现的地方，返回值是字符串find出现在字符串in里面的位置。如果在in里找不到find，则返回0。
例如：
print index("prenut","an")
将打印出3。&lt;/p&gt;
&lt;p&gt;length(string)
求出string有几个字符。&lt;/p&gt;
&lt;p&gt;match(string,regexp)
在字符串string里找到符合regexp的最长的最靠左边的子字符串。返回值是regexp在string的开始位置，即index值。match函数会设置内置变量RSTART等于index，它也会设置内置变量RLENGTH等于符合的字符个数。如果不符合，则会设定RSTART为0、RLENGTH为-1。&lt;/p&gt;
&lt;p&gt;sprintf(fomat,expression,...)
举printf类似，但是sprintf并不打印出来，而是返回字符串。
例如：
sprintf("pi = %.2f(approx.)',22/7)
返回的字符串为"pi = 3.14(approx.)"&lt;/p&gt;
&lt;p&gt;sub(regexp,replacement,target)
在字符串target里面，寻找符合regexp的最长、最靠左边的地方，以字符串replacement代替最左边的regexp。
例如：
str = "water,water,everywhere"
sub(/at/,"ith",str)
结果字符串str会变成
"wither,water,everywhere"&lt;/p&gt;
&lt;p&gt;gsub(regexp,replacement,target)
gsub与前面的sub类似。在字符串target里面，寻找符合regexp的所有地方，以字符串replacement代替所有的regexp。
例如：
str="water,water,everywhere"
gsub(/at/,"ith",str)
结果字串str变成
"wither,wither,everywhere"&lt;/p&gt;
&lt;p&gt;substr(string,start,length)
传回字符串string的子串，这个字串的长度为length个字符。
从第start个位置开始。
例如：
substr("washington",5,3)
返回值为"ing"
如果length没有出现，则返回的字符串是从第start个位置开始至结束。
substr("washington",5)
返回值为"ington"&lt;/p&gt;
&lt;p&gt;tolower(string)
将字符串string的大写字母改为小写字母。&lt;/p&gt;
&lt;p&gt;toupper(string)
将字符串string的小写字母改为大写字母。&lt;/p&gt;
&lt;h2&gt;3.输入输出的内置函数&lt;/h2&gt;
&lt;p&gt;close(filename)
将输入或输出的文件关闭&lt;/p&gt;
&lt;p&gt;system(command)
执行操作系统命令，执行完毕后返回gawk&lt;/p&gt;
&lt;h1&gt;VIII.用户定义的函数&lt;/h1&gt;
&lt;p&gt;复杂的gawk程序常常可以使用自己定义的函数来简化。调用自定义的函数与调用内置函数的方法一样。&lt;/p&gt;
&lt;h2&gt;1.函数定义的格式&lt;/h2&gt;
&lt;p&gt;函数的定义可以放在gawk程序的任何地方。
一个自定义函数的格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;parameter&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;list&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="nx"&gt;body&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;of&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;name是所定义的函数名称，名称可以是字母、数字、下划线，但不能以数字开头。
parameter-list是函数参数，以逗号分开。
body-of-function包含gawk的语句。&lt;/p&gt;
&lt;h2&gt;2.函数定义的例子&lt;/h2&gt;
&lt;p&gt;下面这个例子，将每个记录的第一个栏位之值的平方与第二个栏位之值的平方加起来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"sum ="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;SquareSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;$2&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;SquareSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="nx"&gt;sum&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;sum&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;IX.范例&lt;/h1&gt;
&lt;p&gt;一些gawk程序的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{if(NF&amp;gt;max)max=NF}
END {print max}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印出所有输入行中，栏位的最大个数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'length($0)&amp;gt;80'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印出超过80个字符的一行。此处只有pattern被列出，action是采用内置的print。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'NF &amp;gt; 0'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印至少有一个栏位的所有行。这是一个简单的方法，将一个文件中的空白行删除。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{if(NF &amp;gt;0)print}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与上例相同&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'BEGIN {for (i=0;i&amp;lt;7;i++)
print int(101 * rand())}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此程序会打印出范围在0-100之间的7个随机数值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ls -l files | gawk '{x+=$4};END{print "total bytes:" x}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印出所有指定文件之bytes数目的总和。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;expand file | gawk '{if(x&amp;lt;length()) x = length()}}
END{print "maxinum line length is " x}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将指定文件里最长一行的长度打印出来。expand会将tab改成space，所以是用实际的右边界来做长度的比较。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'BEGIN {FS=":"}
{print $1 | "sort"} /etc/password
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此程序会将所有用户的登录名称，按字母顺序打印出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{nlines++}
END {print nlines}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将文件的总行数打印出来&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'END {print NR}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同上例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{print NR,$0}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印文件的内容时，会在每行的最前面打印出行号，它的功能与'cat -n'类似&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="awk"></category><category term="linux"></category></entry><entry><title>Sed Tips</title><link href="/sed-tips.html" rel="alternate"></link><published>2007-06-19T00:00:00+08:00</published><updated>2007-06-19T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-06-19:/sed-tips.html</id><summary type="html">&lt;h1&gt;I介绍&lt;/h1&gt;
&lt;h2&gt;1. sed可以完成的工作&lt;/h2&gt;
&lt;p&gt;sed最常用在编辑那些需要不断重复某些编辑动作的文件上。&lt;/p&gt;
&lt;p&gt;可以用sed完成一些重复性的工作。&lt;/p&gt;
&lt;p&gt;sed可以一次执行多个不同的编辑动作。&lt;/p&gt;
&lt;h2&gt;2. sed能做哪些编辑动作&lt;/h2&gt;
&lt;p&gt;删除、修改、添加、插入、合并文件中的资料行，或读入其它文件的资料到文件中，也可以替换其中的字符串、转换其中的字母等。&lt;/p&gt;
&lt;h2&gt;3. sed工作流程&lt;/h2&gt;
&lt;p&gt;从输入中读入内容，操作完毕后发送到标准输出。&lt;/p&gt;
&lt;h1&gt;II使用sed&lt;/h1&gt;
&lt;p&gt;sed命令可以分成编辑指令与文件指令两部分。编辑指令负责控制所有编辑工作，文件指令处理文件。编辑指令由位址与函数两部分组件，位址指令用于定位对象，而编辑指令用于编辑对象。&lt;/p&gt;
&lt;h2&gt;1. 命令行上的编辑指令&lt;/h2&gt;
&lt;p&gt;在命令行上执行sed指令时用-e参数，如果sed指令在文件中用-f参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -e '编辑指令1' -e '编辑指令2' ...文件一 ...文件二
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -e '1,10d' -e 's/yellow/black/g' yel.dat …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;I介绍&lt;/h1&gt;
&lt;h2&gt;1. sed可以完成的工作&lt;/h2&gt;
&lt;p&gt;sed最常用在编辑那些需要不断重复某些编辑动作的文件上。&lt;/p&gt;
&lt;p&gt;可以用sed完成一些重复性的工作。&lt;/p&gt;
&lt;p&gt;sed可以一次执行多个不同的编辑动作。&lt;/p&gt;
&lt;h2&gt;2. sed能做哪些编辑动作&lt;/h2&gt;
&lt;p&gt;删除、修改、添加、插入、合并文件中的资料行，或读入其它文件的资料到文件中，也可以替换其中的字符串、转换其中的字母等。&lt;/p&gt;
&lt;h2&gt;3. sed工作流程&lt;/h2&gt;
&lt;p&gt;从输入中读入内容，操作完毕后发送到标准输出。&lt;/p&gt;
&lt;h1&gt;II使用sed&lt;/h1&gt;
&lt;p&gt;sed命令可以分成编辑指令与文件指令两部分。编辑指令负责控制所有编辑工作，文件指令处理文件。编辑指令由位址与函数两部分组件，位址指令用于定位对象，而编辑指令用于编辑对象。&lt;/p&gt;
&lt;h2&gt;1. 命令行上的编辑指令&lt;/h2&gt;
&lt;p&gt;在命令行上执行sed指令时用-e参数，如果sed指令在文件中用-f参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -e '编辑指令1' -e '编辑指令2' ...文件一 ...文件二
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -e '1,10d' -e 's/yellow/black/g' yel.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在面的命令中'1,10d'执行删除1到10行，s/yellow/black/g'将yellow字符串替换成black字符串。&lt;/p&gt;
&lt;h2&gt;2. 编辑指令的格式如下：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[address1[,address2]]function[argument]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;address1,address2为行数或者正则表达式，用于定位所编辑的对象。function[argument]为sed的内置函数，表示在对象上执行的动作。&lt;/p&gt;
&lt;h2&gt;3. 定位(address)参数的表示方法：&lt;/h2&gt;
&lt;p&gt;下面举例以使用函数参数d为例：&lt;/p&gt;
&lt;p&gt;a. 删除文件内第10行的内容，则指令为10d&lt;/p&gt;
&lt;p&gt;b. 删除含有'man'字符串的行，指令为/man/d&lt;/p&gt;
&lt;p&gt;c. 删除文件内第10行到第20行，为10,20d&lt;/p&gt;
&lt;p&gt;d. 删除第10行到含有'man'字符串的行，则指令为10,/man/d&lt;/p&gt;
&lt;p&gt;定位参数的说明：&lt;/p&gt;
&lt;p&gt;a. 定位参数为十进制数字：此数字表示行数。&lt;/p&gt;
&lt;p&gt;b. 定位参数为正则表达式，当输入中有符合该表达式时，执行编辑动作。&lt;/p&gt;
&lt;h2&gt;4. 函数参数&lt;/h2&gt;
&lt;p&gt;函數參數    功能&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;: label     建立 script file 內指令互相參考的位置。 
#   建立註解 
{ }     集合有相同位址參數的指令。 
!   不執行函數參數。 
=   印出資料行數( line number )。 
a\  添加使用者輸入的資料。 
b label     將執行的指令跳至由 : 建立的參考位置。 
c\  以使用者輸入的資料取代資料。
d   刪除資料。 
D   刪除 pattern space 內第一個 newline 字母 \ 前的資料。 
g   拷貝資料從 hold space。 
G   添加資料從 hold space 至 pattern space 。 
h   拷貝資料從 pattern space 至 hold space 。 
H   添加資料從 pattern space 至 hold space 。 
l   印出 l 資料中的 nonprinting character 用 ASCII 碼。 
i\  插入添加使用者輸入的資料行。 
n   讀入下一筆資料。 
N   添加下一筆資料到 pattern space。 
p   印出資料。 
P   印出 pattern space 內第一個 newline 字母 \ 前的資料。 
q   跳出 sed 編輯。 
r   讀入它檔內容。 
s   替換字串。 
t label     先執行一替換的編輯指令 , 如果替換成牛p&amp;gt;則將編輯指令跳至 : label 處執行。 
w   寫資料到它檔內。 
x   交換 hold space 與 pattern space 內容。 
y   轉換(transform)字元。
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5. 执行文件中的编辑指令&lt;/h2&gt;
&lt;p&gt;当执行的指令过多时，可以将指令放到文件中。用sed -f script_file执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -f script_file ...文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -f ysb.scr yel.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，ysb.scr的内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1,10d
s/yellow/black/g
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6. 执行多个文件的编辑&lt;/h2&gt;
&lt;p&gt;在sed命令行上，一次可以执行编辑多个文件，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e 's/yellow/blue/g' white.dat red.dat black.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sed将从左至右依次处理各个文件。&lt;/p&gt;
&lt;h2&gt;7. 执行输出控制&lt;/h2&gt;
&lt;p&gt;默认情况下处理后的结果输出到标准输出。但通过-n，可以将输出的控制权交给sed，由编辑指令来决定结果是否输出。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -n -e '/white/p' white.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例中-n与编辑指令/white/p一起配合控制输出。-n将输出控制权交给编辑指令，/white/p将含有'white'的字符串打印出来。&lt;/p&gt;
&lt;h1&gt;III范例&lt;/h1&gt;
&lt;p&gt;操作需求描述：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    将文件中...资料，执行...(动作)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当需要执行多个动作时，指令形式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    位置参数{
        函数参数1
        函数参数2
        函数参数3
         .
         .
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1. 替换文件中的资料&lt;/h2&gt;
&lt;p&gt;a. 将文件中含'machine'字符串的资料选中的'phi'字符串替换成'beta'字符串&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '/machine/s/phi/beta/g' input.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b. 将文件中第5行资料，替换成'This is a test.'&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '5c\
    This is a test.
    ' input.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c. 将文件中1至100行的资料替换成如下两行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    How are you?
    data be deleted!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '1,100c\
    How are you?\
    data be deleted!
    ' input.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. 移动文件中的资料&lt;/h2&gt;
&lt;p&gt;可以使用sed中的hold space暂存编辑中的资料，用函数w将文件资料搬到它档内存储，或者用函数r半它档内容搬到文件内。当执行函数参数h,H时会将pattern space资料暂存到hold space,当执行x,g,G时，会将暂存的资料取到pattern space&lt;/p&gt;
&lt;p&gt;a. 将文件中前100行，搬到文件第300行后。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -f mov.src 文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mov.src 内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1,100{
H
d
}
300G
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1,100{
H
d
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示将文件前100行，先储存在hold space之后删除。指令300G表示将hold space内的资料，添加在第300行后输出。&lt;/p&gt;
&lt;p&gt;b. 将文件中含'phi'字符串的行，搬至mach.inf中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '/phi/w mach.inf' 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c. 将mach.inf中的内容，移到文件中含'beta'字符串的行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '/beta/r march.inf' 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外由于sed是一个流编辑器，理论上输出后的文件资料不可能再搬回来编辑。&lt;/p&gt;
&lt;h2&gt;3. 删除文件中的资料&lt;/h2&gt;
&lt;p&gt;因为sed是行编辑器，所以sed很容易删除行，或者整个资料。一般用d或D来删除。&lt;/p&gt;
&lt;p&gt;a. 将文件内的所有空白行全部删除：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '/^$/d' 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正则表达式中'^&lt;span class="math"&gt;\('表示空白，'^'表示行开头，'\)&lt;/span&gt;'表示行结尾。&lt;/p&gt;
&lt;p&gt;b. 将文件内连续的空白行，删除成一行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '/^$/{
    N
    /^$/D
    }' 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中N表示将空白的下一行资料加至pattern space内。函数参数/^$/D表示，当添加的是空白行时，删除第一行空白行，而且剩下的空白行则再重新执行一次指令。如此反复，最后只留下一行空白行了。&lt;/p&gt;
&lt;h2&gt;4. 搜索文件中的资料&lt;/h2&gt;
&lt;p&gt;sed可以执行类似UNIX命令grep的功能。理论上可以用正则表达式将文件中匹配的内容输出。&lt;/p&gt;
&lt;p&gt;例如将文件中包含'gamma'的内容输出&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -n -e '/gamma/p' 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但sed是行编辑器，它搜寻基本上是以行为单位。因此，当一些字符串因换行被拆分成两部分时，一般的方法即不可行。此时，就必须以合并行的方式来搜寻这些资料。例：&lt;/p&gt;
&lt;p&gt;将文件中仿'omega'字符串的资料输出。其命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -f gp.scr 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gp.scr内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/omega/b
N
h
s/.*\n//
/omega/b
g
D
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上述sed script中，因函数参数b形成类似C语言中的case结构，使得sed可以分别处理当资料内含'omega'字串，当'omega'字符串被拆成两行，以及资料内没有'omega'字串的情况。下面分三种情况讨论：&lt;/p&gt;
&lt;p&gt;a. 当资料内仿'omega'，则执行编辑指令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/omega/b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它表示当资料内含有'omega'字符串时，sed不再执行它后面的指令，而直接将它输出。&lt;/p&gt;
&lt;p&gt;b. 当资料内没有'omega'，则执行编辑指令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;N
h
s/.*\n//
/omega/b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，函数参数N，表示将下一行资料读入使得pattern space内含前后两行资料。函数参数h表示将pattern space内的前后两行资料存入hold space。函数参数s/.*\n//，它表示将pattern space内的前后两行资料进行合并成一行。/omega/b，它表示如果合并后的资料内含'omega'字符串，则不再执行后面的指令，而将此资料自动输出。&lt;/p&gt;
&lt;p&gt;c. 当合并后的资料依旧不含'omega'，则执行编辑指令如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;g
D
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，函数参数g，它表示将hold space内合并前的两行资料放回pattern space。函数参数D，它表示删除两行资料中的第一行资料，并让剩下的那行资料，重新执行sed script。如此，无论是资料行内或行间的字符串都可以搜索到。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="linux"></category><category term="sed"></category></entry></feed>