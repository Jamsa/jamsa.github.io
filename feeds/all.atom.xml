<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jamsa的笔记</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2015-06-29T00:00:00+08:00</updated><entry><title>Begin Mac Programming 笔记</title><link href="/begin-mac-programming-bi-ji.html" rel="alternate"></link><published>2015-06-29T00:00:00+08:00</published><updated>2015-06-29T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-06-29:/begin-mac-programming-bi-ji.html</id><summary type="html">&lt;h1&gt;关于对象&lt;/h1&gt;
&lt;h2&gt;Objective-C 中的对象类型&lt;/h2&gt;
&lt;p&gt;Mac中使用苹果公司的的Cocoa框架。在Xcode中创建类都继承于NSObject这个基类。&lt;/p&gt;
&lt;p&gt;当我们在Objective-c中实例化一个对象后，它立即会发送一个消息来初始化自己。这个消息被称为&lt;code&gt;init&lt;/code&gt;，它通设置初始值。&lt;/p&gt;
&lt;p&gt;类定义包括&lt;code&gt;.h&lt;/code&gt;和&lt;code&gt;.m&lt;/code&gt;两个文件。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.h&lt;/code&gt;文件结构：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//  NotifyingClass.h&lt;/span&gt;
&lt;span class="c1"&gt;//  TextApp&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//  Created by Tim Isted on 08/09/2009.&lt;/span&gt;
&lt;span class="c1"&gt;//  Copyright 2009 __MyCompanyName__. All rights reserved.&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="cp"&gt;#import &amp;lt;Cocoa/Cocoa.h&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="nc"&gt;NotifyingClass&lt;/span&gt; : &lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Objective-c中，使用某个类具有某个&lt;code&gt;public interface&lt;/code&gt;来描述哪些消息能发送给这个类。&lt;code&gt;@interface&lt;/code&gt;这一行的冒号后面指定这个类的父类，这里指向的是NSObject …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;关于对象&lt;/h1&gt;
&lt;h2&gt;Objective-C 中的对象类型&lt;/h2&gt;
&lt;p&gt;Mac中使用苹果公司的的Cocoa框架。在Xcode中创建类都继承于NSObject这个基类。&lt;/p&gt;
&lt;p&gt;当我们在Objective-c中实例化一个对象后，它立即会发送一个消息来初始化自己。这个消息被称为&lt;code&gt;init&lt;/code&gt;，它通设置初始值。&lt;/p&gt;
&lt;p&gt;类定义包括&lt;code&gt;.h&lt;/code&gt;和&lt;code&gt;.m&lt;/code&gt;两个文件。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;.h&lt;/code&gt;文件结构：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//  NotifyingClass.h&lt;/span&gt;
&lt;span class="c1"&gt;//  TextApp&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;//  Created by Tim Isted on 08/09/2009.&lt;/span&gt;
&lt;span class="c1"&gt;//  Copyright 2009 __MyCompanyName__. All rights reserved.&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="cp"&gt;#import &amp;lt;Cocoa/Cocoa.h&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="nc"&gt;NotifyingClass&lt;/span&gt; : &lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Objective-c中，使用某个类具有某个&lt;code&gt;public interface&lt;/code&gt;来描述哪些消息能发送给这个类。&lt;code&gt;@interface&lt;/code&gt;这一行的冒号后面指定这个类的父类，这里指向的是NSObject，它是Cocoa框架的基类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@interface&lt;/code&gt;段中的大括号用于指定类的属性。&lt;/p&gt;
&lt;p&gt;右大括号和&lt;code&gt;@end&lt;/code&gt;间的内容用于指定类可以接收的消息。&lt;/p&gt;
&lt;p&gt;定义Interface的语法结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="nc"&gt;nameOfClass&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;nameOfClassToInheritFrom&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;messages&lt;/span&gt; &lt;span class="n"&gt;responded&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;

&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;code&gt;.m&lt;/code&gt;文件结构：&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.m&lt;/code&gt;文件包含对象的实现。编写的方法放在&lt;code&gt;@implementation&lt;/code&gt;和&lt;code&gt;@end&lt;/code&gt;之间。&lt;/p&gt;
&lt;p&gt;用于响应&lt;code&gt;init&lt;/code&gt;消息的初始化方法默认会调用NSObject基类中的实现。通过查看&lt;code&gt;NSObject.h&lt;/code&gt;可以找到它定义的初始化消息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;NSLog日志类&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@implementation&lt;/span&gt; &lt;span class="nc"&gt;NotifyingClass&lt;/span&gt;

&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Hello World! I'm a new NotifyingClass instance!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;消息机制&lt;/h1&gt;
&lt;h2&gt;消息的定义：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;allocWithZone:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSZone&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;zone&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;messageName&lt;/span&gt; &lt;span class="err"&gt;&amp;raquo;&lt;/span&gt; &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt;或&lt;code&gt;-&lt;/code&gt;用于标明它是一个类方法或是实例方法。&lt;code&gt;&amp;laquo;word&amp;raquo;&lt;/code&gt;指定方法的返回类型。在&lt;code&gt;.h&lt;/code&gt;中的方法签名列表中，可以看到使用&lt;code&gt;void&lt;/code&gt;或&lt;code&gt;id&lt;/code&gt;作为返回类型。&lt;/p&gt;
&lt;h2&gt;Target-Action机制&lt;/h2&gt;
&lt;p&gt;某些由Cocoa框架提供的对象允许你为他们提供&lt;code&gt;target&lt;/code&gt;对象和指定&lt;code&gt;action&lt;/code&gt;&amp;mdash;&amp;mdash;发送给这个对象的消息。比如，在Xcode的界面设计器中创建NSButton实例后，我们可以指定这个按钮被点击时调用NotifyingClass实例（&lt;code&gt;target&lt;/code&gt;）的displaySomeText方法（&lt;code&gt;action&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;如果消息名称的右边有冒号，表明它接收一个或多个参数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;buildHouse:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;House&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;houseToBeBuilt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;括号中内容（House*）用于指定参数类型，括号后面是参数名称。&lt;/p&gt;
&lt;h2&gt;发送消息&lt;/h2&gt;
&lt;p&gt;方法调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;displaySomeText:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;sender&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"displaySomeText just got called!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;变量与内存&lt;/h1&gt;
&lt;p&gt;类似C的变量指针。&lt;/p&gt;
&lt;h1&gt;对象和内存管理&lt;/h1&gt;
&lt;h2&gt;对象内存分配&lt;/h2&gt;
&lt;p&gt;NSObject提供了类方法&lt;code&gt;alloc&lt;/code&gt;用于分配内存。永远不需要重载这个方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;someNewObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将分配一块足够容纳NSObject实例的内存并将这块内存的地址返回给someNewObject指针。&lt;code&gt;alloc&lt;/code&gt;方法将所有实例变量设置为零或nil（指针类型），但它不会进行更进一步的『设置』。在使用对象前应该先初始化它的属性。&lt;/p&gt;
&lt;h3 id="dui-xiang-chu-shi-hua"&gt;对象初始化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Hello world~"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应该在使用对象前对它的属性进行初始化，因此应该在分配内存后立即调用&lt;code&gt;init&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;我们应该合并内存分配和初始化代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;NotifyingClass&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myFavoriteNotifier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;NotifyingClass&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我们嵌套的调用了&lt;code&gt;alloc&lt;/code&gt;和&lt;code&gt;init&lt;/code&gt;方法，因此需要让&lt;code&gt;init&lt;/code&gt;方法返回初始化后的对象地址，并传递给指针。&lt;/p&gt;
&lt;p&gt;继承时的初始化：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当从NSObject继承时，不需要调用父类的&lt;code&gt;init&lt;/code&gt;方法，因为NSObject不做任何的初始化，&lt;code&gt;isa&lt;/code&gt;实例变量是在&lt;code&gt;alloc&lt;/code&gt;中设置的。考虑到后期有可能修改父类型，比较好的实践方法是始终调用&lt;code&gt;[super init]&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;在代码中创建对象&lt;/h2&gt;
&lt;h3 id="fen-pei-nei-cun"&gt;分配内存&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;displaySomeText:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;sender&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;wonderfulValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;storedNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;
        &lt;span class="nl"&gt;stringWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"My Wonderful Value = %f&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wonderfulValue&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码中存在问题，通过查看NSObject文档中关于『Creating, Copying, and Deallocating Objects.』相关的内容，能找到NSObject有&lt;code&gt;``dealloc&lt;/code&gt;方法。文档中指出，『永远不要直接发送&lt;code&gt;dealloc&lt;/code&gt;消息』。应该使用"release" NSObject protocol方法。&lt;/p&gt;
&lt;p&gt;当对象从内存中删除时它会接收到&lt;code&gt;dealloc&lt;/code&gt;消息。&lt;/p&gt;
&lt;p&gt;可以在类的&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;dealloc&lt;/code&gt;中输出日志，查看释放情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@implementation&lt;/span&gt; &lt;span class="nc"&gt;WonderfulNumber&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;storedNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"A WonderfulNumber object was initialized!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;dealloc&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"A WonderfulNumber object was deallocated!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;dealloc&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;setStoredNumber:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;newNumber&lt;/span&gt;
&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;continues&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回到之前displaySomeText的代码。添加上述日志后，再执行时会发现&lt;code&gt;dealloc&lt;/code&gt;中的日志未被输出。myWonderfulNumber未被释放，会产生内存泄漏。&lt;/p&gt;
&lt;p&gt;因此，我们需要某种方法来标明某个对象不再需要使用，可以被释放掉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;需要重申的是，苹果建议永远不要直接调用&lt;code&gt;dealloc&lt;/code&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;对象的生命周期&lt;/h2&gt;
&lt;h3 id="yin-yong-ji-shu"&gt;引用计数&lt;/h3&gt;
&lt;p&gt;假设某个程序需要在屏幕上显示一个数字。当点击菜单上的一个选项时，会创建一个WonderfulNumber对象，并将它显示在窗口中。用户可以打开多个窗口，每次新窗口将显示WonderfulNumber中数字。当所有窗口都被关闭时WonderfulNumber对象才不再被需要。&lt;/p&gt;
&lt;p&gt;我们可能需要在创建WonderfulNumber代码的结尾处调用&lt;code&gt;removeYourselfFromMemory&lt;/code&gt;方法。但是问题是我们不知道它被多少个其它的对象所需要。&lt;/p&gt;
&lt;p&gt;我们需要某种方法来跟踪有多少个对象对这个实例『感兴趣』。&lt;/p&gt;
&lt;h4 id="yin-yong-ji-shu-de-jie-shao"&gt;引用计数的介绍&lt;/h4&gt;
&lt;p&gt;Cocoa框架使用了『引用计数』来处理这个问题。这项技术允许对象声明它们对某个对象感兴趣或不再对它感兴趣。&lt;/p&gt;
&lt;p&gt;如果objectA要声明它对objectB感兴趣，objectA向objectB发送&lt;code&gt;retain&lt;/code&gt;。当objectA决定不再需要objectB时，它向objectB发送&lt;code&gt;release&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;引用计数是通过在每个对象上维护一个&lt;code&gt;retain count&lt;/code&gt;来工作的。在对象上调用&lt;code&gt;retain&lt;/code&gt;后，计数加1，调用&lt;code&gt;releas&lt;/code&gt;后，计数减1。当对象的引用计数为0时，它将自动从内存中释放。&lt;/p&gt;
&lt;p&gt;比如前面提到的每个新窗口都显示那个WonderfulNumber对象，这些窗口都retain这个WonderfulNumber对象。任何一个窗口关闭时，窗口都release对象。当所有窗口都关闭时，引用计数为0，WonderFulNumber对象被释放。&lt;/p&gt;
&lt;h4 id="nei-cun-fen-pei-hou-de-yin-yong-ji-shu"&gt;内存分配后的引用计数&lt;/h4&gt;
&lt;p&gt;因为引用计数为0时，对象会被释放。因此在对象分配内存后，它的计数初始为1。当我们编写下面这行代码时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它不只是为对象分配了内存，同样它声明了我们对这个对象感兴趣，因此我们不需要显式的retain这个对象。&lt;/p&gt;
&lt;p&gt;从另一个角度来看，使用了&lt;code&gt;alloc&lt;/code&gt;来创建对象，就表示我们『同意』对它『负责』。即我们同意当我们不需要使用它时会&lt;code&gt;release&lt;/code&gt;它。&lt;/p&gt;
&lt;p&gt;因此完整的代码应该是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;displaySomeText:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;sender&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="nl"&gt;setStoredNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;wonderfulValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;storedNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt;
        &lt;span class="nl"&gt;stringWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"My Wonderful Value = %f&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wonderfulValue&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;拒绝对内存管理负责&lt;/h2&gt;
&lt;p&gt;上节提到需要对创建的对象负责。但在某些情况下『对对象负责的责任』并不是非常清析。&lt;/p&gt;
&lt;p&gt;比如，在类的方法中返回字符串指针时，这个类并不应该对字符串对象的最终释放负责。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;storedNumberAsString&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stringToReturn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                     &lt;span class="nl"&gt;initWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"%f"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;storedNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;stringToReturn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法分配并初始化了一个新的的字符串并在方法结束的地方返回了这个字符串。在这里应该要意识到我们分配了新的对象但是并没有释放它&amp;mdash;&amp;mdash;我们没有对我们创建的对象完全负责。&lt;/p&gt;
&lt;p&gt;如果我们在返回对象前使用&lt;code&gt;[stringToReturn relaase]&lt;/code&gt;释放它，那么它会立即被释放掉，方法的返回值将是个无效的对象。&lt;/p&gt;
&lt;p&gt;我们也不希望在其它使用了&lt;code&gt;storedNumberAsString&lt;/code&gt;这类方法的地方使用&lt;code&gt;release&lt;/code&gt;&amp;mdash;&amp;mdash;除非我们调用了&lt;code&gt;alloc] init]&lt;/code&gt;或&lt;code&gt;retain&lt;/code&gt;，否则我们不需要调用&lt;code&gt;release&lt;/code&gt;，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="nl"&gt;setStoredNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;storedNumberAsString&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;numberString&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// Uh-oh!&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上在的代码并不是个好主意，我们需要的效果是提供某种机制使得使用WonderfulNumber对象的人总是会释放他们通过&lt;code&gt;storedNumberAsString&lt;/code&gt;所得到的字符串。&lt;/p&gt;
&lt;p&gt;我们需要某种方法将对象传递到其它地方，明确的解除我们对它的内存管理『责任』。&lt;/p&gt;
&lt;h3 id="autorelease_1"&gt;autorelease&lt;/h3&gt;
&lt;p&gt;Cocoa提供了&lt;code&gt;autoreleasing&lt;/code&gt;机制来处理这种情况。&lt;/p&gt;
&lt;p&gt;通过在对象上调用&lt;code&gt;autorelease&lt;/code&gt;而不是&lt;code&gt;release&lt;/code&gt;，我们可以将对象的&lt;code&gt;release&lt;/code&gt;延时至下一个事件循环。即它在当前执行的代码上会一直存在。一旦程序代码执行完毕，应用程序等侍用户输入时，这个对象就会被&lt;code&gt;release&lt;/code&gt;。如果此时它的引用计数为0，则它被释放。&lt;/p&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//WonderfulNumber.m&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;storedNumberAsString&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stringToReturn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                     &lt;span class="nl"&gt;initWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"%f"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;storedNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stringToReturn&lt;/span&gt; &lt;span class="n"&gt;autorelease&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//NotifyingClass.m&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;displaySomeText:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;sender&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="nl"&gt;setStoredNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;storedNumberAsString&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里在WonderfulNumber对象创建之后，我们创建了一个指向字符串对象的指针&lt;code&gt;numberString&lt;/code&gt;，并把它插入了textViewer中。&lt;/p&gt;
&lt;p&gt;我们只需要对&lt;code&gt;myWonderfulNumber&lt;/code&gt;对象调用&lt;code&gt;release&lt;/code&gt;，因为它是在这方法中唯一一个使用&lt;code&gt;alloc&lt;/code&gt;分配出来的对象。当&lt;code&gt;displaySomeText&lt;/code&gt;方法结束后，&lt;code&gt;numberString&lt;/code&gt;指针将不再处于作用范围，由于这里是当前的事件响应代码的『最后一行』，因此这个由&lt;code&gt;storedNumberAsString&lt;/code&gt;所返回的字符串对象将在随后被释放（下一事件循环）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;我的思考：autorelease的运行方式：执行autorelease时标记在下一事件循环中，需要对该对象进行release。当进入下一次事件循环后，先对这一对象进行release，发现引用计数为0时，进行释放。这样也能保证在当前这次事件循环中&lt;code&gt;[textView insertText&lt;/code&gt;执行时，对象仍然存在&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;对象初始化参数&lt;/h2&gt;
&lt;p&gt;类似于NSString中的&lt;code&gt;initWithFormat&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;通过提供支持参数的&lt;code&gt;init&lt;/code&gt;方法来初始化对象的属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;initWithNumber:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;newNumber&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;storedNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;newNumber&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Object was initialized!"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就可以编写下面这样支持初始化参数的代码了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;displaySomeText:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;sender&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;storedNumberAsString&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;numberString&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;myWonderfulNumber&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何避免用户直接调用&lt;code&gt;[[WonderfulNumber alloc] init]&lt;/code&gt;而不提供初始化参数呢？我们可以在&lt;code&gt;init&lt;/code&gt;中提供某些默认值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;@implementation&lt;/span&gt; &lt;span class="nc"&gt;WonderfulNumber&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;initWithNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;initWithNumber:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;newNumber&lt;/span&gt;
&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;continues&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;工具类类方法&lt;/h2&gt;
&lt;p&gt;在NSString中定义了很多类方法，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;stringWithFormat:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;localizedStringWithFormat:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;stringWithCharacters:length:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;stringWithString:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这此工具方法可以直接在NSString类上调用，它们会返回一个初始化过的对象。使用这些方法的好处在于它们的返回值都是&lt;code&gt;autorelease&lt;/code&gt;的。这意味着你可以不使用&lt;code&gt;alloc&lt;/code&gt;来创建NSString的实例而不需要对它调用&lt;code&gt;release&lt;/code&gt;。因为这些方法返回的是一个已经构建好的对象，因此它们经常被称为&lt;code&gt;factory&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;因此我们可以用这个方法来简化我们的&lt;code&gt;storedNumberAsString&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;storedNumberAsString&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stringToReturn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="nl"&gt;stringWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"%f"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;storedNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;stringToReturn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为NSString的类方法返回的是一个已经&lt;code&gt;autorelease&lt;/code&gt;的字符串对象，因此我们不需要在返回前再对它调用&lt;code&gt;autorelease&lt;/code&gt;了。&lt;/p&gt;
&lt;h3 id="bian-xie-zi-ji-de-lei-gong-han-fang-fa"&gt;编写自己的类工厂方法&lt;/h3&gt;
&lt;p&gt;遵循习惯性约定，工厂方法的命名一般按下面的格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;laquo;objectType&amp;raquo;With&amp;laquo;optional arguments:&amp;raquo;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WonderfulNumber的工厂方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;wonderfulNumberWithFloat:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;newNumber&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numberToReturn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;WonderfulNumber&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                             &lt;span class="nl"&gt;initWithNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;newNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;numberToReturn&lt;/span&gt; &lt;span class="n"&gt;autorelease&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="lei-fang-fa-zhong-de-self"&gt;类方法中的&lt;code&gt;self&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;考虑到将来WonderfulNumber类可能会存在子类型EvenMoreWonderfulNumber。子类型会继承父类型的方法，当调用`[EvenMoreWonderfulNumber wonderfulNumberWithFloat:55.4]时，它将会返回一个新的WonderfulNumber类型的对象，而不是EvenMoreWonderfulNumber类型的对象。&lt;/p&gt;
&lt;p&gt;为了确保这个方法返回正确的类型我们需要将方法修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;wonderfulNumberWithFloat:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;newNumber&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;numberToReturn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithNumber&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;newNumber&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;numberToReturn&lt;/span&gt; &lt;span class="n"&gt;autorelease&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类方法中的&lt;code&gt;self&lt;/code&gt;关键字指向的是类本身，而不是类的实例。这里返回的类型是&lt;code&gt;id&lt;/code&gt;类型的，工厂方法基本上都是返回这一类型，这是因为我们不希望在工厂方法中对类型进行硬编码。&lt;/p&gt;
&lt;h3 id="he-shi-shi-yong-alloche-shi-shi-yong-gong-han-fang-fa"&gt;何时使用&lt;code&gt;alloc&lt;/code&gt;，何时使用工厂方法&lt;/h3&gt;
&lt;p&gt;到目前为止似乎总是应该使用工厂方法。&lt;/p&gt;
&lt;p&gt;但是有时我们会需要一个对象在内存中保留一段时间，在当前事件循环结束后能继续存在。比如，A对象的某个实例变量指向了B对象，在A对象的生命周期中它都需要B对象存在。那么我们应该在A对象的&lt;code&gt;init&lt;/code&gt;方法中使用B对象的&lt;code&gt;alloc] init]&lt;/code&gt;方法来初始化它，并在A对象的&lt;code&gt;dealloc&lt;/code&gt;方法中&lt;code&gt;release&lt;/code&gt;这个实例。&lt;/p&gt;
&lt;h1&gt;集合&lt;/h1&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;Cocoa提供了&lt;code&gt;NSArray&lt;/code&gt;类。它的常用初始化方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithArray:&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithArray:copyItems:&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithContentsOfFile:&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithContentsOfURL:&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithObjects:&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="nf"&gt;initWithObjects:count:&lt;/span&gt;
&lt;span class="c1"&gt;//工厂方法&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;array&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithArray:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithContentsOfFile:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithContentsOfURL:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithObject:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithObjects:&lt;/span&gt;
&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="nf"&gt;arrayWithObjects:count:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以认为类方法只是调用实例方法并返回一个autorelease的数组。&lt;/p&gt;
&lt;h3 id="xiang-fang-fa-chuan-di-duo-ge-can-shu"&gt;向方法传递多个参数&lt;/h3&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;personWithFirstName:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;firstName&lt;/span&gt; &lt;span class="nf"&gt;lastName:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;Person&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;somebody&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Person&lt;/span&gt; &lt;span class="nl"&gt;personWithFirstName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Jane"&lt;/span&gt; &lt;span class="nl"&gt;lastName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Doe"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这个工厂方法的名称为&lt;code&gt;personWithFirstName:lastName:&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;NSArray的&lt;code&gt;arrayWithObjects&lt;/code&gt;可以接收多个参数，但它并不是&lt;code&gt;arrayWithObject1:object2:object3:&lt;/code&gt;，因为它需要接收任意数量的对象。&lt;/p&gt;
&lt;p&gt;Objective-C支持可变长度参数，只需要在调用时在最后一个参数的后面提供一个&lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;arrayWithObjects:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;firstObj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Milk"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Eggs"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;thirdObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Butter"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="nl"&gt;arrayWithObjects&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;secondObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;thirdObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="nl"&gt;stringWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"shoppingListArray = %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//%@用于显示数组&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

 &lt;span class="n"&gt;stringToOutput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt;
           &lt;span class="nl"&gt;stringByAppendingString&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt;
                                      &lt;span class="nl"&gt;componentsJoinedByString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@", "&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;&lt;span class="c1"&gt;//拼接数组&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textView&lt;/span&gt; &lt;span class="nl"&gt;insertText&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shu-zu-yuan-su-suo-yin"&gt;数组元素索引&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;stringToOutput&lt;/span&gt;
        &lt;span class="nl"&gt;stringByAppendingString&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="nl"&gt;objectAtIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;&lt;span class="c1"&gt;//第二个元素&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;indexOfObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="nl"&gt;indexOfObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//元素索引&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Objective-C中数组索引是从0开始的。&lt;/p&gt;
&lt;h3 id="shu-zu-yuan-su-shu-liang"&gt;数组元素数量&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;nmberOfItems&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;对象可变性&lt;/h2&gt;
&lt;p&gt;NSString和NSArray都是不可变对象。&lt;/p&gt;
&lt;p&gt;NSString类的&lt;code&gt;stringByAppendingString&lt;/code&gt;不是修改已有的字符串，而是返回一个包含旧内容和新内容的字符串。&lt;/p&gt;
&lt;p&gt;NSArray提供了类似的方法&lt;code&gt;arrayByAddingObject&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="ke-bian-de-shu-zu-he-zi-fu-chuan"&gt;可变的数组和字符串&lt;/h3&gt;
&lt;p&gt;如果一个对象是可变(&lt;code&gt;mutable&lt;/code&gt;)的，则它的内容可以动态的修改。&lt;/p&gt;
&lt;p&gt;Cocoa提供了多个可变类，它们是是基于不可变类型的。如：NSMutableString、NSMutableArray等。&lt;/p&gt;
&lt;p&gt;NSMutableArray提供了额外的方法，如&lt;code&gt;addObject&lt;/code&gt;或&lt;code&gt;insertObject:atIndex:&lt;/code&gt;等可以在数组的中间位置插入新元素。也提供了对应的方法从数组中删除元素。&lt;/p&gt;
&lt;p&gt;创建NSMutableArray对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSMutableArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;changingArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSMutableArray&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// changingArray is currently an empty array&lt;/span&gt;
&lt;span class="c1"&gt;// calling [changingArray count] at this point would return 0&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"The first string"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;changingArray&lt;/span&gt; &lt;span class="nl"&gt;addObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"The second string"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;changingArray&lt;/span&gt; &lt;span class="nl"&gt;addObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shu-zu-de-xiao-lu"&gt;数组的效率&lt;/h3&gt;
&lt;p&gt;如果知道最终要保存在数组中的元素数量，我们可以使用&lt;code&gt;initWithCapacity&lt;/code&gt;或&lt;code&gt;arrayWithCapacity&lt;/code&gt;工厂方法来初始化数组。这样在存储元素时速度会更快。超出初始容量时，仍然可以存储，效率比在初始容量中存储差一些。&lt;/p&gt;
&lt;p&gt;这是因为在没有能容纳所有元素的大块内存或我们在原始容量之外添加添加新元素时，数组对象会需要跟踪多个内存块来维护它所保存的对象指针。&lt;/p&gt;
&lt;h3 id="xiu-gai-shu-zu-yuan-su-nei-rong"&gt;修改数组元素内容&lt;/h3&gt;
&lt;p&gt;NSArray数组虽然是不可变的，但它的元素内容是可变的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Milk"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Eggs"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fixedArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="nl"&gt;arrayWithObjects&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;secondObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@"Bread"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Contents of Array = %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fixedArray&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码输出的内容是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Contents of Array = (
    Milk,
Eggs )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Contents of Array = (
    Milk,
Bread )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是因为数组会&lt;code&gt;retain&lt;/code&gt;添加到其中的元素。当给&lt;code&gt;secondObject&lt;/code&gt;重新赋值时，是让它指向一个新的内存地址，之前它与数组元素所指向的内存地址相同，重新赋值后，它指向了一个新地址，这对于数组里的内容没有影响。&lt;/p&gt;
&lt;p&gt;如果我们在不可变数组中保存可变字符串，那么数组元素中的内容仍然是可以修改的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSMutableString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSMutableString&lt;/span&gt; &lt;span class="nl"&gt;stringWithString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Milk"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="bp"&gt;NSMutableString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSMutableString&lt;/span&gt; &lt;span class="nl"&gt;stringWithString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Eggs"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fixedArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="nl"&gt;arrayWithObjects&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;secondObject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;secondObject&lt;/span&gt; &lt;span class="nl"&gt;setString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Bread"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Contents of Array = %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fixedArray&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Contents&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Array&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="n"&gt;Milk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;Bread&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方式虽然可以修改数组元素的内容，但是并不能向数组中添加、删除元素。&lt;/p&gt;
&lt;h3 id="zi-fu-chuan-de-gao-ji-te-xing"&gt;字符串的高级特性&lt;/h3&gt;
&lt;p&gt;构建NSString时使用的&lt;code&gt;@"string"&lt;/code&gt;格式与上面的代码是等效的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="nl"&gt;stringWithCString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;"this is a C string"&lt;/span&gt; &lt;span class="nl"&gt;encoding&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;&amp;laquo;&lt;/span&gt;&lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="err"&gt;&amp;raquo;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="tian-jia-shu-zu-yuan-su"&gt;添加数组元素&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;typedValue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textField&lt;/span&gt; &lt;span class="n"&gt;stringValue&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;shoppingListArray&lt;/span&gt; &lt;span class="nl"&gt;arrayByAddingObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;typedValue&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建新应用&lt;/h2&gt;</content><category term="objective-c"></category><category term="mac"></category></entry><entry><title>C Primer Plus 笔记</title><link href="/c-primer-plus-bi-ji.html" rel="alternate"></link><published>2015-06-29T00:00:00+08:00</published><updated>2015-06-29T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-06-29:/c-primer-plus-bi-ji.html</id><summary type="html">&lt;h1&gt;C Primer Plus 笔记&lt;/h1&gt;
&lt;h2&gt;起步&lt;/h2&gt;
&lt;h3 id="biao-zhun"&gt;标准&lt;/h3&gt;
&lt;p&gt;C89 标准是由 1983 年由 ANSI 起草，于 1989 年被正式接受，它定义了语言和标准 C 程序库。C99 标准是 ISO于 1990 年制定的。ISO 和 ANSI 的标准在本质上是相同的。通常说的 ANSI C 就是指的 ANSI 版本。
C99 标准在 1994 年开始制定，目标是在原有 C90 基础上保持语言小而简单。在三个方面对它进行增强：
 1. 添加了对国际化字符集的处理。
 2. 修复明显的不足（如，64 位处理器）
 3. 数值计算方面的增强 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;C Primer Plus 笔记&lt;/h1&gt;
&lt;h2&gt;起步&lt;/h2&gt;
&lt;h3 id="biao-zhun"&gt;标准&lt;/h3&gt;
&lt;p&gt;C89 标准是由 1983 年由 ANSI 起草，于 1989 年被正式接受，它定义了语言和标准 C 程序库。C99 标准是 ISO于 1990 年制定的。ISO 和 ANSI 的标准在本质上是相同的。通常说的 ANSI C 就是指的 ANSI 版本。
C99 标准在 1994 年开始制定，目标是在原有 C90 基础上保持语言小而简单。在三个方面对它进行增强：
 1. 添加了对国际化字符集的处理。
 2. 修复明显的不足（如，64 位处理器）
 3. 数值计算方面的增强（代替 FORTRAN ）
C11 标准是在 2007 年提出的，最初叫 C1X。在 C11 中标准委员会考虑到 C99 并未像 C90 那样广泛会厂商支持，因此 C99 中的一些内容在 C11 中变成了可选功能。&lt;/p&gt;
&lt;h3 id="bian-cheng"&gt;编程&lt;/h3&gt;
&lt;p&gt;C 实现将编写过程分为编译和链接两步。编译器将代码转换为中间代码，链接器将它与其它代码组合成执行文件。C 使用这两部分来实现程序的模块化。&lt;/p&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;h3 id="guan-yu-han-shu-shen-ming"&gt;关于函数申明&lt;/h3&gt;
&lt;p&gt;C90 标准中中添加了原型，旧编译器可能不识别。原型申明对于编译器来说是个特殊的函数，称为&lt;strong&gt;函数申明&lt;/strong&gt;。它需要指定函数的所有属性。
旧的 C 在函数申明时有更多的限制，只能指定返回值，不能说明参数。C90，C99 和 C11 编译器能识别这一写法但会指出不要再使用它。
C 标准推荐提供所有函数的原型。&lt;/p&gt;
&lt;h3 id="cheng-xu-zhuang-tai"&gt;程序状态&lt;/h3&gt;
&lt;p&gt;简单来说就是在程序某个时间点上所有变量的值的集合。它是当前计算状态的快照&lt;/p&gt;
&lt;h3 id="guan-jian-zi"&gt;关键字&lt;/h3&gt;
&lt;p&gt;C99 增加的关键字：
&lt;code&gt;signed, const, enum, volatile&lt;/code&gt;
C11 增加的关键字：
&lt;code&gt;inline, _Alignas, _Alignof, _Bool, _Complex, _Generic, _Imaginary, _Noreturn, _Static_Assert, #_Thread_local&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;C 中的数据&lt;/h2&gt;
&lt;h3 id="shu-ju-lei-xing"&gt;数据类型&lt;/h3&gt;
&lt;p&gt;bit, Byte, Word 中 byte 通常是计算机的内存单元。word 是特定计算机平台上内存的自然单位。比如 16 位机器，就是 word 为 16 位。&lt;/p&gt;
&lt;p&gt;浮点数与数学上的实数对应。在机器中表示为分数和它的指数两部分。因此对浮点数进行某些数学操作时（如减去一个较大的数）会丢失精度。浮点数不可能表示所有的数字，因此它会取近似值。比如将 7.0 存储为 6.99999。浮点操作也比整数操作慢。&lt;/p&gt;
&lt;h3 id="ji-chu-lei-xing"&gt;基础类型&lt;/h3&gt;
&lt;h4 id="zheng-shu-lei-xing"&gt;整数类型&lt;/h4&gt;
&lt;p&gt;C 提供了多种整数类型
 1. int 为表示有符号整数。
 2. short int 或称 short
 3. long int 或称 long
 4. long long int 或称 long long (C99)，最少为 64 位。
 5. unsigned int 或称 unsigned 用于非负整数
 6. unsigned long int 或称 unsigned long。unsigned short int 或称 unsigned short 都来自于 C90 标准。C99 还添加了 unsigned long long int 或称 unsigned long long。
 7. . signed 关键字可以显式的用于前面的那些类型。&lt;/p&gt;
&lt;p&gt;这么多的整数类型，C 只保证 short 不会比 int 长，long 不会比 int 短。对于当前的 PC，通常认为 long long 为 64 位，long 为 32 位，short 为 16 位，int 为 16 或 32位，这依赖于具体的机器的 word 长度。
在 printf 中使用 &lt;code&gt;%u&lt;/code&gt;打印 unsigned int，&lt;code&gt;%hd%&lt;/code&gt;打印 long，&lt;code&gt;%ld&lt;/code&gt;打印 long long。&lt;/p&gt;
&lt;h4 id="zi-fu-xing"&gt;字符型&lt;/h4&gt;
&lt;p&gt;char 用于存储字符，但在技术上来说存的是整数。用数字来描述某个字符。标准 ASCII 代码用 0 至 127 表示。这个范围用 7 位就够了，char 类型通常定义为一个内存单元大小（8-bit）。很多字符集用 127 或 255 不够表示。Unicode 可以描述超过 110000 个字符。ISO/IEC 开发的 10646 与 unicode 字符集兼容。
C 将 byte 定义为 char 使用的 bit 数量，因此有 16-bit 或 32-bit 的 char 类型。&lt;/p&gt;
&lt;p&gt;Signed 和 Unsigned char，分别用 -128 至 127 或 0 至 255 表示 char，需要查看编译器手册或检查 limits.h 来了解你的编译器所使用的类型。C90 标准中允许使用 signed char 或 unsigned char。&lt;/p&gt;
&lt;h4 id="_bool-xing"&gt;_Bool 型&lt;/h4&gt;
&lt;p&gt;C99 中添加的类型，可以为 true 或 false。由于 C 中使用 1 作为 true，0 作为 false，因此 _Bool 类型实际上只是整型。&lt;/p&gt;
&lt;h4 id="ke-yi-zhi-lei-xing-stdinth-he-inttypesh"&gt;可移植类型：stdint.h 和 inttypes.h&lt;/h4&gt;
&lt;p&gt;C 提供了非常多的整数类型。同一个名称在不同平台上可能代表的含义不同。C99 中为不同平台的名称定义了统一的含义，定义在 stdint.h 中。比如，int32_t 表示 32 位有符号整数。
为避免某些平台不支持明确的整数宽度（比如指定为 32 位），C99 和 C11 提供了另一种类型的名称。这套名称保证提供的满足需要的最小类型，这些类型被称为&lt;em&gt;最小宽度类型&lt;/em&gt;。比如，&lt;code&gt;int_least8_t&lt;/code&gt;能提供保存 8 位整数的类型。如果在 16 位系统上，&lt;code&gt;int8_t&lt;/code&gt;类型可能没有定义。但是，&lt;code&gt;int_least8_t&lt;/code&gt;类型将是可用的，有可能它会使用一个 16 位的整数。
有些程序员可能会更关心速度而不是空间。对他们来说，C99 和 C11 中定义了鼍一套用于快速计算的类型。这些类型被称为&lt;em&gt;快速最小宽度类型&lt;/em&gt;。比如&lt;code&gt;int_fast8_t&lt;/code&gt;定义了用于代替整数的提供最快计算速度的的 8 位无符号值。
最后，对于一些程序员来说，最大的&lt;/p&gt;</content><category term="c"></category></entry><entry><title>Learing Go 笔记</title><link href="/learing-go-bi-ji.html" rel="alternate"></link><published>2015-06-05T00:00:00+08:00</published><updated>2015-06-05T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-06-05:/learing-go-bi-ji.html</id><summary type="html">&lt;h1&gt;Learing Go 笔记&lt;/h1&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;h3 id="chi-xian-wen-dang"&gt;离线文档&lt;/h3&gt;
&lt;p&gt;Go自带&lt;code&gt;godoc&lt;/code&gt;用于查看程序模块的文档。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;godoc &lt;span class="nb"&gt;builtin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="hello-world"&gt;Hello World&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* 这行是必须的，所有 Go 文件都必须以 package 开头，对于可单独运行的程序来说，package main 是必须的 */&lt;/span&gt;
&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;"fmt"&lt;/span&gt; &lt;span class="c1"&gt;//导入 fmt 包&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="c1"&gt;//可执行程序入口函数&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello, world; or 汉字"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bian-liang-lei-xing-he-guan-jian-zi"&gt;变量、类型和关键字&lt;/h3&gt;
&lt;p&gt;Go 使用类似 C 的语法，行结尾不需要分号，同一行放两个以上语句需要用分号隔开。Go 的变量类型放在变量名后面。如不写作&lt;code&gt;int …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Learing Go 笔记&lt;/h1&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;h3 id="chi-xian-wen-dang"&gt;离线文档&lt;/h3&gt;
&lt;p&gt;Go自带&lt;code&gt;godoc&lt;/code&gt;用于查看程序模块的文档。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;godoc &lt;span class="nb"&gt;builtin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="hello-world"&gt;Hello World&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* 这行是必须的，所有 Go 文件都必须以 package 开头，对于可单独运行的程序来说，package main 是必须的 */&lt;/span&gt;
&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;"fmt"&lt;/span&gt; &lt;span class="c1"&gt;//导入 fmt 包&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="c1"&gt;//可执行程序入口函数&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello, world; or 汉字"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bian-liang-lei-xing-he-guan-jian-zi"&gt;变量、类型和关键字&lt;/h3&gt;
&lt;p&gt;Go 使用类似 C 的语法，行结尾不需要分号，同一行放两个以上语句需要用分号隔开。Go 的变量类型放在变量名后面。如不写作&lt;code&gt;int a&lt;/code&gt;而应该写作&lt;code&gt;a int&lt;/code&gt;。声明变量时，变量就被赋予了这种类型的&amp;ldquo;自然&amp;rdquo;空值。如&lt;code&gt;var a int&lt;/code&gt;，&lt;code&gt;a&lt;/code&gt;值为&lt;code&gt;0&lt;/code&gt;。&lt;code&gt;var a string&lt;/code&gt;，&lt;code&gt;a&lt;/code&gt;值为&lt;code&gt;""&lt;/code&gt;。也可以将变量的声明和赋值合并为一步：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与下面的写法是同等的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以同时声明多个变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;和&lt;code&gt;import&lt;/code&gt;也支持这种写法。声明多个变量时还可以使用&lt;code&gt;var x, y int&lt;/code&gt;，并且还可以同时赋值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下划线&lt;code&gt;_&lt;/code&gt;是个特殊的变量，任何赋给它的值都将被丢弃&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;申明却未使用的变量在 Go 中是编译错误。&lt;/p&gt;
&lt;h4 id="bu-er-xing"&gt;布尔型&lt;/h4&gt;
&lt;p&gt;布尔值由常量&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;描述，类型为&lt;code&gt;bool&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="shu-zhi-lei-xing"&gt;数值类型&lt;/h4&gt;
&lt;p&gt;Go 有如&lt;code&gt;int&lt;/code&gt;的数值类型。这些类型的长度与机器相关，32 位机器上它是 32 位的，64 位机器上是 64 位的。int 只有 32 位或 64 位，没有其它的定义。&lt;code&gt;uint&lt;/code&gt;也是同样的情况。
如果想使用明确的长度，也可以使用&lt;code&gt;int32&lt;/code&gt;或&lt;code&gt;uint32&lt;/code&gt;。可用的整数类型列表：&lt;code&gt;int8, int16, int32, int64, byte, uint8, uint16, uint32, uint64&lt;/code&gt;。&lt;code&gt;byte&lt;/code&gt;是&lt;code&gt;uint8&lt;/code&gt;的别名。没有&lt;code&gt;float&lt;/code&gt;类型，只有&lt;code&gt;float32, float64&lt;/code&gt;。
所有这些类型的赋值是严格检查的，混合使用这些类型会产生编译错误。&lt;/p&gt;
&lt;h4 id="chang-liang"&gt;常量&lt;/h4&gt;
&lt;p&gt;Go 中的常量在编译时创建，只允许是数值、字符串或布尔型。可以使用&lt;code&gt;iota&lt;/code&gt;建立枚举值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;iota&lt;/span&gt;
    &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;iota&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行&lt;code&gt;iota&lt;/code&gt;产生的值为&lt;code&gt;0&lt;/code&gt;，每行增加&lt;code&gt;1&lt;/code&gt;。甚至可以让 Go 自己重复&lt;code&gt;iota&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;iota&lt;/span&gt;
    &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="c1"&gt;//隐式的 b = iota&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="zi-fu-chuan"&gt;字符串&lt;/h4&gt;
&lt;p&gt;Go 中的字符串是用双引号包括的 UTF-8 字符串。单引号中的是 UTF-8 字符，而不是字符串。
字符串是不可变的。如果希望像 C 中那样以数组的方式操作字符串，则需要使用&lt;code&gt;rune&lt;/code&gt;，它能将字符串转化为数组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;
&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="nb"&gt;rune&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'c'&lt;/span&gt;
&lt;span class="nx"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="duo-xing-zi-fu-chuan"&gt;多行字符串&lt;/h4&gt;
&lt;p&gt;由于 Go 会自动在行末插入分号，因此需要小心使用多行字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;"Starting part"&lt;/span&gt;       &lt;span class="c1"&gt;//;&lt;/span&gt;
    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;"Ending part"&lt;/span&gt;         &lt;span class="c1"&gt;//;&lt;/span&gt;
&lt;span class="nx"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;"Starting part"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;     &lt;span class="c1"&gt;//不会添加;&lt;/span&gt;
      &lt;span class="s"&gt;"Ending part"&lt;/span&gt;         &lt;span class="c1"&gt;//;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;s1 写法是错误的。
另一种方法是使用反引号：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;`Starting part&lt;/span&gt;
&lt;span class="s"&gt;    Ending part`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要注意这种写法包含了反引号之间的所有字符（换行 ）。&lt;/p&gt;
&lt;h4 id="rune"&gt;Rune&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Rune&lt;/code&gt;是&lt;code&gt;int32&lt;/code&gt;的别名。它是一个 UTF-8 编码的指针。可以用于遍历字符串中的单个字符。&lt;/p&gt;
&lt;h4 id="fu-shu"&gt;复数&lt;/h4&gt;
&lt;p&gt;Go 原生支持复数类型。对应的类型是&lt;code&gt;complex128&lt;/code&gt;（64 位实部和 64 位虚部）或&lt;code&gt;complex64&lt;/code&gt;（32 位实部和 32 位虚部）。复数写作&lt;code&gt;re + imi&lt;/code&gt;，&lt;code&gt;re&lt;/code&gt;是实部，&lt;code&gt;im&lt;/code&gt;是虚部：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;complex64&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="m"&gt;5i&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Value is: %v"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="cuo-wu"&gt;错误&lt;/h4&gt;
&lt;p&gt;Go 内置了错误类型。&lt;code&gt;var e error&lt;/code&gt;创建了一个&lt;code&gt;error&lt;/code&gt;类型的变量&lt;code&gt;e&lt;/code&gt;，它的值为&lt;code&gt;nil&lt;/code&gt;。&lt;code&gt;error&lt;/code&gt;类型是一个接口。&lt;/p&gt;
&lt;h3 id="cao-zuo-fu-he-nei-zhi-han-shu_1"&gt;操作符和内置函数&lt;/h3&gt;
&lt;p&gt;Go 支持通常的数值操作符。
Go 不支持操作符重载（或方法重载），但是一些内置的操作符是被重载过的。如：&lt;code&gt;+&lt;/code&gt;可以用于整数、浮点、复数和字符串。&lt;/p&gt;
&lt;h3 id="guan-jian-zi"&gt;关键字&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;func&lt;/code&gt;定义函数
&lt;code&gt;return&lt;/code&gt;从函数中返回
&lt;code&gt;go&lt;/code&gt;用于并发编程
&lt;code&gt;select&lt;/code&gt;用于选择不同类型的通讯
&lt;code&gt;interface&lt;/code&gt;
&lt;code&gt;struct&lt;/code&gt;用于定义类型
&lt;code&gt;type&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="kong-zhi-jie-gou"&gt;控制结构&lt;/h3&gt;
&lt;p&gt;Go 的控制结构比较少。比如只有&lt;code&gt;for&lt;/code&gt;是用于循环。&lt;code&gt;switch&lt;/code&gt;和&lt;code&gt;if&lt;/code&gt;都能像&lt;code&gt;for&lt;/code&gt;一样接收初始化语句。另外还有被称为&lt;code&gt;type switch&lt;/code&gt;和&lt;code&gt;multiway communications multiplexer(多路通信多路复用器)&lt;/code&gt;的&lt;code&gt;select&lt;/code&gt;。语法与&lt;code&gt;C&lt;/code&gt;也有些不同，括号不是必需的，并且左括花号不换行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// { 是必需的，且不能放到下一行&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;y&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;switch&lt;/code&gt;支持初始化语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;Chmod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8664&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//err的作用域被限制在 if 的 body 区&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="goto"&gt;Goto&lt;/h3&gt;
&lt;p&gt;Go 有&lt;code&gt;goto&lt;/code&gt;语句，它能跳转到当前函数范围内的&lt;code&gt;label&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="for"&gt;For&lt;/h3&gt;
&lt;p&gt;Go 的&lt;code&gt;for&lt;/code&gt;循环有三种形式，只有一种带分号：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;init&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;condition&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;post&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  &lt;span class="c1"&gt;//类似 C 中的 for&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;condition&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;//类似 while&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;//无限循环&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Go 没有逗号操作符，&lt;code&gt;++&lt;/code&gt;和&lt;code&gt;--&lt;/code&gt;是语句不是表达式，如果你想要在&lt;code&gt;for&lt;/code&gt;中使用多个变量就要使用并行赋值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="break-he-continue"&gt;Break 和 continue&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;break&lt;/code&gt;可以退出当前循环。也可以用于跳转到指定的标签位置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;J&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="nx"&gt;J&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nb"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;continue&lt;/code&gt;可以立即开始下一次循环。&lt;/p&gt;
&lt;h3 id="range"&gt;Range&lt;/h3&gt;
&lt;p&gt;关键字&lt;code&gt;range&lt;/code&gt;可以用于循环。它可以用于&lt;code&gt;slices, array, strings, maps, channel&lt;/code&gt;的循环。&lt;code&gt;range&lt;/code&gt;是个迭代器，调用它时，它将返回它迭代对象的下一个键值对。
当对&lt;code&gt;slice&lt;/code&gt;和&lt;code&gt;array&lt;/code&gt;循环时&lt;code&gt;range&lt;/code&gt;返回&lt;code&gt;slice&lt;/code&gt;的&lt;code&gt;index&lt;/code&gt;和对应位置的值。
也可以直接在字符串上使用&lt;code&gt;range&lt;/code&gt;。它将解析 UTF-8 字符串并返回单个 Unicode 字符和它的位置。&lt;/p&gt;
&lt;h3 id="switch"&gt;Switch&lt;/h3&gt;
&lt;p&gt;Go 的&lt;code&gt;switch&lt;/code&gt;非常具有弹性。表达式不需要是常量甚至不需要是整数；&lt;code&gt;case&lt;/code&gt;从上至下求值，直到找到一个匹配。因此可以使用它编写一个&lt;code&gt;if-else-if-else&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;unhex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;byte&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'0'&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;'9'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;'0'&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'a'&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;'f'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;'a'&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;'A'&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="sc"&gt;'F'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="sc"&gt;'A'&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用&lt;code&gt;default&lt;/code&gt;匹配未能匹配的情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;case&lt;/code&gt;可以是逗号分隔的列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;shouldEscape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="sc"&gt;' '&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'?'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'&amp;amp;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'='&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'+'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="nei-zhi-han-shu"&gt;内置函数&lt;/h3&gt;
&lt;p&gt;内置函数不需要包含其它的包。
 - &lt;code&gt;close&lt;/code&gt;：用于&lt;code&gt;channel&lt;/code&gt;通讯中关闭&lt;code&gt;channel&lt;/code&gt;。
 - &lt;code&gt;delete&lt;/code&gt;：用于从&lt;code&gt;map&lt;/code&gt;中删除一个元素。
 - &lt;code&gt;len&lt;/code&gt;和&lt;code&gt;cap&lt;/code&gt;：被用于多种不同的类型，&lt;code&gt;len&lt;/code&gt;用于返回字符串&lt;code&gt;slice&lt;/code&gt;和数组类型的长度。
 - &lt;code&gt;new&lt;/code&gt;：用于为用户定义的数据类型分配内存。
 - &lt;code&gt;make&lt;/code&gt;：用于为内置类型（&lt;code&gt;map, slice, channel&lt;/code&gt;）分配内存。
 - &lt;code&gt;copy&lt;/code&gt;：用于复制&lt;code&gt;slice&lt;/code&gt;。
 - &lt;code&gt;append&lt;/code&gt;：用于拼接&lt;code&gt;slice&lt;/code&gt;。
 - &lt;code&gt;panic&lt;/code&gt;和&lt;code&gt;recover&lt;/code&gt;：用于异常机制。
 - &lt;code&gt;print&lt;/code&gt;和&lt;code&gt;println&lt;/code&gt;：低层次的打印函数可以不依赖于&lt;code&gt;fmt&lt;/code&gt;包使用。主要用于调试。
 - &lt;code&gt;complex, real, img&lt;/code&gt;：用于处理得数类型。&lt;/p&gt;
&lt;h3 id="array-slice-he-map"&gt;Array, slice 和 map&lt;/h3&gt;
&lt;h4 id="array"&gt;Array&lt;/h4&gt;
&lt;p&gt;定义为：&lt;code&gt;[n]&amp;lt;type&amp;gt;&lt;/code&gt;，&lt;code&gt;n&lt;/code&gt;是数组的长度，&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;是数组元素的类型。数组的大小是它的类型的一部分，不能增长。数组是值：将一个数组赋值给另一个将会复制所有元素。如果将它传递给函数，函数接收到的将是数组的副本，而不是指针。
定义数组时可以将：&lt;code&gt;a := [3]int{1,2,3}&lt;/code&gt;写作&lt;code&gt;a := [...]int{1,2,3}&lt;/code&gt;，Go 会自动计数。
所有字段都必须指定，因此如果定义多维数组将会是如下的结构：
&lt;code&gt;a := [2][2]int{ [2]int{1,2}, [2]int{3,4}}&lt;/code&gt;或写作&lt;code&gt;a := [2][2]int{ [...]int{1,2}, [...]int{3,4}}&lt;/code&gt;声明数组时总是会需要在方括号中输入数字或三个点。
定义 Array，slice 和 map 的表达方式已经被简化了：
&lt;code&gt;a := [2][2]int{ {1,2}, {3,4}}&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="slice"&gt;Slice&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Slice&lt;/code&gt;与&lt;code&gt;Array&lt;/code&gt;类似，但它可以添加元素。&lt;code&gt;slice&lt;/code&gt;总是指向它内部的&lt;code&gt;array&lt;/code&gt;。&lt;code&gt;slice&lt;/code&gt;与是指向&lt;code&gt;array&lt;/code&gt;的指针；&lt;code&gt;slice&lt;/code&gt;是引用类型，将一个 slice 赋值给另一个 slice 时，两者指向同一个内部&lt;code&gt;array&lt;/code&gt;。
&lt;code&gt;s1 := make([]int ,10)&lt;/code&gt;创建了一个可以保存 10 个元素的&lt;code&gt;slice&lt;/code&gt;。&lt;code&gt;slice := array[0:n]&lt;/code&gt;从 array 中创建&lt;code&gt;slice&lt;/code&gt;。&lt;code&gt;len(array) == cap(array) == m&lt;/code&gt;。
使用&lt;code&gt;[I:J]&lt;/code&gt;语法可以从&lt;code&gt;array&lt;/code&gt;或&lt;code&gt;slice&lt;/code&gt;中创建新的&lt;code&gt;slice&lt;/code&gt;，包含从 I 至 J 的元素，长度为 J - I。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nx"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nx"&gt;s3&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[:]&lt;/span&gt;
&lt;span class="nx"&gt;s4&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nx"&gt;s5&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;[:]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;超出容量时会产生运行时错误。
使用&lt;code&gt;append&lt;/code&gt;和&lt;code&gt;copy&lt;/code&gt;可以扩展&lt;code&gt;slice&lt;/code&gt;的元素。使用&lt;code&gt;append&lt;/code&gt;向&lt;code&gt;slice&lt;/code&gt;中添加0个或多个值到&lt;code&gt;slice&lt;/code&gt;中将返回如果结果&lt;code&gt;slice&lt;/code&gt; 的容量不够则会重新分配一块足够大的&lt;code&gt;slice&lt;/code&gt;存放原有&lt;code&gt;slice&lt;/code&gt;和新的元素。因此，返回的&lt;code&gt;slice&lt;/code&gt;内部的数组有可能不是原来的数组。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;s0&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;s3&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;20.&lt;/span&gt;&lt;span class="p"&gt;..)&lt;/span&gt;     &lt;span class="c1"&gt;//s3 == []int{0,0,2,3,5,7,0,0}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;copy&lt;/code&gt;函数将源&lt;code&gt;slice&lt;/code&gt;中的元素复制到目标&lt;code&gt;slice&lt;/code&gt;，并返回复制的元素个数。源和目标可以重叠。可复制的数量是&lt;code&gt;len(src)&lt;/code&gt;和&lt;code&gt;len(dst)&lt;/code&gt;的最小值。&lt;/p&gt;
&lt;h4 id="map"&gt;Map&lt;/h4&gt;
&lt;p&gt;声明方式：&lt;code&gt;map[&amp;lt;from type&amp;gt;]&amp;lt;to type&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;monthdays&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="kd"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;"Jan"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Feb"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Mar"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Apr"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"May"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Jun"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Jul"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Aug"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Sep"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Oct"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Nov"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Dec"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="c1"&gt;//需要这个逗号&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;make&lt;/code&gt;定义&lt;code&gt;map&lt;/code&gt;：&lt;code&gt;monthdays := make(map[string]int)&lt;/code&gt;。
使用方括号定位元素：&lt;code&gt;fmt.Printf("%d\n", somedays["Dec"])&lt;/code&gt;
遍历 map 中的元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;year&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;days&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="nx"&gt;monthdays&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//key 未使用，因此是 _&lt;/span&gt;
    &lt;span class="nx"&gt;year&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nx"&gt;days&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加元素：&lt;code&gt;monthdays["Undecim"] = 30&lt;/code&gt;，测试检测元素是否存在：&lt;code&gt;value,present = monthdays["Jane"]&lt;/code&gt;，如果存在，则&lt;code&gt;present&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;。
删除元素：&lt;code&gt;delete(monthdays, "Mar")&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;函数&lt;/h2&gt;
&lt;p&gt;函数声明的格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;mytype&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="nx"&gt;mytype&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;funcname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;q&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nx"&gt;r&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;func&lt;/code&gt;：关键字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p mtype&lt;/code&gt;：函数可以被绑定到指定的类型上。它被称为接收者（&lt;code&gt;receiver&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;funcname&lt;/code&gt;：函数名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q int&lt;/code&gt;：函数参数声明。参数是值传递的，会被复制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r,s int&lt;/code&gt;：返回值类型声明。函数可以返回多个值。可以不给出具体名称，只声明类型。只有一个返回值时外部可以不加括号。没有返回值时，可以完全省略掉这个部分。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return 0,0&lt;/code&gt;：函数体。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数声明不需要是有序的。编译器会扫描整个文件，不需要先声明函数原型。&lt;/p&gt;
&lt;h3 id="zuo-yong-yu_1"&gt;作用域&lt;/h3&gt;
&lt;p&gt;定义在函数外的变量是全局变量。定义在函数内的是局部变量。如果名称相同，局部变量会隐藏局部变量。&lt;/p&gt;
&lt;h3 id="duo-zhi-fan-hui"&gt;多值返回&lt;/h3&gt;
&lt;h3 id="ming-ming-de-fan-hui-can-shu"&gt;命名的返回参数&lt;/h3&gt;
&lt;p&gt;在函数内可以像使用变量一样使用命名的返回参数。当命名了返回参数时，它们会在函数开始时被初始化为对应类型的零值。如果函数执行没有参数的&lt;code&gt;return&lt;/code&gt;语句，则命名名返回参数的当前值会被返回。
命名并不是必须的，但它可以让代码变得简短清晰。&lt;/p&gt;
&lt;h3 id="yan-shi-zhi-xing-de-dai-ma-deferred-code"&gt;延时执行的代码（Deferred code）&lt;/h3&gt;
&lt;p&gt;Go 中的&lt;code&gt;defer&lt;/code&gt;语句可以指定一个函数，该函数在当前函数退出之前执行。利用它可以编写以下代码，该代码能保证文件在函数退出前被关闭掉：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;ReadWrite&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"file"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//将 file.Close() 添加到 defer list&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;failureX&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;    &lt;span class="c1"&gt;//Close() 会被调用&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;failureY&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;    &lt;span class="c1"&gt;//在这里执行&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;         &lt;span class="c1"&gt;//在这里执行&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以将多个函数添加到&lt;code&gt;deferred list&lt;/code&gt;中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%d"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;延时执行函数按&lt;code&gt;LIFO&lt;/code&gt;执行。因此上面的代码将输出：4，3，2，1，0。
甚至可以在延时执行函数中修改返函数的返回值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="nx"&gt;ret&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;ret&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;         &lt;span class="c1"&gt;//括号是必须的&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;    &lt;span class="c1"&gt;//实际将返回1。&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ke-bian-chang-du-can-shu-variadic-parameters"&gt;可变长度参数（Variadic parameters）&lt;/h3&gt;
&lt;p&gt;声明方式：&lt;code&gt;func myfunc(arg ...int) {}&lt;/code&gt;
在函数内部这些参数是一个&lt;code&gt;slice&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="nx"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"And the number is: %d\n"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不指定可变长度参数的类型，它默认为空接口&lt;code&gt;interface{}&lt;/code&gt;。参数传递：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arg&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;myfunc2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arg&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;myfunc2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="han-shu-zuo-wei-zhi"&gt;函数作为值&lt;/h3&gt;
&lt;p&gt;函数也是值，可以被赋值给变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="nb"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;fmt.Printf("%T\n",a)&lt;/code&gt;来显示&lt;code&gt;a&lt;/code&gt;的类型，它将显示为&lt;code&gt;func()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="hui-diao"&gt;回调&lt;/h3&gt;
&lt;p&gt;因为函数也是值，因此它们也可以作为回调函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;printit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%v\n"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//打印出结果&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="panic-and-recovering"&gt;Panic and recovering&lt;/h3&gt;
&lt;p&gt;Go 没有这机制。它提供了&lt;code&gt;panic-and-recover&lt;/code&gt;机制。应该将它作为最后的手段。&lt;/p&gt;
&lt;h4 id="panic"&gt;Panic&lt;/h4&gt;
&lt;p&gt;它是一个用于停止处理流程并进行&lt;code&gt;panicking&lt;/code&gt;的内置函数。当函数&lt;code&gt;F&lt;/code&gt;调用&lt;code&gt;panic&lt;/code&gt;时，执行过程被停止，延时执行函数（deferred function）被正常执行。&lt;code&gt;F&lt;/code&gt;将返回。对于调用者来说&lt;code&gt;F&lt;/code&gt;的行为就像是在调用&lt;code&gt;panic&lt;/code&gt;函数。这个过程会在调用栈上持续，超越到当前&lt;code&gt;goroutine&lt;/code&gt;返回，在这个时候程序崩溃。&lt;/p&gt;
&lt;h4 id="recover"&gt;Recover&lt;/h4&gt;
&lt;p&gt;内置函数&lt;code&gt;recover&lt;/code&gt;将获取到&lt;code&gt;panicking goroutine&lt;/code&gt;控制权。Recover 只在 deferred 函数内有效。
在正常执行过程中，调用&lt;code&gt;recover&lt;/code&gt;将不产生任何效果，并返回&lt;code&gt;nil&lt;/code&gt;。如果当前&lt;code&gt;goroutine&lt;/code&gt;处于&lt;code&gt;panicking&lt;/code&gt;状态，调用&lt;code&gt;recover&lt;/code&gt;将会捕获到传递给&lt;code&gt;panic&lt;/code&gt;的值并恢复正常执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;throwsPanic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;//参数f是有可能产生 panic 的函数&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;recover&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;//在defer中检查是否产生了 panic&lt;/span&gt;
            &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;                    &lt;span class="c1"&gt;//产生 panic 时修改返回值&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;包&lt;/h2&gt;
&lt;p&gt;包是函数和数据的集合。文件名可以与包名不同。通常包名用小写字符。包可能会包含多个文件，它们共享相同的名称。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;even&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;Env&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;      &lt;span class="c1"&gt;//可导出函数&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;odd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;      &lt;span class="c1"&gt;//私有函数&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大写开头的函数是可导出的，小写开头的函数是私有函数。&lt;/p&gt;
&lt;h3 id="biao-shi-fu_1"&gt;标识符&lt;/h3&gt;
&lt;h4 id="bao-ming"&gt;包名&lt;/h4&gt;
&lt;p&gt;包名应该是简单的小写单词；不要使用下划线或混合大小写。导入时可以重命名&lt;code&gt;import bar "bytes"&lt;/code&gt;。
包名是基于它的源码目录的；位于&lt;code&gt;src/pkg/compress/gzip&lt;/code&gt;使用&lt;code&gt;compress/gzip&lt;/code&gt;来导入，但是使用时的名称是&lt;code&gt;bzip&lt;/code&gt;而不是&lt;code&gt;compress_gzip&lt;/code&gt;或&lt;code&gt;compressGzip&lt;/code&gt;。
导入的包需要使用名称来引用它的内容，因此包中的导出名称可以避免重复。比如&lt;code&gt;bufio&lt;/code&gt;中的&lt;code&gt;Reader&lt;/code&gt;，不需要称为&lt;code&gt;BufReader&lt;/code&gt;，因为用户必须使用&lt;code&gt;bufio.Reader&lt;/code&gt;来引用它。
Go 使用&lt;code&gt;MizedCaps, mixedCaps&lt;/code&gt;格式而不推荐使用下划线分隔多个单词。&lt;/p&gt;
&lt;h4 id="bao-wen-dang"&gt;包文档&lt;/h4&gt;
&lt;p&gt;每个包都应该包含包注释，包注释放在包语句的前面。包含多个文件的包，包注释应该只在一个文件中存在。包注释应该介绍并提供整个包的信息。它将会出现在&lt;code&gt;godoc&lt;/code&gt;的最前面。
每个定义（被导出）的函数应该有一行简单短的注释对其进行说明。&lt;/p&gt;
&lt;h3 id="ce-shi-bao_1"&gt;测试包&lt;/h3&gt;
&lt;p&gt;测试文件保存在包目录中，并且命名为&lt;code&gt;*_test.go&lt;/code&gt;，测试文件与其它 Go 程序一样，但是&lt;code&gt;go test&lt;/code&gt;只会执行这些测试函数。每个测试函数都有相同的签名，并且名称都是以&lt;code&gt;Test&lt;/code&gt;开头：&lt;code&gt;func TestXxx(t *testing.T)&lt;/code&gt;测试成功的函数只需要返回即可，测试失败时可以用下面的函数通知&lt;code&gt;go test&lt;/code&gt;：
 - &lt;code&gt;func (t *T) Fail()&lt;/code&gt;：标明测试函数失败，但继续执行。
 - &lt;code&gt;func (t *T) FailNow()&lt;/code&gt;：标明测试函数失败并停止执行，同一文件中的其它测试被跳过，然后继续执行下一个测试。
 - &lt;code&gt;func (t *T) Log(args ...interface{})&lt;/code&gt;：以类似&lt;code&gt;Print()&lt;/code&gt;的方式格式化它的参数，并记录错误日志。
 - &lt;code&gt;func (t *T) Fatal(args ...interface{})&lt;/code&gt;：等效于在&lt;code&gt;Log()&lt;/code&gt;后执行&lt;code&gt;FailNow()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;even&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;"testing"&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;TestEven&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;testing&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt; &lt;span class="nx"&gt;Even&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"2 should be even!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Fail&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Go 测试工具也允许你编写示例函数，它可以作为文档和测试用例，这些函数需要以&lt;code&gt;Example&lt;/code&gt;开头：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;ExampleEven&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;Even&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Is even\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// Output:&lt;/span&gt;
    &lt;span class="c1"&gt;// Is even&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的两行注释是&lt;code&gt;example&lt;/code&gt;的一部分，&lt;code&gt;go test&lt;/code&gt;使用它来检查输出并以此判断测试是否失败。&lt;/p&gt;
&lt;h3 id="chang-yong-bao"&gt;常用包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fmt&lt;/code&gt;：格式化输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;io&lt;/code&gt;：提供原始的 I/O 接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bufio&lt;/code&gt;：实现缓冲 I/O。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort&lt;/code&gt;：集合排序。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strconv&lt;/code&gt;：字符串与基础数据类型的转换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os&lt;/code&gt;：操作系统功能接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sync&lt;/code&gt;：提供同步基础功能，如排它锁等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flag&lt;/code&gt;：命令行参数解析。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;encoding/json&lt;/code&gt;：用于编码解码&lt;code&gt;JSON&lt;/code&gt;对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;html/template&lt;/code&gt;：生成文本输出的数据驱动模板。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net/http&lt;/code&gt;：解析&lt;code&gt;HTTP&lt;/code&gt;请求响应，URL提供了一个可扩展的&lt;code&gt;HTTP&lt;/code&gt;服务和客户端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsafe&lt;/code&gt;：提供超出 Go 类型安全的功能（指针类型转换等）。通常应该不使用它。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reflect&lt;/code&gt;：用于实现运行时反射功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os/exec&lt;/code&gt;：用于运行外部命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基础知识&lt;/h2&gt;
&lt;p&gt;Go 有指针但没有指针运算，因此他们更像 C 里的引用。调用函数时，总是传值的。因此为了修改传递的参数，应该使用指针。
新声明的指针与其它类型一样也被赋了零值，它的值为&lt;code&gt;nil&lt;/code&gt;，表示它不指向任何东西。为了让它指向某些东西，需要使用取地址操作符&lt;code&gt;&amp;amp;&lt;/code&gt;来获取地址。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%v"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;//nil&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%v"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;//指针地址&lt;/span&gt;
&lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%v\n"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="nei-cun-fen-pei"&gt;内存分配&lt;/h3&gt;
&lt;p&gt;Go 有垃圾收集器，使用&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;make&lt;/code&gt;分配内存。它们的区别：&lt;/p&gt;
&lt;h4 id="new"&gt;&lt;code&gt;new&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;的行为与其它语言中差不多：&lt;code&gt;new(T)&lt;/code&gt;分配&lt;code&gt;T&lt;/code&gt;类型的零值并返回它的地址，值为&lt;code&gt;*T&lt;/code&gt;类型。
要注意返回的是零值。比如&lt;code&gt;bytes.Buffer&lt;/code&gt;的零值为空的缓冲。&lt;code&gt;sync.Mutex&lt;/code&gt;的零值是一个未上锁的互斥量。
分配内存与声明都会初始化为零值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;SyncedBuffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="nx"&gt;SyncedBuffer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的&lt;code&gt;p&lt;/code&gt;和&lt;code&gt;v&lt;/code&gt;都能马上使用。&lt;/p&gt;
&lt;h4 id="make"&gt;&lt;code&gt;make&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;make(T, args)&lt;/code&gt;与&lt;code&gt;new(T)&lt;/code&gt;的目标不同，它只用于创建&lt;code&gt;slice&lt;/code&gt;，&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;channel&lt;/code&gt;，并且它返回的是初始化过的（非零值）&lt;code&gt;T&lt;/code&gt;而不是&lt;code&gt;*T&lt;/code&gt;。原因在于这三种类型的底层数据结构在使用前需要初始化。以&lt;code&gt;slice&lt;/code&gt;为例如果不初始化它的初始值为&lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="gou-zao-qi-he-chu-shi-hua"&gt;构造器和初始化&lt;/h4&gt;
&lt;p&gt;有些情况下零值不能直接使用需要进行初始化。以&lt;code&gt;os&lt;/code&gt;中的一个方法为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;NewFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;File&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;fd&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;File&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;fd&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;direinfo&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;nepipe&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以简化为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;NewFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;File&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;fd&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;File&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的创建文件对象的一行，还可以简化为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;File&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未传递的字段将会是字段类型的零值。即&lt;code&gt;new(File)&lt;/code&gt;与&lt;code&gt;&amp;amp;File{}&lt;/code&gt;是等效的。&lt;/p&gt;
&lt;h3 id="zi-ding-yi-lei-xing_1"&gt;自定义类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;type foo int&lt;/code&gt;创建了一个与&lt;code&gt;int&lt;/code&gt;相同的类型。更复杂的类型需要使用&lt;code&gt;struct&lt;/code&gt;关键字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;NameAge&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="c1"&gt;//不导出&lt;/span&gt;
    &lt;span class="nx"&gt;age&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;     &lt;span class="c1"&gt;//不导出&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="jie-gou-zi-duan"&gt;结构字段&lt;/h4&gt;
&lt;p&gt;结构体的每个项是一个字段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;A&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;F&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果忽略字段名，那么会创建一个匿名字段：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;T1&lt;/span&gt;      &lt;span class="c1"&gt;//自动产生名称为 T1 的字段&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;T2&lt;/span&gt;     &lt;span class="c1"&gt;//自动产生名称为 *T2 的字段&lt;/span&gt;
    &lt;span class="nx"&gt;P&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;T3&lt;/span&gt;    &lt;span class="c1"&gt;//自动产生名称为 T3 的字段&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字段名以大写开头的会被导出，可以被其它包读写。小写开头的字段是对当前包私有的。&lt;/p&gt;
&lt;h4 id="fang-fa"&gt;方法&lt;/h4&gt;
&lt;p&gt;有两种方法可以创建处理所定义的类型的函数：
1. 函数调用：创建函数时带类型参数（即函数参数类型）：&lt;code&gt;func doSomething(n1 *NameAge, n2 int){}&lt;/code&gt;
2. 方法调用：创建只工作于特定类型的函数：&lt;code&gt;func (n1 *NameAge) doSomething(n2 int){}&lt;/code&gt;，使用：&lt;code&gt;var n*NameAge; n.doSomething(2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用函数或方法取决于程序员，但是满足接口时必须使用方法。
在上面的情况中这种代码不是错误：&lt;code&gt;var n NameAge; n.doSomething(2)&lt;/code&gt;这里&lt;code&gt;a&lt;/code&gt;不是指针。这种情况下 Go 会搜索类型&lt;code&gt;NameAge&lt;/code&gt;的方法列表，找不到之后将会搜索类型&lt;code&gt;*NameAge&lt;/code&gt;的方法列表，然后将方法调用转化为&lt;code&gt;(&amp;amp;n).doSomething(2)&lt;/code&gt;。
定义结构时的方法不同会导致结构所包含的方法也不同，有结构体&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Mutex&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;Lock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;Unlock&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后定义两种新的类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;NewMutex&lt;/span&gt; &lt;span class="nx"&gt;Mutex&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;PrintableMutex&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;Mutex&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在&lt;code&gt;NewMutex&lt;/code&gt;与&lt;code&gt;Mutex&lt;/code&gt;是相等的，但是它没有&lt;code&gt;Mutex&lt;/code&gt;的任何方法，它的方法是空的。但是&lt;code&gt;PrintableMutex&lt;/code&gt;继承了&lt;code&gt;Mutex&lt;/code&gt;的方法，它的&lt;code&gt;Mutex&lt;/code&gt;属性上绑定了&lt;code&gt;Lock&lt;/code&gt;和&lt;code&gt;Unlock&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id="lei-xing-zhuan-huan_1"&gt;类型转换&lt;/h3&gt;
&lt;p&gt;类型转换由操作符完成，但看起来像是函数调用，如：&lt;code&gt;byte()&lt;/code&gt;。不是所有转换都是允许的。
别名类型同样需要转换，不能直接赋值。&lt;/p&gt;
&lt;h3 id="zu-he"&gt;组合&lt;/h3&gt;
&lt;p&gt;当前的 Go 不是面向对象的编程语言因此没有继承，需要实现&amp;ldquo;继承&amp;rdquo;效果时可以嵌入一个类型。&lt;/p&gt;
&lt;h2&gt;接口&lt;/h2&gt;
&lt;p&gt;Go 中&lt;code&gt;interface&lt;/code&gt;有多种含义。所有类型都有一个接口，就是该类型定义的方法的集合。例如：
```type S struct { i int}
func (p &lt;em&gt;S) Get() int {return p.i }
func (p &lt;/em&gt;S) Put(v int) { p.i = v }&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;你可以定义一个接口类型：
```go
type I inteface {
    Get() int
    Put(int)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;S&lt;/code&gt;是实现了接口&lt;code&gt;I&lt;/code&gt;的，因为它定义了两个&lt;code&gt;I&lt;/code&gt;所需要的方法。注意，实现接口并不需要显式的声明。
使用接口值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="nx"&gt;I&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Get&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里&lt;code&gt;p&lt;/code&gt;是一个接口类型的值。&lt;code&gt;S&lt;/code&gt;实现了接口&lt;code&gt;I&lt;/code&gt;，我们可以传递指向类型&lt;code&gt;S&lt;/code&gt;的指针给函数：&lt;code&gt;var s S; f(&amp;amp;s)&lt;/code&gt;。这里需要传递指针的原因在于我们将方法定义在操作指针类型上了。这不是必需的&amp;mdash;&amp;mdash;我们可以将方法定义的值上&amp;mdash;&amp;mdash;但是&lt;code&gt;Put&lt;/code&gt;方法将不会按期望的方式工作。
事实上 Go 是鸭式类型，不需要声明一个类型是否实现了某一类型。但它不是纯的鸭式类型，因为 Go 编译嘎嘎将进行静态类型检查，检查精英是否实现了接口。但是，Go 有真正的动态特性，它将一种接口转化为另一接口。通常情况下，这一转换发生在运行时。如果转换失败，程序将出错并产生运行时错误。
Go 中的接口与其它语言中的理念类似：&lt;code&gt;C++&lt;/code&gt;中的纯抽像虚拟基类，&lt;code&gt;Haskell&lt;/code&gt;中的&lt;code&gt;typeclasses&lt;/code&gt;或&lt;code&gt;Python&lt;/code&gt;中的鸭式类型。但是其它语言没有能组合接口值、静态类型检查、运行时动态类型转换并且不需要显式的在类型声明时声明它满足某个接口。因此 Go 中的接口是非常强大、具有弹性、高效并且易于编写的。
当有多个类型实现某一接口时，可以根据类型进行处理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="nx"&gt;I&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;S&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;R&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;S&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;R&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;code&gt;switch&lt;/code&gt;之外使用&lt;code&gt;(type)&lt;/code&gt;是非法的。这并不是唯一一种在运行时检查类型的方法。你也可以使用&lt;code&gt;; ok&lt;/code&gt;的格式检查接口类型是否实现了特定的接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;something&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="nx"&gt;I&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// something 实现了接口 I&lt;/span&gt;
    &lt;span class="c1"&gt;// t 是类型&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当你确定变量实现了某一接口时可以用&lt;code&gt;t := something.(I)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;空接口&lt;/em&gt;
因为每个类型都满足空接口：&lt;code&gt;interface {}&lt;/code&gt;。我们可以定义一个通用函数以空接口作为它的参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;something&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;something&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="nx"&gt;I&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;Get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用这一方法是要注意，传递给&lt;code&gt;g&lt;/code&gt;的参数不管是否实现了接口&lt;code&gt;I&lt;/code&gt;时都不会产生编译错误，但在运行时，如果参数未实现接口&lt;code&gt;I&lt;/code&gt;就会产生运行时错误。&lt;/p&gt;
&lt;h3 id="fang-fa_1"&gt;方法&lt;/h3&gt;
&lt;p&gt;方法是有接收者的函数。可以在任何类型上定义方法（不能定义在属于其它包的类型上，同样也包括内置的&lt;code&gt;int&lt;/code&gt;类型）。但是你可以定义自己的&lt;code&gt;int&lt;/code&gt;类型然后添加方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;self&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;Emit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"%v"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Emitter&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;Emit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="jie-kou-lei-xing-shang-de-fang-fa"&gt;接口类型上的方法&lt;/h4&gt;
&lt;p&gt;接口定义了方法集，方法包含了实际的代码。即方法是接口的实现。因此接收者（receiver）不能是接口类型。
接收类型必须是&lt;code&gt;T&lt;/code&gt;或&lt;code&gt;*T&lt;/code&gt;格式，&lt;code&gt;T&lt;/code&gt;是类型名。&lt;code&gt;T&lt;/code&gt;被称为接收者基础类型。这个基础类型不能是指针或接口类型必须定义在与方法相同的包里。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;接口指针&lt;/em&gt;
Go 中使用接口指针是没有必要的。实际上创建指向接口值的指针是非法的。&lt;/p&gt;
&lt;h3 id="jie-kou-ming-cheng_1"&gt;接口名称&lt;/h3&gt;
&lt;p&gt;通常，只有一个方法的接口被命名为方法名加&lt;code&gt;-er&lt;/code&gt;后缀。&lt;/p&gt;
&lt;h4 id="nei-sheng-he-fan-she"&gt;内省和反射&lt;/h4&gt;
&lt;p&gt;下例展示了如何通过反射包检查定义在类型&lt;code&gt;Person&lt;/code&gt;中的&lt;code&gt;tag&lt;/code&gt;（&lt;code&gt;namestr&lt;/code&gt;）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt; &lt;span class="nx"&gt;Person&lt;/span&gt; &lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="s"&gt;"namestr"&lt;/span&gt;   &lt;span class="c1"&gt;// namestr 是 tag&lt;/span&gt;
    &lt;span class="nx"&gt;age&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;ShowTag&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//使用 *Person 来调用&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TypeOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Kind&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Ptr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nx"&gt;tag&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Elem&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;Tag&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用反射获取类型和值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt;&lt;span class="p"&gt;{})&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;Person&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nx"&gt;t&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TypeOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//类型元数据&lt;/span&gt;
            &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;reflect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ValueOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//实际值&lt;/span&gt;
            &lt;span class="nx"&gt;tag&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Elem&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;Tag&lt;/span&gt;
            &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Elem&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;Field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;String&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置值的方式与获取值的方式类似，但是只允许在导出成员上使用，在私有成员上使用时会产生运行时错误。&lt;/p&gt;
&lt;h2&gt;并发程序&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;goroutine&lt;/code&gt;与已有的线程、协程或进程等概念不完全一样。它有自己的模型：它是与其它&lt;code&gt;goroutine&lt;/code&gt;并行执行的，有着相同的地址空间的函数。它是轻量级的，仅比分配栈空间多一点点消耗。而初始时栈是很小的，所以它们也是廉价的，并且随着需要在堆空间上分配（和释放）。
&lt;code&gt;goroutine&lt;/code&gt;是个普通函数，只需要使用关键字&lt;code&gt;go&lt;/code&gt;作为 开头。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tea"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;//普通函数调用&lt;/span&gt;
&lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tea"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//作为 goroutine 运行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在程序退出时，所有&lt;code&gt;goroutine&lt;/code&gt;都会停止。为了修复这个问题，需要一些能够同&lt;code&gt;goroutine&lt;/code&gt;通讯的机制。这一机制通过&lt;code&gt;channels&lt;/code&gt;的形式使用。&lt;code&gt;channel&lt;/code&gt;与&lt;code&gt;Unix shell&lt;/code&gt;中的双向管道类似：可以通过它发送或接收值。这些值只能是特定的类型：&lt;code&gt;channel&lt;/code&gt;类型。定义它时也需要定义发送到&lt;code&gt;channel&lt;/code&gt;的值的类型。必须使用&lt;code&gt;make&lt;/code&gt;创建&lt;code&gt;channel&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="c1"&gt;//定义传输整数的全局的 channel&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;sec&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Duration&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Second&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;ft&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"is ready!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;      &lt;span class="c1"&gt;//发送整数 1&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//初始化 c&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Tea"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//开始 goroutine&lt;/span&gt;
    &lt;span class="k"&gt;go&lt;/span&gt; &lt;span class="nx"&gt;ready&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Coffee"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"I'm waiting, but not too long"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;     &lt;span class="c1"&gt;//从 channel 上接收值，收到的值将被丢弃&lt;/span&gt;
    &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个列子仍然有些问题，它从&lt;code&gt;channel&lt;/code&gt;上读取了两次。如果在不知道启动了多少个&lt;code&gt;goroutine&lt;/code&gt;的情况下怎么办呢？这就要使用到 Go 的另一个关键字：&lt;code&gt;select&lt;/code&gt;。通过&lt;code&gt;select&lt;/code&gt;可以监听&lt;code&gt;channel&lt;/code&gt;上输入的数据。将上例中的两行&lt;code&gt;&amp;lt;-c&lt;/code&gt;换以下代码之后，程序会一直等下去，只到从&lt;code&gt;channel c&lt;/code&gt;上收到多个响应时才会退出循环L。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;L&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="nx"&gt;L&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然&lt;code&gt;goroutine&lt;/code&gt;是并发执行的，但它们并不是并行运行的。如果不告诉 Go 额外的东西，同一时刻只会有一个&lt;code&gt;goroutine&lt;/code&gt;执行。利用&lt;code&gt;runetime.GOMAXPROCS(n)&lt;/code&gt;可以设置&lt;code&gt;goroutine&lt;/code&gt;并行执行的数量。
&lt;code&gt;GOMAXPROCS&lt;/code&gt;设置了同时运行的&lt;code&gt;CPU&lt;/code&gt;的最大数量，并返回之前的设置。如果&lt;code&gt;n&amp;lt;1&lt;/code&gt;，不会改变当前设置。也可以通过设置环境变量&lt;code&gt;GOMAXPROCS&lt;/code&gt;为它设置值。&lt;/p&gt;
&lt;h3 id="geng-duo-guan-yu-channel_1"&gt;更多关于 channel&lt;/h3&gt;
&lt;p&gt;在 Go 中使用&lt;code&gt;ch := make(chan bool)&lt;/code&gt;创建&lt;code&gt;channel&lt;/code&gt;时，&lt;code&gt;bool&lt;/code&gt;型的无缓冲&lt;code&gt;channel&lt;/code&gt;将被创建。这意味着：首先，如果读取（&lt;code&gt;value := &amp;lt;- ch&lt;/code&gt;）它将会被阻塞，直到有数据接收。其次，任何发送（&lt;code&gt;ch&amp;lt;-5&lt;/code&gt;）将会被阻塞，直到数据被读出。无缓冲&lt;code&gt;channel&lt;/code&gt;可以方便的在多个&lt;code&gt;goroutine&lt;/code&gt;间同步。
Go 也允许指定&lt;code&gt;channel&lt;/code&gt;缓冲区的大小，用于设定&lt;code&gt;channel&lt;/code&gt;可存储元素的数量。&lt;code&gt;ch := make(chan bool, 4)&lt;/code&gt;创建了可以存储 4 个元素的&lt;code&gt;bool&lt;/code&gt;型&lt;code&gt;channel&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关闭 channel &lt;/em&gt;
当&lt;code&gt;channel&lt;/code&gt;被关闭后，读取端需要知道这个事情。下面的代码演示了如何检查&lt;code&gt;channel&lt;/code&gt;是否被关闭:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当&lt;code&gt;ok&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;时意味着&lt;code&gt;channel&lt;/code&gt;未被关闭，可以读取数据。否则表示它已经被关闭了。&lt;/p&gt;
&lt;h2&gt;通讯&lt;/h2&gt;
&lt;h3 id="ioreader"&gt;io.Reader&lt;/h3&gt;
&lt;p&gt;Go 的 I/O 核心是接口&lt;code&gt;io.Reader&lt;/code&gt;和&lt;code&gt;io.Writer&lt;/code&gt;。
在 Go 中读写文件使用&lt;code&gt;os&lt;/code&gt;包就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;"os"&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/etc/passwd"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Stdout&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缓冲 I/O，则需要&lt;code&gt;bufio&lt;/code&gt;包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"os"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="s"&gt;"bufio"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;buf&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/etc/passwd"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nx"&gt;r&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;bufio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewReader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;w&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;bufio&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewWriter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Stdout&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Flush&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;r&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nx"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ming-ling-xing-can-shu"&gt;命令行参数&lt;/h3&gt;
&lt;p&gt;命令行参数在程序中通过&lt;code&gt;os.Args&lt;/code&gt;获取。&lt;code&gt;flags&lt;/code&gt;包提供了接口来解析参数。&lt;/p&gt;
&lt;h3 id="zhi-xing-ming-ling"&gt;执行命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;os/exec&lt;/code&gt;包可以执行外部命令，这也是在 Go 中主要的执行命令的方法。&lt;/p&gt;
&lt;h3 id="wang-luo"&gt;网络&lt;/h3&gt;
&lt;p&gt;所有网络相关的类型和函数可以在&lt;code&gt;net&lt;/code&gt;包中找到。&lt;/p&gt;</content><category term="go"></category></entry><entry><title>Scala Cookbook 笔记</title><link href="/scala-cookbook-bi-ji.html" rel="alternate"></link><published>2015-05-21T00:00:00+08:00</published><updated>2015-05-21T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-21:/scala-cookbook-bi-ji.html</id><summary type="html">&lt;h1&gt;Scala Cookbook 笔记&lt;/h1&gt;
&lt;h2&gt;String&lt;/h2&gt;
&lt;h3 id="jian-jie"&gt;简介&lt;/h3&gt;
&lt;p&gt;Scala String 是 Java String，可以使用 Java 中 String 对象的方法。由于 Scala 提供了隐式转换，因此 String（即使它是 final 的） 实例也可以使用 StringOps 类中的所有方法，因此你可以将字符串实例当作字符序列。对它使用 foreach 或使用 for 循环。字符串的另一些功能来自于 StringLike 和 WrappedString 等类。String 类至 StringOps 的隐式转换源于 Predef 对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;
&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Scala Cookbook 笔记&lt;/h1&gt;
&lt;h2&gt;String&lt;/h2&gt;
&lt;h3 id="jian-jie"&gt;简介&lt;/h3&gt;
&lt;p&gt;Scala String 是 Java String，可以使用 Java 中 String 对象的方法。由于 Scala 提供了隐式转换，因此 String（即使它是 final 的） 实例也可以使用 StringOps 类中的所有方法，因此你可以将字符串实例当作字符序列。对它使用 foreach 或使用 for 循环。字符串的另一些功能来自于 StringLike 和 WrappedString 等类。String 类至 StringOps 的隐式转换源于 Predef 对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getClass&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;
&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scala String 同时拥有字符串和集合特性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"scala"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;drop&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;take&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;capitalize&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="xiang-deng-xing"&gt;相等性&lt;/h3&gt;
&lt;p&gt;Scala 中直接使用 &lt;code&gt;==&lt;/code&gt; 比较字符串。这个操作不会在对象为 &lt;code&gt;null&lt;/code&gt; 时抛出空指针异常。如果在比较时要忽略大小写，则可以将要比较的字符串都转换为大写或小写。在 &lt;code&gt;null&lt;/code&gt; 上调用大小写转换方法时是会产生空指针异常的。也可以直接使用 Java String 的&lt;code&gt;equalsIgnoreCase&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s3&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s4&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;
&lt;span class="n"&gt;s3&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;s4&lt;/span&gt;
&lt;span class="n"&gt;s4&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;s3&lt;/span&gt; &lt;span class="c1"&gt;//不产生异常&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scala 中使用&lt;code&gt;==&lt;/code&gt;比较对象相等性，而不是使用&lt;code&gt;equals&lt;/code&gt;方法。&lt;code&gt;==&lt;/code&gt;定义在 AnyRef 中，它会先检查是否为 null，然后再调用&lt;code&gt;equal&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id="duo-xing-zi-fu-chuan"&gt;多行字符串&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"""This is&lt;/span&gt;
&lt;span class="s"&gt;a multiline&lt;/span&gt;
&lt;span class="s"&gt;String"""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;多行字符串的对齐&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//默认按|对齐&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;speech&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"""Four score and&lt;/span&gt;
&lt;span class="s"&gt;|seven years ago"""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stripMargin&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;speech&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"""Four score and&lt;/span&gt;
&lt;span class="s"&gt;#seven years ago"""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stripMargin&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;//多行转单行&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;speech&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"""Four score and&lt;/span&gt;
&lt;span class="s"&gt;#seven years ago"""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stripMargin&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="sc"&gt;'#'&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;replaceAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zi-fu-chuan-fen-ge"&gt;字符串分割&lt;/h3&gt;
&lt;p&gt;字符串分割时使用的&lt;code&gt;split&lt;/code&gt;来自于 Java String 类型，如果传递的参数是字符则使用的是来自 StringLike 类的方法。两者不同的地方在于返回值的类型为 Array[java.lang.String] 和 Array[String]，一般情况下这一区别并不重要。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"hello world"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Array[java.lang.String] = Array(hello, world)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"eggs, milk, butter, Coco Puffs"&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;","&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Array[java.lang.String] = Array(eggs, " milk", " butter", " Coco Puffs")&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;","&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Array[java.lang.String] = Array(eggs, milk, butter, Coco Puffs)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ti-huan-zi-fu-chuan-zhong-de-bian-liang"&gt;替换字符串中的变量&lt;/h3&gt;
&lt;p&gt;Scala 2.10 开始你可以使用 string interpolation。使用时需要在字符串前加 &lt;code&gt;s&lt;/code&gt; 前缀，在字符串中包含的变量名前添加 &lt;code&gt;$&lt;/code&gt; 符号。表达式则需要嵌入在 &lt;code&gt;${}&lt;/code&gt; 间。&lt;code&gt;s&lt;/code&gt;是一种前缀，使用&lt;code&gt;f&lt;/code&gt;时可以使用&lt;code&gt;printf&lt;/code&gt;方式格式化显示内容。使用&lt;code&gt;raw&lt;/code&gt;前缀时不会对内容进行转义。除了这3种 Scala 2.10 内置的解析器外，你也可以定义自己的解析器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Fred"&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;200.00&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s"&lt;/span&gt;&lt;span class="si"&gt;$name&lt;/span&gt;&lt;span class="s"&gt; is &lt;/span&gt;&lt;span class="si"&gt;$age&lt;/span&gt;&lt;span class="s"&gt; years old, and weight &lt;/span&gt;&lt;span class="si"&gt;$weight&lt;/span&gt;&lt;span class="s"&gt; pounds."&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s"Age next years: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s"You are 33 years old: &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Student&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;score&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;hannah&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Student&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hannah"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;95&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;s"&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;hannah&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt; has a score of &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="n"&gt;hannah&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;score&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;f"&lt;/span&gt;&lt;span class="si"&gt;$name&lt;/span&gt;&lt;span class="s"&gt; is &lt;/span&gt;&lt;span class="si"&gt;$age&lt;/span&gt;&lt;span class="s"&gt; years old, and weighs &lt;/span&gt;&lt;span class="si"&gt;$weight&lt;/span&gt;&lt;span class="s"&gt;%.2f pounds."&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Fred is 33 years old, and weighs 200.00 pounds.&lt;/span&gt;

&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;f"&lt;/span&gt;&lt;span class="si"&gt;$name&lt;/span&gt;&lt;span class="s"&gt; is &lt;/span&gt;&lt;span class="si"&gt;$age&lt;/span&gt;&lt;span class="s"&gt; years old, and weighs &lt;/span&gt;&lt;span class="si"&gt;$weight&lt;/span&gt;&lt;span class="s"&gt;%.0f pounds."&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Fred is 33 years old, and weighs 200 pounds.&lt;/span&gt;

&lt;span class="s"&gt;raw"foo\nbar"&lt;/span&gt;
&lt;span class="c1"&gt;//foo\nbar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.10 之前的版本可以使用 string 的&lt;code&gt;format&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"%s is %d years old"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//Fred is 33 years old&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以在类的&lt;code&gt;toString&lt;/code&gt;中使用这一方法来输出对象内容。&lt;/p&gt;
&lt;h3 id="chu-li-zi-fu-chuan-zhong-de-zi-fu"&gt;处理字符串中的字符&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello world"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUpper&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello world"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUpper&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello, world"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUpper&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;upper&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUpper&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="s"&gt;"hello, world"&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;'l'&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toUpper&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toLower&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toByte&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;
&lt;span class="s"&gt;"HELLO"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;toLower&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;toLower&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toByte&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;
&lt;span class="s"&gt;"HELLO"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;toLower&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zi-fu-chuan-mo-shi-pi-pei"&gt;字符串模式匹配&lt;/h3&gt;
&lt;p&gt;调用字符串的&lt;code&gt;.r&lt;/code&gt;方法可以创建正则表达式对象，使用它的&lt;code&gt;findFirstIn&lt;/code&gt;返回第一个匹配，使用&lt;code&gt;findAllIn&lt;/code&gt;返回所有匹配。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;numPattern&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"[0=9]+"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"123 Main Street Suite 101"&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;match1&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numPattern&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findFirstIn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//match1: Option[String] = Some(123)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;matchs&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numPattern&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAllIn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;//matches: scala.util.matching.Regex.MatchIterator = non-empty iterator&lt;/span&gt;
&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;matches&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numPattern&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findAllIn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toArray&lt;/span&gt;
&lt;span class="c1"&gt;//Array[String] = Array(123, 101)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建&lt;code&gt;Regex&lt;/code&gt;对象的另一方式是使用&lt;code&gt;scala.util.matching.Regex&lt;/code&gt;类。
&lt;code&gt;findFirstIn&lt;/code&gt;的结果是&lt;code&gt;Option[String]&lt;/code&gt;，它可能的值为&lt;code&gt;Some(String)&lt;/code&gt;或&lt;code&gt;None&lt;/code&gt;。使用&lt;code&gt;Options&lt;/code&gt;的几种方法：
 - 调用&lt;code&gt;getOrElse&lt;/code&gt;获取值
 - 在&lt;code&gt;match&lt;/code&gt;表达式中使用&lt;code&gt;Option&lt;/code&gt;
 - 在&lt;code&gt;foreach&lt;/code&gt;中使用&lt;code&gt;Option&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="zi-fu-chuan-mo-shi-ti-huan"&gt;字符串模式替换&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"123 Main Street"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"[0-9]"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;regex&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"[0-9]"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;newAddress&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;regex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceAllIn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"123 Main Street"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceFirst&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"[0-9]"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;regex&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"H"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;regex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceFirstIn&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello world"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"J"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zi-fu-chuan-mo-shi-ti-qu"&gt;字符串模式提取&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"([0-9]+) ([A-Za-z]+)"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;fruit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"100 Bananas"&lt;/span&gt;
&lt;span class="c1"&gt;//count: String = 100&lt;/span&gt;
&lt;span class="c1"&gt;//fruit: String = Bananas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语法看起来有些奇怪像是将&lt;code&gt;pattern&lt;/code&gt;定义了两次。&lt;/p&gt;
&lt;h3 id="fang-wen-zi-fu-chuan-zhong-de-zi-fu"&gt;访问字符串中的字符&lt;/h3&gt;
&lt;p&gt;使用 Java 中的&lt;code&gt;charAt&lt;/code&gt;方法，或是像 Scala 的数组那样使用字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;charAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常可以用&lt;code&gt;map&lt;/code&gt;或&lt;code&gt;foreach&lt;/code&gt;来遍历字符串中的字符，也可以把字符串当作数组。&lt;/p&gt;
&lt;h3 id="xiang-string-lei-zhong-tian-jia-fang-fa"&gt;向 String 类中添加方法&lt;/h3&gt;
&lt;p&gt;从 Scala 2.10，你可以定义隐式类，通过这个类里的方法来增加你需要的功能。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StringImprovements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;隐式类必须定义在类、对象或包对象里。然后在需要使用的地方导入这个类。
对于 Scala 2.10 之前的版本可以通过隐式转换的方式向类中添加方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StringImprovements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;stringToString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;StringImprovements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建议在隐式转换类中定义的方法应该注明返回值。特别是在遇到编译器找不到你的隐式类中的方法时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;implicit&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StringImprovements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// 显式的标明每个方法都返回一个字符串&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;increment&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;decrement&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;==&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;toChar&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;hideAll&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replaceAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"."&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尽管上面的例子都是返回的字符串，但是你可以在这些方法中返回任何类型。&lt;/p&gt;
&lt;h2&gt;数字&lt;/h2&gt;
&lt;h3 id="jie-shao"&gt;介绍&lt;/h3&gt;
&lt;p&gt;Scala 中所有数值类型都是对象。获取表达范围：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;Short&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;MinValue&lt;/span&gt;
&lt;span class="nc"&gt;Short&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;MaxValue&lt;/span&gt;
&lt;span class="nc"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;MinValue&lt;/span&gt;
&lt;span class="nc"&gt;Float&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;MinValue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于&lt;em&gt;复数和日期&lt;/em&gt;等复杂类型来说，有很多第三方项目提供了支持。如&lt;code&gt;Spire project&lt;/code&gt;提供了有理数、复数、实数等类型，而&lt;code&gt;nscala-time&lt;/code&gt;则提供了对&lt;code&gt;Joda Time&lt;/code&gt;的封装。&lt;/p&gt;
&lt;h3 id="cong-wen-ben-zhong-jie-xi-shu-zi"&gt;从文本中解析数字&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;StringLike&lt;/code&gt;trait 提供了&lt;code&gt;to*&lt;/code&gt;方法用于将字符串转换成数字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;
&lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toByte&lt;/span&gt;
&lt;span class="s"&gt;"foo"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt; &lt;span class="c1"&gt;//出错&lt;/span&gt;
&lt;span class="err"&gt;```&lt;/span&gt;&lt;span class="n"&gt;`&lt;/span&gt;
&lt;span class="n"&gt;如果想要标明转换时可能发生异常可以使用`&lt;/span&gt;&lt;span class="nd"&gt;@throws&lt;/span&gt;&lt;span class="n"&gt;`注解，特别是给 Java 调用时。&lt;/span&gt;
&lt;span class="n"&gt;`&lt;/span&gt;&lt;span class="err"&gt;``&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;
&lt;span class="c1"&gt;//不需要添加 throws &lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;

&lt;span class="nd"&gt;@throws&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;classOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;NumberFormatException&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者使用&lt;code&gt;Option/Some/None&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Optiion&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;NumberFormatException&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后使用&lt;code&gt;getOrElse&lt;/code&gt;或&lt;code&gt;match&lt;/code&gt;来取值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;getOrElse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aString&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Boom! That wasn't a number."&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;toInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;aString&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="zai-shu-zhi-lei-xing-jian-zhuan-huan"&gt;在数值类型间转换&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mf"&gt;19.45&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toInt&lt;/span&gt;     &lt;span class="c1"&gt;// 19&lt;/span&gt;
&lt;span class="mf"&gt;19.&lt;/span&gt;&lt;span class="n"&gt;toFloat&lt;/span&gt;      &lt;span class="c1"&gt;// 19.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不能像在 Java 中那样进行数值类型间的转换，而应该使用&lt;code&gt;to*&lt;/code&gt;方法。
为了避免转换失败，可以使用&lt;code&gt;isValid&lt;/code&gt;方法进行类型的检查：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100L&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isValidByte&lt;/span&gt;       &lt;span class="c1"&gt;// false&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isValidShort&lt;/span&gt;      &lt;span class="c1"&gt;// true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="fu-gai-mo-ren-de-shu-zhi-lei-xing"&gt;覆盖默认的数值类型&lt;/h4&gt;
&lt;p&gt;Scala 会在定义数值型变量时给予默认的数据类型。也可以覆盖默认的类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;span class="c1"&gt;//Int&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;      &lt;span class="c1"&gt;//Double&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;      &lt;span class="c1"&gt;//Float&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000L&lt;/span&gt;   &lt;span class="c1"&gt;//Long&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种方式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Byte&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x20&lt;/span&gt;    &lt;span class="c1"&gt;//Int 32&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x20&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;   &lt;span class="c1"&gt;//Long 32&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="dai-ti-he-"&gt;代替&lt;code&gt;++&lt;/code&gt;和&lt;code&gt;--&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;val&lt;/code&gt;是不可变的，因此不能使用自增和自减。但是&lt;code&gt;var Int&lt;/code&gt;是可以使用&lt;code&gt;+=&lt;/code&gt;和&lt;code&gt;-=&lt;/code&gt;来修改的，同样也可以使&lt;code&gt;*=&lt;/code&gt;和&lt;code&gt;/=&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="bi-jiao-fu-dian-shu-zhi"&gt;比较浮点数值&lt;/h4&gt;
&lt;p&gt;与在 Java 和其它语言类似，通过一个方法来指定需要比较的精度：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="o"&gt;~=(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;precision&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;={&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;precision&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外还可以结合隐式转换和工具类来处理。&lt;/p&gt;
&lt;h4 id="chu-li-fei-chang-da-de-shu-zhi"&gt;处理非常大的数值&lt;/h4&gt;
&lt;p&gt;使用 Scala 提供的&lt;code&gt;BigInt&lt;/code&gt;和&lt;code&gt;BigDecimal&lt;/code&gt;来处理大数值。与 Java 中不同的是这两个类支持其它数值类型的所有操作符，它们的底层仍然是 Java 中的&lt;code&gt;BigInteger&lt;/code&gt;和&lt;code&gt;BigDecimal&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id="sheng-cheng-sui-ji-shu-zi"&gt;生成随机数字&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;scala.util.Random&lt;/code&gt;生成随机数。这个类可以处理所有常见的用例，也可以用它来生成随机字符。&lt;/p&gt;
&lt;h4 id="chuang-jian-rang-listhuo-shu-zi-shu-zu"&gt;创建&lt;code&gt;Rang&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;或数字数组&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;            &lt;span class="c1"&gt;//Range(1,3,5,7,9)&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;     &lt;span class="c1"&gt;//Vector(2,4,6,8,10)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="ge-shi-hua-shu-zi-he-jin-e"&gt;格式化数字和金额&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pi&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"$p%1.5f"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;//3.14159&lt;/span&gt;
&lt;span class="s"&gt;f"&lt;/span&gt;&lt;span class="si"&gt;$pi&lt;/span&gt;&lt;span class="s"&gt;%1.5f"&lt;/span&gt;             &lt;span class="c1"&gt;//3.14159&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scala 2.10 之前的版本可以使用format方法。&lt;/p&gt;
&lt;h2&gt;控制结构&lt;/h2&gt;</content><category term="scala"></category></entry><entry><title>Build Machine Learning Systems with Python 笔记</title><link href="/build-machine-learning-systems-with-python-bi-ji.html" rel="alternate"></link><published>2015-05-18T00:00:00+08:00</published><updated>2015-05-18T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-18:/build-machine-learning-systems-with-python-bi-ji.html</id><summary type="html">&lt;h1&gt;Build Machine Learning Systems with Python 笔记&lt;/h1&gt;
&lt;h2&gt;起步&lt;/h2&gt;
&lt;p&gt;机器学习（ML）告诉机器如何自己处理任务。
机器学习计算的典型过程：
1. 读取和清理数据
2. 浏览和理解输入的数据
3. 分析如何以将数据呈现给学习算法
4. 选择合适的模型和学习算法
5. 准确的评估性能&lt;/p&gt;
&lt;h3 id="zhun-bei-gong-zuo"&gt;准备工作&lt;/h3&gt;
&lt;p&gt;安装NumPy、SciPy、Matplotlib。NumPy提供高度优化过的多维数组计算支持，这是多数先进算法的基础数据结构。SciPy使用这些数组来提供快速的算法实现。Matplotlib用于绘制高质量的图形。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Build Machine Learning Systems with Python 笔记&lt;/h1&gt;
&lt;h2&gt;起步&lt;/h2&gt;
&lt;p&gt;机器学习（ML）告诉机器如何自己处理任务。
机器学习计算的典型过程：
1. 读取和清理数据
2. 浏览和理解输入的数据
3. 分析如何以将数据呈现给学习算法
4. 选择合适的模型和学习算法
5. 准确的评估性能&lt;/p&gt;
&lt;h3 id="zhun-bei-gong-zuo"&gt;准备工作&lt;/h3&gt;
&lt;p&gt;安装NumPy、SciPy、Matplotlib。NumPy提供高度优化过的多维数组计算支持，这是多数先进算法的基础数据结构。SciPy使用这些数组来提供快速的算法实现。Matplotlib用于绘制高质量的图形。&lt;/p&gt;</content><category term="machine learn"></category><category term="python"></category></entry><entry><title>Hadoop In Action 笔记</title><link href="/hadoop-in-action-bi-ji.html" rel="alternate"></link><published>2015-05-18T00:00:00+08:00</published><updated>2015-05-18T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-18:/hadoop-in-action-bi-ji.html</id><summary type="html">&lt;h1&gt;Hadoop In Action 笔记&lt;/h1&gt;
&lt;h2&gt;MapReduce&lt;/h2&gt;
&lt;p&gt;MapRecuce程序执行的2个阶段，分别称为mapping和reducing。每个阶段都定义了数据处理函数，这些函数被称为mapper和reducer。在mapping阶段，MapReduce接收输入并将这些数据分别发送给mapper。在reducing阶段，reducer处理所有来自于mapper的输出并产生最终结果。简单来说mapper对输入进行过滤和转换（filter and transform）成reducer可以聚合（aggregate）的东西。
除mapping和reducing外还需要处理数据的分割和传送。但它们与mapper和reducer不同，它们通常与特定的数据处理过程无关。MapReduce框架提供了能满足于大多数情况下的缺省实现。
为便于处理需要一种足够强大的通用的数据结构。MapReduce使用list和pair(key/value)作为主要的数据结构。
MapReduce框架的数据处理过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用程序的输入必须被构建成包含pair（key/value）的list，list(k1,v1)。处理多个文件的输入格式通常为&lt;code&gt;list(&amp;lt;String filename, String file_content&amp;gt;)&lt;/code&gt;。处理单个大文件的格式可能是&lt;code&gt;list(&amp;lt;Integer line_number, String log_event&amp;gt;)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;list …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h1&gt;Hadoop In Action 笔记&lt;/h1&gt;
&lt;h2&gt;MapReduce&lt;/h2&gt;
&lt;p&gt;MapRecuce程序执行的2个阶段，分别称为mapping和reducing。每个阶段都定义了数据处理函数，这些函数被称为mapper和reducer。在mapping阶段，MapReduce接收输入并将这些数据分别发送给mapper。在reducing阶段，reducer处理所有来自于mapper的输出并产生最终结果。简单来说mapper对输入进行过滤和转换（filter and transform）成reducer可以聚合（aggregate）的东西。
除mapping和reducing外还需要处理数据的分割和传送。但它们与mapper和reducer不同，它们通常与特定的数据处理过程无关。MapReduce框架提供了能满足于大多数情况下的缺省实现。
为便于处理需要一种足够强大的通用的数据结构。MapReduce使用list和pair(key/value)作为主要的数据结构。
MapReduce框架的数据处理过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用程序的输入必须被构建成包含pair（key/value）的list，list(k1,v1)。处理多个文件的输入格式通常为&lt;code&gt;list(&amp;lt;String filename, String file_content&amp;gt;)&lt;/code&gt;。处理单个大文件的格式可能是&lt;code&gt;list(&amp;lt;Integer line_number, String log_event&amp;gt;)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;list(k1,v1)被分散为&lt;k1,v1&gt;对，然后调用mapper中的map函数来处理它。mapper将每个&lt;k1,v1&gt;转换成list(k2,v2)。转换的细节很大部分决定了这个MapReduce程序要做什么。需要注意的是，&lt;k1,v1&gt;的处理是无序的。转换过程必须是自包含的，它的输出只依赖于单个键值对。&lt;/k1,v1&gt;&lt;/k1,v1&gt;&lt;/k1,v1&gt;&lt;/li&gt;
&lt;li&gt;所有mapper的输出被聚合到一个巨大（概念上）的list&lt;k2,v2&gt;。拥有相同k2的被被分组到一个新的pair&lt;k2, list(v2)=""&gt;。然后框架调用reducer来处理这些被聚合过的pair(&lt;k2, list(v2)=""&gt;)。&lt;/k2,&gt;&lt;/k2,&gt;&lt;/k2,v2&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Hadoop的构成&lt;/h2&gt;
&lt;h3 id="namenode"&gt;NameNode&lt;/h3&gt;
&lt;p&gt;Hadoop最重要的守护进程&amp;mdash;&amp;mdash;NameNode。Hadoop的分布式存储和分布式计算都使采用了主/从架构。分布式存储系统称为HDFS。NameNode是HDFS中的&amp;ldquo;主&amp;rdquo;，它控制DataNode（&amp;ldquo;从&amp;rdquo;）执行低级别的IO任务。NameNode记录了文件是如何打碎成块的，哪个节点存储了这些块，并记录下了整个分布式文件系统的健康状况。
NameNode的功能是内存和IO消耗型的。因此，作为NameNode的服务器通常不存储用户数据和执行MapReduce程序的。这意味着NameNode服务不会同时作为DataNode或TaskTracker。
NameNode的重要性也导致了它是Hadoop集群的SPOF（single point of failure）。其它节点出现故障，Hadoop集群都可以正常工作，你也可以对快速的故障点进行重启。但是NameNode不行。&lt;/p&gt;
&lt;h3 id="datanode"&gt;DataNode&lt;/h3&gt;
&lt;p&gt;集群中的每个&amp;ldquo;从&amp;rdquo;机器都会运行DataNode守护进程以执行分布式文件系统的任务&amp;mdash;&amp;mdash;读取和写入HDFS块到其本地文件系统的文件中。当你读写HDFS文件时，NameNode告诉客户端哪个DataNode保存了这些文件块。客户端直接与这些DataNode进程通讯以读取这些块。DataNode之间也可以进行通讯，以进行数据块的冗余备份。
DataNode会不断的向NameNode报告它的情况，比如在初始化时，每个DataNode都会告诉NameNode它们当前所存储的块。这个过程结束后，DataNode会持续向NameNode提供本地的变化信息如：从本地磁盘中创建、移动或删除数据块。&lt;/p&gt;
&lt;h3 id="secondary-namenode"&gt;Secondary NameNode&lt;/h3&gt;
&lt;p&gt;SNN是用于监控HDFS集群状态的辅助进程。与NameNode类似，每个集群都有一个SNN，通常它在独立的服务器上运行。没有DataNode或TaskTracker进程一同运行在这个服务器上。SNN与NameNode不同，它不接收HDFS数据块的实时变化信息。而是与NameNode通讯，按集群配置文件所定义的时间间隔获取HDFS元数据的快照。
如NameNode一节所介绍的，NameNode是Hadoop集群的SPOF，SNN快照能帮助我们最小化停机时间和丢失数据。但是，NameNode故障仍然会需要人工干预来将一个SNN配置为主NameNode。&lt;/p&gt;
&lt;h3 id="jobtracker"&gt;JobTracker&lt;/h3&gt;
&lt;p&gt;JobTracker进程是联络应用程序和Haddoop的。当提交代码到集群中时，JobTracker会通根据要处理的文件决定执行计划，它给节点分配不同的任务，监控任务的执行。任务失败时，JobTracker会尽可能在另一节点上重启这个任务，直至达到所配置的重试次数限制。
每个Hadoop集群只有一个JobTracker。它通常运行在集群中某个作为主节点的服务器上。&lt;/p&gt;
&lt;h3 id="tasktracker"&gt;TaskTracker&lt;/h3&gt;
&lt;p&gt;与存储进程结构类似，计算进程也是使用了主/从架构：JobTracker是主，监督所有MapReduce任务，TaskTrackers管理各个任务在各从节点上的执行。
每个TaskTracker负责执行JobTacker分配给它的各项任务。尽管每个从节点都只有一个TaskTracker，但是每个TaskTracker可以派生出多个JVM进程来并行处理多个map或reduce任务。
TaskTracker的另一个职责是与JobTracker通讯。如果JobTracker在指定的时间内接收不到来自于TaskTracker的心跳信号，它将会认为这个TaskTracker已经崩溃，它会将对应的任务分配给集群的其它节点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="典型 Hadoop 集群" src="/hadoop_in_action/Image.png"/&gt;&lt;/p&gt;
&lt;h2&gt;Hadoop组件&lt;/h2&gt;
&lt;h3 id="wen-jian-cao-zuo"&gt;文件操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;hdfs相关的操作命令-get -cat -ls -lsr -tail -rm -put -mkdir......&lt;/li&gt;
&lt;li&gt;使用Configuration，FileSystem，FSDataOutputStream，FSDataInputStream对象操作HDFS或者本地文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="mapreducecheng-xu-jie-xi"&gt;MapReduce程序解析&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Hadoop数据类型&amp;mdash;&amp;mdash;Writable接口类型的可以作为值，WritableComparable&lt;t&gt;类型的可以作为键或值。Hadoop预定义了常用数据类型的WritableComparable封装类。&lt;/t&gt;&lt;/li&gt;
&lt;li&gt;Mapper&amp;mdash;&amp;mdash;需要实现Mapper接口并继承自MapReduceBase类。MapReduceBase是mapper和reducer的基类。它的configure和close方法分别作为对象的构造器和销毁器。Mapper处理数据的方法为map方法。&lt;/li&gt;
&lt;li&gt;Reducer&amp;mdash;&amp;mdash;需要继承MapReduceBase类。它同样有configure和close方法。它还需要实现Reducer接口的reduce方法来处理数据。&lt;/li&gt;
&lt;li&gt;Partitioner&amp;mdash;&amp;mdash;将Mapper输出重定向。它可以将Mapper的输出定向到不同的reducer。Hadoop默认的策略是根据key/value对中key的hash值决定它的reducer，这个Partitioner是HashPartitioner。&lt;/li&gt;
&lt;li&gt;自定义的partioner只需要实现configure()和getPartition()这2个函数。前者被Hadoop job来配置partioner，后者返回一个介于0和reduce任务数量之间的数，它标明了pair将被要发送至的reducer的索引。&lt;/li&gt;
&lt;li&gt;在map和reduce阶段之间，MapReduce程序还需要将mapper任务的输出分发给大量的reducer任务。这个处理过程称为shuffling，单个节点上的mapper的输出有可能会被发送到集群中多个reducer节点。&lt;/li&gt;
&lt;li&gt;Combiner&amp;mdash;&amp;mdash;本地reduce。在许多MapReduce应用中，我们可能会需要在分发mapper结果前执行"local reduce&amp;ldquo;。即将mapper结果中拥有相同key的内容进行合并。比如word count中，某个job包含了"the" 574，更为有效的存储和传送方式应该是传递("the", 574)而不是传递574次("the", 1)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="du-qu-he-xie-ru"&gt;读取和写入&lt;/h3&gt;
&lt;p&gt;输入数据通常是很大的文件通常是十几G或上百G甚至更大。MapReduce将这些输入数据分割成块（chunks）。然后在多台机器上并行的处理这些块。Hadoop里称这些块为input splits。每个块应的粒度应该小到足够并行处理。而又不能太小，而导致启动和停止job的时间还长一些。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;InputFormat。Hadoop分割和读取文件是由InputFormat接口定义的。TextInputFormat是InputFormat的默认实现。其它实现有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TextInputFormat文本文件中的每行作为一条记录，Key是行的偏移位置。Value是行内容。&lt;/li&gt;
&lt;li&gt;KeyValueTextInputFormat每行一条记录。第一个分隔符，分割每行。牌分隔符之前的内容作为Key，其它内容作为Value。分隔符由key.value.separator.in.input.line属性决定，默认为tab字符。&lt;/li&gt;
&lt;li&gt;SequenceFileInputFormat&lt;k,v&gt;读取SequenceFile的时候使用。SequenceFile是Hadoop中一种特殊的二进制压缩格式。它被优化为适合于在不同的MapReduce任务之间传递。&lt;/k,v&gt;&lt;/li&gt;
&lt;li&gt;NLineInputFormat与TextInputFormat类似，但它是按N行来分割的。mapred.line.input.format.linespermap属性决定按多少行来分割，默认为1。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OutputFormat。MapReduce使用OutputFormat类将数据输出至文件。输出内容不需要分割，每个reducer将它的输出写入自己的文件中。输出的文件被写入一个共同的目录中通常被命名为part-nnnnn，nnnnn是写入这个文件的reducer的partition ID。Hadoop提供的几种OutputFormat：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TextOutputFormat&lt;k,v&gt;，它将每行记录写入一行。Key和Value被当作字符串写入，并以tab字符分开。这个字符可以通过mapred.textoutputformat.separator来设定。&lt;/k,v&gt;&lt;/li&gt;
&lt;li&gt;SequenceFileOutputFormat&lt;k,v&gt;将键值对按Hadoop sequence file格式写入。定入的内容可以当作下一个MapReduce的SequenceFileInputFormat。&lt;/k,v&gt;&lt;/li&gt;
&lt;li&gt;NullOutputFormat&lt;k,v&gt;，不输出东西。&lt;/k,v&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;编写MapReduce程序&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;基本的MapReduce程序包含Mapper类、Reducer类、Job类。&lt;/li&gt;
&lt;li&gt;MapReduce程序通常很小。可以构建出一个程序模板，其它程序从这个模板基础上修改就可以了。&lt;/li&gt;
&lt;li&gt;IntWritable通常比Text性能更好。使用它的set方法，可以避免new大量的对象。&lt;/li&gt;
&lt;li&gt;可以通过添加combiner来提升性能。&lt;/li&gt;
&lt;li&gt;运用Streaming可以直接用其它脚本语言甚至是Unix命令编写MapReduce程序。Streaming使用Unix流来与其它程序交互。程序可以从STDIN获取输入，向STDOUT进行输出。数据都被当作文本处理，每行作为一条记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;高级MapReduce程序&lt;/h2&gt;
&lt;h3 id="mapreducelian"&gt;MapReduce链&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;顺序执行的任务链类似于Unix管道，它只需要将多个mapreduce任务按顺序执行，将上一任务的输出作为下一任务的输入。&lt;/li&gt;
&lt;li&gt;具有复杂依赖关系的MapReduce任务，即任务是非线性执行的。Hadoop通过Job和JobControl这两个类来管理依赖。Job用于描述MapReduce任务，使用Job.addDependingJob()方法来指定它依赖的任务。然后通过JobControl的addJob()方法将所有job和依赖关系添加进来，并执行它的run()方法。JobControl也提供了类似于allFinished()和getFailedJobs()方法跟踪执行情况。&lt;/li&gt;
&lt;li&gt;一些数据处理任务需要处理面向记录的前置和后置处理过程。可以编写单独的MapReduce任务来处理这些前置或后置步骤，并使用IdentityReducer（或者无reducer）将这些步骤链在一起。这种方法在处理任务链中消耗I/O和存储作为中间结果的步骤时效率低下。另一种方法是编写自己的mapper来处理&lt;/li&gt;
&lt;/ol&gt;</content><category term="hadoop"></category></entry><entry><title>Ext JS 5 手册 核心概念（二）类型系统</title><link href="/ext-js-5-shou-ce-he-xin-gai-nian-er-lei-xing-xi-tong.html" rel="alternate"></link><published>2015-05-17T00:00:00+08:00</published><updated>2015-05-17T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-17:/ext-js-5-shou-ce-he-xin-gai-nian-er-lei-xing-xi-tong.html</id><summary type="html">&lt;h1&gt;Ext JS 5 手册 核心概念（二）类型系统&lt;/h1&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3 id="lei-xing-xi-tong"&gt;类型系统&lt;/h3&gt;
&lt;h4 id="ming-ming-yue-ding"&gt;命名约定&lt;/h4&gt;
&lt;h5 id="lei"&gt;类&lt;/h5&gt;
&lt;p&gt;类名只允许包含字母和数字。数字是允许使用的，但只在必要时使用。不使用下划线、连字符和其它非数字字母。
类名应该按包分类。至少应该使用唯一的顶级命名空间。
顶级命名字音和类名应该使用驼峰式命名规则，其它部分都使用小写。
非&lt;code&gt;Sencha&lt;/code&gt;提供的类不应该使用&lt;code&gt;Ext&lt;/code&gt;作为顶级命名空间。&lt;/p&gt;
&lt;h5 id="yuan-wen-jian"&gt;源文件&lt;/h5&gt;
&lt;p&gt;类文件名按包路径保存。一个文件中只有一个类。
所有的类都应该放在同一个根目录下。&lt;/p&gt;
&lt;h5 id="fang-fa-he-bian-liang"&gt;方法和变量&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;方法和变量只使用字母和数字。只在必要时使用数字字符。不要使用下划线、连字符和其它非数字字母。&lt;/li&gt;
&lt;li&gt;方法和变量名应该使用驼峰式命名。这一规则同样适用于缩略词。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="shu-xing"&gt;属性&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;类属性名遵循相同的命名规则&lt;/li&gt;
&lt;li&gt;类的静态属性应该全部使用大写&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="sheng-ming_1"&gt;声明&lt;/h4&gt;
&lt;h5 id="ext-js-4-zhi-qian-de-fang-shi"&gt;Ext JS 4 之前的方式&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'My.cool'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;My&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;cool …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Ext JS 5 手册 核心概念（二）类型系统&lt;/h1&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3 id="lei-xing-xi-tong"&gt;类型系统&lt;/h3&gt;
&lt;h4 id="ming-ming-yue-ding"&gt;命名约定&lt;/h4&gt;
&lt;h5 id="lei"&gt;类&lt;/h5&gt;
&lt;p&gt;类名只允许包含字母和数字。数字是允许使用的，但只在必要时使用。不使用下划线、连字符和其它非数字字母。
类名应该按包分类。至少应该使用唯一的顶级命名空间。
顶级命名字音和类名应该使用驼峰式命名规则，其它部分都使用小写。
非&lt;code&gt;Sencha&lt;/code&gt;提供的类不应该使用&lt;code&gt;Ext&lt;/code&gt;作为顶级命名空间。&lt;/p&gt;
&lt;h5 id="yuan-wen-jian"&gt;源文件&lt;/h5&gt;
&lt;p&gt;类文件名按包路径保存。一个文件中只有一个类。
所有的类都应该放在同一个根目录下。&lt;/p&gt;
&lt;h5 id="fang-fa-he-bian-liang"&gt;方法和变量&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;方法和变量只使用字母和数字。只在必要时使用数字字符。不要使用下划线、连字符和其它非数字字母。&lt;/li&gt;
&lt;li&gt;方法和变量名应该使用驼峰式命名。这一规则同样适用于缩略词。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="shu-xing"&gt;属性&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;类属性名遵循相同的命名规则&lt;/li&gt;
&lt;li&gt;类的静态属性应该全部使用大写&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="sheng-ming_1"&gt;声明&lt;/h4&gt;
&lt;h5 id="ext-js-4-zhi-qian-de-fang-shi"&gt;Ext JS 4 之前的方式&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'My.cool'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;My&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;cool&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Window&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Window&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="xin-de-fang-shi"&gt;新的方式&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;className&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;members&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;onClassCreated&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="pei-zhi_1"&gt;配置&lt;/h4&gt;
&lt;p&gt;在 Ext JS 4 中使用&lt;code&gt;config&lt;/code&gt;属性，它由&lt;code&gt;Ext.Class&lt;/code&gt;前置处理器在类创建前进行处理，它包含以下功能：
 - 配置和封装类专员
 - 自动在类原型中生成属性的&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;方法
 - 为每个属性生成&lt;code&gt;apply&lt;/code&gt;方法。自动生成的&lt;code&gt;setter&lt;/code&gt;方法将会在设置值之前调用&lt;code&gt;apply&lt;/code&gt;方法。可以覆盖属性的&lt;code&gt;apply&lt;/code&gt;方法来添加自己的逻辑。如果&lt;code&gt;apply&lt;/code&gt;方法无返回值，则&lt;code&gt;setter&lt;/code&gt;将不会设置这个值。&lt;/p&gt;
&lt;p&gt;在 Ext JS 5 中对于使用&lt;code&gt;config&lt;/code&gt;的类来说，不再需要手动调用&lt;code&gt;initConfig()&lt;/code&gt;方法。但是如果你的类继承自&lt;code&gt;Ext.Base&lt;/code&gt;，则仍要调用&lt;code&gt;initConfig()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h4 id="jing-tai-cheng-yuan"&gt;静态成员&lt;/h4&gt;
&lt;p&gt;可以使用&lt;code&gt;statics&lt;/code&gt;来进行配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Computer'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;statics&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;instanceCount&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;factory&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;brand&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// 'this' in static methods refer to the class itself&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;brand&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;brand&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;

    &lt;span class="nx"&gt;config&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;brand&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;dellComputer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Computer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;factory&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Dell'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;appleComputer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Computer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;factory&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Mac'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;appleComputer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBrand&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; &lt;span class="c1"&gt;// using the auto-generated getter to get the value of a config property. Alerts "Mac"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="cuo-wu-chu-li-he-diao-shi"&gt;错误处理和调试&lt;/h4&gt;
&lt;p&gt;Ext JS 包含了有效的调试和错误处理功能。
 - 可以使用&lt;code&gt;Ext.getDisplayName()&lt;/code&gt;来获取方法的显示名称。这在发生异常时显示类名和方法名时非常有用。&lt;code&gt;throw new Error('['+ Ext.getDisplayName(arguments.callee) +'] Some message here');&lt;/code&gt;
 - 当使用&lt;code&gt;Ext.define()&lt;/code&gt;定义的任何类方法抛出错误时，你可以在基于 WebKit 的浏览器的调用栈中看到方法和类名。&lt;/p&gt;</content><category term="javascript"></category><category term="extjs"></category></entry><entry><title>Ext JS 5 手册 核心概念（三）组件</title><link href="/ext-js-5-shou-ce-he-xin-gai-nian-san-zu-jian.html" rel="alternate"></link><published>2015-05-17T00:00:00+08:00</published><updated>2015-05-17T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-17:/ext-js-5-shou-ce-he-xin-gai-nian-san-zu-jian.html</id><summary type="html">&lt;h1&gt;Ext JS 5 手册 核心概念（三）组件&lt;/h1&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3 id="zu-jian"&gt;组件&lt;/h3&gt;
&lt;p&gt;Ext JS 应用中的 UI 是由一个或多个被称为&lt;code&gt;组件(Components)&lt;/code&gt;的构件组成的。所有组件都是&lt;code&gt;Ext.Component&lt;/code&gt;的子类，它能自动管理组件的生命周期，如：实例化、渲染、改变大小和位置、销毁。&lt;/p&gt;
&lt;h4 id="zu-jian-de-ceng-ji"&gt;组件的层级&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Container&lt;/code&gt;是一种特殊的能包含其它组件的组件。一个典型的应用是由一些树状嵌套的组件组成的，由&lt;code&gt;container&lt;/code&gt;来负责管理组件和它们的子组件的生命周期，包括它们的：创建、渲染、改变大小和位置、销毁。一个典型应用的组件层级是由顶部的&lt;code&gt;Viewport&lt;/code&gt;开始，它包含了其它&lt;code&gt;containers&lt;/code&gt;和组件嵌套而成：
&lt;img alt="组件层级" src="/extjs5_guide/component_heirarchy_5.png"/&gt;
子组件通过&lt;code&gt;Container&lt;/code&gt;的&lt;code&gt;items&lt;/code&gt;配置属性添加到 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Ext JS 5 手册 核心概念（三）组件&lt;/h1&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3 id="zu-jian"&gt;组件&lt;/h3&gt;
&lt;p&gt;Ext JS 应用中的 UI 是由一个或多个被称为&lt;code&gt;组件(Components)&lt;/code&gt;的构件组成的。所有组件都是&lt;code&gt;Ext.Component&lt;/code&gt;的子类，它能自动管理组件的生命周期，如：实例化、渲染、改变大小和位置、销毁。&lt;/p&gt;
&lt;h4 id="zu-jian-de-ceng-ji"&gt;组件的层级&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Container&lt;/code&gt;是一种特殊的能包含其它组件的组件。一个典型的应用是由一些树状嵌套的组件组成的，由&lt;code&gt;container&lt;/code&gt;来负责管理组件和它们的子组件的生命周期，包括它们的：创建、渲染、改变大小和位置、销毁。一个典型应用的组件层级是由顶部的&lt;code&gt;Viewport&lt;/code&gt;开始，它包含了其它&lt;code&gt;containers&lt;/code&gt;和组件嵌套而成：
&lt;img alt="组件层级" src="/extjs5_guide/component_heirarchy_5.png"/&gt;
子组件通过&lt;code&gt;Container&lt;/code&gt;的&lt;code&gt;items&lt;/code&gt;配置属性添加到&lt;code&gt;Container&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Containers&lt;/code&gt;使用布局管理器来确定子组件的大小和位置。&lt;/p&gt;
&lt;h4 id="xtypeshe-yan-shi-shi-li-hua"&gt;XTypes和延时实例化&lt;/h4&gt;
&lt;p&gt;每个组件都有个被称为&lt;code&gt;xtype&lt;/code&gt;的符号名称。比如&lt;code&gt;Ext.panel.Panel&lt;/code&gt;的&lt;code&gt;xtype&lt;/code&gt;是&lt;code&gt;panel&lt;/code&gt;。在大型应用中，并不是所有界面上用到的组件都需要立即被实例化，某些组件在应用中可能永远都不会使用，因此不需要被实例化。这也是使用&lt;code&gt;xtype&lt;/code&gt;的一个原因，它能让&lt;code&gt;Container&lt;/code&gt;的子元素先进行配置，但是直到&lt;code&gt;Container&lt;/code&gt;决定在必要时才进行实例化。&lt;/p&gt;
&lt;h4 id="xian-shi-he-yin-cang"&gt;显示和隐藏&lt;/h4&gt;
&lt;p&gt;所有组件都有内置的&lt;code&gt;show&lt;/code&gt;和&lt;code&gt;hide&lt;/code&gt;方法。默认使用的 CSS 的&lt;code&gt;display:none&lt;/code&gt;来隐藏组件，但是也可以通过&lt;code&gt;hideMode&lt;/code&gt;配置属性来进行控制：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.panel.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
        &lt;span class="nx"&gt;title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Test'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Test Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;hideMode&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'visibility'&lt;/span&gt; &lt;span class="c1"&gt;// 使用 CSS 的 visibility 属性来控制组件的显示和隐藏&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;

    &lt;span class="nx"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;hide&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// hide the component&lt;/span&gt;

    &lt;span class="nx"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;show&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// show the component&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="fu-dong-zu-jian"&gt;浮动组件&lt;/h4&gt;
&lt;p&gt;浮动组件使用了 CSS 绝对定位，不参与它所属的&lt;code&gt;Container&lt;/code&gt;的布局。像&lt;code&gt;Window&lt;/code&gt;这样的组件默认就是浮动的，但是任何组件都可以通过&lt;code&gt;floating&lt;/code&gt;配置项被设置为浮动组件。&lt;/p&gt;
&lt;p&gt;通常的组件要么具有&lt;code&gt;renderTo&lt;/code&gt;配置项，要么被添加为某个&lt;code&gt;Container&lt;/code&gt;的子组件，但是浮动组件不需要这样。浮动组件在初次调用&lt;code&gt;show&lt;/code&gt;方法时被自动渲染到&lt;code&gt;body&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;其它几个与浮动组件相关的配置项和方法：
 - &lt;code&gt;draggable&lt;/code&gt; 允许组件在屏幕上拖动
 - &lt;code&gt;shadow&lt;/code&gt; 自定义浮动组件的阴影效果
 - &lt;code&gt;alignTo()&lt;/code&gt; 将浮动组件对齐到某个特定的元素
 - &lt;code&gt;center()&lt;/code&gt; 将浮动组件定位到&lt;code&gt;Container&lt;/code&gt;的中心位置&lt;/p&gt;
&lt;h4 id="chuang-jian-zi-ding-yi-zu-jian"&gt;创建自定义组件&lt;/h4&gt;
&lt;h5 id="zu-he-huo-kuo-zhan"&gt;组合或扩展&lt;/h5&gt;
&lt;p&gt;创建新的 UI 类时，可以使用组合或继承&lt;code&gt;Component&lt;/code&gt;的方法。&lt;/p&gt;
&lt;p&gt;推荐继承功能性最接近的类。因为它能使用 Ext JS 提供的自动化生命周期管理。&lt;/p&gt;
&lt;h5 id="zi-lei-hua"&gt;子类化&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Ext.Base&lt;/code&gt;是所有类型的基础，这个类的原型和静态成员被所有其它类所继承。&lt;/p&gt;
&lt;p&gt;可以向这个&lt;code&gt;Ext.Base&lt;/code&gt;中添加低层次的功能。&lt;/p&gt;
&lt;h5 id="mo-ban-fang-fa"&gt;模板方法&lt;/h5&gt;
&lt;p&gt;Ext JS 使用模板方法模式将行为委派给子类，行为只对子类型有效。&lt;/p&gt;
&lt;p&gt;继承链中的每个类都可以向组件的生命周期的某个阶段&amp;ldquo;贡献&amp;rdquo;出额外的逻辑代码。每个类都实现了特定的行为并允许继承链中的其它类&amp;ldquo;贡献&amp;rdquo;它们的逻辑。&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;render&lt;/code&gt;方法为例，它是&lt;code&gt;Component&lt;/code&gt;中定义的方法。它的职责是启动组件的渲染阶段。&lt;code&gt;render&lt;/code&gt;不允许被覆盖，但它会调用&lt;code&gt;onRender&lt;/code&gt;来允许子类添加它们自己的处理过程。每个子类在&lt;code&gt;onRender&lt;/code&gt;方法中必须先调用它们的父类的&lt;code&gt;onRender&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;下面的图描述了&lt;code&gt;onRender&lt;/code&gt;模板方法的运行机制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Render&lt;/code&gt;方法被调用时（通常由&lt;code&gt;Container&lt;/code&gt;的布局管理器）。这个方法可能没有被覆盖，而是继承自&lt;code&gt;Ext.base&lt;/code&gt;类。它调用当前的子类中实现的&lt;code&gt;this.onRender&lt;/code&gt;（如果有）。这将调用父类型中的方法。最后，每个类中的功能都调用到了，控制权返回到render函数
&lt;img alt="模板方法调用机制" src="/extjs5_guide/template_pattern.png"/&gt;
以下是一个&lt;code&gt;Component&lt;/code&gt;的子类实现的&lt;code&gt;onRender&lt;/code&gt;方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'My.custom.Component'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.Component'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;onRender&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;callParent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// call the superclass onRender method&lt;/span&gt;

        &lt;span class="c1"&gt;// perform additional rendering tasks here.&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是很多模板方法也有对应的事件。比如&lt;code&gt;render&lt;/code&gt;事件，它在组件被渲染之后触发。当进行子类化时，必须使用模板方法在生命周期的重要阶段执行它的逻辑，而不使用事件。事件可以以编程的方式挂起，或被事件处理器停止。&lt;/p&gt;
&lt;p&gt;以下是&lt;code&gt;Component&lt;/code&gt;的子类型可以实现的模板方法：
 - &lt;code&gt;initComponent&lt;/code&gt; 这个方法由构造器调用。它用于初始化数据，设置配置项和添加事件处理器。
 - &lt;code&gt;beforeShow&lt;/code&gt; 这个方法在组件显示前被调用。
 - &lt;code&gt;onShow&lt;/code&gt; 在显示操作时添加行为。在调用父类的&lt;code&gt;onShow&lt;/code&gt;之后，组件将被显示。
 - &lt;code&gt;afterShow&lt;/code&gt; 这个方法在组件显示后被调用。
 - &lt;code&gt;onShowComplete&lt;/code&gt; 这个方法在调用调用完&lt;code&gt;afterShow&lt;/code&gt;之后执行。
 - &lt;code&gt;onHide&lt;/code&gt; 在隐藏操作时添加行为。在调用你类的&lt;code&gt;onHide&lt;/code&gt;之后，组件将被隐藏。
 - &lt;code&gt;onRender&lt;/code&gt; 在渲染阶段添加行为。
 - &lt;code&gt;afterRender&lt;/code&gt; 在渲染完成之后添加行为。在这个阶段组件的 DOM 元素将按配置被设置样式，会具有任何配置了的 CSS 类名称，并且会被按配置设置为显示和启用状态。
 - &lt;code&gt;onEnable&lt;/code&gt; 在启用操作时添加行为。在调用父类的&lt;code&gt;onEnable&lt;/code&gt;之后，组件被启用。
 - &lt;code&gt;onDisable&lt;/code&gt; 在禁用操作时添加行为。在调用父类的&lt;code&gt;onDisable&lt;/code&gt;之后，组件被禁用。
 - &lt;code&gt;onAdded&lt;/code&gt; 在组件被添加到&lt;code&gt;Container&lt;/code&gt;时添加行为。在这个阶段，组件已经存在于父&lt;code&gt;Container&lt;/code&gt;的子项集合中。在调用父类的&lt;code&gt;onAdded&lt;/code&gt;之后，&lt;code&gt;ownerCt&lt;/code&gt;引用将会存在，如果配置了&lt;code&gt;ref&lt;/code&gt;，&lt;code&gt;refOwner&lt;/code&gt;将被设置。
 - &lt;code&gt;onRemoved&lt;/code&gt; 在组件从&lt;code&gt;Container&lt;/code&gt;中移除时添加行为。在这个阶段，组件已经被从父&lt;code&gt;Container&lt;/code&gt;中移出，但是还未被销毁（它将在父&lt;code&gt;Container&lt;/code&gt;的&lt;code&gt;autoDestroy&lt;/code&gt;被设置为&lt;code&gt;true&lt;/code&gt;或调用&lt;code&gt;remove&lt;/code&gt;时传递的第二个参数为&lt;code&gt;true&lt;/code&gt;时被销毁）。在调用完父类的&lt;code&gt;onRemoved&lt;/code&gt;之后，&lt;code&gt;ownerCt&lt;/code&gt;和&lt;code&gt;refOwner&lt;/code&gt;将不再存在。
 - &lt;code&gt;onResize&lt;/code&gt; 在改变大小时添加行为。
 - &lt;code&gt;onPosition&lt;/code&gt; 在改变位置时添加行为。
 - &lt;code&gt;onDestroy&lt;/code&gt; 在销毁操作时添加行为。在调用父类的&lt;code&gt;onDestroy&lt;/code&gt;后，组件将被销毁。
 - &lt;code&gt;beforeDestroy&lt;/code&gt; 在组件被销毁前执行。
 - &lt;code&gt;afterSetPosition&lt;/code&gt; 在组件的位置被设置之后执行。
 - &lt;code&gt;afterComponentLayout&lt;/code&gt; 在组件被布局之后执行。
 - &lt;code&gt;beforeComponentLayout&lt;/code&gt; 在组件被布局之前执行。&lt;/p&gt;
&lt;h5 id="ji-cheng-na-ge-lei"&gt;继承哪个类&lt;/h5&gt;
&lt;p&gt;无论 UI 组件是否需要被渲染和管理，总是倾向于继承&lt;code&gt;Ext.panel.Panel&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Panel&lt;/code&gt;类有非常多的功能：
 - 边框
 - 头部
 - 头部工具条
 - 底部
 - 底部按钮
 - 顶部工具条
 - 底部工具条
 - 容纳和管理子组件&lt;/p&gt;
&lt;h6 id="component"&gt;Component&lt;/h6&gt;
&lt;p&gt;如果需要的 UI 组件不需要包含其它组件，而只是一些 HTML，则继承&lt;code&gt;Ext.Component&lt;/code&gt;也是合适的。&lt;/p&gt;
&lt;h6 id="container"&gt;Container&lt;/h6&gt;
&lt;p&gt;如果需要的 UI 组件要能包含其它的组件，但是不需要&lt;code&gt;Panel&lt;/code&gt;的其它功能，则可以继承&lt;code&gt;Ext.container.Container&lt;/code&gt;。需要记住&lt;code&gt;Ext.layout.container.Container&lt;/code&gt;用于渲染和管理子组件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Container&lt;/code&gt;有下列额外的模板方法：
 - &lt;code&gt;onBeforeAdd&lt;/code&gt; 这个方法在添加了新的子组件时被调用。它会传递这个新的组件，以便修改这个组件，或以其它方式准备&lt;code&gt;Container&lt;/code&gt;。返回&lt;code&gt;false&lt;/code&gt;时将中止添加操作。
 - &lt;code&gt;onAdd&lt;/code&gt; 这个方法在添加了新的组件之后执行。它将会传递这个新添加的组件。这个方法可以用于根据子组件的状态更新内部结构。
 - &lt;code&gt;onRemove&lt;/code&gt; 在子组件被删除时被调用。它将传递要被删除的组件。这个方法可以用于根据子组件的状态更新内部结构。
 - &lt;code&gt;beforeLayout&lt;/code&gt; 这个方法在&lt;code&gt;Container&lt;/code&gt;对它的子组件进布局（和渲染）之前执行。
 - &lt;code&gt;afterLayout&lt;/code&gt; 这个方法在&lt;code&gt;Container&lt;/code&gt;对它的子组件进行而已（和渲染）之后执行。&lt;/p&gt;
&lt;h6 id="panel"&gt;Panel&lt;/h6&gt;
&lt;p&gt;如果需要的 UI 组件需要头、尾或工具栏时，应该继承&lt;code&gt;Ext.panel.Panel&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;重点：&lt;code&gt;Panel&lt;/code&gt;是一个&lt;code&gt;Container&lt;/code&gt;。&lt;code&gt;Layout&lt;/code&gt;是用于渲染和管理子组件的。&lt;/p&gt;
&lt;p&gt;继承&lt;code&gt;Ext.panel.Panel&lt;/code&gt;是应用中经常使用的，用于将 UI 组件进行布局的类，并能使用&lt;code&gt;tbar&lt;/code&gt;和&lt;code&gt;bbar&lt;/code&gt;来提供操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Panel&lt;/code&gt;有以下额外的模板方法：
 - &lt;code&gt;afterCollapse&lt;/code&gt; 这个方法在&lt;code&gt;Panel&lt;/code&gt;收缩时被调用。
 - &lt;code&gt;afterExpand&lt;/code&gt; 这个方法在&lt;code&gt;Panel&lt;/code&gt;展开时被调用。
 - &lt;code&gt;onDockedAdd&lt;/code&gt; 这个方法在&lt;code&gt;Docked&lt;/code&gt;项添加到&lt;code&gt;Panel&lt;/code&gt;上后被调用。
 - &lt;code&gt;onDockedRemove&lt;/code&gt; 这个方法在&lt;code&gt;Docked&lt;/code&gt;项从&lt;code&gt;Panel&lt;/code&gt;上删除后被调用。&lt;/p&gt;</content><category term="javascript"></category><category term="extjs"></category></entry><entry><title>Ext JS 5 手册 核心概念（四）数据包</title><link href="/ext-js-5-shou-ce-he-xin-gai-nian-si-shu-ju-bao.html" rel="alternate"></link><published>2015-05-17T00:00:00+08:00</published><updated>2015-05-17T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-17:/ext-js-5-shou-ce-he-xin-gai-nian-si-shu-ju-bao.html</id><summary type="html">&lt;h1&gt;Ext JS 5 手册 核心概念（四）数据包&lt;/h1&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3 id="shu-ju-bao"&gt;数据包&lt;/h3&gt;
&lt;p&gt;数据包是应用中处理数据加载和保存的。它包含了很多类，其中以下三个是最重要的：
 - Ext.data.Model
 - Store
 - Ext.data.proxy.Proxy&lt;/p&gt;
&lt;p&gt;上面的类几乎在所有应用中都被用到。它们由一些卫星类支撑：&lt;/p&gt;
&lt;p&gt;&lt;img alt="数据包相关类" src="/extjs5_guide/data-model.png"/&gt;&lt;/p&gt;
&lt;h4 id="model"&gt;Model&lt;/h4&gt;
&lt;p&gt;类所包的中心是&lt;code&gt;Ext.data.Model&lt;/code&gt;。&lt;code&gt;Model&lt;/code&gt;用于描述应用中一个实体。
Model中的主要部分有：
 - Fields
 - Proxies
 - Validations
 - Associations&lt;/p&gt;
&lt;p&gt;&lt;img alt="Model 的主要组成部分" src="/extjs5_guide/model-breakdown.png"/&gt;&lt;/p&gt;
&lt;h5 id="chuang-jian-model"&gt;创建 Model&lt;/h5&gt;
&lt;p&gt;通常可以定义一个公用的基础类。这个基类能定义所有 Model 公用的属性。
Model 有两个重要的属性&lt;code&gt;fields&lt;/code&gt;和&lt;code&gt;schema&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.model.Base' …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Ext JS 5 手册 核心概念（四）数据包&lt;/h1&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3 id="shu-ju-bao"&gt;数据包&lt;/h3&gt;
&lt;p&gt;数据包是应用中处理数据加载和保存的。它包含了很多类，其中以下三个是最重要的：
 - Ext.data.Model
 - Store
 - Ext.data.proxy.Proxy&lt;/p&gt;
&lt;p&gt;上面的类几乎在所有应用中都被用到。它们由一些卫星类支撑：&lt;/p&gt;
&lt;p&gt;&lt;img alt="数据包相关类" src="/extjs5_guide/data-model.png"/&gt;&lt;/p&gt;
&lt;h4 id="model"&gt;Model&lt;/h4&gt;
&lt;p&gt;类所包的中心是&lt;code&gt;Ext.data.Model&lt;/code&gt;。&lt;code&gt;Model&lt;/code&gt;用于描述应用中一个实体。
Model中的主要部分有：
 - Fields
 - Proxies
 - Validations
 - Associations&lt;/p&gt;
&lt;p&gt;&lt;img alt="Model 的主要组成部分" src="/extjs5_guide/model-breakdown.png"/&gt;&lt;/p&gt;
&lt;h5 id="chuang-jian-model"&gt;创建 Model&lt;/h5&gt;
&lt;p&gt;通常可以定义一个公用的基础类。这个基类能定义所有 Model 公用的属性。
Model 有两个重要的属性&lt;code&gt;fields&lt;/code&gt;和&lt;code&gt;schema&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.model.Base'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.data.Model'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;fields&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'id'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'int'&lt;/span&gt;
    &lt;span class="p"&gt;}],&lt;/span&gt;

    &lt;span class="nx"&gt;schema&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;namespace&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'MyApp.model'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// generate auto entityName&lt;/span&gt;

        &lt;span class="nx"&gt;proxy&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     &lt;span class="c1"&gt;// Ext.util.ObjectTemplate&lt;/span&gt;
            &lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;ajax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;url&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'{entityName}.json'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;reader&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'json'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;rootProperty&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'{entityName:lowercase}'&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="proxy"&gt;Proxy&lt;/h5&gt;
&lt;p&gt;Proxy 由 Model 和 Store 使用的，用于处理加载和保存 Model 数据的。有两种类型的 Proxy: Client 和 Server。
 - Client Proxy 包括 Memory 和 Local Storage两种。
 - Server Proxy 用于从远程服务端处理数据。例如：AJAX、JSONP、REST。&lt;/p&gt;
&lt;h5 id="schema"&gt;Schema&lt;/h5&gt;
&lt;p&gt;Schema 是一些有关联关系的实体的集合。当 Model 父类型指定了&lt;code&gt;schema&lt;/code&gt;属性时，这个属性将会被子类模板继承。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;schema&lt;/code&gt;的&lt;code&gt;namespace&lt;/code&gt;属性能让所有 Model 得到一个缩短的&lt;code&gt;entityName&lt;/code&gt;。这个名称主要用于定义 Model 之间的关联关系。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;schema&lt;/code&gt;的&lt;code&gt;proxy&lt;/code&gt;属性是一个对象模板它与基于 Ext.XTemplate 的文本模板是类似的。不同之处在于当给予对象模板数据时它将产生出来对象来。在上面的代码里，模板数据用于自动定义所有 Model 的&lt;code&gt;proxy&lt;/code&gt;配置，而不需要显式的定义&lt;code&gt;proxy&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这样每个 Model 实例将根据不同的值采用相同的方式来加载数据。可以避免了在不同的 Model 中重复定义 proxy。&lt;/p&gt;
&lt;h4 id="store_1"&gt;Store&lt;/h4&gt;
&lt;p&gt;Model 通常与 Store 一起使用，Store 是记录（Model 子类的实例）的集合。创建 Store 并加载数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;store&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Store&lt;/span&gt; &lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="nx"&gt;model&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'MyApp.model.User'&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;store&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;load&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="nx"&gt;callback&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
        &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;first_name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;first&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;first_name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="nei-lian-shu-ju"&gt;内联数据&lt;/h5&gt;
&lt;p&gt;Store 可以加载内联数据。Store 将会将它的&lt;code&gt;data&lt;/code&gt;属性中的对象转换成对应的 Model 类型的记录集。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Store&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="nx"&gt;model&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'MyApp.model.User'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Philip J. Fry"&lt;/span&gt;
    &lt;span class="p"&gt;},{&lt;/span&gt;
        &lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Hubert Farnsworth"&lt;/span&gt;
    &lt;span class="p"&gt;},{&lt;/span&gt;
        &lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Turanga Leela"&lt;/span&gt;
    &lt;span class="p"&gt;},{&lt;/span&gt;
        &lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Amy Wong"&lt;/span&gt;
    &lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="pai-xu-he-fen-zu"&gt;排序和分组&lt;/h5&gt;
&lt;p&gt;Store 可以在本地或远程执行排序、过滤和分组操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Store&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="nx"&gt;model&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'MyApp.model.User'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;sorters&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;'id'&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="nx"&gt;filters&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;property&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;value&lt;/span&gt;   &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Philip J. Fry'&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="association_1"&gt;Association&lt;/h4&gt;
&lt;p&gt;Model 可以通过 Association API 关联起来。多数应用都需要处理很多互相关联的 Model。&lt;/p&gt;
&lt;p&gt;以下是一个多对一的关联示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.model.User'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'MyApp.model.Base'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;fields&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'string'&lt;/span&gt;
    &lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.model.Post'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'MyApp.model.Base'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;fields&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'userId'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;reference&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'User'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// the entityName for MyApp.model.User&lt;/span&gt;
        &lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'int'&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'title'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'string'&lt;/span&gt;
    &lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义好关联关系之后，就可以很容易的访问关联的数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Loads User with ID 1 and related posts and comments&lt;/span&gt;
&lt;span class="c1"&gt;// using User's Proxy&lt;/span&gt;
&lt;span class="nx"&gt;MyApp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;User&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;callback&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'User: '&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

        &lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;posts&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;posts&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="nx"&gt;posts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;each&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Post: '&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'title'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
            &lt;span class="p"&gt;});&lt;/span&gt;
        &lt;span class="p"&gt;});&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;posts&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;add&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="nx"&gt;userId&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Post 10'&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;posts&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;sync&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="nx"&gt;MyApp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;callback&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="nx"&gt;post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getUser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Got user from post: '&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="p"&gt;});&lt;/span&gt;                           
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="nx"&gt;MyApp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;callback&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;post&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;setUser&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                         
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id="jia-zai-qian-tao-shu-ju"&gt;加载嵌套数据&lt;/h5&gt;
&lt;p&gt;定义好关联关系之后，可以在单个请求中加载关联数据。例如，服务端的响应如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;"success"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s2"&gt;"user"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="s2"&gt;"id"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"name"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Philip J. Fry"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"posts"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
            &lt;span class="s2"&gt;"title"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Post 1"&lt;/span&gt;
        &lt;span class="p"&gt;},{&lt;/span&gt;
            &lt;span class="s2"&gt;"title"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Post 2"&lt;/span&gt;
        &lt;span class="p"&gt;},{&lt;/span&gt;
            &lt;span class="s2"&gt;"title"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Post 3"&lt;/span&gt;
        &lt;span class="p"&gt;}]&lt;/span&gt;
    &lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种情况下框架能自动解析出单个响应中的嵌套数据，而不需要发起两次请求，分别来获取 User 和 Post 的数据。&lt;/p&gt;
&lt;h4 id="yan-zheng_1"&gt;验证&lt;/h4&gt;
&lt;p&gt;Model 提供了数据验证的支持。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.model.User'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.data.Model'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;fields&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;...,&lt;/span&gt;

    &lt;span class="nx"&gt;validators&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
            &lt;span class="s1"&gt;'presence'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'length'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;min&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="p"&gt;},&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'exclusion'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;list&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'Bender'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;验证定义时是以字段名作为 key，值作为它的规则。这些规则由一个验证对象配置，或多个验证对象配置数组构成的。上面的这个验证规则验证了&lt;code&gt;name&lt;/code&gt;字段，它的长度必须大于7，并且不能是&lt;code&gt;Bender&lt;/code&gt;。
某些验证规则可能会包含不同的属性&amp;mdash;&amp;mdash;比如&lt;code&gt;min&lt;/code&gt;和&lt;code&gt;max&lt;/code&gt;属性等等。Ext JS 有5种内置验证器并且易于添加自定义的规则。
 - presence 确保字段有值。
 - length 确保字符串的长度处于&lt;code&gt;min&lt;/code&gt;和&lt;code&gt;max&lt;/code&gt;之间，这两个选项都是可选的
 - format 确保字符串匹配某个正则表达式
 - inclusion 确保值匹配某个特定的值列表
 - exclusion 确保值不属于某个特定的值列表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// now lets try to create a new user with as many validation&lt;/span&gt;
&lt;span class="c1"&gt;// errors as we can&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;newUser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;MyApp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;model&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;User&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Bender'&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="c1"&gt;// run some validation on the new user we just created&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Is User valid?'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;newUser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;isValid&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

&lt;span class="c1"&gt;//returns 'false' as there were validation errors&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;errors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;newUser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getValidation&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;error&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;errors&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Error is: "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="nx"&gt;newUser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Bender Bending Rodriguez'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;errors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;newUser&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getValidation&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="javascript"></category><category term="extjs"></category></entry><entry><title>Ext JS 5 手册 核心概念（五）事件</title><link href="/ext-js-5-shou-ce-he-xin-gai-nian-wu-shi-jian.html" rel="alternate"></link><published>2015-05-17T00:00:00+08:00</published><updated>2015-05-17T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-17:/ext-js-5-shou-ce-he-xin-gai-nian-wu-shi-jian.html</id><summary type="html">&lt;h1&gt;Ext JS 5 手册 核心概念（五）事件&lt;/h1&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3 id="shi-yong-shi-jian"&gt;使用事件&lt;/h3&gt;
&lt;p&gt;Ext JS 中的组件和类在其生命周期中会产生大量的事件。事件能让你的代码响应程序的变化。&lt;/p&gt;
&lt;h4 id="shi-yao-shi-shi-jian"&gt;什么是事件&lt;/h4&gt;
&lt;p&gt;以 Ext.Component 渲染到屏幕上为例，Ext JS 会在渲染完成后产生事件。我们可以配置一个&lt;code&gt;listeners&lt;/code&gt;对象来监听这个事件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'My Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;afterrender&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'We have been rendered'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="jian-ting-shi-jian"&gt;监听事件&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Ext JS 5 手册 核心概念（五）事件&lt;/h1&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3 id="shi-yong-shi-jian"&gt;使用事件&lt;/h3&gt;
&lt;p&gt;Ext JS 中的组件和类在其生命周期中会产生大量的事件。事件能让你的代码响应程序的变化。&lt;/p&gt;
&lt;h4 id="shi-yao-shi-shi-jian"&gt;什么是事件&lt;/h4&gt;
&lt;p&gt;以 Ext.Component 渲染到屏幕上为例，Ext JS 会在渲染完成后产生事件。我们可以配置一个&lt;code&gt;listeners&lt;/code&gt;对象来监听这个事件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'My Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;afterrender&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'We have been rendered'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="jian-ting-shi-jian"&gt;监听事件&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'My Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;mouseover&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;hide&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="nx"&gt;hide&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;// Waits 1 second (1000ms), then shows the button again&lt;/span&gt;
            &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;show&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="zai-hou-qi-tian-jia-jian-ting-qi"&gt;在后期添加监听器&lt;/h4&gt;
&lt;p&gt;可以使用&lt;code&gt;on&lt;/code&gt;函数来给组件添加监听器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'My Button'&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;button&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'click'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Event listener attached by .on'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;button&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="nx"&gt;mouseover&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;hide&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="nx"&gt;hide&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;show&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="yi-chu-jian-ting-qi"&gt;移除监听器&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;un&lt;/code&gt;函数可以移除监听器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;doSomething&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'listener called'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'My Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;click&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;button&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;un&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'click'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;doSomething&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="mi"&gt;3000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="jian-ting-qi-de-zuo-yong-yu"&gt;监听器的作用域&lt;/h4&gt;
&lt;p&gt;作用域限定了监听处理器的取值范围。默认情况下，这个范围限定在触发事件的对象实例上。但是可以通过&lt;code&gt;scope&lt;/code&gt;属性指定作用域：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Panel HTML'&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Click Me'&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;button&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="nx"&gt;click&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;scope&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;fn&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getXType&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子中的&lt;code&gt;this&lt;/code&gt;指向 Panel。运行这个例子将看到弹出了 Panel 的 xtype。&lt;/p&gt;
&lt;h4 id="zhi-jian-ting-yi-ci"&gt;只监听一次&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Click Me'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;click&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;single&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;fn&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'I will say this only once'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="shi-yong-huan-cun-pei-zhi"&gt;使用缓存配置&lt;/h4&gt;
&lt;p&gt;对于那些发生频率很高的事件，我们可以使用&lt;code&gt;buffer&lt;/code&gt;重新配置发生的次数。在下例中我们只需要让按钮每2秒才触发一次，而不管点击了多少次：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Click Me'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;click&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;buffer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;fn&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'I say this only once every 2 seconds'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="chan-sheng-zi-ding-yi-shi-jian"&gt;产生自定义事件&lt;/h4&gt;
&lt;p&gt;可以调用&lt;code&gt;fireEvent&lt;/code&gt;来产生自定义事件。下例产生了名为&lt;code&gt;myEvent&lt;/code&gt;的事件，并传递了两个参数&amp;mdash;&amp;mdash;按钮自身和一个 1 至 100 之间的随机数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Just wait 2 seconds"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;myEvent&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;button&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;points&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'myEvent fired! You score '&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;points&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;' points'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ceil&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;Math&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;random&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nx"&gt;button&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;fireEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'myEvent'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;button&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;number&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用了&lt;code&gt;Ext.defer&lt;/code&gt;延时 2 秒来触发自定义事件。&lt;/p&gt;
&lt;h4 id="jian-ting-dom-shi-jian"&gt;监听 DOM 事件&lt;/h4&gt;
&lt;p&gt;不是每个 Ext JS 组件都会抛出所有事件。但是通过定位 container 上的元素，我们可以产生原生事件并监听它们。以 Ext.container.Container 为例，它并没有 click 事件，但是我们可以给它一个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;container&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Ext.Container'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;renderTo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getBody&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
    &lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Click Me!'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;click&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'I have been clicked!'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getEl&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'click'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; 
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;fireEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'click'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="nx"&gt;container&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不添加第二段代码，container 的 click 监听器不会被触发。&lt;/p&gt;
&lt;h4 id="shi-jian-biao-zhun-hua-event-normalization"&gt;事件标准化（Event Normalization）&lt;/h4&gt;
&lt;p&gt;事件标准化是 Ext JS 5 应用支持触屏设备的关键。它能将标准的鼠标事件转换成触摸和点击事件（Pointer event）。&lt;/p&gt;
&lt;p&gt;Pointer 事件是 w3c 标准中用来处理坐标系事件的，它与输入设备无关（鼠标、触控、触控笔等等）。&lt;/p&gt;
&lt;p&gt;当你的代码需要监听一个鼠标事件时，框架会附加到一个对应的触控或点击事件上。比如应用程序需要监听&lt;code&gt;mousedown&lt;/code&gt;时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;myElement&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'mousedown'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;someFunction&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;事件系统在某些设备上会将它转换到&lt;code&gt;touchstart&lt;/code&gt;事件上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;myElement&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'touchstart'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;someFunction&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而在某些系统上会将它转换到&lt;code&gt;pointerdown&lt;/code&gt;事件上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;myElement&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'pointerdown'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;someFunction&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个转换的发生是&lt;code&gt;in place&lt;/code&gt;的，因此不需要为不同设备编写不同的代码。&lt;/p&gt;
&lt;p&gt;在多数情况下框架能无缝的进行鼠标、触控、点击之间的转换。但是某些鼠标交互（如&lt;code&gt;mouseover&lt;/code&gt;）无法转换成对应的触控动作。这些事件的处理需要使用下一节中提到的方式进行处理。&lt;/p&gt;
&lt;h4 id="shou-shi"&gt;手势&lt;/h4&gt;
&lt;p&gt;除标准的 DOM 事件之外，元素也可以产生合成的&lt;code&gt;gesture&lt;/code&gt;事件。&lt;/p&gt;
&lt;p&gt;从浏览器的角度来看，主要有 3 种类型的点击、触控和鼠标事件&amp;mdash;&amp;mdash;开始、移动和结束：&lt;/p&gt;
&lt;p&gt;|| &lt;em&gt;Event&lt;/em&gt; || &lt;em&gt;Touch&lt;/em&gt;    ||   &lt;em&gt;Pointer&lt;/em&gt;   ||   &lt;em&gt;Mouse&lt;/em&gt;   ||&lt;/p&gt;
&lt;p&gt;|| &lt;em&gt;Start&lt;/em&gt; || touchstart ||  pointerdown  ||  mousedown  || &lt;/p&gt;
&lt;p&gt;|| &lt;em&gt;Move&lt;/em&gt;  || touchmove  ||  pointermove  ||  mousemove  ||&lt;/p&gt;
&lt;p&gt;|| &lt;em&gt;Stop&lt;/em&gt;  || touchend   ||  pointerup    ||             ||&lt;/p&gt;
&lt;p&gt;根据解释这些事件发生的时间和顺序，框架能合成更复杂的事件，比如：&lt;code&gt;drag&lt;/code&gt;,&lt;code&gt;swipe&lt;/code&gt;,&lt;code&gt;longpress&lt;/code&gt;,&lt;code&gt;pinch&lt;/code&gt;,&lt;code&gt;rotate&lt;/code&gt;和&lt;code&gt;tap&lt;/code&gt;。Ext JS 应用可以像监听普通事件一样监听这些事件。&lt;/p&gt;
&lt;p&gt;Sencha 触控事件系统主要是为触控事件来设计的。通过添加对点击和鼠标事件的完全支持，Ext JS 5 允许手势系统响应任何类型的输入。这意味着你不光可以使用触控输入设备来产生手势事件，也可以使用鼠标来产生单点触控事件。这使得手势系统在不同的设备和输入类型上是无缝切换的。&lt;/p&gt;</content><category term="javascript"></category><category term="extjs"></category></entry><entry><title>Ext JS 5 手册 核心概念（一）可访问性</title><link href="/ext-js-5-shou-ce-he-xin-gai-nian-yi-ke-fang-wen-xing.html" rel="alternate"></link><published>2015-05-17T00:00:00+08:00</published><updated>2015-05-17T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-17:/ext-js-5-shou-ce-he-xin-gai-nian-yi-ke-fang-wen-xing.html</id><summary type="html">&lt;h1&gt;Ext JS 5 手册 核心概念（一）可访问性&lt;/h1&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3 id="ke-fang-wen-xing"&gt;可访问性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;它提供了浅析的标明当前焦点的样式，并允许自字义焦点样式&lt;/li&gt;
&lt;li&gt;键盘导航&lt;/li&gt;
&lt;li&gt;组件的 DOM 元素使用属性提供了语义信息来辅助屏幕阅读等功能：&lt;ul&gt;
&lt;li&gt;ARIA 角色&lt;/li&gt;
&lt;li&gt;ARIA 状态和属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提供了 ARIA 包，可以像引用其它包一样的在&lt;code&gt;app.json&lt;/code&gt;中引用&lt;/li&gt;
&lt;li&gt;提供了 ARIA 皮肤&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;Ext JS 5 手册 核心概念（一）可访问性&lt;/h1&gt;
&lt;h2&gt;核心概念&lt;/h2&gt;
&lt;h3 id="ke-fang-wen-xing"&gt;可访问性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;它提供了浅析的标明当前焦点的样式，并允许自字义焦点样式&lt;/li&gt;
&lt;li&gt;键盘导航&lt;/li&gt;
&lt;li&gt;组件的 DOM 元素使用属性提供了语义信息来辅助屏幕阅读等功能：&lt;ul&gt;
&lt;li&gt;ARIA 角色&lt;/li&gt;
&lt;li&gt;ARIA 状态和属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;提供了 ARIA 包，可以像引用其它包一样的在&lt;code&gt;app.json&lt;/code&gt;中引用&lt;/li&gt;
&lt;li&gt;提供了 ARIA 皮肤&lt;/li&gt;
&lt;/ul&gt;</content><category term="javascript"></category><category term="extjs"></category></entry><entry><title>Ext JS 5 手册 应用程序架构（一）应用程序架构简介</title><link href="/ext-js-5-shou-ce-ying-yong-cheng-xu-jia-gou-yi-ying-yong-cheng-xu-jia-gou-jian-jie.html" rel="alternate"></link><published>2015-05-17T00:00:00+08:00</published><updated>2015-05-17T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-17:/ext-js-5-shou-ce-ying-yong-cheng-xu-jia-gou-yi-ying-yong-cheng-xu-jia-gou-jian-jie.html</id><summary type="html">&lt;h1&gt;Ext JS 5 手册 应用程序架构（一）应用程序架构简介&lt;/h1&gt;
&lt;h2&gt;程序架构&lt;/h2&gt;
&lt;h3 id="ying-yong-cheng-xu-jia-gou-jian-jie"&gt;应用程序架构简介&lt;/h3&gt;
&lt;p&gt;Ext JS 提供了对 MVC 和 MVVM 架构的支持。&lt;/p&gt;
&lt;h4 id="mvc"&gt;MVC&lt;/h4&gt;
&lt;p&gt;在 MVC 架构中，用户与 View 交互，它显示 Model 中的数据。这些交互由 Controller 来处理，它负责修改 View 和 Model。&lt;/p&gt;
&lt;p&gt;View 和 Model 互相是不知道的，因为 Controller 在直接处理更新。即，Controller 包含了 MVC 应用中大多数的程序逻辑。View 有可能也包含了少量业务逻辑。Model 则主要是提供了数据处理和业务逻辑处理的接口。&lt;/p&gt;
&lt;p&gt;MVC …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Ext JS 5 手册 应用程序架构（一）应用程序架构简介&lt;/h1&gt;
&lt;h2&gt;程序架构&lt;/h2&gt;
&lt;h3 id="ying-yong-cheng-xu-jia-gou-jian-jie"&gt;应用程序架构简介&lt;/h3&gt;
&lt;p&gt;Ext JS 提供了对 MVC 和 MVVM 架构的支持。&lt;/p&gt;
&lt;h4 id="mvc"&gt;MVC&lt;/h4&gt;
&lt;p&gt;在 MVC 架构中，用户与 View 交互，它显示 Model 中的数据。这些交互由 Controller 来处理，它负责修改 View 和 Model。&lt;/p&gt;
&lt;p&gt;View 和 Model 互相是不知道的，因为 Controller 在直接处理更新。即，Controller 包含了 MVC 应用中大多数的程序逻辑。View 有可能也包含了少量业务逻辑。Model 则主要是提供了数据处理和业务逻辑处理的接口。&lt;/p&gt;
&lt;p&gt;MVC 的目标是要清楚的区分应用程序中各个类的职责。这意味着在大型项目中能很好的解耦。让程序易于测试和维护，并且便于代码重用。&lt;/p&gt;
&lt;h4 id="mvvm"&gt;MVVM&lt;/h4&gt;
&lt;p&gt;MVC 和 MVVM 的区别在于 MVVM 突出了一个抽象的 ViewModel。它通过数据绑定技术来协调 Model 的数据和 View 展现时使用的数据。&lt;/p&gt;
&lt;p&gt;这使得框架能处理更多的工作，能最小化或消除程序逻辑中直接处理 View。&lt;/p&gt;
&lt;h4 id="yong-hu-de-shi-yong"&gt;用户的使用&lt;/h4&gt;
&lt;p&gt;Ext JS 5 引入的 MVVM 构架中提升了 MVC 架构中的 C。并且能兼容 Ext JS 4 MVC 应用。&lt;/p&gt;
&lt;h4 id="mvc-he-mvvm"&gt;MVC 和 MVVM&lt;/h4&gt;
&lt;p&gt;为了了解哪个更适合你的应用，我们需要了解以下术语：
 - （M）Model 程序中的数据。它由一组定义了字段的构成。Model 知道如何使用 data package 对数据进行持久化，并且能通过 association 关联到其它的 model。Model 通常与 Store 一起使用，为 grid 或其它组件提供数据。Model 也适合进行验证、转换等数据逻辑处理。
 - （V）View 用于展现数据。
 - （C）Controller 用于处理视图中的逻辑。它可以渲染视图、控制路由、实例化 Model、进行其它的逻辑处理。
 - （VM）ViewModel 用于管理特定的 View 的数据。组件能绑定到它，在数据发生变化时组件会自动更新。&lt;/p&gt;
&lt;p&gt;这些构架能提供非常好的结构和一致性。遵循以下约定能获取很多好处：
 - 每个应用都是以相同的方式工作的，因此只需要学习一个
 - 很容易在不同的应用间共享代码
 - Sencha Cmd 能为你的应用生成优化版&lt;/p&gt;
&lt;h4 id="chuang-jian-yi-ge-shi-li-ying-yong"&gt;创建一个示例应用&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sencha generate app -ext MyApp ./app
&lt;span class="nb"&gt;cd&lt;/span&gt; app
sencha app watch
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="ying-yong-cheng-xu-gai-lan"&gt;应用程序概览&lt;/h4&gt;
&lt;h5 id="mu-lu-jie-gou"&gt;目录结构&lt;/h5&gt;
&lt;p&gt;Ext JS 应用遵循统一的目录结构。在推荐的目录结构中所有类都放在 app 目录中。这个目录包含的子目录是 MVC 元素的命名空间。View，View Controller 和 ViewModel 都属于视图类元素。&lt;/p&gt;
&lt;h5 id="ming-ming-kong-jian"&gt;命名空间&lt;/h5&gt;
&lt;p&gt;每个类的第一行都是它的命名空间。格式为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;AppName&amp;gt;.&amp;lt;foldername&amp;gt;.&amp;lt;ClassAndFileName&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="ying-yong-cheng-xu_1"&gt;应用程序&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;index.html&lt;/code&gt;中只引用了&lt;code&gt;bootstrap.js&lt;/code&gt;，它用于加载&lt;code&gt;app.json&lt;/code&gt;。&lt;code&gt;app.json&lt;/code&gt;中定义了整个应用的元数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;app.json&lt;/code&gt;中添加了大量的注释信息。&lt;/p&gt;
&lt;h5 id="appjs"&gt;app.js&lt;/h5&gt;
&lt;p&gt;应用程序在&lt;code&gt;Application.js&lt;/code&gt;中定义了应用类，在&lt;code&gt;app.js&lt;/code&gt;中调用了这个类的实例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * This file is generated and updated by Sencha Cmd. You can edit this file as&lt;/span&gt;
&lt;span class="cm"&gt; * needed for your application, but these edits will have to be merged by&lt;/span&gt;
&lt;span class="cm"&gt; * Sencha Cmd when upgrading.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;application&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
    &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'MyApp'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'MyApp.Application'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;autoCreateViewport&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'MyApp.view.main.Main'&lt;/span&gt;

    &lt;span class="c1"&gt;//-------------------------------------------------------------------------&lt;/span&gt;
    &lt;span class="c1"&gt;// Most customizations should be made to MyApp.Application. If you need to&lt;/span&gt;
    &lt;span class="c1"&gt;// customize this file, doing so below this section reduces the likelihood&lt;/span&gt;
    &lt;span class="c1"&gt;// of merge conflicts when upgrading to new versions of Sencha Cmd.&lt;/span&gt;
    &lt;span class="c1"&gt;//-------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;autoCreateViewport&lt;/code&gt;是 Ext JS 5 的一个新功能。通过为 container 类指定&lt;code&gt;autoCreateViewport&lt;/code&gt;，你可以使用任何类作为你的 Viewport。在这个你还子中我们使用 MyApp.view.main.Main（它是一个 Container 类）作为 Viewport。&lt;/p&gt;
&lt;h5 id="applicationjs"&gt;Application.js&lt;/h5&gt;
&lt;p&gt;每个 Ext JS 应用都是从一个 Application 类的实例开始的。这个类由 app.js 调用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.Application'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.app.Application'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'MyApp'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;stores&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="c1"&gt;// TODO: add global/shared stores here&lt;/span&gt;
    &lt;span class="p"&gt;],&lt;/span&gt;

    &lt;span class="nx"&gt;launch&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// TODO - Launch the application&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Application 类包含了应用的命名空间、共享的 store 等全局设置。&lt;/p&gt;
&lt;h4 id="view_1"&gt;View&lt;/h4&gt;
&lt;p&gt;View 都是 Ext.Component 的子类。View 包含了应用中所有可以看到的东西。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.main.Main'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.container.Container'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'app-main'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;controller&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'main'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;viewModel&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'main'&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;

    &lt;span class="nx"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'border'&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;

    &lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;bind&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'{name}'&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'west'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'&amp;lt;ul&amp;gt;...&amp;lt;/ul&amp;gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;width&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;250&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;split&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;tbar&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
            &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;handler&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onClickButton'&lt;/span&gt;
        &lt;span class="p"&gt;}]&lt;/span&gt;
    &lt;span class="p"&gt;},{&lt;/span&gt;
        &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'center'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'tabpanel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;[{&lt;/span&gt;
            &lt;span class="nx"&gt;title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Tab 1'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'&amp;lt;h2&amp;gt;Content ...&amp;lt;/h2&amp;gt;'&lt;/span&gt;
        &lt;span class="p"&gt;}]&lt;/span&gt;
    &lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;View 并不包含任何程序逻辑。所有的 view 逻辑应该放在 ViewController 中。&lt;/p&gt;
&lt;p&gt;View 中比较重要的是配置是 controller 和 viewModel。&lt;/p&gt;
&lt;h5 id="controller-pei-zhi"&gt;Controller 配置&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;controller&lt;/code&gt;配置项可以指定 View 的 ViewController类，它是 View 的事件处理器的容器。&lt;/p&gt;
&lt;h5 id="viewmodel-pei-zhi"&gt;ViewModel 配置&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;viewModel&lt;/code&gt;配置项可以指定 View 的 ViewModel 类，它是组件的数据提供者。ViewModel 中的数据通常通过组件上的数据绑定来展现和编辑数据。如上例中的面板名称。&lt;/p&gt;
&lt;h4 id="controller_1"&gt;Controller&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.main.MainController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.app.ViewController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;requires&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s1"&gt;'Ext.MessageBox'&lt;/span&gt;
    &lt;span class="p"&gt;],&lt;/span&gt;

    &lt;span class="nx"&gt;alias&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'controller.main'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;onClickButton&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;confirm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Confirm'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Are you sure?'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'onConfirm'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;

    &lt;span class="nx"&gt;onConfirm&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;choice&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;choice&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="s1"&gt;'yes'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看之前的视图 Main.js，你可以看到 tbar 按钮事件的处理器 onClickButton 就定义在这个 Controller 中。&lt;/p&gt;
&lt;p&gt;ViewController 主要用于：
 - 使用&lt;code&gt;listeners&lt;/code&gt;和&lt;code&gt;reference&lt;/code&gt;配置连接到 View。
 - View 的生命周期管理将自动管理相关联的 ViewController。从初始化到销毁，Ext.app.ViewController 总是与它相关的组件关联。
 - ViewController 与其管理的 View 是一对一关联的，减少了复杂性
 - 提供了支持 View 嵌套使用的封装
 - 能在关联的 View 的任意层级上选中组件并监听它的事件&lt;/p&gt;
&lt;h4 id="viewmodel"&gt;ViewModel&lt;/h4&gt;
&lt;p&gt;Ext JS 5 手册 应用程序架构（二）View Controller&lt;/p&gt;
&lt;h5 id="jian-ting"&gt;监听&lt;/h5&gt;
&lt;p&gt;在 Ext JS 5 中对&lt;code&gt;listeners&lt;/code&gt;这个配置项进行了增强。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.Foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.panel.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;controller&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'textfield'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;fieldLabel&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Bar'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;change&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onBarChange'&lt;/span&gt;  &lt;span class="c1"&gt;// no scope given here&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.FooController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.app.ViewController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;alias&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'controller.foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;onBarChange&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;barTextField&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// called by 'change' event&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例的&lt;code&gt;onBarChange&lt;/code&gt;并未指定&lt;code&gt;scope&lt;/code&gt;，事件系统默认会到 Bar 所属的 ViewController 中去找。&lt;/p&gt;
&lt;p&gt;由于历史原因，组件的创建者可以使用&lt;code&gt;listeners&lt;/code&gt;配置项，那么 View 是怎么监听到它自己的事件呢？答案是需要显式的配置&lt;code&gt;scope&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.Foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.panel.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;controller&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;collapse&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onCollapse'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;scope&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'controller'&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;

    &lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;scope&lt;/code&gt;选项有两个有效的值：&lt;code&gt;this&lt;/code&gt;和&lt;code&gt;controller&lt;/code&gt;。当编写 MVC 应用时通常总会是&lt;code&gt;controller&lt;/code&gt;，即在 ViewController （不是创建 View 实例的 ViewController）中查找。&lt;/p&gt;
&lt;p&gt;由于 View 可能通过 xtype 来创建：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.bar.Bar'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.panel.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;controller&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;collapse&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onCollapse'&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种情况下，Foo 是由 Bar 创建的。它能像 Foo 一样 去监听 collapse 事件。在之前的版本的 Ext JS 中，这种声明方式会导致冲突。在 Ext JS 5 中，解决了这一问题。在 Foo 中声明的事件将会触发在 Foo 的 ViewController 中的监听中。在 Bar 中声明的事件将会触发在 Bar 的 ViewController 中。&lt;/p&gt;
&lt;h5 id="reference"&gt;Reference&lt;/h5&gt;
&lt;p&gt;我们经常会在编写 controller 时获取某个组件然后对它进行某些操作。比如获取某个表格，然后向表格中添加一行新记录。&lt;/p&gt;
&lt;p&gt;但是如何能获取到组件呢？在 Ext JS 4 中，需要使用&lt;code&gt;refs&lt;/code&gt;配置项或其它的方式查找组件。所有这些技术都需要你在要获取的组件上放置一个特殊的唯一属性来进行标识。旧的技术手段使用&lt;code&gt;id&lt;/code&gt;配置项（和 Ext.getCmp）或使用&lt;code&gt;itemId&lt;/code&gt;配置项（使用&lt;code&gt;refs&lt;/code&gt;或其它组件查询方法）。使用&lt;code&gt;id&lt;/code&gt;的好处是查询速度快，但是它要求这标识符必须在整个应用程序的 DOM 结构中是唯一的，这通常不方便。使用&lt;code&gt;itemId&lt;/code&gt;和其它查询方法要更灵活一些，但是也需要执行一些查询才能获取相应的组件。&lt;/p&gt;
&lt;p&gt;Ext JS 5 提供了&lt;code&gt;reference&lt;/code&gt;配置项，可以通过&lt;code&gt;lookupReference&lt;/code&gt;来获取组件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.Foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.panel.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;controller&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;tbar&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Add'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;handler&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onAdd'&lt;/span&gt;
    &lt;span class="p"&gt;}],&lt;/span&gt;

    &lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
        &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'grid'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;reference&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'fooGrid'&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.FooController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.app.ViewController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;alias&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'controller.foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;onAdd&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;grid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;lookupReference&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'fooGrid'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这类似于将&lt;code&gt;itemId&lt;/code&gt;设置成"fooGrid"并执行&amp;ldquo;this.down('#fooGrid')&amp;rdquo;。区别在于&lt;code&gt;reference&lt;/code&gt;配置项会将自己注册到它所属的 View 中；&lt;code&gt;lookupReference&lt;/code&gt;方法通过查询缓存来检查 refrence 是否需要刷新。当缓存成功后会从缓存中加载对象。&lt;/p&gt;
&lt;h5 id="feng-zhuang"&gt;封装&lt;/h5&gt;
&lt;p&gt;在 Ext JS 4 MVC 实现中使用选择器非常灵活，但是有时会存在一些风险。这些选择器能&amp;ldquo;看到&amp;rdquo;所有的组件。&lt;/p&gt;
&lt;p&gt;这个问题可能通过遵循某些最佳实践来解决，但是在 ViewController 中使用&lt;code&gt;listeners&lt;/code&gt;和&lt;code&gt;references&lt;/code&gt;会变得简单。因为它们只会在它所属的 ViewController 间建立连接。View 可以使用任何的 reference 值，只要保证所属的 view 中是唯一的，这些名称不会被 view 的创建者暴露出去。&lt;/p&gt;
&lt;p&gt;同样，View 会在所属的 ViewController 中查找监听器，而不会将事件分发到由于不正确的选择器所选中的组件的 controller 上。&lt;/p&gt;
&lt;h5 id="jian-ting-qi-he-shi-jian-yu"&gt;监听器和事件域&lt;/h5&gt;
&lt;p&gt;在 Ext JS 4.2中，MVC的事件分发器引入了事件域。事件域在事件发生时拦截事件，并通过选器来匹配并分发到 controller。&amp;ldquo;组件&amp;rdquo;事件域有整个组件的选择器，其它域具有限制性的选择器。&lt;/p&gt;
&lt;p&gt;在 Ext JS 5 中，每个 ViewController 创建一个被称为&amp;ldquo;View&amp;rdquo;事件域的新类型的事件域实例。这下事件域允许 ViewController 使用标准的&lt;code&gt;listen&lt;/code&gt;和&lt;code&gt;control&lt;/code&gt;方法限定在它们所属的 View。它也提供了一个特殊的选择器匹配 View 本身：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.FooController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.app.ViewController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;alias&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'controller.foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="nx"&gt;control&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s1"&gt;'#'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// 匹配当前 View 自己&lt;/span&gt;
            &lt;span class="nx"&gt;collapse&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onCollapse'&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="nx"&gt;button&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;click&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onAnyButtonClick'&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要的区别在于上面的监听和选择器。&amp;ldquo;button&amp;rdquo;选择器将匹配这个 view 或子 view 中任何的按钮。&lt;/p&gt;
&lt;p&gt;最后，这些事件域会向上层的 view 结构 &amp;ldquo;冒泡&amp;rdquo;。当事件发生时，首先会投递到标准监听器。然后是投递到它所属的 ViewController，然后是它所属的 view 的父 view 的 ViewController。最后，事件被投递到标准的&amp;ldquo;component'事件域，被 Ext.app.Controller 派生的控制器处理。&lt;/p&gt;
&lt;h5 id="sheng-ming-zhou-qi"&gt;生命周期&lt;/h5&gt;</content><category term="javascript"></category><category term="extjs"></category></entry><entry><title>Ext JS5 手册 应用程序架构（二） View Controller</title><link href="/ext-js5-shou-ce-ying-yong-cheng-xu-jia-gou-er-view-controller.html" rel="alternate"></link><published>2015-05-17T00:00:00+08:00</published><updated>2015-05-17T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2015-05-17:/ext-js5-shou-ce-ying-yong-cheng-xu-jia-gou-er-view-controller.html</id><summary type="html">&lt;h2&gt;Ext JS5 手册 应用程序架构（二） View Controller&lt;/h2&gt;
&lt;h5 id="jian-ting"&gt;监听&lt;/h5&gt;
&lt;p&gt;在 Ext JS 5 中对&lt;code&gt;listeners&lt;/code&gt;这个配置项进行了增强。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.Foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.panel.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;controller&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
&lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'textfield'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;fieldLabel&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Bar'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;change&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onBarChange'&lt;/span&gt; &lt;span class="c1"&gt;// no scope given here&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.FooController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.app …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h2&gt;Ext JS5 手册 应用程序架构（二） View Controller&lt;/h2&gt;
&lt;h5 id="jian-ting"&gt;监听&lt;/h5&gt;
&lt;p&gt;在 Ext JS 5 中对&lt;code&gt;listeners&lt;/code&gt;这个配置项进行了增强。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.Foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.panel.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;controller&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
&lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'textfield'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;fieldLabel&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Bar'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;change&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onBarChange'&lt;/span&gt; &lt;span class="c1"&gt;// no scope given here&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.FooController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.app.ViewController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;alias&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'controller.foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="nx"&gt;onBarChange&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;barTextField&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// called by 'change' event&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例的&lt;code&gt;onBarChange&lt;/code&gt;并未指定&lt;code&gt;scope&lt;/code&gt;，事件系统默认会到 Bar 所属的 ViewController 中去找。&lt;/p&gt;
&lt;p&gt;由于历史原因，组件的创建者可以使用&lt;code&gt;listeners&lt;/code&gt;配置项，那么 View 是怎么监听到它自己的事件呢？答案是需要显式的配置&lt;code&gt;scope&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.Foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.panel.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;controller&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;collapse&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onCollapse'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;scope&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'controller'&lt;/span&gt;
&lt;span class="p"&gt;},&lt;/span&gt;

&lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;scope&lt;/code&gt;选项有两个有效的值：&lt;code&gt;this&lt;/code&gt;和&lt;code&gt;controller&lt;/code&gt;。当编写 MVC 应用时通常总会是&lt;code&gt;controller&lt;/code&gt;，即在 ViewController （不是创建 View 实例的 ViewController）中查找。&lt;/p&gt;
&lt;p&gt;由于 View 可能通过 xtype 来创建：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.bar.Bar'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.panel.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;controller&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
&lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;listeners&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;collapse&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onCollapse'&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种情况下，Foo 是由 Bar 创建的。它能像 Foo 一样 去监听 collapse 事件。在之前的版本的 Ext JS 中，这种声明方式会导致冲突。在 Ext JS 5 中，解决了这一问题。在 Foo 中声明的事件将会触发在 Foo 的 ViewController 中的监听中。在 Bar 中声明的事件将会触发在 Bar 的 ViewController 中。&lt;/p&gt;
&lt;h5 id="reference"&gt;Reference&lt;/h5&gt;
&lt;p&gt;我们经常会在编写 controller 时获取某个组件然后对它进行某些操作。比如获取某个表格，然后向表格中添加一行新记录。&lt;/p&gt;
&lt;p&gt;但是如何能获取到组件呢？在 Ext JS 4 中，需要使用&lt;code&gt;refs&lt;/code&gt;配置项或其它的方式查找组件。所有这些技术都需要你在要获取的组件上放置一个特殊的唯一属性来进行标识。旧的技术手段使用&lt;code&gt;id&lt;/code&gt;配置项（和 Ext.getCmp）或使用&lt;code&gt;itemId&lt;/code&gt;配置项（使用&lt;code&gt;refs&lt;/code&gt;或其它组件查询方法）。使用&lt;code&gt;id&lt;/code&gt;的好处是查询速度快，但是它要求这标识符必须在整个应用程序的 DOM 结构中是唯一的，这通常不方便。使用&lt;code&gt;itemId&lt;/code&gt;和其它查询方法要更灵活一些，但是也需要执行一些查询才能获取相应的组件。&lt;/p&gt;
&lt;p&gt;Ext JS 5 提供了&lt;code&gt;reference&lt;/code&gt;配置项，可以通过&lt;code&gt;lookupReference&lt;/code&gt;来获取组件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.Foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.panel.Panel'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;controller&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="nx"&gt;tbar&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
&lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;text&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Add'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;handler&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onAdd'&lt;/span&gt;
&lt;span class="p"&gt;}],&lt;/span&gt;

&lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;
&lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'grid'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;reference&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'fooGrid'&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;

&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.FooController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.app.ViewController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;alias&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'controller.foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="nx"&gt;onAdd&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;grid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;lookupReference&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'fooGrid'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这类似于将&lt;code&gt;itemId&lt;/code&gt;设置成"fooGrid"并执行&amp;ldquo;this.down('#fooGrid')&amp;rdquo;。区别在于&lt;code&gt;reference&lt;/code&gt;配置项会将自己注册到它所属的 View 中；&lt;code&gt;lookupReference&lt;/code&gt;方法通过查询缓存来检查 refrence 是否需要刷新。当缓存成功后会从缓存中加载对象。&lt;/p&gt;
&lt;h5 id="feng-zhuang"&gt;封装&lt;/h5&gt;
&lt;p&gt;在 Ext JS 4 MVC 实现中使用选择器非常灵活，但是有时会存在一些风险。这些选择器能&amp;ldquo;看到&amp;rdquo;所有的组件。&lt;/p&gt;
&lt;p&gt;这个问题可能通过遵循某些最佳实践来解决，但是在 ViewController 中使用&lt;code&gt;listeners&lt;/code&gt;和&lt;code&gt;references&lt;/code&gt;会变得简单。因为它们只会在它所属的 ViewController 间建立连接。View 可以使用任何的 reference 值，只要保证所属的 view 中是唯一的，这些名称不会被 view 的创建者暴露出去。&lt;/p&gt;
&lt;p&gt;同样，View 会在所属的 ViewController 中查找监听器，而不会将事件分发到由于不正确的选择器所选中的组件的 controller 上。&lt;/p&gt;
&lt;h5 id="jian-ting-qi-he-shi-jian-yu"&gt;监听器和事件域&lt;/h5&gt;
&lt;p&gt;在 Ext JS 4.2中，MVC的事件分发器引入了事件域。事件域在事件发生时拦截事件，并通过选器来匹配并分发到 controller。&amp;ldquo;组件&amp;rdquo;事件域有整个组件的选择器，其它域具有限制性的选择器。&lt;/p&gt;
&lt;p&gt;在 Ext JS 5 中，每个 ViewController 创建一个被称为&amp;ldquo;View&amp;rdquo;事件域的新类型的事件域实例。这下事件域允许 ViewController 使用标准的&lt;code&gt;listen&lt;/code&gt;和&lt;code&gt;control&lt;/code&gt;方法限定在它们所属的 View。它也提供了一个特殊的选择器匹配 View 本身：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'MyApp.view.foo.FooController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;extend&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'Ext.app.ViewController'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="nx"&gt;alias&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'controller.foo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="nx"&gt;control&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="s1"&gt;'#'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 匹配当前 View 自己&lt;/span&gt;
&lt;span class="nx"&gt;collapse&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onCollapse'&lt;/span&gt;
&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="nx"&gt;button&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;click&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'onAnyButtonClick'&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要的区别在于上面的监听和选择器。&amp;ldquo;button&amp;rdquo;选择器将匹配这个 view 或子 view 中任何的按钮。&lt;/p&gt;
&lt;p&gt;最后，这些事件域会向上层的 view 结构 &amp;ldquo;冒泡&amp;rdquo;。当事件发生时，首先会投递到标准监听器。然后是投递到它所属的 ViewController，然后是它所属的 view 的父 view 的 ViewController。最后，事件被投递到标准的&amp;ldquo;component'事件域，被 Ext.app.Controller 派生的控制器处理。&lt;/p&gt;
&lt;h5 id="sheng-ming-zhou-qi"&gt;生命周期&lt;/h5&gt;</content><category term="javascript"></category><category term="extjs"></category></entry><entry><title>设计模式回顾</title><link href="/she-ji-mo-shi-hui-gu.html" rel="alternate"></link><published>2014-11-04T00:00:00+08:00</published><updated>2014-11-04T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2014-11-04:/she-ji-mo-shi-hui-gu.html</id><summary type="html">&lt;h1&gt;设计模式回顾&lt;/h1&gt;
&lt;h2&gt;创建模式&lt;/h2&gt;
&lt;h3 id="simple-factory"&gt;Simple Factory&lt;/h3&gt;
&lt;p&gt;工厂类提供静态方法来创建某一接口类型的具体实现，该方法根据传入的参数来决定需要创建哪种类型的实现，因此传入的参数一般带有具体的类型信息（ class 的完整名称，或在某个包下的简称等等）。
举例：音乐盒接口的实现有钢琴音乐盒，小提琴音乐盒，有一音乐盒工厂类，它的 createMusicBox 方法内部根据参数来创建钢琴音乐盒或小提琴音乐盒。&lt;/p&gt;
&lt;h3 id="abstract-factory"&gt;Abstract Factory&lt;/h3&gt;
&lt;p&gt;抽象工厂模式一般用于创建一套对象，它将具体的某套对象的创建方法封装在对应的工厂类实现里。这些工厂类实现了同一接口（抽象工厂）。工厂类接口中的各个方法都返回接口类型。在具体工厂类的实现中它的各个方法能返回一套实现中不同类型的对象。
举例：多套 UI 组件具有不同的外观，每一套都由实现同一抽象工厂接口的具体工厂类型来创建。抽象工厂接口里规定了能创建哪些 UI 组件，各个组件的接口类型是什么。具体工厂实现里的各个方法会根据它的风格创建出对应的UI组件。&lt;/p&gt;
&lt;h3 id="builder"&gt;Builder&lt;/h3&gt;
&lt;p&gt;当创建复杂的对象或结构时，需要一个负责指挥的的导演类对象，它根据传递给它的 IBuilder ，按某一步骤来进行对象的构建。IBuider中 的各个方法代表构建过程的不同步骤。IBuilder 可以有多个不同的实现。&lt;/p&gt;
&lt;h3 id="factory-method"&gt;Factory Method&lt;/h3&gt;
&lt;p&gt;Factory Method 会在抽象类中留下某个创建 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;设计模式回顾&lt;/h1&gt;
&lt;h2&gt;创建模式&lt;/h2&gt;
&lt;h3 id="simple-factory"&gt;Simple Factory&lt;/h3&gt;
&lt;p&gt;工厂类提供静态方法来创建某一接口类型的具体实现，该方法根据传入的参数来决定需要创建哪种类型的实现，因此传入的参数一般带有具体的类型信息（ class 的完整名称，或在某个包下的简称等等）。
举例：音乐盒接口的实现有钢琴音乐盒，小提琴音乐盒，有一音乐盒工厂类，它的 createMusicBox 方法内部根据参数来创建钢琴音乐盒或小提琴音乐盒。&lt;/p&gt;
&lt;h3 id="abstract-factory"&gt;Abstract Factory&lt;/h3&gt;
&lt;p&gt;抽象工厂模式一般用于创建一套对象，它将具体的某套对象的创建方法封装在对应的工厂类实现里。这些工厂类实现了同一接口（抽象工厂）。工厂类接口中的各个方法都返回接口类型。在具体工厂类的实现中它的各个方法能返回一套实现中不同类型的对象。
举例：多套 UI 组件具有不同的外观，每一套都由实现同一抽象工厂接口的具体工厂类型来创建。抽象工厂接口里规定了能创建哪些 UI 组件，各个组件的接口类型是什么。具体工厂实现里的各个方法会根据它的风格创建出对应的UI组件。&lt;/p&gt;
&lt;h3 id="builder"&gt;Builder&lt;/h3&gt;
&lt;p&gt;当创建复杂的对象或结构时，需要一个负责指挥的的导演类对象，它根据传递给它的 IBuilder ，按某一步骤来进行对象的构建。IBuider中 的各个方法代表构建过程的不同步骤。IBuilder 可以有多个不同的实现。&lt;/p&gt;
&lt;h3 id="factory-method"&gt;Factory Method&lt;/h3&gt;
&lt;p&gt;Factory Method 会在抽象类中留下某个创建 IProduct 类型对象的方法(即创建对象的工厂方法)没有实现，而抽象类中其它方法都使用 IProduct 接口来操作该对象。
通常抽象类自己会调用这个抽像方法，并将创建出来的对象保存在抽象类的某个属性中，抽象类的其它方法直接使用 IProduct 接口来操作这一对象实例。&lt;/p&gt;
&lt;h3 id="prototype"&gt;Prototype&lt;/h3&gt;
&lt;p&gt;通过 clone 原型对象来创建新的实例。&lt;/p&gt;
&lt;h3 id="singleton"&gt;Singleton&lt;/h3&gt;
&lt;p&gt;单例模式的观念简单但很多时候会根据具体的环境进行调整和变化，比如多线程，lazy 实例化等。&lt;/p&gt;
&lt;h3 id="registry-of-singleton"&gt;Registry of Singleton&lt;/h3&gt;
&lt;p&gt;处理 Singleton 存在子类型的问题。
Singleton 的类型中定义一个 Map 保存 Singleton 各子类型的单实例对象，并提供一个 register 方法给 Singleton 的子类型注册其单实例。在 Singleton 的 getInstance 方法会根据当前的环境或配置到 map 中去 lookup 满足条件的实例。
在情况比较简单的情况下也可以不使用 register 方法，而直接根据当前的环境或配置通过反射获取类型并进行 Singleton 子类对象的实例化。&lt;/p&gt;
&lt;h2&gt;结构模式&lt;/h2&gt;
&lt;h3 id="default-adapter"&gt;Default Adapter&lt;/h3&gt;
&lt;p&gt;继承实现了某一接口的类（实现的方法中几乎什么都不做），而不是直接实现该接口的所有方法。这个实现了接口的类就是这一接口的缺省适配器，它能避免实现接口时需要实现该接口所有方法的问题。&lt;/p&gt;
&lt;h3 id="object-adapter"&gt;Object Adapter&lt;/h3&gt;
&lt;p&gt;Adapter 通过实现目标 ITarget 接口，将被适配类型 Adaptee 的实例包装成 ITarget 类型。这一模式中 Adapter 类型不需要继承 Adaptee 类型，它只需要用一个实例变量来保存 Adaptee 类型的实例。&lt;/p&gt;
&lt;h3 id="class-adapter"&gt;Class Adapter&lt;/h3&gt;
&lt;p&gt;Adapter 直接继承被适配类型 Adaptee 和 Target 类型，这需要语言层面支持多继承。在 Java 中只能实现继承 Adaptee 类型和 实例 ITarget 接口，这一限制也导致它在 Java 中的使用场合较少。&lt;/p&gt;
&lt;h3 id="bridget"&gt;Bridget&lt;/h3&gt;
&lt;p&gt;GOF 中指出 Bridge 的目的是：&amp;ldquo;将抽象部分与它的实现部分分享，使它们都可以独立的变化。&amp;rdquo;，即将对象的行为定义与针对于特定类型的行为实现进行分离。这样可以让行为定义部分和行为实现两部分互不交错，都可以持续的扩充下去。&lt;/p&gt;
&lt;h3 id="composite"&gt;Composite&lt;/h3&gt;
&lt;p&gt;使用 Composite 类型来定义树状组合结构。Composite 对象中可以添加其它的 Composite 对象，这样可以组合出更为复杂的大对象。而对 Composite 实例的方法调用，可以触发属于它的 Composite 实例的方法调用，保持整个 Composite 行为的一致。
举例：以绘图程序来说，定义一个图像 Component 为基础类型，直线、文字、矩形都是它的子类型，它们都实现了 Component 中定义的 draw 等基本接口，而图像容器 Container 则实现了 Component 的添加、删除、获取子图像的接口，它的 draw 方法会调用属于它的所有子元素的 draw 方法。这样就能通过将 Component 对象的嵌套，构造出复杂的结构。&lt;/p&gt;
&lt;h3 id="decorator"&gt;Decorator&lt;/h3&gt;
&lt;p&gt;装饰器模式能动态的为被装饰的对象添加新功能。
举例：Swing 中的 JTextArea 并没有带滚动条，只需要给它加上 JScrollPane 装饰器就可以实现滚动条的功能。抽象的装饰器与被装饰对象都实现了同样的接口，抽象装饰器中通常包含了一个被装饰的对象实例，对装饰器的调用会被转换为对被装饰对象的调用。包含其它功能的装饰器，可以继承自抽象装饰器，以实现更多的功能。
举例：GOF 中 Stream 抽象类和 StreamDecorator 类，Stream 的子类有 MemoryStream 和 FileStream，它们负责处理不同类型的流，但这些类都只负责最基本的字节处理。实现流压缩等功能则没有被编码到 Stream 子类，而是被实现为 StreamDecorator，由它们来提供这些额外的功能，由使用者来决定是否使用这些额外的功能。&lt;/p&gt;
&lt;h3 id="adapter-yu-decorator-de-bi-jiao"&gt;Adapter 与 Decorator 的比较&lt;/h3&gt;
&lt;p&gt;Adapter 与 Decorator 从定义上比较：
 - 都有个别名叫&lt;code&gt;包装模式&lt;/code&gt;
 - 装饰模式以对客户端透明的方式扩展对象，是继承关系的替代方案，比继承提供更多的灵活性。使用装饰类的实例，把客户端的调用委派到被装饰类。
 - 适配器模式则是把一个类的接口变换为客户端所期侍的另一种接口，从而使原本类型不匹配的两个类能一起工作。&lt;/p&gt;
&lt;p&gt;Adapter 与 Decorator 从使用条件上比较：
 - 装饰模式在需要扩展一个类的功能或者给这个类附加责任时使用；需要动态的给对象增加功能，这些附加的功能和责任可以撤销；所要增加的功能较多，并且排列组合量非常大，使用继承关系变得不现实
 - 适配器模式一般是新系统需要使用现有的类，但这个类已经不符合新系统的要求了。通常在系统升级时使用频率较高。&lt;/p&gt;
&lt;h3 id="facade"&gt;Facade&lt;/h3&gt;
&lt;p&gt;门面模式用于隐藏各个组件之间的合作行为，以及组件本身的操作与设置细节。它会让门面类的使用者损失一些直接操作各个组件细节的方便性。
举例：邮件程序可能要使用 FileUpload, Calendar, SimpleSMTP 等组件，因此可以定义一个 IFacade 及其实现 ConcreteFacade ，由 ConcreteFacade 来调用各个合作组的工作，由 IFacade 向外部提供统一的接口。&lt;/p&gt;
&lt;h3 id="flyweight"&gt;Flyweight&lt;/h3&gt;
&lt;p&gt;享元模式在描述数量多且性质接近的对象时将对象的信息分为两个部分：内部状态与外部状态。内部状态是对象的可共享部分，外部状态则依赖于具体的场景。
举例：Java 中的字符串使用的就是 Flyweight 模式，它维护了一个 String Pool，对于可共享的字符串对象，它会在 String Pool 中查找是否存在相同的内容，如果有就直接使用。两个指向相同内容的字符串使用 == 进行比较时，有可能返回的就是 true，因为它们可能引用的 String Pool 中的同一对象。&lt;/p&gt;
&lt;h3 id="proxy"&gt;Proxy&lt;/h3&gt;
&lt;p&gt;GOF 中给代理模式的目的定义是：给其它对象提供一种代理，以控制对这一对象的访问。
举例：文档中嵌入图片的例子，文档嵌入时并不直接加载图片，而是加载一个图片的代理，它代替图片被加载，以提升加载文档的速度。当文档滚动到图片所在的页数时，这时再加载图片。
代理的实现有两种：静态代理和动态代理：
 - 静态代理直接继承被代理对象的接口，并保存有一个被代理对象的实例。代理对象在调用被代理对象的方法前后加上需要的操作。
 - Java JDK 1.3 之后添加了 Dynamic Proxy 功能，定义一个实现 InvocationHandler 接口的类，它的bind方法将返回一个代理对象，它的 invoke 方法能捕捉到对被代理对象的方法调用。&lt;/p&gt;
&lt;h3 id="proxy-yu-decorator-de-qu-bie"&gt;Proxy 与 Decorator 的区别&lt;/h3&gt;
&lt;p&gt;两者都能很容易的在真实对象的方法前后加上自定义的方法。
装饰器模式关注于在对象上动态的添加方法，而代理模式关注于控制对对象的方法。代理类对客户端隐藏对象的具体信息，因此通常在代理类中创建对象实例。而使用装假模式的时候，通常是装饰原始的对象作为参数传递给装饰器的构造器。&lt;/p&gt;
&lt;h2&gt;行为模式&lt;/h2&gt;
&lt;h3 id="chain-of-responsibility"&gt;Chain of Responsibility&lt;/h3&gt;
&lt;p&gt;GOF 中的定义：使多个对象都有机会处理请求，以避免请求的发送者与接收者之间的耦合关系，将这些对象组合为一个链，并沿着这个链传递请求，直到有对象处理它为止。
因此链上的每个 Handler 都会有个类似于 successor 的对象，它是处理链上的下一个 Handler 。&lt;/p&gt;
&lt;h3 id="command"&gt;Command&lt;/h3&gt;
&lt;p&gt;以 Swing 中的菜单为例，每个菜单项都有一个 Command 与它对应，actionListener 根据点击的项，获取到对应的 Command 并调用它的方法进行处理。
很多 Web  MVC 框架也是使用这种方式来设计 Controller，由 Invoker 根据客户端请求的路径信息来决定调用某个具体的 Controller。
在使用中通常会将所有 ICommand 接口的实现注册到 Invoker 的一个集合属性中，客户端代码通过调用 Invoker.request 发起请求时，Invoker 根据请求信息（或参数），从集合中获取相应的 ICommand 对象，并调用它实现的 ICommand.execute 方法。&lt;/p&gt;
&lt;h3 id="interpreter"&gt;Interpreter&lt;/h3&gt;
&lt;p&gt;用于处理层次节点关系中解析每一个节点。（ AST？）&lt;/p&gt;
&lt;h3 id="iterator"&gt;Iterator&lt;/h3&gt;
&lt;p&gt;与期在集合对象上直接设计遍历的方法，不如设计为一个 Iterator 接口。当需要对它进行遍历时，将对象包装为一个 Iterator 后返回给客户端。
Iterator 模式可以简化集合对象的使用。&lt;/p&gt;
&lt;h3 id="mediator"&gt;Mediator&lt;/h3&gt;
&lt;p&gt;使用一个中间对象来封装对象之间的交互，对象之间不需要知道对方的存在，这样可以降低对象之间的耦合。当某个对象的状态发生变化时，它只需要通知 Mediator，由 Mediator 来处理与之相关的其它对象的状态。如果要改变对象之间的交互行为，也只需要对 Mediator 进行修改。&lt;/p&gt;
&lt;h3 id="memento"&gt;Memento&lt;/h3&gt;
&lt;p&gt;它为对象提供恢复机制。将对象的状态恢复机制放在对象之外，可以减轻对象本身的职责。
Memento 模式中，在 Originator 中有两个方法，一个方法用于获取代表它当前状态的 Memento 对象，另一个方法接收一个 Menento 对象，并将自己恢复为与它相同的状态。Memento 可能包含有 Originator 的所有属性。在外部有一个 Caretaker 来对 Memento 进行维护，每对 Originator 进行一个操作，Caretaker 就将操作前 Originator 的状态保存到它的 Memento 属性中，如果要恢复 Originator 的状态，就只要由 Caretaker 取得 Memento 属性，并对 Originator 进行状态恢复。&lt;/p&gt;
&lt;h3 id="observer"&gt;Observer&lt;/h3&gt;
&lt;p&gt;Observer 模式中的主角为主题（Subject）和观察者（Observer），观察者订阅它感兴趣的主题，一个主题可以被多个观察者订阅，当主题的状态发生变化时，它必须通知（notify）所有订阅它的观察者，观察者检查主题的状态变化，并作出对应的动作，因此 Observer 模式也被称为 Publish - Subscribe 模式。
举例：Java 中实现 Observer 接口的是观察者，这个接口定义了 update 方法，这个方法会在主题对象发生变化时被调用。主题是 Observable 的子类，这个类中有两个重要的方法： setChanged() 和 notifyObserver()。setChanged() 方法用于标明主题对象已经被修改，而 notifyObserver() 方法会通知所有订阅主题对象的观察者，并调用它们的 update() 方法。&lt;/p&gt;
&lt;h3 id="state"&gt;State&lt;/h3&gt;
&lt;p&gt;状态模式中 IObject 的每个可能的状态都实现 IState 接口。IObject 中的 current 属性是 IState 类型的，用于描述 IObject 的当前状态。当 IObject 的状态需要修改时，则它会调用 current 中的相关方法，并将自己传递给该方法，current 的这个方法会调用这个 IObject 的 setCurrentState() 方法来更新状态。
这样处理的好处是，当状态迁移关系是复杂的网状结构时，各个 IState 的实现可以根据传递进来的 IObject 的属性和自身的信息，决定 IObject 的下一个状态。即在设置下一个合理的状态时，只需要考虑当前的状态值，而不需要从整个状态迁移网来判断下一状态，避免大量的判断和检查。&lt;/p&gt;
&lt;h3 id="strategy"&gt;Strategy&lt;/h3&gt;
&lt;p&gt;将策略封装成对象，而不是将策略写死在某个类中，这样策略可以独立于客户端运行，随时可以增加新策略，减少策略，即使是修改某个策略也不会对客户端造成影响。
举例：在 CMS 区块内容的设置时，不应该根据区块内容的类型写死每个类型的处理策略。而应该将不同的类型包装为多个单独的策略（将所有策略注册为字典），这样就可以很方便的增加新策略。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;IState&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;switchFire&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FireSwitch&lt;/span&gt; &lt;span class="n"&gt;sw&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OffState&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;IState&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;switchFire&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FireSwitch&lt;/span&gt; &lt;span class="n"&gt;sw&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;sw&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SmallState&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SmallState&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;IState&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;switchFire&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FireSwitch&lt;/span&gt; &lt;span class="n"&gt;sw&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;sw&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OffState&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FireSwitch&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;IState&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OffState&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;//状态设置方法&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IState&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;//状态切换接口&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;switchFire&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;switchFire&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="template-method"&gt;Template Method&lt;/h3&gt;
&lt;p&gt;举例：比如在需要按一定的流程规则处理一些步骤时，可以在抽像类中将处理流程规划好，而具体流程中的各个步骤留给具体的实现类来处理。
Factory Method 可以将对象的创建推迟至子类来决定，而 Template Method 则是将流程中各步骤的具体实现推迟至子类来实现。&lt;/p&gt;
&lt;h3 id="visitor"&gt;Visitor&lt;/h3&gt;
&lt;p&gt;当集合中保存有实现了同一接口的多种类型的对象，而在遍历这些对象时，需要调用这些元素的具体类型上的方法时，可以使用 IVisitor 来实现，IVisitor 中的 visit 方法通过方法重载能处理集合中的各种类型。
Visitor 是基于方法重载而实现的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;IElement&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;accept&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IVisitor&lt;/span&gt; &lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//或&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;AbstractElement&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;accept&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IVisitor&lt;/span&gt; &lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;visitor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;visit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;IVisitor&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;visit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ElementA&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;visit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ElementB&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;visit&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ElementC&lt;/span&gt; &lt;span class="n"&gt;element&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;多线程相关&lt;/h2&gt;
&lt;h3 id="guarded-suspension"&gt;Guarded Suspension&lt;/h3&gt;
&lt;p&gt;举例：服务器需要处理来自多个客户端的请求，为了不丢失客户端的请求，它需要维持一个缓冲区，客户端的请求先被保存在缓冲区，服务器从缓冲区中读取请求并执行，如果缓冲区没有请求，服务器就一直等侍，直到有新的请求存入缓冲区。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RequestQueue&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LinkedList&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LinkedList&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;synchronized&lt;/span&gt; &lt;span class="n"&gt;Request&lt;/span&gt; &lt;span class="nf"&gt;getRequest&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;size&lt;/span&gt;&lt;span class="o"&gt;()&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
            &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;removeFirst&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;synchronized&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;putRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addLast&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;notifyAll&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="producer-consumer"&gt;Producer Consumer&lt;/h3&gt;
&lt;p&gt;它与 Guarded Suspension 是类似的，只不过 Guarded Suspension 模式并不限制缓冲区的长度，Producer Consumer 模式假设所生产的产品旋转在一个长度有限的缓冲区中。缓冲区满了，则生产者必须停止继续将产品放入缓冲区，直到消费者取走了产品而有了空间，如果缓冲区中没有产品，则消费者必须等侍，直到有新的产品放入缓冲区。&lt;/p&gt;
&lt;h3 id="worker-thread"&gt;Worker Thread&lt;/h3&gt;
&lt;p&gt;它对于 Request 的管理上像是 Producer Consumer 模式，而在 Request 的行为上像上 Command 模式。Consumer 取得 Request 之后，执行 Request 中指定的请求方法，也就是使用 Command 模式。
在这一模式下，通常 Request 缓冲区还管理了 Consumer，即在 Request 中有一个 WorkerThread 池，Consumer 初始化时会启动这个池中的所有线程，这些线程自己从 Consumer 中获取 Request（Command）, 并调用它的 exeucute 方法。当 Request 缓冲区中没有新的 Request 时，线程从缓冲区获取 Reuqest 的操作会被阻塞。&lt;/p&gt;
&lt;h3 id="thread-per-message"&gt;Thread-Per-Message&lt;/h3&gt;
&lt;p&gt;简单来说就是在某个请求发生时，生成一个执行线程来执行该请求，而主线程继续向下执行。&lt;/p&gt;
&lt;h3 id="future"&gt;Future&lt;/h3&gt;
&lt;p&gt;Future 模式可以看成 Proxy 模式与 Thread-Per-Message 模式的结合。Future 模式中在请求发生时，会先产生一个 Future 对象给发出请求的客户，它的作用就像是 Proxy 对象，与此同时，客户端真正需要的目标对象在一个新的线程（Thread-Per-Message）中开始创建，等到创建过程结束，就将它放入 Future 之中，当客户端真正需要该对象时，它就已经准备好了，可以让客户端提取。&lt;/p&gt;
&lt;h3 id="read-write-lock"&gt;Read-Write-Lock&lt;/h3&gt;
&lt;p&gt;简单来说就是读取和写入某个文件或对象时都需要先取得锁。这样可以保证读取方始终得到的是最新的数据。
可以在处理过程中添加类似 writeFirst 的标记，确保在读写请求都存在时写入请求先被执行。&lt;/p&gt;
&lt;h3 id="two-phase-termination"&gt;Two-phase Termination&lt;/h3&gt;
&lt;p&gt;两阶段终止，在线程的终止时使用两阶段终止，可以尽量让线程完成当前周期的工作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SomeThread&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;isContinue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;terminate&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="n"&gt;isTerminated&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;interrupt&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;beforeShutdown&lt;/span&gt;&lt;span class="o"&gt;(){}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="o"&gt;(){&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;isTerminated&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;

            &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;beforeShutdown&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="thread-specific-storage"&gt;Thread-Specific Storage&lt;/h3&gt;
&lt;p&gt;各个线程之间不共享资源，而是各自使用一个资源的副本，将每个线程的数据存储行为加以隔离。
举例：Java 中的 ThreadLocal。&lt;/p&gt;</content><category term="java"></category><category term="design pattern"></category></entry><entry><title>Beginning Android Games学习笔记</title><link href="/beginning-android-gamesxue-xi-bi-ji.html" rel="alternate"></link><published>2012-07-28T00:00:00+08:00</published><updated>2015-04-25T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2012-07-28:/beginning-android-gamesxue-xi-bi-ji.html</id><summary type="html">&lt;h1&gt;Game Development 101&lt;/h1&gt;
&lt;p&gt;在开始hacking前先进行游戏设计。这并非指基本的设计，比如FPS中的WSAD的鼠标之类的。而是类似：是否需要splash screen？需要哪些菜单项？游戏设置里需要有哪些选项？等等。&lt;/p&gt;
&lt;p&gt;没有银弹。&lt;/p&gt;
&lt;h2&gt;游戏流派&lt;/h2&gt;
&lt;p&gt;开始之前先决定流派。除非你创造了新的流派。同一流派的游戏往往有类似的游戏机制（如控制方式、游戏目标之类）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Causal Game&lt;/li&gt;
&lt;li&gt;猜迷&lt;/li&gt;
&lt;li&gt;动作&lt;/li&gt;
&lt;li&gt;塔防&lt;/li&gt;
&lt;li&gt;其它创新的游戏&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;游戏设计：笔比代码更强大&lt;/h2&gt;
&lt;p&gt;在编码前集中设计游戏的用户体验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心机制&lt;/li&gt;
&lt;li&gt;主要角色的粗略故事&lt;/li&gt;
&lt;li&gt;基于角色及其背景设计粗略的画面风格&lt;/li&gt;
&lt;li&gt;主要画面的概要及过渡画面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以一个贪食蛇游戏为例。可以用纸和笔记录下这些设计，以坐标纸画出界面草图。&lt;/p&gt;
&lt;h3 id="he-xin-ji-zhi"&gt;核心机制：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;蛇头控制前进方向并拖动它的尾部。头和尾由相等尺寸的部分组成只是显示不同&lt;/li&gt;
&lt;li&gt;当蛇走到屏幕边界时，从屏幕的另一边重新进来&lt;/li&gt;
&lt;li&gt;左右按钮按下时，蛇将顺时针或逆时针转动90度&lt;/li&gt;
&lt;li&gt;如果蛇撞到自己，游戏结束&lt;/li&gt;
&lt;li&gt;如果蛇撞到了新块，则块消失，增加10分，添加一个新块到蛇尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;复杂的游戏需要将这些内容分开来设计，最后再将这些合并起来 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Game Development 101&lt;/h1&gt;
&lt;p&gt;在开始hacking前先进行游戏设计。这并非指基本的设计，比如FPS中的WSAD的鼠标之类的。而是类似：是否需要splash screen？需要哪些菜单项？游戏设置里需要有哪些选项？等等。&lt;/p&gt;
&lt;p&gt;没有银弹。&lt;/p&gt;
&lt;h2&gt;游戏流派&lt;/h2&gt;
&lt;p&gt;开始之前先决定流派。除非你创造了新的流派。同一流派的游戏往往有类似的游戏机制（如控制方式、游戏目标之类）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Causal Game&lt;/li&gt;
&lt;li&gt;猜迷&lt;/li&gt;
&lt;li&gt;动作&lt;/li&gt;
&lt;li&gt;塔防&lt;/li&gt;
&lt;li&gt;其它创新的游戏&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;游戏设计：笔比代码更强大&lt;/h2&gt;
&lt;p&gt;在编码前集中设计游戏的用户体验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心机制&lt;/li&gt;
&lt;li&gt;主要角色的粗略故事&lt;/li&gt;
&lt;li&gt;基于角色及其背景设计粗略的画面风格&lt;/li&gt;
&lt;li&gt;主要画面的概要及过渡画面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以一个贪食蛇游戏为例。可以用纸和笔记录下这些设计，以坐标纸画出界面草图。&lt;/p&gt;
&lt;h3 id="he-xin-ji-zhi"&gt;核心机制：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;蛇头控制前进方向并拖动它的尾部。头和尾由相等尺寸的部分组成只是显示不同&lt;/li&gt;
&lt;li&gt;当蛇走到屏幕边界时，从屏幕的另一边重新进来&lt;/li&gt;
&lt;li&gt;左右按钮按下时，蛇将顺时针或逆时针转动90度&lt;/li&gt;
&lt;li&gt;如果蛇撞到自己，游戏结束&lt;/li&gt;
&lt;li&gt;如果蛇撞到了新块，则块消失，增加10分，添加一个新块到蛇尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;复杂的游戏需要将这些内容分开来设计，最后再将这些合并起来。&lt;/p&gt;
&lt;p&gt;最后一个隐含的机制是：游戏将在蛇充满整个屏幕时结束。&lt;/p&gt;
&lt;h3 id="gu-shi-he-mei-zhu-feng-ge"&gt;故事和美术风格&lt;/h3&gt;
&lt;p&gt;取个有趣的名字：Mr.Nom&lt;/p&gt;
&lt;p&gt;其它：
 - 涂鸦风格。将草图中设计的块扫描进去作为图像资源
 - Mr.Nom是利己主义者，我们修改它的块改小点并加个帽子
 - 让Mr.Nom在每次吃掉一个墨水块时发出咕哝声
 - 将游戏及其它标识的地方设置为Mr.Nom而不是Doodle Snake&lt;/p&gt;
&lt;h3 id="ping-mu-xian-shi-he-guo-du"&gt;屏幕显示和过渡&lt;/h3&gt;
&lt;p&gt;屏幕显示的组成：
 - 屏幕是一个具有元子性的单元，它将整个显示屏充满，负责游戏的一个部分（如：主画面、设置界面或者游戏屏幕）
 - 屏幕可以由多个组件（如：按钮、控件等等）
 - 屏幕允许用户与屏幕元素交互。这些交互可能触发屏幕过渡（从一个屏幕转到另一个屏幕）。&lt;/p&gt;
&lt;p&gt;按这些规则，Mr.Nom游戏的屏幕和过渡如下：
 - 首先显示游戏的名称，放上Mr.Nom的logo
 - 为了让这些看起来更一致，我们也需要背景，可以重用这个背景
 - 玩家需要玩游戏，因此需要放一个Play按钮。这将是第一个交互组件
 - Help按钮过渡到帮助屏幕
 - 声音设计为可爱类型的，有些玩家可能需要静音。给他们一个切换这个选项的按钮&lt;/p&gt;
&lt;p&gt;然后是详细设计各个屏幕及屏幕上的元素，各个屏幕的状态及不同状态之间的切换，各个屏幕之间如何过渡等细节。&lt;/p&gt;
&lt;h2&gt;编码&lt;/h2&gt;
&lt;p&gt;另一个蛋与鸡的问题：我们知道Android游戏相关的API。但我们仍不知道如何编写游戏。我们有游戏设计，但是将它转化为可执行的程序对我们来说仍像是种巫术。下面将开始介绍一个游戏的基本组成。我们将看到接口的伪代码然后用Android提供的API来实现它。使用接口的2个原因：它让我们关注于语义而不是实现细节；它让我们可以在以后更改实现。（比如：将基于CPU渲染的2D画面替换成基于OpenGL ES的实现）。&lt;/p&gt;
&lt;p&gt;游戏的基本框架可以分为以下模块：
 - 窗口管理：它的职责是创建窗口和处理关闭窗口、暂停/恢复Android应用程序等
 - 输入：与窗口管理模块相关，跟踪用户的输入（比如：点击事件、按键等）
 - 文件IO：用于从磁盘读取我们的资源（asserts）
 - 图像：这可能是实际游戏中最复杂的模块。它的职责是加载图像并将它们绘制到屏幕上
 - 音频：它的职责是加载和播放所有声音
 - 游戏框架：将上面所有的内容连接到一起提供一个易于编写游戏的基础&lt;/p&gt;
&lt;p&gt;每个模块都是由一到多个接口组成。每个接口将有至少一个依赖于底层平台（这里是Android）的实现。&lt;/p&gt;
&lt;h3 id="ying-yong-cheng-xu-he-chuang-kou-guan-li"&gt;应用程序和窗口管理&lt;/h3&gt;
&lt;p&gt;游戏与其它程序一样有UI。它包含在某种窗口中。窗口作为容器，基本上可以将它当作画布，我们在上面绘制游戏内容。&lt;/p&gt;
&lt;p&gt;多数操作系统允许用户通过某种方式与窗口交互。&lt;/p&gt;
&lt;p&gt;应用程序和窗口管理模块也实际上负责设置窗口以使得它填充满某个UI组件以便我们可以将来在上面进行渲染。它也接收用户输入。UI组件可以使用CPU或依赖于硬件加速（OpenGL ES）进行渲染。&lt;/p&gt;
&lt;p&gt;应用程序和窗口管理模块没有实际的接口集。我们会将它合并到游戏框架中。我们需要记住应用程序状态和窗口事件需要管理：
 - 创建：在窗口（应用程序）启动时被调用一次
 - 暂停：在应用程序被某种机制暂停运行时被调用
 - 恢复：在窗口被放到前台应用被恢复运行时被调用&lt;/p&gt;
&lt;h3 id="shu-ru"&gt;输入&lt;/h3&gt;
&lt;p&gt;用户需要以某种方式与游戏交互。多数操作系统中，输入事件被分发给当前被聚焦的窗口。这个窗口再将事件分给被聚焦的UI组件。这个分发过程对用户是透明的；我们需要关心的只是从被聚焦的UI组件获取事件。操作系统的UI API会在事件分发系统中提供某种钩子机制以便我们可以简单的注册和记录事件。通过钩子记录事件是输入模块的主要任务。有两种操作可以记录这些信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮询：通过检查输入设备的当前状态。任何当前检查和上次检查之间的状态将丢失。这种输入处理适用于检查类似用户是否点了某个特殊的按钮之类的情况。不适合于跟踪文本输入，按键事件的顺序也会丢失。&lt;/li&gt;
&lt;li&gt;基于事件的处理：它能提供完整自上次检查以来完整的事件历史。适用于执行文本输入和任何依赖于顺序的事件。它也适用于检查手指何时第一次点击屏幕或者何时离开屏幕的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入设备&amp;mdash;&amp;mdash;Android有3种主要输入方法：触摸屏、键盘/轨迹球和加速感应。前2者可以适用于轮询和事件机制。加速感应通常只适用于轮询。触摸屏事件可以生成三种事件：
 - 接触：在手指接触屏幕时发生
 - 拖动：手指在屏幕上拖动时发生。在拖动事件之前总会有一个接触事件
 - 离开：在手指离开屏幕时发生&lt;/p&gt;
&lt;p&gt;每个触摸屏事件都有附加信息：相对于UI组件原点的相对位置和在多点触控条件下区分接触手指的索引指示器。&lt;/p&gt;
&lt;p&gt;键盘可以产生两种事件：
 - Key-down：在一个键被按下时发生
 - Key-up：在键弹起时发生。这个事件的前面总会存在一个Key-down事件&lt;/p&gt;
&lt;p&gt;键盘事件也携带了附加信息。Key-down事件保存了被按的键的代码。Key-up事件保存了键的代码和一个实际的Unicode字符。Key-up事件产生的键代码和Unicode字符是不同的。其它键的状态也被记录，比如Shift键。通过这种方法，我们可以在key-up事件中获得大写和小写字母。在key-down事件中我们只知道某种按钮被按下了；而不知道实际产生了什么字符。&lt;/p&gt;
&lt;p&gt;加速感应&amp;mdash;&amp;mdash;我们总是轮询加速感应。加速感应报告加速度x,y和z三个方向的加速。x沿屏幕下边从左向右，y沿屏幕左边从下向上，z沿与屏幕垂直方向从下向上。各个方向以米/秒的平方(m/s^2)表示。&lt;/p&gt;
&lt;h3 id="wen-jian-io"&gt;文件IO&lt;/h3&gt;
&lt;p&gt;通过输入输出流读写数据。从APK文件中读取Assert。&lt;/p&gt;
&lt;p&gt;我们需要的文件IO接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;com.badlogic.androidgames.framework&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.io.IOException&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.io.InputStream&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.io.OutputStream&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;FileIO&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;InputStream&lt;/span&gt; &lt;span class="nf"&gt;readAsset&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;IOException&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;InputStream&lt;/span&gt; &lt;span class="nf"&gt;readFile&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;IOException&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;OutputStream&lt;/span&gt; &lt;span class="nf"&gt;writeFile&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;IOException&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="yin-pin"&gt;音频&lt;/h3&gt;
&lt;p&gt;音频编程是个更加复杂的主题。我们不使用高级音频处理，只是回放从文件加加载的声音效果和音乐，与图像模块加载位图类似。&lt;/p&gt;
&lt;h4 id="sheng-yin-de-wu-li-xian-xiang"&gt;声音的物理现象&lt;/h4&gt;
&lt;p&gt;声音通常是被当作波在某种媒介中传播，比如在空气或水中。波不是实际的物体，而是分子在媒介中的运动。&lt;/p&gt;
&lt;h4 id="ji-lu-he-hui-fang"&gt;记录和回放&lt;/h4&gt;
&lt;p&gt;声音的记录和回放看起来非常简单：记录时，我们只需要记录在某个时间点在某个区域中声波产生的分子压力有多大。回放只是让喇叭周围的空气分子像我们记录时的那样波动就可以了。&lt;/p&gt;
&lt;p&gt;实际上当然比这要复杂。音频的两种记录方式：模拟的和数字的。这两种方式都是通过某种麦克风记录音波，通常使用某种薄膜将分子压力记录为某种信号。&lt;/p&gt;
&lt;p&gt;记录数字音频时是时间上分离的时间点来记录的。根据在薄膜上的分子压力它被推向内或向外。这个过程被称为采样，我们在不同的时间点上进行采样。在某个时间单元上进行的采样次数被称作采样率。通常这个时间单元以秒记，这个单位被称作Hz。每秒进行的采样次数越多，音频的质量就越高。CD回放的率是44100Hz即44.1KHz，在电话传输的语音是8KHz。&lt;/p&gt;
&lt;p&gt;采样率只是一种音频质量的一种属性。存储每个采样状态的方法也扮演了重要的角色，它也是数字化的的一个子工程。这个采样的状态实际上是薄膜离它的自然原点的位置。为记录下它是向外还是向内推的。采样状态被记录为正数或附数。我们可以将这个数以多种方式记录：8位、16位或者32位整数，32位浮点甚至是64位浮点数。每种数据类型都有它的精度限制，8位的整数只能存储127个正数和128个负数值。32位整数则提供了更多的值。当存储浮点数时，这个状态值通常被记录在-1和1之间。最大正数和最小附描述了薄膜与它的自然原点的位置差。薄膜的状态也因此被称为振幅。它描述了它遇到的声音的响亮程度。&lt;/p&gt;
&lt;p&gt;单个麦克风只能记录单声道声音，它将丢失空间信息。两个麦克风可以让我们可以度量出在不同的空间位置，因此被称为立体声。你可以将我个麦克风放在左边另一个放在右边以记录下立体声。当这两个声音被同时播放时，可以再现出空间感。但这也意味着在保存立体声时我们需要保存两倍数量的采样。&lt;/p&gt;
&lt;p&gt;回放则简单一些。一旦我们有了数字格式的音频采样，通过指定采样率和数据类型我们就可以将这些数据放到音频处理单元，它会将这些信息转化为信号传递到喇叭上。喇叭将这些信号转化为薄膜的振动，它按顺序使周围的空间振动产生声波。这与记录声音时相同，只是反过来了。&lt;/p&gt;
&lt;h4 id="yin-pin-zhi-liang-he-ya-suo"&gt;音频质量和压缩&lt;/h4&gt;
&lt;p&gt;根据上面的内容可以知道更高的采样率和更精确的数据类型可以得到更好的音频效果。但是也意味着需要更大的空间来存储音频信号。&lt;/p&gt;
&lt;p&gt;设想记录一段60秒的的音频两次：一次是8KHz的采样率每个采样以8位来存储，另一次是44KHz的采样率每个采样以16位来存储。第一种情况下每个采样率占用1byte。除以采样率8000Hz，我们每秒需要8000butes。完全保存60秒的音频记录需要480000butes大概为半MB。另一种方式下：每个采样2bytes，2乘以44000bytes每秒。即88000butes每秒。乘60秒，达到5280000bytes超过5MB。通常3分钟的流行音乐需要超过15MB内存，这还只是单声道的录音。立体声所需内存还要翻倍。&lt;/p&gt;
&lt;p&gt;很多聪明的人们相出了复杂的算法将音频进行压缩。压缩后的音频通常损失很小，原始音频中某些次要的部分被忽略了。当你播放MP3或者OGG时，实际听到的是有损的压缩音频。因此，使用MP3或者OGG将帮助我们节约大量的磁盘空间。&lt;/p&gt;
&lt;p&gt;如何从被压缩文件中回放音频呢？有一些专业的解码硬件可以处理各种压缩音频格式，普通的音频硬件只能处理未压缩的采样。在将采样传递给音频卡之前，我们需要先读取这些压缩的音频并进行解压，或通过流读取所需要的部分。&lt;/p&gt;
&lt;h4 id="shi-jian"&gt;实践&lt;/h4&gt;
&lt;p&gt;由于音频要占用大量内存。我们在播放背景音乐时，将使用音频流，通常只有一个音频流在播放，因此我们只需要访问一次磁盘。&lt;/p&gt;
&lt;p&gt;对于音效，比如枪声等，则不同。通常需要多次播放。应该将这些短的声音加载到内存中。&lt;/p&gt;
&lt;p&gt;因此，我们有下面的需求：
 - 我们需要一个方式从文件加载音频流
 - 需要控制音频流的播放
 - 我们需要控制完全加载到内存的音频的播放&lt;/p&gt;
&lt;p&gt;将这些直接转换成Audio、Music和Sound接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;com.badlogic.androidgames.framework&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Audio&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Music&lt;/span&gt; &lt;span class="nf"&gt;newMusic&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Sound&lt;/span&gt; &lt;span class="nf"&gt;newSound&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Audio接口使用我们的方法来创建Music和Sound实例。Music表示音频流文件。Sound表示保存在内存中的音效。Audio.newMusic()和Audio.newSound()都接收文件名参数并抛出IOException。文件名指向APK文件中的assert文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;com.badlogic.androidgames.framework&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Music&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;play&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;stop&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;pause&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setLooping&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;looping&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setVolume&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;volume&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;isPlaying&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;isStopped&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;isLooping&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;dispose&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Music接口包含的内容更多点。除了控制播放外还可以设置是否循环播放。也允许设置音量值&amp;mdash;&amp;mdash;从0到1之间的浮点数。在我们不再需要这个Music实例时，应该使用dispose来关闭资源。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;com.badlogic.androidgames.framework&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Sound&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;play&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;volume&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;dispose&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Sound接口更简单些。我们只需要调用它的play()方法，它接收一个音量参数。当我们不需要这个实例时也使用dispose释放资源。&lt;/p&gt;
&lt;h2&gt;图形&lt;/h2&gt;
&lt;p&gt;图形模块用于将图像绘制到屏幕上。如果需要高性能的图形，则至少需要知道图形编程的一些基础知识。我们从2D图形开始。&lt;/p&gt;
&lt;p&gt;问题：图片是如何输出显示的？&lt;/p&gt;
&lt;h3 id="guang-zha-xiang-su-he-zheng-huan-chong_1"&gt;光栅、像素和帧缓冲&lt;/h3&gt;
&lt;p&gt;当今的显示器都是基于光栅的。光栅是一种二维的网格，称为图片元素，即像素。光栅网格有有限的宽和高，通常用每行和每列的像素个数表示。&lt;/p&gt;
&lt;p&gt;像素有2个属性：它在网格上的位置和颜色。位置是二维的迪卡尔坐标。这意味着它总是整数。在这个坐标系中原点在网格的左上角。x轴从左向右，y轴从上至下。&lt;/p&gt;
&lt;p&gt;网格的左上角是(0,0)。坐标系中x轴最大值是光栅宽度减1，y轴最大值是光栅高度减1。&lt;/p&gt;
&lt;p&gt;显示器从图形处理器接收固定的流信息。它将光栅中每个像素的颜色按程序或操作系统的控制绘制到屏幕上。显示器将每秒刷新很多次显示。这个频率叫作刷新率。以Hz表示。液晶显示器的刷新率通常是每秒60Hz；CRT和等离子显示器通常会有更高的刷新率。&lt;/p&gt;
&lt;p&gt;图形处理器可以访问特殊的被称为显示内存（VRAM）的内存区域。VRAM是一块保留的区域用于保存显示在屏幕上的每个像素。这个区域通常被称为帧缓冲。一个完整的屏幕图片被称作一帧。对于显示在光栅网格中的每个像素，在帧缓冲中都有一个内存地址保存了它的颜色。当我们需要改变屏幕显示时，只需要简单的修改VRAM中像素的颜色值。&lt;/p&gt;
&lt;p&gt;为什么y轴在坐标系统中是从上向下的？VRAM或者RAM，是线性的一维的。可以将它看作一维数组。如何将2维的像素坐标映射到一维的内存地址上呢？位于(x,y)坐标上的像素的内存地址是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;rasterWidth&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们也可以从地址计算出坐标：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;rasterWidth&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;rasterWidth&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此y轴坐标从上向下是因为像素颜色所使用的内存布局决定的。显示器将从左至右坐上至下更新每个像素的颜色，直到屏幕的底部。它可以很方便的将VRAM中的内容转换成屏幕上的颜色信息。&lt;/p&gt;
&lt;p&gt;NOTE：如果可以完全访问帧缓冲，则可以得到非常好的性能。现代操作系统不允许用户直接访问帧缓冲。通常是绘制到内存区域然后由操作系统将它们复制到实际的帧缓冲。&lt;/p&gt;
&lt;h3 id="chui-zhi-sao-miao-he-shuang-huan-chong"&gt;垂直扫描和双缓冲&lt;/h3&gt;
&lt;p&gt;前面介绍过的刷新率看起来速度比较慢，有可能出现写帧缓冲的速度快过刷新的速度。更坏的是我们不知道VRAM是何时被复制到帧的，这可能会产生一个问题如果我们在这个中间绘制了新的内容。则屏幕会显示一部分新帧的内容和一部分旧帧的内容。这在很多PC游戏中可以看到。&lt;/p&gt;
&lt;p&gt;解决这个问题的一个办法是被称为双缓冲。它不只使用一个帧缓冲，图形处理器（GPU）管理两个，一个前台缓冲一个后台缓冲。前台是显示器可用的帧，后台帧是允许绘制下一帧才会显示的。当我们完成绘制后，我们告诉GPU将这两个缓冲区进行交换，通常只是交换前台和后台缓冲的地址。在图形编程API文档中，可以找到page flip和buffer swap之类的，就是指的这个操作。&lt;/p&gt;
&lt;p&gt;双缓冲没有完全解决这个问题，尽管：交换可能发生在屏幕刷新显示内容的中间。这就是垂直扫描出现的原因。当我们调用buffer swap方法时，GPU将阻塞直到显示器发出它已经完成当前刷新的信号。这时GPU可以安全的交换缓冲区地址。&lt;/p&gt;
&lt;p&gt;幸运的是，现在我们不需要关心NVRAM、双缓冲和垂直扫描的细节了。我们通过一组API来处理应用程序窗口的内容。这些API，如：OpenGL ES，提供硬件加速，这基于在图形芯片上使用特殊的电路来处理VRAM。可以看到这里没有魔法！你应该知道内部的工作原理，至少在较高的层面上，这可以让你知道你的应用的性能特性。&lt;/p&gt;
&lt;p&gt;当我们使用非硬件加速的API渲染时，我们不直接处理显示本身。而是在我们的窗口中绘制一个UI组件。这里我们是处理一个延伸至整个窗口的UI组件。我们的坐标系统不会延伸至整个屏幕，只是在这个UI组件中。通过UI组件自身的虚拟帧缓冲，它变成了我们的显示器。操作系统将管理所有可见窗口中的复合组件，确保组件被正确的转化到实际帧缓冲的区域中。&lt;/p&gt;
&lt;h3 id="shi-yao-shi-yan-se"&gt;什么是颜色？&lt;/h3&gt;
&lt;p&gt;物理上讲颜色是不同波长的光波。&lt;/p&gt;
&lt;h4 id="yan-se-mo-xing"&gt;颜色模型&lt;/h4&gt;
&lt;p&gt;RGB、YUV和CMYK。多数程序API中都是使用RGB颜色模型。&lt;/p&gt;
&lt;h4 id="yan-se-de-shu-zi-hua-bian-ma"&gt;颜色的数字化编码&lt;/h4&gt;
&lt;p&gt;如何将RGB三种颜色转化到内存当中？首先是要定义数据类型。我们可以使用浮点数和指定的范围来描述。比如0.0至1.0之间的浮点数。但是这种方法会战胜大量的空间（每个像素3乘以4或8bytes，依赖于使用32位或64位浮点数）。&lt;/p&gt;
&lt;p&gt;我们可以丢失掉一部分颜色以减少开销，这完全可以，显示器能发出的颜色通常也有一定范围限制。因此我们可以使用整数代替浮点数。我们使用32位整数，使用无符号bytes来描述颜色组成，每个组成的范围是从0至255。对于一个像素，我们只需要3bytes，或者24bits。这可以描述2的24次方（16777216）种不同的颜色。&lt;/p&gt;
&lt;p&gt;也可以使用16bit来描述像素的颜色。红使用5bits，绿使用6bits，蓝使用余下的5bit。绿使用6bit的原因是我们的眼睛可以看到比红和蓝更多的绿色。&lt;/p&gt;
&lt;h4 id="tu-pian-ge-shi-yu-ya-suo"&gt;图片格式与压缩&lt;/h4&gt;
&lt;h4 id="alphahun-he"&gt;Alpha混合&lt;/h4&gt;
&lt;p&gt;使用32bit描述像素颜色时，可以用24bit来描述RGB值，另外的8bit描述alpha值。&lt;/p&gt;
&lt;p&gt;图像绘制到帧缓冲中的时候与顺序是相关的，后面绘制的会屏幕前面的，如果存在alpha值，则颜色的计算方式会不同。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;red&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;red&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;alpha&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;red&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="err"&gt;&amp;ndash;&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="n"&gt;blue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;green&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;alpha&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;green&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="err"&gt;&amp;ndash;&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="n"&gt;green&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;blue&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;alpha&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;dst&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;blue&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="err"&gt;&amp;ndash;&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;alpha值通常在0.0到1.0之间。计算出来的值才是实际显示到屏幕上的值。多数图形软件支持alpha值的计算，如果它不支持则我们可以在加载它们时自己在内存中计算。&lt;/p&gt;
&lt;h1&gt;游戏框架&lt;/h1&gt;
&lt;p&gt;游戏应该执行的任务：
 - 游戏被划分到不同的画面，每个画面都执行类似任务：处理用户输入、将输入应用到屏幕状态、渲染场景。某些屏幕画面可能不需要用户输入，但它会在经过一段时间后转换到另一个画面（如：Splash画面）。
 - 画面需要以某种方式进行管理（比如：跟踪当前的画面并且要有方法过渡到新画面，将旧画面销毁并将新画面设置为当前画面）。
 - 游戏还需要允许画面访问不同的模块（图形、音频、输入等）。因此它需要加载资源，获取用户输入，播放声音，渲染缓冲区等等。
 - 游戏应该是实时的（这意味着移动和更新应该是不断进行的），我们需要让当前的画面不断的更新自己的状态并尽快的渲染。当用户退出游戏时这个循环将被终止。这个循环的单次迭代被称为一帧。每秒的帧数被称为帧率（FPS）。
 - 我们也需要跟踪上一帧以来所消耗的时间。这可以用于帧率无关的运动。
 - 游戏需要跟踪窗口的状态（如：它被暂停或恢复），并将这些事件通知给当前的画面。
 - 游戏框架还需要处理窗口和创建要渲染的UI组件并从它们接收输入。&lt;/p&gt;
&lt;p&gt;游戏框架伪代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//创建UI组件用于显示和接收输入&lt;/span&gt;
&lt;span class="n"&gt;createWindowAndUIComponent&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;//初始化需要的支持模块&lt;/span&gt;
&lt;span class="n"&gt;Input&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Input&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;Graphics&lt;/span&gt; &lt;span class="n"&gt;graphics&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Graphics&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;Audio&lt;/span&gt; &lt;span class="n"&gt;audio&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Audio&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="n"&gt;Screen&lt;/span&gt; &lt;span class="n"&gt;currentScreen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MainMenu&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;Float&lt;/span&gt; &lt;span class="n"&gt;lastFrameTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;currentTime&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;//游戏主循环&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;userQuit&lt;/span&gt;&lt;span class="o"&gt;()){&lt;/span&gt;
    &lt;span class="c1"&gt;//计算上一帧与当前时间的时间差，通常以秒计，用于帧率无关的运动&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;deltaTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;currentTime&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;lastFrameTime&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;lastFrameTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;currentTime&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;//更新画面状态并展现出来。展现既包括渲染屏幕状态到缓冲区，也包括播放音效和声音&lt;/span&gt;
    &lt;span class="n"&gt;currentScreen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;updateState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;deltaTime&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;currentScreen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;present&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;graphics&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;audio&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;deltaTime&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//回收资源&lt;/span&gt;
&lt;span class="n"&gt;cleanupResources&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码是几乎所有游戏的工作方式。&lt;/p&gt;
&lt;p&gt;现代操作系统的UI应用程序通常不是实时的。它们基于事件机制，当操作系统将输入事件通知应用时，应用程序渲染自身。这通常是通过在应用启动的时候向操作系统注册回调，然后由它们处理事件通知。这些都发生在UI线程中&amp;mdash;&amp;mdash;一个UI程序的主线程。通常应该尽快从回调中返回，因此我们不需要来自己实现这个循环。&lt;/p&gt;
&lt;p&gt;我们需要处理游戏的主循环，它将在游戏启动时从主线程派生出来。这意味着我们需要某些措施以便从UI线程中接收事件，比如用户输入和窗口事件。我们需要在某些点上对游戏主循环和UI线程进行同步。&lt;/p&gt;
&lt;h2&gt;游戏和画面接口&lt;/h2&gt;
&lt;p&gt;游戏接口
 - 设置窗口和UI组件并向UI线程注册钩子以便我们接收窗口和输入事件
 - 启动游戏主循环线程
 - 跟踪当前画面并在主循环的每次迭代中告诉它更新状态和展现自己
 - 将UI线程中的窗口事件（如暂停和恢复事件）传送到主循环中并将它们传递到当前画面以便它改变状态
 - 允许游戏访问所有底层模块：输入、文件IO、图形和音频&lt;/p&gt;
&lt;p&gt;画面抽像类
 - 需要通过访问游戏接口的实例来访问底层模块
 - 需要一个update方法来更新状态
 - 需要present来展现自己
 - 需要提供暂停和恢复方法以便游戏实例能暂停或恢复当前的画面
 - 还需要一个dispose方法来释放系统资源（如assets中的Pixmap）&lt;/p&gt;
&lt;p&gt;作为游戏开发者，我们想要成为不可知论者，不想要知道主循环是否在运行、是否需要与UI线程同步等这些细节。我们只需要根据底层模块和窗口事件实现不同的游戏画面。&lt;/p&gt;
&lt;h2&gt;帧率无关的运动&lt;/h2&gt;
&lt;p&gt;假设用户的设备以60FPS运行我们的游戏。位图以每100帧100像素的速度沿X轴移动。即每帧移动一个像素。它将在经过1.66秒（100/60）从(0,0)移动到(100,0)。&lt;/p&gt;
&lt;p&gt;如果第二个用户的设备只能以30FPS运行我们的游戏。那它将会需要3.33秒才能从(0,0)移动到(100,0)。&lt;/p&gt;
&lt;p&gt;这将会不同设备带来不同的体验。解决这个问题的办法是使用帧率无关的运动，而不是在每帧移动固定的像素。如果我们需要以每秒50像素的速度移动，则在计算新位置时使用50*deltaTime就可以计算出自上一帧到现在应该移动的像素。&lt;/p&gt;
&lt;h1&gt;游戏开发者的Android&lt;/h1&gt;
&lt;p&gt;实现游戏框架及底层组件的实现基础。&lt;/p&gt;
&lt;h2&gt;Mainfest文件&lt;/h2&gt;
&lt;p&gt;Android应用包括多种组件：
 - Activity：UI组件
 - Service：后台工作
 - Content Provider：它可以让你的应用程序与其它应用共享数据
 - Intent：它由系统或应用自己创建，然后被传递到应用中对它感兴趣的地方
 - Broadcast Receive：它对某些Intent作出反应，并执行一些相应的动作&lt;/p&gt;
&lt;h3 id="manifestyuan-su_1"&gt;manifest元素&lt;/h3&gt;
&lt;p&gt;它是AndroidMainifest.xml的根元素。它的命名空间为android。
  - package属性指定应用的包名称
  - versionCode和versionName属性指定应用的版本号的版本名称
  - installLocation属性可以用于指定2.2及以上版本的系统将应用安装到外部存储卡上。只需要将它的值设置为preferExternal。&lt;/p&gt;
&lt;h3 id="applicationyuan-su"&gt;application元素&lt;/h3&gt;
&lt;p&gt;它的属性值中以@开头表示从其它地方获取资源。如从res/drawable目录获取图像（不要指定扩展名）。或者从res/values/strings.xml中获取字符串。
  - icon属性指定程序图标
  - label属性指定程序的名称
  - debuggable属性指定程序是否允许被调试&lt;/p&gt;
&lt;h3 id="activityyuan-su"&gt;activity元素&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;name属性指定activity所对应的Java类相对于manifest的package属性所指定的包名的名称。你也可以直接指定类的完整包名和类名&lt;/li&gt;
&lt;li&gt;label属性显示于activity的标题栏。如果未指定application元素的label属性，这个label将被作为应用名称的标题。&lt;/li&gt;
&lt;li&gt;screenOrientation属性用于指定activity所使用的屏幕方向。可选值可以是portrait,landscape。如果不指定则会使用设备的当前方向，则将是由加速感应的数据决定的。这也意味着当屏幕方向改变时，activity将会被销毁并重新启动。&lt;/li&gt;
&lt;li&gt;configChanges属性指定设备调整方向或者滑出键盘时作为配置改变进行处理。这种情况下，Android将销毁并重启应用程序以适应这种改变。这通常不适合于游戏。它的可选值有keyboard, keyboardHidden和orientation，多个选项以|组合。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Android应用程序有多个入口，可以从activity或service中接收系统或第三方程序发送的特定的intent开始执行。因此我们需要告诉Android针对特定的intent，应该启动哪个activity或service。这些配置记录在activity的intent-filter子元素中。&lt;/p&gt;
&lt;p&gt;常见的两种intent filter：action和category。action元素告诉Android这个activity是程序的主入口。category元素指定我们想要把这个activity添加到app launcher中。这两个元素放在一起告诉Android将应用程序的图标放到app launcher，当点击它时启动相应的activity。这两个元素的name属性指定了activity将作出反应的intent。android.intent.action.MAIN是Android系统所使用的一个特殊的intent，它用于启动一个应用程序的主activity。android.intent.category.LAUNCHER用于告诉Android这个activity是否应该作为在app launcher中的应用程序入口。通常只会在一个activity中指定这两个intent filter。&lt;/p&gt;
&lt;h3 id="uses-permissionyuan-su"&gt;uses-permission元素&lt;/h3&gt;
&lt;p&gt;它是manifest的子元素。它用于对资源的访问许可。它的属性name指定要访问的资源。常用的资源有：
 - android.permission.RECORD_AUDIO：允许访问录音设备
 - android.permission.INTERNET：允许访问网络API
 - android.permission.WRITE_EXTERNAL_STORAGE：允许读写外部存储设备
 - android.permission.WAKE_LOCK：允许我们取得wake lock。通过使用wake lock我们可以保持设备不进入睡眠状态，即使长时间不接触屏幕。&lt;/p&gt;
&lt;p&gt;程序安装时将提醒用户程序需要这些访问许可。&lt;/p&gt;
&lt;h3 id="uses-featureyuan-su"&gt;uses-feature元素&lt;/h3&gt;
&lt;p&gt;它用于指定应用程序对设备功能的需求。当你从设备上访问Android Market时，如果你的设备无法满足这些要求，这个程序可能不会显示出来。uses-feature有下面的属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;uses-feature android:name="string" android:required=["true" | "false"]
android:glEsVersion="integer" /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用的与游戏相关的feature：
 - android.hardware.touchscreen.multitouch：需要设备支持多点触控。这种类型的屏幕在跟踪多个手指的独立运动轨迹方面会有些问题。
 - android.hardware.touchscreen.multitouch.distinct：这是上一个功能的大哥。它需要完全的多点触控支持。&lt;/p&gt;
&lt;p&gt;游戏开发中通常还需要指定用到OpenGL ES的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;uses-feature android:glEsVersion="0x00020000" required="true"/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里指定的是需要设备支持OpenGL ES2.0。&lt;/p&gt;
&lt;h3 id="use-sdkyuan-su"&gt;use-sdk元素&lt;/h3&gt;
&lt;p&gt;它是manifest的子元素。每个SDK都有自己的版本号。这个元素可以指定应用程序需要的SDK的最小版本和目标版本号。&lt;/p&gt;
&lt;h2&gt;创建游戏的步骤&lt;/h2&gt;
&lt;p&gt;需求
 - 应该能使用最最新的SDK，并与低版本SDK兼容。至少支持Android 1.5以上的版本
 - 应用能安装到SD卡上
 - 允许调试
 - 应该有一个主activity处理所有配置改变，在键盘滑出或者屏幕方向改变时不会被销毁
 - 它应该固定为纵向或横向
 - 应该允许我们访问SD卡
 - 它应该获取到wake lock&lt;/p&gt;
&lt;p&gt;步骤
 - 在Ecipse里创建工程
 - 选反SDK版本，设置目标版本的最低的SDK版本
 - 将最低的SDK版本设置为3
 - 打开AndroidManifest.xml
 - 在manifest元素中添加installLocation属性，将它的值设置为preferExternal
 - 将application元素的debuggable属性设置为true
 - 在activity元素中添加screenOrientation属性设置为portrait或landscape。如果要处理keyboard, keyboardHidden, orientation属性改变，则可以将activity元素的configChanges属性设置为keyboard, keyboardHidden或orientation
 - 添加两个子元素到manifest元素中，并指定它们的name属性为android.permission.WRITE_EXTERNALSTORAGE和android.permission.WAKE_LOCK
 - 最后，将targetSdkVersion属性添加到use-sdk元素并指定目标平台SDK版本。它应该与第一步指定的版本一致&lt;/p&gt;
&lt;h2&gt;定义游戏的图标&lt;/h2&gt;
&lt;p&gt;application元素里定义了属性icon，它指向了res/drawable目录下的icon这个文件。从android 1.6(SDK Version 4)开始。res/drawable目录下可以包含不同分辨率的资源，ldpi是36x36，mdpi为48x48，hdpi是72x72。&lt;/p&gt;
&lt;p&gt;为了兼容1.5版本系统，我们还需要添加res/drawable目录将res/drawable-mdpi目录的内容放到这里。因为Android 1.5不知道ldpi,mdpi和hdpi，它有可能找不到这些资源。&lt;/p&gt;
&lt;h2&gt;Android API基础&lt;/h2&gt;
&lt;h3 id="activityde-sheng-ming-zhou-qi"&gt;Activity的生命周期&lt;/h3&gt;
&lt;h4 id="li-lun"&gt;理论&lt;/h4&gt;
&lt;p&gt;Activity的三种状态：
 - Running：顶层的Activity占用屏幕与用户交互
 - Paused：当Activity被其它透明的Activity或者对话框覆盖，但是仍然在屏幕上可见，或者屏幕被锁。这个状态的Activity有可能被Android系统在任何时间点杀掉。这时的Activity仍然存活并有可能重新被放到前台运行。
 - Stopped：当Activity完全被另一个Activity掩盖不再显示在屏幕上（比如启动了另一个Activity或者用户按下了Home键）。系统可以将这个Activity杀掉以回收内存。&lt;/p&gt;
&lt;p&gt;在Paused和Stopped状态下，Android系统可以决定是否杀掉Activity。它有可能会调用这个Activity的finished()方法来通知它，也有可能直接杀掉Activity所对应的进程。&lt;/p&gt;
&lt;p&gt;在Paused和Stopped状态下，Activity有可能被放到前台而进入Running状态。恢复运行的Activity仍然是之前内存中的同一个实例，所有Paused或者Stopped时内存的状态和变量都存在。&lt;/p&gt;
&lt;p&gt;生命周期方法：
 - onCreate()：应用初次启动时调用的方法。通常在这里设置UI组件和初始化hook到输入系统。这个方法在整个生命周期中只被调用一次。
 - onRestart()：用于从stopped状态中恢复。它的前一个调用为onStop()。
 - onStart()：它在onCreate()之后被调用，或者在Activity从Stopped状态恢复之后被调用。在后面这情况下它的前一个方法调用是onRestart()。
 - onStop()：当Activity进入Stopped状态时被调用。它的前一个方法是onPause()。这意味着在activity进入Stopped之前，它先Paused。onPause()方法可能系统杀掉Activity之前最后一个被调用的方法。我们可能在这里保存状态。因为系统可以决定在杀掉Activity之前不调用onStop()方法，所以我们应该在onPause()方法中保存数据。
 - onDestroy()方法：这是Activity生命周期结束的调用，当Activity不可恢复地被销毁时将调用它。这是最后一个用来保存信息的方法。注意，这个方法有可能永远不会被调用，系统有可能在调用onPause()或者onStop()之后将Activity杀掉。&lt;/p&gt;
&lt;p&gt;三个重点：
 - 在Activity进入Running状态之前，onResume()方法总是会被调用，不论它是从Stopped或Paused状态恢复。因此我们可以简单的忽略onRestart()和onStart()方法。不用区分它是从Stopped状态还是从Paused状态恢复的。对于游戏，只需要知道从onResume()方法开始游戏进入运行Running状态。
 - Activity有可能在onPause()方法之后被销毁。因此不应该假设onStop()或onDestroy()会被调用。但是也应该明确onPause()一定会在onStop()之前被调用。因此我们可以忽略onStop()和onDestroy()方法，只覆盖onPause()方法。在这个方法中，我们来确保所有状态被持久化，比如最高得分写入外部存储卡。在onPause()方法之后，所有东西关闭，因为Activity有可能不再会运行了。
 - 如果系统决定在onPause()或onStop()之后杀掉Activity，则onDestroy()方法不会运行。但是有时我们或许想要知道Activity是否会被杀掉。可能使用Activity.isFinishing()方法来检查。可以在onPause()方法中来检查就知道Activity是否会被杀掉。&lt;/p&gt;
&lt;p&gt;通常我们只需要覆盖onCreate，onResume()和onPause()方法。onCreate()方法创建UI组件来渲染输出和接收输入。onResume()方法启动或者恢复主循环。onPause()来停止主循环，如果Activity.isFinishing()为true，则还需要保存状态。&lt;/p&gt;
&lt;h2&gt;输入设备处理&lt;/h2&gt;
&lt;h3 id="huo-qu-hong-kong-shi-jian_1"&gt;获取触控事件&lt;/h3&gt;
&lt;p&gt;Android2.0开始支持单点触控。2.0（SDK 5）开始支持多点触控。&lt;/p&gt;
&lt;h3 id="chu-li-dan-dian-hong-kong"&gt;处理单点触控&lt;/h3&gt;
&lt;p&gt;触控事件被传入OnTouchListener接口的实现中。这个接口只有一个方法onTouch(View view, MotionEvent event)。第一个参数是产生触控事件的View。第二个参数可以获取到触控事件的细节。&lt;/p&gt;
&lt;p&gt;触控事件的监听可以通过View.setOnTouchListener()方法注册到任何View的实现上。在MotionEvent传递给View自身之前将调用监听中的方法。我们可以在这个方法中返回true来告诉View我们已经处理好这个事件了。如果返回false，则View自己将处理这个事件。&lt;/p&gt;
&lt;p&gt;MotionEvent实例中常用的3个方法：
 - MotionEvent.getX()和MotionEvent.getY()：这些方法可以获取触控点在View中的相对坐标的位置。坐标的原点位于View的左上角。x向右，y向下。坐标以像素为单位。这些方法返回的是浮点类型的值，因此坐标值有亚像素坐标精度。
 - MotionEvent.getAction()：这个方法返回触控的类型。它是一个整数值，它的值可以为：MotionEvent.ACTION_DOWN，MotionEvent.ACTION_MOVE，MotionEvent.ACTION_CANCEL和MotionEvent.ACTION_UP。&lt;/p&gt;
&lt;p&gt;当手指接触到屏幕时产生MotionEvent.ACTION_DOWN事件。当手指移动时产生MotionEvent.ACTION_MOVE。不能通过保持手指不动来避免产生MotionEvent.ACTION_MODE事件。当手指离开屏幕时产生MotionEvent.ACTION_UP事件。MotionEvent.ACTION_CANCEL事件神秘一些。文档上说是手势取消时产生 。在现实中我从未遇到过这种事件。我们仍然会处理这个事件并将它当作MotionEvent.ACTION_UP来处理。&lt;/p&gt;
&lt;p&gt;在旧版的Android和第一代设备上触控事件存在下面的问题：
 - Touch event flood：当手指按到屏幕上时驱动将尽可能的报告更多的事件&amp;mdash;&amp;mdash;有些设备将每秒产生上百次。我们可以在onTouch()方法中添加Thread.sleep(16)来解决这个问题，这将会使分发这个事件的UI线程睡眠16秒。这将使我们每秒最多获取到60个事件，这个响应性对于游戏来说已经足够了。这个问题只在Android1.5的设备上才会有。
 - 触控操作消耗CPU资源：即使我们在onTouch()中进行睡眠，系统内核仍需要处理驱动报告的事件。在如Hero或者G1这样的设备上，这将消耗50%的CPU资源，这将消耗主循环线程所使用的CPU资源。因此，将导致丢帧，有些情况下可能导致游戏不可玩。在第二代设备上，这个问题报告得少一些，通常可以忽略。对于旧设备这个问题没有很好的解决办法。&lt;/p&gt;
&lt;p&gt;通常你可以将Thread.sleep(16)放到所有onTouch()方法中。对于新设备这不会产生影响；旧设备将阻止Touch event flood的产生。&lt;/p&gt;
&lt;h3 id="chu-li-duo-dian-hong-kong"&gt;处理多点触控&lt;/h3&gt;
&lt;p&gt;多点触控API附加到了MotionEvent类，这个类原来只是为了处理单点触控。&lt;/p&gt;
&lt;p&gt;处理多点触控与处理单点触控类似。也是实现OnTouchListener接口。也能获取到MotionEvent对象。也可以获取到MotionEvent.ACTION_UP之类的事件类型。&lt;/p&gt;
&lt;h4 id="pointer-idshe-indices"&gt;Pointer IDs和indices&lt;/h4&gt;
&lt;p&gt;在获取触控点坐标的时候不同。获取多点触控的坐标时要通过pointer index才能获取到对应的触控点的坐标。类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getX&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointerIndex&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getY&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointerIndex&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pointerIndex是MotionEvent中保存手指接触屏幕的坐标值数组（多点中代表一点）的索引。实际用于标识具体某个手指的标识被称为pointer identifier。MotionEvent.getPointerIdentifier(int pointerIndex)会根据pointerIndex返回pointer identifier。在同一手指接触屏幕其间，其pointer identifier值总是一致的，而它的pointer index则有可能会不同，&lt;/p&gt;
&lt;p&gt;获取pointerIndexr的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="n"&gt;pointerIndex&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAction&lt;/span&gt;&lt;span class="o"&gt;()&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;MotionEvent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ACTION_POINTER_ID_MASK&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;MotionEvent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ACTION_POINTER_ID_SHIFT&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="duo-dian-hong-kong-de-shi-jian-lei-xing"&gt;多点触控的事件类型&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAction&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;MotionEvent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ACTION_MASK&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;action的值之前解释过。对于多点触控增加了一些新的事件类型：
 - MotionEvent.ACTION_POINTER_DOWN：这个事件发生在第一个手指接触屏幕之后的其它手指接触屏幕时。第一个手指接触时仍然产生MotionEvent.ACTION_DOWN。
 - MotionEvent.ACTION_POINTER_UP：最后一个手指离开屏幕之前，其它手指离开屏幕时产生这个事件。最后一个离开屏幕的手指将产生MotionEvent.ACTION_UP，它不必是第一个接触屏幕的手指。&lt;/p&gt;
&lt;p&gt;单个MotionEvent可以包含多个事件。这种情况出现在合并的事件中，这些事件具有相同的类型。通常只会是MotionEvent.ACTION_MOVE事件。为了检查在单个MotionEvent中包含了多少个事件，可以使用MotionEvent.getPointerCount()方法，它能告诉我们有多少个手指的数据。然后使用数组下标从0至MotionEvent.getPointerCount()-1使用MotionEvent.getX()、MotionEvent.getY()和MotionEvent.getPointerId()来获取pointer identifier和坐标。&lt;/p&gt;
&lt;h4 id="shi-jian_1"&gt;实践&lt;/h4&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;h3 id="chu-li-an-jian-shi-jian_1"&gt;处理按键事件&lt;/h3&gt;
&lt;p&gt;为了捕获按键事件，我们只需要实现OnKeyListener接口。它只有一个onKey()方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;onKey&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;keyCode&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;KeyEvent&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;view变量指定了接收到按键事件的View，keyCode是定义于KeyEvent类中的一个常量，event是代表按键事件自身，它包含了一些额外的信息。&lt;/p&gt;
&lt;p&gt;屏幕上的虚拟键盘和设备的按键都能产生一个唯一的keyCode。这些code定义于KeyEvent类中，是个static public final的整数。比如KeyCode.KEYCODE_A是字母键A的code。它的值与输入的字符无关，只是用来唯一标识一个按键。&lt;/p&gt;
&lt;p&gt;KeyEvent与MotionEvent类似。它也有两个常用的方法：
 - KeyEvent.getAction()：它返回KeyEvent.ACTION_DOWN，KeyEvent.ACTION_UP和KeyEvent.ACTION_MULTIPLE。我们通常可以忽略最后一个，前面两个事件会在按键按下和松开时产生。
 - KeyEvent.getUnicodeChar()：它返回按键将产生的能输入到文本字段中的Unicode字符。&lt;/p&gt;
&lt;p&gt;为了获取键盘事件，View必须要拥有输入焦点。可以使用下面的方法强制View获取焦点：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;View&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setFocusableInTouchMode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;View&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;requestFocus&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个方法保证View能被聚焦。第二个方法请求让View获取焦点。&lt;/p&gt;
&lt;h3 id="du-qu-jia-su-ji-de-zhuang-tai"&gt;读取加速计的状态&lt;/h3&gt;
&lt;p&gt;加速计是游戏中非常有意思的输入方式。所有Android设备都需要包含一个三轴的加速计。&lt;/p&gt;
&lt;p&gt;为了获取加速计的状态需要实现SensorEventListener接口，它有两个方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onSensorChanged&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SensorEvent&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onAccuracyChanged&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Sensor&lt;/span&gt; &lt;span class="n"&gt;sensor&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;accurary&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个方法将在有新的加速事件到达时被调用。第二个方法将在加速度改变时被调用。通常我们可以忽略第二个方法。&lt;/p&gt;
&lt;p&gt;如何注册SesorEventListener呢？首先要检查设备是否安装了加速计。现在所有的Android设备都必须包含加速计，但是将来这有可能会改变。我们要100%保证这个设备存在。我们可以通过获取SensorManager来检查设备是否存在。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SensorManager&lt;/span&gt; &lt;span class="n"&gt;manager&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SensorManager&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSystemService&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;SENSOR_SERVICE&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SensorManager被称为系统服务，它由Android系统提供。Android系统提供了多种系统服务，每个服务提供不同类型的系统信息。&lt;/p&gt;
&lt;p&gt;获取到manager之后，我们可以检查是否存在加速计：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;hasAccel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;manager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSensorList&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Sensor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYPE_ACCELEROMETER&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;size&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这个代码能获取到所有加速计。但通常只会有一个设备。&lt;/p&gt;
&lt;p&gt;检测到设备存在后，我们可以从SensorManager中获取到加速计并将监听注册进去。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Sensor&lt;/span&gt; &lt;span class="n"&gt;sensor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;manager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSensorList&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Sensor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYPE_ACCELEROMETER&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;manager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;registerListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sensor&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SensorManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;SENSOR_DELAY_GAME&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SensorManager.SENSOR_DELAY_GAME指定了应该将加速计的最后的状态告诉给监听器。这通常是为游戏设计的。SensorManager.registerListener()方法返回一个boolean类型的值标识注册是否成功。&lt;/p&gt;
&lt;p&gt;注册成功后，我们就可以从SensorEventListener.onSensorChanged()方法中接收SensorEvent事件了。这个方法在感应器状态发生改变时被调用。这听起来有点迷惑，因为加速计的状态改变频率是个常量。当我们注册监听时，已经指定了频率了。&lt;/p&gt;
&lt;p&gt;处理SensorEvent非常容易，它有一个public类型的浮点数组SensorEvent.values，它保存了当前加速计中三个轴的值。SensorEvent.values[0]保存的是X轴，SensorEvent.values[1]保存的是Y轴，SensorEvent.values[2]保存的是Z轴。&lt;/p&gt;
&lt;p&gt;注意：
 - 加速计的值有时可能会超出特定的范围，这是因为感应器的错误引起的，如果你需要精确的值则需要对这些值进行调整。
 - 加速计的轴线总是按相同的顺序，而与屏幕或者Activity的显示方向无关。&lt;/p&gt;
&lt;h2&gt;文件处理&lt;/h2&gt;
&lt;h3 id="du-qu-zi-yuan-assets"&gt;读取资源（Assets）&lt;/h3&gt;
&lt;p&gt;资源位于工程的assets目录下。res目录下的内容读取有限制。使用AssetManager能访问assets目录下的资源。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;AssetManager&lt;/span&gt; &lt;span class="n"&gt;assetManager&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAssets&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Activity实现了Context接口。通常可以直接从Activity中获取AssertManager。使用AssertManager的open方法可以获取相对于assets目录下的目录中的内容。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;InputStream&lt;/span&gt; &lt;span class="n"&gt;inputStream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;assetManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;open&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"dir/dir2/filename.txt"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="fang-wen-wai-bu-cun-chu"&gt;访问外部存储&lt;/h3&gt;
&lt;p&gt;Android提供了多种方式存储信息：你可以使用首选项、SQLite数据库等等。这些选项都不能很好的处理大的二进制文件。为什么需要这么做呢。因为将应用安装到外部存储而不浪费内部存储的选项只有在Android2.2之后才有。对于之前的版本所有应用程序的数据都必须安装在内部存储空间，因此APK文件中通常只能包含程序代码，在程序首次运行时，再从网络上下载资源文件到SD卡上。&lt;/p&gt;
&lt;p&gt;其它情况下我们可能也需要访问外部存储，比如游戏关卡编辑器将关卡保存在存储卡上。&lt;/p&gt;
&lt;p&gt;要访问外部存储首先要使用&lt;uses-permission&gt;获取权限。&lt;/uses-permission&gt;&lt;/p&gt;
&lt;p&gt;接下来是要检测外部存储卡是否存在。使用下面的代码检测：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Environment&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getExternalStorageState&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;state是个字符串。Enviroment中定义了一些常量。其中一个是Enviroment.MEDIA_MOUNTED。它也是字符串。如果state的值为这个常量，则可以读写外部存储卡。&lt;/p&gt;
&lt;p&gt;知道是否能访问外部存储卡后，我们需要获取根目录的名称。如果我们要访问某个具体的名字，则我们需要指定它相对于这个根目录的名字。为了获取根目录的名称，我们需要使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="n"&gt;externalDir&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Environment&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getExternalStorageDirectory&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从这里开始，我们就可以使用Java I/O类来读写文件了。&lt;/p&gt;
&lt;h2&gt;音频编程&lt;/h2&gt;
&lt;h3 id="she-zhi-yin-liang"&gt;设置音量&lt;/h3&gt;
&lt;p&gt;在Android中，打开Youtube程序的时候按音量键调整音量时，调整的是视频的音量。在Home中按音量调整键时调整的是电话的音量。Android对不同的目的有不同的音频流。当我们在游戏中播放音乐和音效时使用的音频流叫music stream。在播放音效或音乐前，我们要保证音量调整键能控制正确的音频流。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setVolumeControlStream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AudioManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STREAM_MUSIC&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的context就是我们的Activity。调用完这个方法后音量调整键将控制music stream。这将在Activity的整个生命周期中影响播放的音乐和音效。通常应该在Activity.onCreate()方法中做这个操作。&lt;/p&gt;
&lt;h2&gt;播放音效&lt;/h2&gt;
&lt;p&gt;前面讨论过音频流和音效的区别。后者存储于内存中通常时长只有数秒。Android提供了SoundPool类来播放音效。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SoundPool&lt;/span&gt; &lt;span class="n"&gt;soundPool&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SoundPool&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;AudioManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STREAM_MUSIC&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个参数指定了最多同时可以播放多少个音效。这并不是说我们不能加载多个音效播放，它只是限制我们能并发的播放多少音效。第二个参数指定SoundPool将音频输出到哪个音频流，这里选择了音量调整键对应的music stream。最后一个参数现在没有使用默认设置为0。&lt;/p&gt;
&lt;p&gt;为了从音频文件将音效加载到内存堆中。我们可以使用SoundPool.load()方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;AssetFileDescriptor&lt;/span&gt; &lt;span class="n"&gt;descriptor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;assetManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;openFd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"explosion.ogg"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;explosionId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;soundPool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;load&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;descriptor&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SoundPool.load()的第二个参数是音效的优先级，目前还没有使用，应该将它设置为1以保证与将来的兼容。&lt;/p&gt;
&lt;p&gt;SoundPool.load()方法将返回一个整数，它被当作被加载的音效的句柄。当我们需要播放这个音效时，只需要指定这个句柄。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;soundPool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;play&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;explosionId&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个参数是由SoundPool.load()方法返回的句柄。接下来的两个方法是指定左右声道的音量。这两个值应该处于0到1之间。接下来的两个值很少用到，第一个是优先级，当前没有使用设置为0。另一个指定音效是否应该循环播放。通常音效不需要循环播放。最后一个参数是指定回放速度。将它设置为高于1的值时回放的速度将比录制时的速度快，设置为小于1时回放速度将比录制时的速度慢。&lt;/p&gt;
&lt;p&gt;当我们不再需要音效时可以释放内存。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;soundPool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;unload&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;explosionId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常我们只一个SoundPool实例，使用它来加载、播放和释放音效。当不再需要使用SoundPool时我们应该调用SoundPool.release()方法，它会释放SoundPool使用的资源。调用完这个方法之后，就不能再使用SoundPool了。所有由它加载的音效也都会丢失。&lt;/p&gt;
&lt;p&gt;注意：
 - SoundPool.load()方法执行加载的时候是异步进行的。在调用SoundPool.play()方法之前应该等侍一段时间以保证加载的完成。但是我们没有办法检查音效是否加载完成了。只有在SDK8之上的SoundPool才支持这个检测。
 - SoundPool在播放长的MP3音频文件时存在问题，这个长音频文件批的是&amp;ldquo;超过5至6秒的&amp;rdquo;。这些问题都没有文档。推荐的方法是使用OGG音频文件代替MP3，和使用低的采样率和采样时间，这样会得到较差的音质。&lt;/p&gt;
&lt;h2&gt;音频流&lt;/h2&gt;
&lt;p&gt;小的音效可以放到Android应用从操作系统获取到的空间有限的内存堆中。大的音频文件包含长时间的音乐。基于这个原因我们需要将音频流发送到硬件，我们只需要在某一时刻读取一小块足够大小的文件，将它解码成原始的PCM数据并将它丢给音效芯片。&lt;/p&gt;
&lt;p&gt;这个过程的起来比较吓人。幸运的是我们有MediaPlayer类，它能帮我们处理这些复杂的操作。我们需要做的是告诉它要播放的音频文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;MediaPlayer&lt;/span&gt; &lt;span class="n"&gt;mediaPlayer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MediaPlayer&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们需要告诉MediaPlayer哪个文件需要播放。这又需要通过AssetFileDescriptor：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;AssetFileDescriptor&lt;/span&gt; &lt;span class="n"&gt;descriptor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;assetManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;openFd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"music.ogg"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;mediaplayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setDataSource&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;descriptor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getFileDescriptor&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;descriptor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getStartOffset&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;descriptor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getLength&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这比SoundPool的使用复杂些。MediaPlayer.setDataSouce()方法不能直接接收AssetFileDescriptor。它需要的是FileDescriptor，这可以通过AssetFileDescriptor.getFileDescriptor()方法获取到。另外我们还需要指定偏移量和音频文件的长度。为什么需要偏移量呢？实际上整个Asset是存储在单个文件中的。为了让MediaPlayer获取某个文件的开始位置我们需要提供它在Asset中的偏移量。&lt;/p&gt;
&lt;p&gt;在播放音乐之前，我们需要调用MediaPlayer的prepare方法来准备播放。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mediaPlayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;prepare&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将实际打开文件和检查它是否能被MediaPlayer实例读取的播放。从这里开始我们可以播放、暂停和停止播放，也可以设置循环播放和改变音量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mediaPlayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法只能在MediaPlayer.prepare()方法调用成功后（可以检查它是否抛出了runtime异常）才能调用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mediaPlayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;pause&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法也只能在prepare方法和start方法被调用之后才能调用。继续播放可以调用start()方法，不需要再次调用prepare方法。&lt;/p&gt;
&lt;p&gt;需要停止播放时调用下面的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mediaPlayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;stop&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们需要再次启动一个已经stopped的MediaPlayer时，我们又需要先调用prepare()方法。&lt;/p&gt;
&lt;p&gt;可以用下面方法设置成循环播放：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mediaPlayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setLooping&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用下面的方法设置音量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mediaPlayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setVolume&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将设置左右声道的音量。文档里没有指定这两个值的范围。以经验来说，有效的范围为0到1。&lt;/p&gt;
&lt;p&gt;我们可能还需要检查播放是否结束了。有两个方法可以实现这个。在MediaPlayer中注册一个OnCompletionListener接口，它将在播放结束时被调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mediaPlayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setOnCompletionListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们需要主动从MediaPlayer中获取状态，我们可以使用下面的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;isPlaying&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mediaPlayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isPlaying&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果MediaPlayer被设置为循环播放，则没有办法来标明播放停止了。&lt;/p&gt;
&lt;p&gt;最后，如果播放器使用完毕了，我们要确保所有资源都被释放。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mediaPlayer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;release&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在丢弃实例之前总是调用这是是个好的实践。&lt;/p&gt;
&lt;p&gt;当我们没有将MediaPlayer设置为循环播放并且播放结束时，我们可以调用MediaPlayer.prepare()和MediaPlayer.start()方法重新播放。&lt;/p&gt;
&lt;p&gt;多数这些方法是以异步的方式工作的，因此在调用MediaPlayer.stop()之后，MediaPlayer.isPlaying()方法可能会要过一小段时间才能返回。这通常不是很大的问题。多数游戏会需要将MediaPlayer设置为循环播放，当需要时再停止播放（比如，切换到另一个屏幕后要播放另一个音乐）。&lt;/p&gt;
&lt;p&gt;注意：
 - MediaPlayer.start()，MediaPlayer.pause()和MediaPlayer.resume()只能在上面讨论过的条件下才能被调用。不要在没有prepared的情况下调用不这些方法。MediaPlayer.start()只能在preparing之后的MediaPlayer才能调用或者在调用MediaPlayer.pause()之后用resume恢复。
 - MediaPlayer实例是重量级对象。拥有多个这样的实例将消耗大量资源。应该尽量保持只有1个来播放音乐。SoundPool处理的音效的情况好一些。
 - 记得将音量按键设置到music stream否则将不能调整游戏的音量。&lt;/p&gt;
&lt;h2&gt;图形编程基础&lt;/h2&gt;
&lt;p&gt;Android为我们提供了2种API绘制内容到屏幕上。主要使用的是较简单的2D图形编程，另一种是可以使用硬件加速的3D图形编程。下面主要讨论使用CanvasAPI进行2D图形编程，它是Skia库的封装，适应于适度复杂的2D图形。在进行图形编程前，我们需要先知道如何进入全屏和wake locks。&lt;/p&gt;
&lt;h3 id="shi-yong-wake-locks"&gt;使用Wake locks&lt;/h3&gt;
&lt;p&gt;如果将不接触设备一段时间，电话的屏幕将会变暗。只有在接触屏幕或者按下按钮之后屏幕才会恢复变亮。为了保持屏幕一直亮着，我们需要使用wake lock。&lt;/p&gt;
&lt;p&gt;首先我们需要在&lt;uses-permission&gt;标签中添加android.permission.WAKE_LOCK。这将允许我们使用WakeLock类。&lt;/uses-permission&gt;&lt;/p&gt;
&lt;p&gt;我们可以从PowerManager中获取到WakeLock的实例。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;PowerManager&lt;/span&gt; &lt;span class="n"&gt;powerManager&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PowerManager&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSystemService&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;POWER_SERVICE&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;WakeLock&lt;/span&gt; &lt;span class="n"&gt;wakeLock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;powerManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;newWakeLock&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PowerManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;FULL_WAKE_LOCK&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"My Lock"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与其它系统服务一样，我们从Context实例中获取PowerManager。PowerManager.newWakeLock()方法接收两个参数：lock的类型和一个可以自定义的标签。有几个不同类型的wake lock：对于我们的需求使用PowerManager.FULL_WAKE_LOCK是正确的选择。它将保证屏幕一直亮着，CPU将一直工作于全速模式下，键盘也将是启用的。&lt;/p&gt;
&lt;p&gt;为了启用wake lock我们要调用acquire()方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wakeLock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;acquire&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;电话将从这时开始保持唤醒状态，不论用户有多久没有操作。当我们的应用程序paused或者destroyed，我们可以禁用或者释放wake lock：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wakeLock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;release&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常我们在Activity.onCreate()方法中实例化WakeLock实例，在Activity.OnResume()方法中调用WakeLock.acquire()，在Activity.onPause()方法中调用WakeLock.release()。这样可以保证我们的应用程序在paused或resumed状态下仍然能正常工作。&lt;/p&gt;
&lt;h3 id="jin-ru-quan-ping"&gt;进入全屏&lt;/h3&gt;
&lt;p&gt;到目前为止，我们的程序中通知栏和标题栏都是显示的。添加下面的代码可以隐藏这些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;requestWindowFeature&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Window&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;FEATURE_NO_TITLE&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;getWindow&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;setFlags&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WindowManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LayoutParams&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;FLAG_FULLSCREEN&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;WindowManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LayoutParams&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;FLAG_FULLSCREEN&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个调用删除了Activity的标题栏，第二个方法隐藏掉状态栏。这些调用只能在设置Activity的context view之前执行。&lt;/p&gt;
&lt;h3 id="zai-uixian-cheng-zhong-chi-xu-xuan-ran"&gt;在UI线程中持续渲染&lt;/h3&gt;
&lt;p&gt;尽管持续性的渲染（实现动画效果）听起来很复杂，实际上Android让它变得非常容易了。我们只需要继承View类，并覆盖它的View.onDraw()。这个方法将在View需要重绘时被调用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RenderView&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;RenderView&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onDraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Canvas&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
        &lt;span class="c1"&gt;//实现&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;传入onDraw()方法的Canvas是干重活的，通过它来形状、位图到另一个位图或者View（或者Surface）中。&lt;/p&gt;
&lt;p&gt;我们可以用RenderView作为activity的content view，并用它来进行输入监听。但是这还不够，有两个原因：它没有实际绘制任何内容，即使它绘制了，它也只会在需要的时候进行重绘（比如：当它created或者resumed时或者当被对话框覆盖后重新恢复可见时）。如何让它自己重绘呢？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onDraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Canvas&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
    &lt;span class="c1"&gt;//绘制&lt;/span&gt;
    &lt;span class="n"&gt;invalidate&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在onDraw的最后调用View.invalidate()方法告诉Android系统尽快重绘RenderView。这些都是发生在UI线程中，which is a bit of a lazy horse。但我们在onDraw()方法中实现了连续渲染的，虽然相对来说比较慢。后面我们将修复这个问题，现在它还能满足我们的需求。&lt;/p&gt;
&lt;p&gt;回到Canvas类，它是一个非常强大的类，它对底层的图形库Skia进行了封装，这个库经过了特别的裁剪以执行使用CPU进行的2D渲染。Canvas类提供了非常多的绘制方法，比如绘制图形、位图甚至是文字。&lt;/p&gt;
&lt;p&gt;draw方法绘制到哪里去了呢？这要看具体的情况。Canvas可以渲染Bitmap实例；Bitmap是Android的2DAPI提供的另一个类。在这里，它被绘制到屏幕上对应的View所占据的区域。当然，这个说法过于简单化了。实际上，它不是直接绘制到屏幕上，而是绘制到了某种位图上，系统会用它来合并Activity中所有View所对应的位图并组合成最终输出的图像。然后这个图像被传递给GPU，并通过其它复杂的方法显示到屏幕上。&lt;/p&gt;
&lt;p&gt;我们不需要关心这些细节，从我们的角度来看，View看起来像是被拉伸到了整个屏幕，因此它可以被绘制到系统的帧缓冲区。在下面的讨论中，我们假设我们是直接绘制到帧缓冲的，系统来处理垂直扫描和双缓冲的问题。&lt;/p&gt;
&lt;p&gt;在onDraw()方法中将在系统允许时被调用。对我们来说，它与理论上的游戏主循环非常类似。如果我们想要使用这个方法来实现游戏，我们就需要将所有我们的游戏逻辑放到这个方法中。很多原因导致我们不能这样做，但是，性能只是其中一个原因。&lt;/p&gt;
&lt;p&gt;注意：
 上面的方法能实现持续的渲染，但是强烈推荐你不要使用这种方法！我们只应该在UI线程中执行很少的操作。我们将讨论如何在合适的独立线程中执行游戏的逻辑。&lt;/p&gt;
&lt;h3 id="huo-qu-ping-mu-fen-bian-chuang-he-zuo-biao-xi-tong"&gt;获取屏幕分辨床（和坐标系统）&lt;/h3&gt;
&lt;p&gt;为了将游戏元素渲染到屏幕上，我们需要知道屏幕的X轴和Y轴有多少个像素。Canvas类提供了两个方法来获取这些信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getWidth&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHeight&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将返回Canvas的渲染目标的宽度和高度。注意屏幕方向不同时width有可能会小于height。&lt;/p&gt;
&lt;p&gt;另一个我们需要知道的信息是坐标系统。首先，坐标系统由整数组成（有子像素的概念，这里我们忽略它）。坐标的原点(0,0)总是位于显示的左上角，与屏幕方向无关。X轴向右增长，Y轴向下增长。&lt;/p&gt;
&lt;h3 id="hui-zhi-jian-dan-de-tu-xing"&gt;绘制简单的图形&lt;/h3&gt;
&lt;p&gt;介绍Canvas中常用的绘制方法。&lt;/p&gt;
&lt;h3 id="shi-yong-wei-tu"&gt;使用位图&lt;/h3&gt;
&lt;p&gt;使用基础的图形如线和圆来绘制游戏也是可能的，但是那并不性感。我们需要了不起的艺术来创建精灵和背景和其它激动人心的东西，我们可以从PNG或者JPEG文件来加载这些。&lt;/p&gt;
&lt;h4 id="jia-zai-he-jian-cha-wei-tu"&gt;加载和检查位图&lt;/h4&gt;
&lt;p&gt;Bitmap类会成为我们最好的朋友。我们可以使用BitmapFactory单例从文件加载位图。如下面从assets目录加载图像。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;InputStream&lt;/span&gt; &lt;span class="n"&gt;inputStream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;assetManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;open&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"bob.png"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="n"&gt;bitmap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BitmapFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;decodeStream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputStream&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bitmap类有一些有趣的方法。首先我们要知道图像的像素宽度和高度。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bitmap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getWidth&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bitmap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHeight&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们可能需要知道Bitmap中存储的颜色的格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bitmap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Config&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bitmap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getConfig&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;config的可选值有：
 - Config.ALPHA_8
 - Config.ARGB_4444
 - Config.ARGB_8888
 - Config.RGB_565
第三章和数字化编码颜色一节讨论过这些。&lt;/p&gt;
&lt;p&gt;有趣的是上面的可选值里没有RGB888。PNG只支持ARGB8888，RGB888和调色板颜色。那么RGB888格式的PNG加载后是什么颜色格式呢？它将是BitmapConfig.RGB_565。这个转换是在使用BitmapFactory加载RGB888格式的PNG时自动发生的。原因是绝大多数的Android设备的缓冲区都是使用这种颜色格式。加载每个像素都是高角深的图像是在浪费内存（image with higher bit depth per pixel）,这些像素最终也将需要被转换成RGB565来渲染。&lt;/p&gt;
&lt;p&gt;那为什么还需要Config.ARGB_8888配置呢？因为图像在被绘制到帧缓冲区之前是在CPU上构成的。在使用Alpha时，我们可以有比Config.ARGB_4444更多的色深（more bit depth）来处理某些高质量的图像。&lt;/p&gt;
&lt;p&gt;ARGB8888格式的PNG图像将被加载为Config.ARGB_8888的Bitmap。其它两种颜色格式较少使用。我们可以告诉BitmapFactory尝试以某种特定的颜色格式来加载图像，甚至是与原始的格式不同的格式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;InputStream&lt;/span&gt; &lt;span class="n"&gt;inputStream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;assetManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;open&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"bob.png"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;BitmapFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Options&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;BitmapFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Options&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;inPreferredConfig&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Bitmap&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Config&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ARGB_4444&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Bitmap&lt;/span&gt; &lt;span class="n"&gt;bitmap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BitmapFactory&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;decodeStream&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputStream&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（上面代码中关于颜色格式的细节）.....&lt;/p&gt;
&lt;p&gt;（释放位图）......&lt;/p&gt;
&lt;p&gt;（绘制位图）......&lt;/p&gt;
&lt;p&gt;（渲染文字）......&lt;/p&gt;
&lt;h3 id="shi-yong-surfaceviewjin-xing-chi-xu-xuan-ran_1"&gt;使用SurfaceView进行持续渲染&lt;/h3&gt;
&lt;h4 id="dong-ji"&gt;动机&lt;/h4&gt;
&lt;p&gt;之前想要实现持续渲染时，我们使用了错误的方法。影响到UI线程的方法是不可接受的；我们需要一个办法在独立的线程中完成那些脏活。即，使用SurfaceView。&lt;/p&gt;
&lt;p&gt;从它的名字可以看出，SurfaceView类是一个View包含了Surface，Surface是Android API提供的一个类。什么是Surface呢？它是屏幕合成器（screen compositor）渲染View所使用的的原始缓冲区（raw buffer）的抽象。屏幕合成器是在Android所有渲染的后台策划者，也是由它负责在最后将像素放到GPU。Surface在某些情况下可能是硬件加速的。我们不需要知道这些细节，我们只需要知道使用它是一种更直接的渲染内容到屏幕上的方法。&lt;/p&gt;
&lt;p&gt;我们的目标是在单独的线程中进行渲染而不影响UI线程，而让它来处理其它的事情。SurfaceView类提供了这样的方法从非UI线程中进行渲染。&lt;/p&gt;
&lt;h4 id="surfaceholderhe-locking"&gt;SurfaceHolder和Locking&lt;/h4&gt;
&lt;p&gt;为了从非UI线程中渲染SurfaceView，我们需要获取到Surfaceholder类的实例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SurfaceHolder&lt;/span&gt; &lt;span class="n"&gt;holder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;surfaceView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHolder&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SurfaceHolder封装了Surface，并为我们做了些辅助工作。它提供了两个方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Canvas&lt;/span&gt; &lt;span class="n"&gt;SurfaceHolder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lockCanvas&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;SurfaceHolder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;unlockAndPost&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Canvas&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个方法锁定要渲染的Surface并返回相应的Canvas给我们使用。第二个方法解锁Surface并确保我们使用Canvas绘制的内容显示到屏幕上。我们将在渲染线程中使用这两个方法获取Canvas，并用它渲染它，最终将渲染过的图像显示到屏幕上。传递给SurfaceHolder.unlockAndPost()方法的Canvas必须是我们从SurfaceHolder.lockCanvas()方法中获取到的那个。&lt;/p&gt;
&lt;p&gt;Surface并不会在SurfaceView对象实例化后立即创建。它的创建也是异步的。Surface将在每次Activity进入paused时被销毁并在Activity进入resumed时被创建。&lt;/p&gt;
&lt;h4 id="surfacede-chuang-jian-he-yan-zheng"&gt;Surface的创建和验证&lt;/h4&gt;
&lt;p&gt;我们不能在Surface还没有准备好的时候就获取SurfaceHolder。但是，我们可以检查Surface是否已经被创建。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;isCreated&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;surfaceHolder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSurface&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;isValid&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这个方法返回true，我们就可以安全的锁定Surface并使用我们接收到的Canvas绘制了。必须要保证在调用SurfaceHolder.lockCanvas之后Surface被unlock，否则我们的Activity可能会被锁住电话！&lt;/p&gt;
&lt;h3 id="zui-jia-shi-jian_1"&gt;最佳实践&lt;/h3&gt;
&lt;p&gt;Android有些奇怪的性能特性。下面是对游戏影响较大的部分：
 - 垃圾收集器是你最大的敌人。一旦它得到CPU时间来执行时，它将会锁住整个虚拟机600ms。半秒左右的时间游戏画面不会更新。用户将会迷惑。尽可能的避免创建对象，特别是在循环中。
 - 对象应该在那些不明显的地方创建，尽量避免。不要使用迭代器，它们将创建新对象。不要使用任何标准的Set或Map集合类，它们会在每次插入操作时创建新的对象；使用Android API提供的SparseArray类来代替它们。使用StringBuffer代替+拼接字符。+号操作将在每次操作时创建一个新的StringBuffer。不要使用原生类型的对象类型。
 - 在Dalvik中方法调用消耗的资源比其它VM的要多。尽量使用静态方法，它们的性能更好。静态方法与静态变量一样通常被当作邪恶的，它们导致错误的设计。因此保持你的设计尽可能的浅析。避免getter和setter方法。直接访问字段比调用那些方法要快上三倍，在没有JIT的情况下要快上七倍。在移除所有getter和setter方法之前先思考你的设计。
 - 在旧设备的Dalvik中没有JIT（Android 2.2之前）浮点操作是用软件实现的。原来的游戏开发者可能会立即想到用fixed-point数学。不要这么做，因为整数除法同样很慢。多数情况下你不需要使用浮点，新的设备带有FPU。
 - 尽可能在方法中使用局部（local）变量。访问局部变量比访问成员或者调用getter更快。&lt;/p&gt;
&lt;h1&gt;OpenGL ES：简介&lt;/h1&gt;
&lt;h2&gt;什么是OpenGL ES为什么应该了解它？&lt;/h2&gt;
&lt;p&gt;OpenGL ES是3D图形编程的工业标准。特别是在移动和嵌入式设备上。它由Khronos Group进行维护，这个公司由ATI、NVIDIA和Intel共同组成。&lt;/p&gt;
&lt;p&gt;当前的3个版本的OpenGL ES：1.0、1.1和2.0。前面两个版本是本书要涉及的版本。所有Android设备都支持OpenGL ES 1.0，多数支持1.1，这个版本在1.0的基础上增加了些新的功能。OpenGL ES 2.0，打破了与1.0的兼容性。你可以使用1.X或者2.0，但是不能同时使用这两个版本。原因在于1.X使用的编程模式被称为fixed-function pipeline，2.0让你可以以编程的方式通过被称为shader的东西部分定义rending pipeline。&lt;/p&gt;
&lt;p&gt;许多二代设备已经支持OpenGL ES 2.0；但是，它的Java绑定当前不可用（除非你的目标平台是Android 2.3）。OpenGL ES 1.x对于多数游戏来说已经足够了，因此，我们仍然使用它。&lt;/p&gt;
&lt;p&gt;注意：模拟器只支持OpenGL ES 1.0。不要依赖于模拟器进行测试。&lt;/p&gt;
&lt;p&gt;OpenGL ES的API是由一套由Khronos提供的C头文件来提供的，没有包含头文件定义的API如何实现的细节。这些细节包含像素和线条如何被渲染等等。硬件制造商按这些规范在它们的GPU的驱动上进行实现。实现的质量会有些区别；有些公司严格遵守规范（PowerVR），有些则很难遵守规范。这有时候会导致与具体实现的GPU相关的BUG，这与Android本身无关，而是与硬件制造商提供的硬件驱动有关。&lt;/p&gt;
&lt;p&gt;注意：OpenGL ES与桌面版本的OpenGL已经与偏离了。有些内容已经重写或者被彻底移除了。不论如何，还是有可能编写可以运行在两者之上的应用程序。&lt;/p&gt;
&lt;p&gt;什么是OpenGL ES呢？简短的回答就是它是一个三角形渲染机器。&lt;/p&gt;
&lt;h3 id="bian-cheng-mo-xing-mo-ni"&gt;编程模型：模拟&lt;/h3&gt;
&lt;p&gt;可以把OpenGL ES工作的时候当成一个摄像机。为了拍摄照片你需要转移到需要拍照的场景。场景是由对象组成的&amp;mdash;&amp;mdash;比如一个放置了东西的桌子。上面的东西都有自己的位置和方向（相对于像机），也有不同的材质和纹理。比如玻璃是透明的，光线反射较少，桌子可能是由木头组成的，杂志上有某个政客最新的照片，等等。有些对象也可能会移动（比如，飞动的水果）。摄像机也有一些特性，比如焦躁、视野、要拍摄的图像分辨率和大小，和它相对于整个世界的位置和方向（相对于某个原点）。甚至对象和像机都在移动，当按下按钮拍摄照片时仍然可以拍到场景上的图像（忽略快门速度）。在这个无穷短的瞬间所有的东西都存在，图像正确的反应出一这些东西的位置、方向、纹理、材质和光线。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图7-1" src="/beginning_android_games/abstract_scene.png"/&gt;
图7-1&lt;/p&gt;
&lt;p&gt;所有的东西相对于场景的原点都有自己的位置和方向。图中的眼睛代表相机，也有它相对于场景原点的位置和方向。图中的锥体被称为视卷或者视锥（view volume or view frustum）。它展示了相机的方向和场景中有多少内容能被它捕获到。白色的球代表的是场景中的光源，它也有相对于原点的位置。&lt;/p&gt;
&lt;p&gt;为了将这些内容映射到OpenGL ES中，我们定义下面的东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象（或者称为模型）：这些通常由2个4点组成：它们的几何特性，如颜色、纹理和材质。几何外形由一套三角形组成。每个三角形由3D空间的3个点组成。Z轴是朝向我们的。颜色由RGB指定。纹理和材质复杂一些。后面我们再讨论。&lt;/li&gt;
&lt;li&gt;灯光：OpenGL ES提供了一套不同的光源类型，有各种属性。它们只是在3D空间中的数学对象，有自己的方向，加上颜色之类的属性。&lt;/li&gt;
&lt;li&gt;摄像机：也是数学对象，也只在3D空间占据一个位置，并且有方向。另外它有参数控制我们能看到多大的图像，类似于真实的相机。这些东西定义一起定义了视锥。任何视锥内的东西都能被相机拍到，而外部的东西则不会进入最终的照片。&lt;/li&gt;
&lt;li&gt;视口：这决定了最终图像的大小和分辨率。可以把它当作你的摄像机拍摄到的影片类型或者数码相机拍摄到的照片的分辨率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这些，OpenGL ES可以构造从摄像机位置所看到的场景的2D图像。我们定义所有的东西都是在3D空间定义的。OpenGL ES是如何将它映射到2D坐标的呢？&lt;/p&gt;
&lt;h3 id="tou-ying"&gt;投影&lt;/h3&gt;
&lt;p&gt;这种2D映射是通过被称为投影的方法实现的。我们注意到OpenGL ES主要是涉及三角形。一个三角形由3D空间的3个点构成。为了将这个3角形渲染到帧缓冲区中，OpenGL ES需要知道这些3D点在帧缓冲坐系统中的坐标。知道这三个角的坐标后，只需要简单的将像素绘制到帧缓冲。我们甚至可以通过将3D点转换到2D点实现简单的OpenGL ES，并使用Canvas进行绘制：&lt;/p&gt;
&lt;p&gt;在3D图形中有2种方法进行投影：
 - 平行或者称为正交投影：如果你使用过CAD软件，则你对它不会陌生。平行投影的情况下最终的图像总是拥有固定的大小。这是在OpenGL ES中进行2D图形渲染时所用的方法。
 - 透视投影：这是我们的眼睛所使用的方法。离我们越远的对象在我们的视网膜上会显得更小。这通常是OpenGL ES中3D图形所使用的投影方法。&lt;/p&gt;
&lt;p&gt;这两种情况下都需要被称为投影平面的东西。它类似于我们的视网膜。这是最终的将光线转换成图片的地方。数学上的投影平面是无限的，我们的视网膜却是有限的。在OpenGL ES中的&amp;ldquo;视网膜&amp;rdquo;相当于视锥顶部的矩形区域。OpenGL ES会将点投影到它的上面。它被称为近端裁剪平面（near clipping plane）它有自己的2D坐标系统。下图展示了叠加了坐标系统的近端裁剪平面。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图7-2" src="/beginning_android_games/view_frustum.png"/&gt;
图7-2&lt;/p&gt;
&lt;p&gt;注意上面的坐标是不固定的。我们可以指定投影的坐标系统（比如告诉OpenGL ES将原点放在左下角，让&amp;ldquo;视网膜&amp;rdquo;可以看到X轴480个单位Y轴320个单位的范围）。听起来很熟悉吧？是的，OpenGL ES允许我们指定投影点的坐标系统。&lt;/p&gt;
&lt;p&gt;当我们指定视锥后，OpenGL ES从三角形的每个点发出一条穿过投影平面的光线。平行或者透视（parallel and perspective）投影方式决定了光线的方向。如下图，展示了两者的区别。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图7-3" src="/beginning_android_games/projection_type.png"/&gt;
图7-3&lt;/p&gt;
&lt;p&gt;透视投影将光线从三角形上的点射向相机（或者说眼睛）。这时离投影平面远的物体会显得小些。而当我们使用平行投影时，光线光垂直射向投影平面。这时不管物体的远近如何，它都将会保持相同的大小。&lt;/p&gt;
&lt;p&gt;前面说过，我们的投影平面在OpenGL ES术语中被称为近端裁剪平面（near clipping plane）。视锥的各个面有相类似的名字。远离相机一端的平面被称为无端裁剪平面（far clipping plane）。其它几个面分别被称为左、右、顶和底端裁剪平面。任何处于这些平面之外或者之后的物体将不会被渲染，即视锥之外的内容被剪掉了。这就是裁剪平面（clipping plane）这一名称的由来。&lt;/p&gt;
&lt;p&gt;你可能想知道为什么上图中平行投影的视锥为什么会是矩形的。它提示了实际上投影是由我们如何定义裁剪平面而决定的。在透视投影中，左、右、顶和底裁剪平面都不垂直于近端和远端裁剪平面。而在平行投影中，这些裁剪面都是垂直的，这告诉OpenGL ES不要管物体离相机的远近，将它们渲染成相同的大小即可。&lt;/p&gt;
&lt;h3 id="biao-zhun-she-bei-kong-jian-he-shi-kou"&gt;标准设备空间和视口&lt;/h3&gt;
&lt;p&gt;当OpenGL ES计算出点在近端裁剪平面上的投影点后，它最终将可以将它们转换成帧缓冲区的像素坐标了。为达到这个目的，它必须先将点转换到标准设备空间（normalized device space）。这等于图7-2中描述的坐标系统。基于标准设备空间坐标OpenGL ES使用下面的简单公式就可以计算出它在帧缓冲区中最终的坐标了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;pixelX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;norX&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;viewportWidth&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;norX&lt;/span&gt;
&lt;span class="n"&gt;pixelY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;norY&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;viewportHeight&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;norY&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;norX和norY是3D点在标准设备空间的坐标，viewportWidth和viewportHeight是视口（viewport）的大小。我们不需要关心标准设备空间坐标，OpenGL会自动帮我们完成转换。我们需要关心的是视口和视锥。&lt;/p&gt;
&lt;h3 id="ju-zhen"&gt;矩阵&lt;/h3&gt;
&lt;p&gt;下面将看到如何处理视锥和投影。OpenGL ES是以矩阵来表达投影的。对于我们来说我们不需要知道矩阵的内部细节。我们只需要知道它们对应于我们在场景中定义的点。下面的关于矩阵的概要：
 - 矩阵将转换（transformation）编码然后应用到点上。转换可以被投影，迁移（translation，点的移动），相对于另一个点和轴旋转、拉伸等等。
 - 通过点和矩阵相乘。我们可以将转换应用到点。例如：通过将一个点与矩阵相乘将导致迁移10个单位，这样就修改了它的坐标。
 - 我们可以将多个矩阵中的转换通过矩阵乘法拼接到单个矩阵中。当我们将这个拼接出来的单个矩阵与点相乘时，所有存储于这个矩阵中的转换将按它们在矩阵乘法中的顺序应用到点上。
 - 有一种特殊的矩阵称为标识矩阵（identity matrix）。如果我们将矩阵或点与它相乘，什么都不会发生。可以把点或矩阵与标识矩阵相乘看成数字与1相乘，不会发生什么变化。当我们了解到OpenGL ES如何处理矩阵时，我们就会对标识矩阵有更清楚的认识。这是一个类似蛋与鸡的问题。&lt;/p&gt;
&lt;p&gt;注意： 这里所讨论的点上指定的3D矢量。&lt;/p&gt;
&lt;p&gt;OpenGL ES有三种不同的矩阵来处理模型中的点：
 - Model-view矩阵：我们可以使用这个矩阵来移动、旋转或者拉伸三角形（即Model-view矩阵的Model部分）。这种矩阵也用于指定相机的位置和方向（即Model-view的view部分）。
 - 投影矩阵：这个矩阵用于对投影进行编码，从而影响相机的视锥。
 - 纹理（Texture）矩阵：这种矩阵让我们可以处理被称为纹理坐标（texture coordinates）的东西。但是，我们将避免在本书中使用这种矩阵，因为OpenGL ES中的这个部分在很多设备上都由于驱动的Bug而有问题。&lt;/p&gt;
&lt;h3 id="xuan-ran-guan-xian"&gt;渲染管线&lt;/h3&gt;
&lt;p&gt;OpenGL ES会跟踪上面这三种矩阵。当我们设置其中一种矩阵时，它将会记住它直到我们再次修改矩阵。在OpenGL ES中，它被称为状态。OpenGL跟踪的不只是矩阵的状态；它也跟踪我们是否需要进行三角形的Ahpha混合，是否要考虑照明，哪个纹理应该被应用到模型上，等等。实际上OpenGL ES是一个巨大的状态机。我们设置它的当前状态，告诉它我们的物体的几何形状，告诉它如何渲染成图片。让我们看看三角形是如何通过这个强大的三角形渲染机器的。下图简要的展示了OpenGL ES中的管线：&lt;/p&gt;
&lt;p&gt;&lt;img alt="way of triangle" src="/beginning_android_games/way_of_triangle.png"/&gt;&lt;/p&gt;
&lt;p&gt;三角形是以下面的方式通过管线的：
 1. 三角形首先被转换成model-view矩阵。这意味着它的点将与这个矩阵相乘。这个乘法将影响到世界（场景）中的点。
 2. 产生的输出与映射矩阵相乘，这将影响到3D点到2D投影平面的转换。
 3. 这两部之间（他们可能并行），当前设置的灯光和材质也被应用到三角形，这让它有了颜色。
 4. 这些工作做完后，投影三角被载剪到我们的&amp;ldquo;视网膜&amp;rdquo;将被转换到帧缓冲区坐标。
 5. 最后一步，OpenGL将三角形的颜色填充到像素，这个颜色受到灯光状态、三角形的纹理、阴影的影响，根据这些因素三角形的某个像素有可能会也有可能不会被合并到帧缓冲区的像素中。&lt;/p&gt;
&lt;p&gt;我们需要学习如何将模型、纹理丢给OpenGL ES，将设置这些步骤中的状态。在这之前我们先要了解如何让Android允许我们访问OpenGL ES。&lt;/p&gt;
&lt;p&gt;注意：本节所描述的OpenGL ES管线的工作方式是在高度抽象的情况下，描述得非常简单所留下的细节会是后面章节的重点。另一个要注意的是当OpenGL ES执行投影时，它并不会实际投影到2D坐标系统。而是投影到被称为同质坐标的系统（homogenous coordinate system）上，这个系统实际上是4维的。这与很多数学知识相关，为了简单起见，我们只需要简单的认为OpenGL ES投影到了2D坐标系统。&lt;/p&gt;
&lt;h2&gt;开始之前&lt;/h2&gt;
&lt;h2&gt;GLSurfaceView：从2008年开始事情变得简单了&lt;/h2&gt;
&lt;p&gt;首先我们需要的是某种类型的View，它允许我们使用OpenGL ES进行绘制。幸运的是Android AP提供了GLSurfaceView，它派生于之前我们所使用过的SurfaceView类。&lt;/p&gt;
&lt;p&gt;我们也需要一个独立的主线程以避免影响UI线程。GLSurfaceView已经为我们提供了这种线程。我们需要做的是实现一个GLSurfaceView.Render的接口，并将它注册到GlSurfaceView中。这个接口有三个方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;interface&lt;/span&gt; &lt;span class="nc"&gt;Render&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onSurfaceCreated&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL10&lt;/span&gt; &lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;EGLConfig&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onSurfaceChanged&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL10&lt;/span&gt; &lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onDrawFrame&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL10&lt;/span&gt; &lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OnSurfaceCreated()方法在每次GLSurfaceView创建时被调用。这将在每一次启动Activity和每次从Paused状态恢复时发生。这个方法接收两个参数，一个GL0和EGLConfig。GL10实例让我们可以向OpenGL ES发送命令。EGLConfig只是告诉我们surface的属性，比如色深之类的。通常会忽略它。我们将会在onSurfaceCreated()方法中设置我们的几何模型和纹理。&lt;/p&gt;
&lt;p&gt;onSurfaceChanged()方法将在每次surface改变大小时被调用。新的高度和宽度将以像素为单位作为参数传递进来，还有GL0实例参数以便我们发出OpenGL ES命令。&lt;/p&gt;
&lt;p&gt;onDrawFrame()方法是发生有趣事件的地方。它与我们之前定义的Screen.render()方法类似，它将会被尽可能快速的被GLSurfaceView提供的渲染线程所调用。在这里我们执行所有渲染操作。&lt;/p&gt;
&lt;p&gt;除了注册Renderer监听之外，我们还需要在Activity的onPause()/onResume()方法中调用GLSurfaceView.onPause()/onResume()方法。原因很简单。GLSurfaceView将在它的onResume()方法中启动渲染线程，并在onPause()方法中停止这个线程。这意味着我们的监听在Activity进入paused时不会被调用，因为调用我们的监听的渲染线程也被paused。&lt;/p&gt;
&lt;p&gt;这里产生了另一个问题：每次Activity进入Paused时，GLSurfaceView中的surface将被销毁。当Activity恢复时（GLSurfaceView.onResume()被我们调用时），GLSurfaceView为我们实例化了一个新的OpenGL ES surface，这会导致调用监听中的onSurfaceCreated()方法。如果没有下面的这个问题这将一切OK，问题是：我们设置的所有OpenGL ES的状态将都丢失。这些内容包括纹理等等，这种情况下我们需要重新加载这些信息。这个问题被称作上下文丢失。上下文一词源于我们创建的OpenGL ES的surface，它保留了当前的状态。当我们销毁这个surface时，上下文就丢失了。这并不是最坏的，因为，我们可以在设计游戏时正确的处理上下文丢失的问题。&lt;/p&gt;
&lt;p&gt;注意：实际上，EGL负责处理上下文和surface的创建和销毁。EGL是Khronos Group的另一个标准；它定义了操作系统UI如何与OpenGL ES一起工作，也定义了操作系统OpenGL ES如何访问底层硬件。这包括了surface的创建，即上下文的管理。因为GLSurfaceView为我们处理了所有EGL的东西，我们可以安全的忽略多数的问题。&lt;/p&gt;
&lt;p&gt;Render中有趣的方法是onDrawFrame()方法。&lt;/p&gt;
&lt;p&gt;前面说过GL10的实例让我们可以访问OpenGL ES API。名字中的10表示的是它让我们可以使用所有OpenGL ES 1.0标准中定义的函数。这个类的所有方法都映射到相应的C函数。每个方法以gl开头，这是OpenGL ES中的一个传统。&lt;/p&gt;
&lt;p&gt;OpenGL ES有许多的常量，这些都定义为了GL10接口中的static public成员。与方法类似，每个常量都有GL_前缀。&lt;/p&gt;
&lt;p&gt;注意：不要在其它线程中调用OpenGL ES！这是第一条也是最后一条戒令！这是因为OpenGL ES是被设计为在单线程环境下使用，并不是线程安全的。有些可以工作于多线程，但是许多驱动会有问题，因此没有实际意义。&lt;/p&gt;
&lt;h2&gt;GLGame：实现Game接口&lt;/h2&gt;
&lt;h2&gt;红色的三角形&lt;/h2&gt;
&lt;p&gt;根据前面已经知道在使用OpenGL ES进行绘制之前我们需要一些准备工作。这些事情中我们最为关心的是投影和矩阵（及视锥）和视口，这决定了最终输出图像的大小和输出到帧缓冲的位置。&lt;/p&gt;
&lt;h3 id="ding-yi-shi-kou"&gt;定义视口&lt;/h3&gt;
&lt;p&gt;OpenGL ES使用视口（viewport）将投影到近端裁剪面的点的坐标转换到帧缓冲坐标。我们可以告诉OpenGL ES只使用一部分帧缓冲区：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Gl10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glViewport&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;x和y轴指定帧缓冲区中viewport的左上角，width和height指定viewport的像素尺寸。注意OpenGL ES假设帧缓冲区坐标系统的原点在屏幕左下方。在全屏模式下通常我们将x和y设置为0，将width和height设置为屏幕的分辨率。通过这种方法可以告诉OpenGL ES只使用部分的帧缓冲。它会将渲染输出拉伸到这个部分区域上。&lt;/p&gt;
&lt;p&gt;注意：这个方法看起来像是在为渲染设置2D坐标系统，实际上并非如此。它只是定义OpenGL ES用于输出最终图像的帧缓冲区的区域。坐标系统是通过投影和Model-view矩阵实现的。&lt;/p&gt;
&lt;h3 id="ding-yi-tou-ying-ju-zhen"&gt;定义投影矩阵&lt;/h3&gt;
&lt;p&gt;下面将讨论投影矩阵。这章我们只讨论2D图形，因此我们使用平行投影。&lt;/p&gt;
&lt;h4 id="ju-zhen-mo-shi-he-ji-huo-ju-zhen"&gt;矩阵模式和激活矩阵&lt;/h4&gt;
&lt;p&gt;OpenGL ES有三种类型的矩阵：投影矩阵、Model-view矩阵和纹理矩阵（这里我们忽略这个）。OpenGL ES提供了一些方法来修改这些矩阵。在使用这些方法之前，我们先要告诉OpenGL ES我们要处理哪种类型的矩阵。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;GL10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glMatrixMode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mode参数可以是GL10.GL_PROJECTION，Gl10.GL_MODELVIEW或者GL10.GL_TEXTURE。这些常量明确了当前所激活的是哪种类型的矩阵。在这之后进行的矩阵处理方法将按这里设置的类型来处理，直到我们再次通过这个方法修改所激活的矩阵类型。矩阵类型是OpenGL ES的一种状态（如果应用程序进入paused或者resumed状态，这个状态将随上下文丢失）。&lt;/p&gt;
&lt;h4 id="shi-yong-glorthofjin-xing-zheng-jiao-tou-ying"&gt;使用glOrthof进行正交投影&lt;/h4&gt;
&lt;p&gt;OpenGL ES为我们提供了下面的方法将当前激活的矩阵设置为正交（平行）投影矩阵：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Gl10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glOrthof&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bottom&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;near&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;far&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这看起来与我们的视锥裁剪平面类似。&lt;/p&gt;
&lt;p&gt;OpenGL ES有标准的坐标系统，X轴朝向右边，Y轴朝向左边，Z轴朝向我们自己。使用glOrthof()我们在这个坐标系统中定义我们的平行投影的视锥。如图7-3所示，我们知道平行投影的视锥像一个盒子。我们可以用这个视锥盒子的各个角来指定glOrthof()的参数。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图7-5" src="/beginning_android_games/orthographic_view_frustum.png"/&gt;
图7-5&lt;/p&gt;
&lt;p&gt;视锥的前面直接可以映射为我们的viewport。在全屏时viewport从(0,0)到(480,320)（相当于Hero的横屏模式），前面的左下角将映射到我们屏幕的左下角，前面的右上角映射到屏幕的左上角。（这里不明白，写错了？）OpenGL将自动执行拉伸。&lt;/p&gt;
&lt;p&gt;由于我们是要进行2D绘图，我们只需要指定角对应的点(left,bottom,near)和（right,top,far），通过这种方式让我们可以如之前在Mr.Nom中使用Canvas一样工作于像素坐标系统。下面是如何设置这个坐标系统：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glOrthof&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;480&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;320&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="图7-6" src="/beginning_android_games/parallel_projection_view_frustum_for_2D.png"/&gt;&lt;/p&gt;
&lt;p&gt;图7-6&lt;/p&gt;
&lt;p&gt;我们的视锥非常薄，因为我们只需要2D绘图。坐标系统中的可视部分是从(0,0,1)至(480,320,-1)。任何出现在这个盒子中的点都将显示到屏幕上。这些点将被投影到这个盒子的前面，即近端裁剪平面。投影然后被拉伸到我们的viewport的分辨率。这就是说当我们用一个800x480的设备时，如果我们按上面的方式设定视锥，则我们可以在480x320的坐标系统里工作，然后OpenGL将会将它拉伸到800x480的帧缓冲区（如果我们指定viewport覆盖了整个帧缓冲区的话）。没有什么可以阻止我们使用疯狂的视锥，比如我们也可以使用(-1,-1,100)和（2，2，-100）。所有在这个盒子中的内容都将被拉伸并显示出来。&lt;/p&gt;
&lt;p&gt;上面的设置中都包含了近端和远端裁剪平面。因为我们在本章里可以完全抛弃z轴，你可能想要将near和far的坐标都设置为0。因为一些原因这样做是不正确的。为求稳当，我们在z轴上分配了一点缓冲。&lt;/p&gt;
&lt;p&gt;注意：你可能已经注意到了y轴是向上的，原点在屏幕的左下方了。但是在使用Canvas时，许多2D渲染相关的API中y是向下的，原点在左上角。实际上，使用这个新坐标系统更有利于游戏编程。比如，超级玛丽跳起时，你一定不会希望y轴是减少而不是增加。&lt;/p&gt;
&lt;h3 id="yi-xie-you-yong-de-dai-ma-pian-duan_1"&gt;一些有用的代码片段&lt;/h3&gt;
&lt;p&gt;下面这段代码在后面所有例子中都会用到。它将屏幕清除为黑色，将viewport设置为整个帧缓冲区大小，并设置投影矩阵（视锥）以便我们使用原点在左下角y轴向上的坐标系统：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glClearColor&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glClear&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;GL_COLOR_BUFFER_BIT&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glViewport&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;glGraphics&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getWidth&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;glGraphics&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHeight&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glMatrixMode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;GL_PROJECTION&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glLoadIdentity&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glOrthof&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;320&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;480&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;glLoadIdentity()方法是做什么的呢？多数OpenGL ES提供的处理当前激活矩阵的方法不会直接设置矩阵。它会先按传递给它的参数构造一个临时矩阵并与当前矩阵相乘。glOrthof()方法也不例外。例如，如果我们在每帧中调用glOrthof()方法，则我们将会用投影矩阵与它自己相乘。为了防止这个，我们要先保证在与投影矩阵相乘之前有一个可用的identity矩阵。记住，矩阵与identity矩阵相乘将得到它自己。可以将这个方法当作加载为1的操作，然后将1与其它东西（这里是指由glOrthof()所处理的投影矩阵）相乘。&lt;/p&gt;
&lt;h3 id="zhi-ding-san-jiao-xing"&gt;指定三角形&lt;/h3&gt;
&lt;p&gt;接下来我们可以告诉OpenGL ES我们需要渲染的三角形了。三角形的定义如下：
 - 它是由3个点组成的
 - 每人点都称为顶点
 - 每个顶点在3D空间中有自己的位置
 - 每个位置是由3个浮点数组成的，用于指定x，y和z轴
 - 每个顶点可以有额外的属性，比如颜色或纹理坐标（texture coordinates）。这些都可以用浮点来描述&lt;/p&gt;
&lt;p&gt;OpenGL ES需要我们以数组的形式来发送我们的三角形定义。这通常是C的API，我们不能直接用Java数组来表示。我们不得不用Java NIO来处理，它们是连续的内存块。&lt;/p&gt;
&lt;h3 id="guan-yu-nio-buffer"&gt;关于NIO Buffer&lt;/h3&gt;
&lt;p&gt;（注：本节内容可以参见Java NIO一书中关于Buffer的部分，那里有详细的描述）&lt;/p&gt;
&lt;p&gt;更精确的来说，我们需要的是direct NIO buffer。这意味着内存不是在虚拟机的堆（heap）中分配的，而是本机堆（native heap）内存。为了构造direct NIO buffer，我们可以使用下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ByteBuffer&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ByteBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;allocateDirect&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NUMBER_OF_BYTES&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;order&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ByteOrder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;nativeOrder&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们共分配了NUMBER_OF_BYTES个字节的内存，并确保字节序等于所使用的CPU的字节序。NIO buffer有三个属性：
 - 容量（Capacity）：它可以保存的元素的总数
 - 位置（Position）：下一个元素将被写入或者读取的元素的位置
 - 限制（Limit）：定义的最后一个元素的索引加1&lt;/p&gt;
&lt;p&gt;Capacity是它的实际大小。在ByteBuffer中，它是以bytes来衡量的。position和limit属性可以通过定义的确定，buffer从position开始至limit结束（limit自身除外）。&lt;/p&gt;
&lt;p&gt;由于我们需要用浮点来定义顶点，因此用bytes来处理并不是很好。但是我们可以将ByteBuffer实例转换为FloatBuffer实例。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;FloatBuffer&lt;/span&gt; &lt;span class="n"&gt;floatBuffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;asFloatBuffer&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Capacity、position和limit在FloatBuffer中是按浮点给出的。我们使用Buffer的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;vertices&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="n"&gt;定义顶点的位置等等&lt;/span&gt; &lt;span class="o"&gt;...;&lt;/span&gt;
&lt;span class="n"&gt;floatBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;clear&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;floatBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;floatBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;flip&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先定义标准的Java浮点数组。在我们将数组放入buffer之前，先用clear()方法将buffer清空。这并不会删除任何数据，只是将positon设置为0并将limit设置为capacity。接下来我们使用FloatBuffer.put(float[] array)方法将整个数组复制到buffer的开始位置。复制完后，buffer的positon增长了数组的长度。如果再次调用put()方法，则会将额外的数据放到我们复制的数据的后面。最后我们使用FloatBuffer.flip()将position和limit的值交换。（注：flip()之后position位于0，这时再进行读取就会从第一个位置开始读取，这样可以保证读取的时候是按写入时的顺序读取的。）&lt;/p&gt;
&lt;h3 id="jiang-ding-dian-fa-song-gei-opengl-es"&gt;将顶点发送给OpenGL ES&lt;/h3&gt;
&lt;p&gt;假设我们的坐标系统是从(0,0,1)到(320,480,-1)，我们可以用下面的代码来定义顶点：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;ByteBuffer&lt;/span&gt; &lt;span class="n"&gt;byteBuffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ByteBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;allocateDirect&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;byteBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;order&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ByteOrder&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;nativeOrder&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;FloatBuffer&lt;/span&gt; &lt;span class="n"&gt;vertices&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;byteBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;asFloatBuffer&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Float&lt;/span&gt;&lt;span class="o"&gt;[]{&lt;/span&gt;    &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;    &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                           &lt;span class="mf"&gt;319.0f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;    &lt;span class="mf"&gt;0.0f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                           &lt;span class="mf"&gt;160.0f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;    &lt;span class="mf"&gt;479.0f&lt;/span&gt;   &lt;span class="o"&gt;});&lt;/span&gt;
&lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;flip&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们感兴趣的是如何决定要分配多少bytes。因为我们有3个顶点，每个点是由x和y两个坐标组成。每个坐标都是一个float类型的，需要4 bytes。3个顶点乘以2个坐标值乘以4 bytes，一共24bytes。&lt;/p&gt;
&lt;p&gt;注意：我们不需要指定z轴，OpenGL ES会自动将z轴设置为0。&lt;/p&gt;
&lt;p&gt;将顶点数据放入buffer并调用flip()之后NIO Buffer的position将被设置为0，limit被设置为6（FloatBuffer的limit和position都是按float占用的空间来计算的而不是byte）。&lt;/p&gt;
&lt;p&gt;接下来我们就可以告诉OpenGL ES来绘制当前的状态（比如：viewport和投影矩阵）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glEnableClientState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;GL_VERTEX_ARRAY&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glVertexPointer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GL10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;GL_FLOAT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vertices&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;gl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glDrawArrays&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GL10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;GL_TRIANGLES&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用glEnableClientState()是为了告诉OpenGL ES我们需要绘制的顶点是有位置的。这里2个地方显得有些白痴：
 - GL0.GL_VERTEX_ARRAY的命名有些迷惑，如果称它为GL10.GL_POSITION_ARRAY会更清楚一些。
 - 如果没有位置则根本不能进行绘制，调用这个方法真的有些多余。但是我们不得不按OpenGL ES的需要调用这个方法。&lt;/p&gt;
&lt;p&gt;glVertexPointer()告诉OpenGL ES到哪里可以找到顶点数据。它的第一个参数告诉OpenGL ES每个顶点坐标只包含了2个坐标，x和y。如果是3D坐标，则要把这个参数设置成3。第二个参数告诉OpenGL ES每个坐标的数据类型。GL0.GL_FLOAT表明我们使用的是占4 bytes的float类型。第三个参数stride告诉OpenGL我们的坐标值中每个坐标值之间的间距（以byte为单位）。在这里为0，因为我们的坐标值是一个挨着一个存储的（坐标1(x,y)坐标2(x,y)...）。最后一个参数是FloatBuffer，对于它有两点需要注意：
 - FloatBuffer是处于本地堆（native heap）的内存块，因此它有一个起始地址。
 - FloatBuffer中的存储的位置（position）位于从起始地址开始的一个偏移量。&lt;/p&gt;
&lt;p&gt;OpenGL ES将buffer的起始地址加上buffer中保存的坐标数据的位置（偏移）可以得到buffer中实际保存的浮点数据的地址，通过这种方式它能读取到顶点的数据。顶点数据是OpenGL ES的一种状态。只要我们不修改它（并且上下文不丢失），OpenGL ES将会在后面的调用中一直保留它。&lt;/p&gt;
&lt;p&gt;接下来调用glDrawArrays()。它将绘制出三角形。它的第一个参数是指定要绘制的图形的类型。我们使用GL10.GL_TRIANGLES告诉它我们需要渲染的是三角形。第二个参数是要渲染的顶点和第一个顶点之间的偏移。这里的偏移是以顶点为单位的，而不是以byte或者float。如果我们定义了多于个三角形时可以用这个偏移来渲染多个三角形中的一部分。最后一个参数告诉OpenGL ES有多少个顶点需要渲染。在这里我们有3个需要渲染。注意这个值总会是3的倍数，这个倍数值与第一个参数指定的图形类型有关。&lt;/p&gt;
&lt;p&gt;当执行glVertexPointer()时，OpenGL ES会将顶点位置传送到GPU，并为后面执行的渲染命令集而存储这些数据。每次我们告诉OpenGL ES渲染顶点时，它将会取上次调用glVertexPointer()时所传递的顶点数据。&lt;/p&gt;
&lt;p&gt;每个顶点数据可以含有多个属性而不仅仅只是坐标数据。其它属性可能是顶点的颜色。通常我们称这些属性为顶点属性。&lt;/p&gt;
&lt;p&gt;OpenGL ES是如何知道我们需要什么颜色的三角形的呢，我们只指定了坐标。OpenGL ES对于没有指定的顶点属性都有默认值。这些默认值中的大多数都是可以直接设置的，比如，设置所有要绘制的顶点的默认颜色：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;GL10&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;glColor4f&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法将会将所有未指定顶点颜色的顶点的默认颜色。颜色值是以RGBA的格式指出的，取值范围从0.0至1.0。顶点颜色的默认值为(1,1,1,1)&amp;mdash;&amp;mdash;不透明的白色。&lt;/p&gt;
&lt;p&gt;上面是在OpenGL ES中使用平行投影渲染一个三角形的所有代码。16行代码清除屏幕，设置viewport和投影矩阵，创建存储顶点位置的NIO缓存，绘制三角形。&lt;/p&gt;
&lt;h3 id="wan-zheng-de-dai-ma"&gt;完整的代码&lt;/h3&gt;
&lt;h2&gt;指定每个顶点的颜色&lt;/h2&gt;</content><category term="android"></category></entry><entry><title>Practical Clojure 记笔</title><link href="/practical-clojure-ji-bi.html" rel="alternate"></link><published>2012-03-12T00:00:00+08:00</published><updated>2010-07-30T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2012-03-12:/practical-clojure-ji-bi.html</id><summary type="html">&lt;h1&gt;状态管理&lt;/h1&gt;
&lt;p&gt;Clojure主张消除状态管理。而现实世界仍要需要状态变化。&lt;/p&gt;
&lt;p&gt;多数语言将事物（things）描述为变量或对象，并允许修改它们。这造成了对锁的需求。&lt;/p&gt;
&lt;h2&gt;状态和identity&lt;/h2&gt;
&lt;p&gt;Clojure引入新的思考事物的哲学。它将事物分解为2个独立的概念&amp;mdash;&amp;mdash;状态和identity。状态是与identity关联的某一时间点的值，而identity是事物不会改变的那个部分，它会与不同时间的不同状态建立连接。每个状态下的值都是不可变的。改变通过将identity指向（refer）不同的状态入口而模拟产生的。&lt;/p&gt;
&lt;p&gt;Clojure中的状态可以是任何Clojure中的数据类型。Identity是由三种引用类型（reference type）所表示的：ref、agent、atom和var。每种都描述了一个identity并指向一个状态。分别用于不同的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ref管理同步的coordinated（协调）状态&lt;/li&gt;
&lt;li&gt;agent管理异步的independent（独立，不受约束）状态&lt;/li&gt;
&lt;li&gt;atom管理同步的independent状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Coordinated与Independent状态&lt;/h2&gt;
&lt;p&gt;许多系统都需要对identity的修改是以协调的方式进行以确保数据的完整性。Coordinated的修改方式下将管理多个独立的identities以确保所有修改都会同时进行。例如，在2个银行帐户间转帐操作时，钱存入一个帐号，必须也保证从另一个帐号减去相应的量，这两个动作必须同时发生。Clojure使用ref来提供这种coodinated状态。&lt;/p&gt;
&lt;p&gt;与coordinated状态管理对应的是independent状态。Independent identity只处理自身，而不与其它identities相关联 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;状态管理&lt;/h1&gt;
&lt;p&gt;Clojure主张消除状态管理。而现实世界仍要需要状态变化。&lt;/p&gt;
&lt;p&gt;多数语言将事物（things）描述为变量或对象，并允许修改它们。这造成了对锁的需求。&lt;/p&gt;
&lt;h2&gt;状态和identity&lt;/h2&gt;
&lt;p&gt;Clojure引入新的思考事物的哲学。它将事物分解为2个独立的概念&amp;mdash;&amp;mdash;状态和identity。状态是与identity关联的某一时间点的值，而identity是事物不会改变的那个部分，它会与不同时间的不同状态建立连接。每个状态下的值都是不可变的。改变通过将identity指向（refer）不同的状态入口而模拟产生的。&lt;/p&gt;
&lt;p&gt;Clojure中的状态可以是任何Clojure中的数据类型。Identity是由三种引用类型（reference type）所表示的：ref、agent、atom和var。每种都描述了一个identity并指向一个状态。分别用于不同的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ref管理同步的coordinated（协调）状态&lt;/li&gt;
&lt;li&gt;agent管理异步的independent（独立，不受约束）状态&lt;/li&gt;
&lt;li&gt;atom管理同步的independent状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Coordinated与Independent状态&lt;/h2&gt;
&lt;p&gt;许多系统都需要对identity的修改是以协调的方式进行以确保数据的完整性。Coordinated的修改方式下将管理多个独立的identities以确保所有修改都会同时进行。例如，在2个银行帐户间转帐操作时，钱存入一个帐号，必须也保证从另一个帐号减去相应的量，这两个动作必须同时发生。Clojure使用ref来提供这种coodinated状态。&lt;/p&gt;
&lt;p&gt;与coordinated状态管理对应的是independent状态。Independent identity只处理自身，而不与其它identities相关联。这仍然需要以某种方式进行控制，但是这种处理方式比起由多个identities参与的coodinating修改会要高效一些。修改independent的identities通常比修改coordinated的identities要快。Clojure提供了agent和atom来处理independent identity。&lt;/p&gt;
&lt;h2&gt;同步和异步更新&lt;/h2&gt;
&lt;p&gt;同步更新会使identities的值在同一线程中立即被修改。在修改操作完成之前将不会继续向下执行，这与多数程序员的需求是一致的。在Clojure中修改ref和atom时都是同步的。&lt;/p&gt;
&lt;p&gt;异步修改不会立即发生，但它会在未指定的将来（与修改点较近的）某个时间发生，通常是在另一线程中。代码将继续运行下去，而不等侍修改的完成。异步修改对于并行编程是非常有用的，特别对于基于事件的编程模型。但是Clojure并不保证异步更新具体在什么时候发生。Clojure中用agent来实现异步修改identities。&lt;/p&gt;
&lt;h2&gt;Ref和事务&lt;/h2&gt;
&lt;p&gt;Ref是Clojure中实现同步coordinated identities的机制。对每个identity的操作能在事务中进行，由事务保证各个identities的值在整个事务中处于一致的状态（不会被其它线程修改）。即STM。&lt;/p&gt;
&lt;p&gt;在事务之外修改ref将抛出错误。&lt;/p&gt;
&lt;h3 id="xiu-gai-ref"&gt;修改ref&lt;/h3&gt;
&lt;p&gt;有多个函数可以修改ref的值，它们的区别是在于性能方面。&lt;/p&gt;
&lt;h3 id="shi-wu"&gt;事务&lt;/h3&gt;
&lt;p&gt;Clojure的事务与数据库事务类似。同一事务中的修改操作是在同一时刻原子性地提交的。ref的值的一致性是有保证的。&lt;/p&gt;
&lt;p&gt;事务也是隔离的，没有事务能看到其它事务正在运行时的值。事务开始时，它获取所有参与事务的ref的值的快照。随后在事务之外对些值的修改也不会被事务中的代码看到，就好像事务中的进行的修改对于外部的世界完全不可见，直到它完成和提交。当然，事务中进行的修改对于同一事务中的其它代码是可见的。对一个处于事务中的ref进行取值时返回的总是ref的&amp;ldquo;in-transaction&amp;rdquo;（从下面的章节看，这个值应该是初次进入事务时的快照值）值，which reflects any updates that have been made since the beginning of the transaction。（前面这句不懂，难道是指能获取到事务中已经修改，但还未提交的值？这样就没达到隔离效果啊？）&lt;/p&gt;
&lt;p&gt;对于嵌套事务。内部的事务只是简单的变成外面事务的一部分，只到外面的事务提交了整个事务才提交。&lt;/p&gt;
&lt;p&gt;Clojure中的事务是采用的乐观锁。这意味着事务不会等侍其它事务执行完才开始。事务永远不会在等侍另一个更新时阻塞线程。当一个事务发现状态已经被另一个事务修改时，事务将被重试，它重新获取到新的值的快照并重新运行自己。由系统来确定提交的顺序，它保证不管对ref有多少个争用都会执行完。&lt;/p&gt;
&lt;p&gt;高并发的情况下将可能导致STM系统产生非常多的重试并导致它变慢。但是多数发问下它都比使用锁要快。在最坏的情况下设计完美的锁系统可能会比STM要快，但是Clojure还是认为STM所带来的认知负担的减轻和简单化的方案仍然是值得的。&lt;/p&gt;
&lt;p&gt;很多人可能会认为STM会带来内存管理和垃圾收集方面的问题：但是多数情况下它还是表现得足够快。&lt;/p&gt;
&lt;h3 id="geng-xin-refde-gong-ju"&gt;更新ref的工具&lt;/h3&gt;
&lt;p&gt;最重要的是dosync宏，它初始化事务并接收任意数量的forms。事务中的form被依次执行。最后一个form的值被作为事务提交后的返回值。如果任何一个form发生异常则整个事务终止且不会被提交。&lt;/p&gt;
&lt;p&gt;在dosync中使用ref-set来修改ref的状态。&lt;/p&gt;
&lt;p&gt;另一个修改ref的函数是alter。它接收一个ref和一个函数和任意数量的参数。传给alter的函数要注意，因为它有可能会在事务重试时多次被执行。&lt;/p&gt;
&lt;p&gt;最后一个函数是commute。它与alter用法类似，但有一个区别：在竟争性事务中，它也会重启整个事务，但它将会使用新值来进行重试，而不是使用in-transaction（in-transaction应该是表示初次执行事务时得到的快照）值。这意味着commute操作产生的争议会更少，在高竟态情况下能得到更好的性能。&lt;/p&gt;
&lt;p&gt;这也意味着commute操作并不能完美的支持事务隔离。如果传递给commute的函数逻辑上或者在数学上是交替的，那将不会有区别。&lt;/p&gt;
&lt;p&gt;交替函数是那些可能按任意顺序来调用而不会影响最终结果的函数&lt;/p&gt;
&lt;p&gt;还有另一个用于操作ref的函数：ensure。它接收单个参数，一个ref。与其它ref函数类似，它也只能用于事务中。与其它ref函数不同的是，它并不实际修改ref。它所做的是在事务中ref被修改则强制事务重试。当然，你将不会在事务中看到这种修改，因为事务的隔离性。但是，如果你不在事务中修改ref，则这个ref将不会被包含在最终提交的一致性保证中（我的理解是如果你在事务中不修改某个ref，则这个ref可以被其它事务所修改，从而触发ensure）。如果在一个事务之后基于coordination的原因你想要确保一个ref在你没有修改时不允许被更新，则可以在事务中使用ensure。&lt;/p&gt;
&lt;h2&gt;Atom&lt;/h2&gt;
&lt;p&gt;它是Clojure中的实现同步修改uncoordinated identities的实现。Atoms是基于java.util.concurrent.atomic中的Java类的。它提供了一种原子性的修改值的方法而不会被发生竞争条件下影响值修改的机制。但是与Java中的atomic包不同，Clojure中的atom是无锁的。读取atom是不会被阻塞的，而对atom的更新将会在atom正在进行更新操作之后重试，与ref类似。&lt;/p&gt;
&lt;p&gt;实际上，atom与ref是类似的，只是它不需要与其它ref协调工作，因此不需要特殊的事务处理。&lt;/p&gt;
&lt;h3 id="he-shi-shi-yong-atom"&gt;何时使用atom&lt;/h3&gt;
&lt;p&gt;对于独立的identity操作，它是最正确的选择。它是最轻量级的identity类型。&lt;/p&gt;
&lt;h2&gt;用于异步处理的agent&lt;/h2&gt;
&lt;p&gt;Agents是Clojure中独有的强大功能。对它的值的修改由专用的独立的由系统管理的线程池来异步的管理。&lt;/p&gt;
&lt;p&gt;这意味着agent不只是一种在并发环境下存储和管理状态的手仙，它也是一种在程序中引入并发的工具。使用agent时，不需要手工产生线程，管理线程池或者用其它方法显式地来进行并发编程。&lt;/p&gt;
&lt;h3 id="chuang-jian-he-shi-yong-agent"&gt;创建和使用agent&lt;/h3&gt;
&lt;p&gt;通过send或send-off向agent发送一个action函数来修改agent的值。&lt;/p&gt;
&lt;p&gt;send-off与send有完全相同的签名。唯一不同的是这两个函数会导致不同的性能表现。send用于CPU密集型的操作，而send-off用于会进行IO阻塞的耗时的操作。&lt;/p&gt;
&lt;h3 id="geng-xin-de-yu-yi"&gt;更新的语义&lt;/h3&gt;
&lt;p&gt;尽管agent不保证何时会执行更新，但是我们仍然可以使用下面的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传递给各个agent的actions是串行执行的，而不是并发的。在竟争条件下发送给同一agent的更新操作不会互相覆盖。&lt;/li&gt;
&lt;li&gt;由同一线程发送给同一agent的多个actions将会按发送的顺序被执行。但是对于由不同线程所发送的action则没有这种保证。&lt;/li&gt;
&lt;li&gt;如果一个action函数中包含了向其它agent或者自己发送action的代码。则这些agent具体发送会发生在action函数返回agent值已经被修改之后。这允许action触发其它action而不产生更新冲突。&lt;/li&gt;
&lt;li&gt;如果一个对agent发送的更新操作发生在STM事务之中，则发送动作在事务提交之前不会产生。这意味着在STM事务中可以安全将动作发送给atom（这里为什么是atom呢？）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="agentde-cuo-wu-chu-li"&gt;Agent的错误处理&lt;/h3&gt;
&lt;p&gt;由于action是在独立线程中异步执行的，因此需要一个特殊的错误处理机制。&lt;/p&gt;
&lt;p&gt;Agent有两种可能的失败处理模型:fail或者:continue。如果是:continue，则在调用错误处理函数之后，action会继续执行就像action导致的异常从来没发生过。如果是:fail，则agent会牌failed状态，并且不会再接收其它的action，直到它被重启（仍然会保留当前的action队列）。&lt;/p&gt;
&lt;p&gt;通常agent会使用:continue模式，并且带有错误处理函数。否则就是默认的:fail模式。&lt;/p&gt;
&lt;h3 id="chu-li-agentde-failedzhuang-tai"&gt;处理Agent的failed状态&lt;/h3&gt;
&lt;p&gt;restart-agent&lt;/p&gt;
&lt;h3 id="deng-shi-agent"&gt;等侍agent&lt;/h3&gt;
&lt;p&gt;尽管agent是异步处理的，但是有时仍然可能需要等侍某个agent更新结果。可以用await和await-for来等侍agent的操作。&lt;/p&gt;
&lt;h3 id="guan-bi-agent"&gt;关闭agent&lt;/h3&gt;
&lt;p&gt;shutdown-agents应该在应用程序关闭之前执行，因为在这之后，所有send和send-off都将导致异常。&lt;/p&gt;</content><category term="clojure"></category></entry><entry><title>Practical Common Lisp笔记</title><link href="/practical-common-lispbi-ji.html" rel="alternate"></link><published>2011-06-03T00:00:00+08:00</published><updated>2011-06-03T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2011-06-03:/practical-common-lispbi-ji.html</id><summary type="html">&lt;h1&gt;环境搭建&lt;/h1&gt;
&lt;p&gt;尝试了多种common lisp的实现，在windows下使用Lispbox时并不能使用slime。而gnu common lisp和ansi common lisp好像也不能在windows中与emacs 23和slime一起工作。结果发现只有gnu clisp的win32版本可以与win32 slime emacs23配合工作。emacs23的.emacs文件如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-to-list&lt;/span&gt; &lt;span class="ss"&gt;'load-path&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nv"&gt;site-lisp-path&lt;/span&gt; &lt;span class="s"&gt;"/slime"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;;;(setq inferior-lisp-program "D:\\GCL-2.6.1\\bin\\gcl.bat") ; your Lisp system&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;inferior-lisp-program&lt;/span&gt; &lt;span class="s"&gt;"D:/clisp-2.46/clisp.exe"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="ss"&gt;'slime&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;slime-setup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Introduction Why Lisp?&lt;/h1&gt;
&lt;h1&gt;Lather, Rinse, Repeat: A …&lt;/h1&gt;</summary><content type="html">&lt;h1&gt;环境搭建&lt;/h1&gt;
&lt;p&gt;尝试了多种common lisp的实现，在windows下使用Lispbox时并不能使用slime。而gnu common lisp和ansi common lisp好像也不能在windows中与emacs 23和slime一起工作。结果发现只有gnu clisp的win32版本可以与win32 slime emacs23配合工作。emacs23的.emacs文件如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-to-list&lt;/span&gt; &lt;span class="ss"&gt;'load-path&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nv"&gt;site-lisp-path&lt;/span&gt; &lt;span class="s"&gt;"/slime"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;;;(setq inferior-lisp-program "D:\\GCL-2.6.1\\bin\\gcl.bat") ; your Lisp system&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;inferior-lisp-program&lt;/span&gt; &lt;span class="s"&gt;"D:/clisp-2.46/clisp.exe"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="ss"&gt;'slime&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;slime-setup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Introduction Why Lisp?&lt;/h1&gt;
&lt;h1&gt;Lather, Rinse, Repeat: A Tour of the REPL&lt;/h1&gt;
&lt;p&gt;使用SLIME来编辑Lisp程序。&lt;/p&gt;
&lt;h2&gt;选择一个Lisp实现&lt;/h2&gt;
&lt;p&gt;与其它语言同Common Lisp是通过规范定义的不只有一个实现。&lt;/p&gt;
&lt;p&gt;使用标准的Common Lisp可以获得较好的通用性，可以在不同的实现上运行。&lt;/p&gt;
&lt;p&gt;某些Common Lisp实现针对特定的方面有所增强，可以根据需要来选择。&lt;/p&gt;
&lt;p&gt;在不同的平台上可以选择不同的实现Franz开发的Allegro Common Lisp在Linux，Windows和OS X上都有试用版本。SBCL是一个高质量的开源实现，它可以在多种Unix系统，包括Linux和OS X上将代码编译为本机代码执行。SBCL是从CMUCL派生出来的，CMUCL是Carnegie Mellon University开发的。CMUCL自身也是另一个较好选择，SBCL易于安装，运行21-bit Unicode。对于OS X用户，OpenMCL是一个优秀的选择&amp;mdash;&amp;mdash;它编译为本机代码，支持线程，并且与OS X的Carbon和Cocoa工具包集成得很好。&lt;/p&gt;
&lt;p&gt;书中所有代码应该都能运行于任何Common Lisp实现，SLIME也将消除不同实现间的差异以提供一个公共的Lisp界面。书中的例子的输出来自于运行在GNU/Linux上的Allegro；某些情况可能会产生一些不同的的错误或调试信息。&lt;/p&gt;
&lt;h2&gt;Lisp in a Box&lt;/h2&gt;
&lt;p&gt;Lisp in a Box包用于提供给初学者使用。它使用Emacs作为编辑器。&lt;/p&gt;
&lt;p&gt;在SLIME中可以使用C-c C-z切换到与Lisp解释器交互的缓冲区。&lt;/p&gt;
&lt;h2&gt;交互式的编程&lt;/h2&gt;
&lt;p&gt;REPL是read-eval-print loop的简写。&lt;/p&gt;
&lt;h2&gt;Lisp风格的"Hello, World"&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; "hello, world"
"hello, world"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lisp读取双引号中的字符串，求值时它显示同样的格式的字符串。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (format t "hello, world")
hello, world
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FORMAT可带多个参数，但只有两个是必须的，分别是发送的目标和一个字符串。NIL表示FORMAT的返回值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (defun hello-world () (format t "hello, world"))
HELLO-WORLD
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DEFUN后的hello-world是函数名称。Common Lisp中符号名称使用-是合法的。&lt;/p&gt;
&lt;h2&gt;保存代码&lt;/h2&gt;
&lt;p&gt;SLIME REPL中可以使用C-c C-l调用slime-load-file，或者在REPL中用(load "file.lisp")加载文件中的代码。C-c C-z在SLIME中切换到REPL中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (load (compile-file "hello.lisp"))
;;; Compiling file hello.lisp
;;; Writing fasl file hello.fasl
;;; Fasl write complete
; Fast loading /home/peter/my-lisp-programs/hello.fasl
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加载文件之前也可以使用COMPILE-FILE将文件转换为FASL（fast-load file的简称）文件，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (load (compile-file "hello.lisp"))
;;; Compiling file hello.lisp
;;; Writing fasl file hello.fasl
;;; Fasl write complete
; Fast loading /home/peter/my-lisp-programs/hello.fasl
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这种方式并不一定会加快加载的速度，因为有些Common Lisp实现总是会自动编译文件。可以在SLIME中输入C-c C-k将当前缓冲区对应的文件编译为FASL文件将重新加载。&lt;/p&gt;
&lt;p&gt;在修改的函数上按C-c C-c重新编译函数定义将会立即反应到REPL中。&lt;/p&gt;
&lt;h1&gt;实践：一个简单的数据库&lt;/h1&gt;
&lt;p&gt;本章将逐渐创建一个CD数据库。&lt;/p&gt;
&lt;h2&gt;CD和记录集&lt;/h2&gt;
&lt;p&gt;为保存单张CD记录我们需要将它描述为一条数据库记录。Common Lisp提供了许多保存结构化数据的选择。&lt;/p&gt;
&lt;p&gt;使用LIST函数创建一个list。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (list 1 2 3)
(1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种list叫作property list，简称为plist。用plist保存CD记录更合适一些。plist中的元素以一个symbol开头，这个symbol描述了list中的下一个元素（这里不讨论什么是symbol，根本上来说它是一个名称）。使用symbol来以CD数据库中的字段命名，这里可以使用一种特殊的symbol，这种symbol被称为keyword symbol。keyword是以冒号开头的名称，例如，:foo。下面是一个以keyword symbol作为plist的property name的list：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (list :a 1 :b 2 :c 3)
(:A 1 :B 2 :C 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建plist时也是使用LIST函数。&lt;/p&gt;
&lt;p&gt;使得plist更适合于描述数据库记录的是GETF函数，这个函数接收一个plist和symbol，返回plist中这个symbol后面值，这使得plist像类种贫血的hash table。Lisp有真正hash table，但是plist在这里已经够用了并且它易于保存于文件中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (getf (list :a 1 :b 2 :c 3) :a)
1
CL-USER&amp;gt; (getf (list :a 1 :b 2 :c 3) :c)
3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以编写一个函数make-cd来接收四个参数并返回一个plist来描述CD了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun make-cd (title artist rating ripped)
  (list :title title :artist artist :rating rating :ripped ripped))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DEFUN关键字告诉我们这个form正在定义一个新的函数。函数名是make-cd。函数名后是参数列表。这个函数有四个参数。参数列表后面函数体。这个函数的使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (make-cd "Roses" "Kathy Mattea" 7 t)
(:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;整理CD&lt;/h2&gt;
&lt;p&gt;单个记录还不能构成数据库。因此需要一些大型的结构来保存记录集。list看起来仍然是不错的选择。这里使用DEFVAR宏定义全局变量&lt;em&gt;db&lt;/em&gt;。星号在Lisp命名约定中表示全局变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defvar *db* nil)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用PUSH宏向&lt;em&gt;db&lt;/em&gt;中添加项。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun add-record (cd) (push cd *db*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以结合使用add-record和make-cd来将CD添加到数据库。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (add-record (make-cd "Roses" "Kathy Mattea" 7 t))
((:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))
CL-USER&amp;gt; (add-record (make-cd "Fly" "Dixie Chicks" 8 t))
((:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
 (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))
CL-USER&amp;gt; (add-record (make-cd "Home" "Dixie Chicks" 9 t))
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
 (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在REPL中将显示每次添加新记录后的返回值。&lt;/p&gt;
&lt;h2&gt;查看数据库内容&lt;/h2&gt;
&lt;p&gt;虽然可以在REPL中输入&lt;em&gt;db&lt;/em&gt;查看&lt;em&gt;db&lt;/em&gt;的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; *db*
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
 (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 7 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但更好的办法是写一个dump-db函数以便于阅读的格式显示出数据库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TITLE&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;Home&lt;/span&gt;
&lt;span class="n"&gt;ARTIST&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;Dixie&lt;/span&gt; &lt;span class="n"&gt;Chicks&lt;/span&gt;
&lt;span class="n"&gt;RATING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;9&lt;/span&gt;
&lt;span class="n"&gt;RIPPED&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;T&lt;/span&gt;

&lt;span class="n"&gt;TITLE&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;Fly&lt;/span&gt;
&lt;span class="n"&gt;ARTIST&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;Dixie&lt;/span&gt; &lt;span class="n"&gt;Chicks&lt;/span&gt;
&lt;span class="n"&gt;RATING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;8&lt;/span&gt;
&lt;span class="n"&gt;RIPPED&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;T&lt;/span&gt;

&lt;span class="n"&gt;TITLE&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;Roses&lt;/span&gt;
&lt;span class="n"&gt;ARTIST&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;Kathy&lt;/span&gt; &lt;span class="n"&gt;Mattea&lt;/span&gt;
&lt;span class="n"&gt;RATING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;RIPPED&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;T&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun dump-db ()
  (dolist (cd *db*)
    (format t "~{~a:~10t~a~%~}~%" cd)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数使用DOLIST宏遍历&lt;em&gt;db&lt;/em&gt;中的元素，将每个元素依次绑定到变量cd。并使用FORMAT函数打印cd。&lt;/p&gt;
&lt;p&gt;FORMAT接收至少两个参数，第一个是它要输出的流；t是&lt;em&gt;standard-output&lt;/em&gt;的简写形式。&lt;/p&gt;
&lt;p&gt;第二个参数是一个格式字符串，它包含纯文本和告诉FORMAT函数如何显示其它参数的转义字符。转义字符以~开头（与printf中的%类似）。FORMAT函数有许多的转义字符。在这里只了解编写dump-db需要的转义符。&lt;/p&gt;
&lt;p&gt;~a是一个美化转义符；它消耗掉一个参数并将它以便于阅读的形式输出。这将使输出不包含:和引号。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (format t "~a" "Dixie Chicks")
Dixie Chicks
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (format t "~a" :title)
TITLE
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;~t转义符表示缩进。~10t告诉FORMAT在处理下一个~a前缩进足够的空间到第10列。另外，~t不消耗任何参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (format t "~a:~10t~a" :artist "Dixie Chicks")
ARTIST:   Dixie Chicks
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当FORMAT遇到~{时下个被消耗的参数必须是一个list。FORMAT将遍历这个list，以~{和~}间的转义符处理list中的每个元素。~%转义符不消耗任何参数但它使得FORMAT进行换行。~}之前的那个~%在输出数据库的一个字段后换行。~}之后的那个~%在输出一条记录后换行。&lt;/p&gt;
&lt;p&gt;技术上来说，可以让FORMAT自己来遍历数据库，将dump-db函数写为一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun dump-db ()
  (format t "~{~{~a:~10t~a~%~}~%~}" *db*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常cool。&lt;/p&gt;
&lt;h2&gt;改进用户交互&lt;/h2&gt;
&lt;p&gt;在用户需要添加很多记录时将需要提示帮助用户录入CD。因此需要一些提示用户输入并读入输出的方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun prompt-read (prompt)
  (format *query-io* "~a: " prompt)
  (force-output *query-io*)
  (read-line *query-io*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用FORMAT提示输入。调用FORCE-OUTPUT确保提示显示出来。&lt;/p&gt;
&lt;p&gt;使用READ-LINE函数读取单行文本。&lt;em&gt;query-io&lt;/em&gt;是一个全局变量，它包含连接的终端的输入。prompt-read的返回值是最后一个form的值，READ-LINE返回读取的字符串（不包含换行符）。&lt;/p&gt;
&lt;p&gt;可以结合make-cd和prompt-read构建一个函数根据输入来构建一个新的CD记录。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun prompt-for-cd ()
  (make-cd
   (prompt-read "Title")
   (prompt-read "Artist")
   (prompt-read "Rating")
   (prompt-read "Ripped [y/n]")))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有两个问题，Rating和Ripped字符，应该分别是number和boolean型。在这里我们只简单的处理一下：以PARSE-INTEGER函数处理rating：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(parse-integer (prompt-read "Rating"))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PARSE-INTEGER在将字符串解析为integer失败时出错。它有一个可选参数:junk-allowed，它不会出错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(parse-integer (prompt-read "Rating") :junk-allowed t)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但仍然有一个问题：如果它不仍不能解析，PARSE-INTEGER将返回NIL而不是一个number。在这里我们简单的将它处理为0并继续执行程序。Lisp的OR宏可以处理个，这接受一连串的表达式，依次执行表达式，并返回第一个non-nil值（或NIL，如果它们全为NIL）。因此你可以使用下面的表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置默认值为0。&lt;/p&gt;
&lt;p&gt;修正Ripped则简单一些。可以使用Common Lisp函数Y-OR-N-P。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(y-or-n-p "Ripped [y/n]: ")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上，这将是prompt-for-cd中最健壮的部分，如果用户的输入是心y，Y，n或N开头Y-OR-N-P将一直提示用户。&lt;/p&gt;
&lt;p&gt;完整的prompt-for-cd函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun prompt-for-cd ()
  (make-cd
   (prompt-read "Title")
   (prompt-read "Artist")
   (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
   (y-or-n-p "Ripped [y/n]: ")))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，可以用循环将prompt-for-cd函数包装起来，反复提示用户录入CD。这可以通过使用LOOP宏，它重复执行它的body表达式，直到它使用RETURN退出。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun add-cds ()
  (loop (add-record (prompt-for-cd))
      (if (not (y-or-n-p "Another? [y/n]: ")) (return))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以使用add-cds添加更多的CD到数据库了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (add-cds)
Title: Rockin' the Suburbs
Artist: Ben Folds
Rating: 6
Ripped  [y/n]: y
Another?  [y/n]: y
Title: Give Us a Break
Artist: Limpopo
Rating: 10
Ripped  [y/n]: y
Another?  [y/n]: y
Title: Lyle Lovett
Artist: Lyle Lovett
Rating: 9
Ripped  [y/n]: y
Another?  [y/n]: n
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;保存和装载数据库&lt;/h2&gt;
&lt;p&gt;保存数据库save-db函数接收一个文件名作为参数并保存当前的数据库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun save-db (filename)
  (with-open-file (out filename
                   :direction :output
                   :if-exists :supersede)
    (with-standard-io-syntax
      (print *db* out))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WITH-OPEN-FILE宏打开一个文件，将流绑定到一个变量，执行一组表达式，并关闭文件。它将确保文件被关闭，即使在执行它的body过程中出现了错误。WITH-OPEN-FILE后面list不是一个函数调用而是WITH-OPEN-FILE定义的语法的一部分。它包含了保存文件流的变量名，它用于在WITH-OPEN-FILE的body中进行写入操作；还有文件名和一些控制如何打开文件的选项。比如用于指定以写入方式打开文件的选项:direction :output和用于覆盖已经存在的文件的选项:if-exists :supersede。&lt;/p&gt;
&lt;p&gt;打开文件后，只需使用&lt;code&gt;(print *db* out)&lt;/code&gt;要将内容print到数据库。与FORMAT不同的是PRINT输出的Lisp对象可以被Lisp reader读取为Lisp对象。宏WITH-STANDARD-IO-SYNTAX确保某些变量的值，这使得PRINT的行为表现为标准的状态。在将数据读取回来时为保证Lisp reader和printer的操作的兼容将需要使用相同的宏。&lt;/p&gt;
&lt;p&gt;save-db的参数是一个包含了要保存数据库的文件名。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (save-db "~/my-cds.db")
((:TITLE "Lyle Lovett" :ARTIST "Lyle Lovett" :RATING 9 :RIPPED T)
 (:TITLE "Give Us a Break" :ARTIST "Limpopo" :RATING 10 :RIPPED T)
 (:TITLE "Rockin' the Suburbs" :ARTIST "Ben Folds" :RATING 6 :RIPPED
  T)
 (:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T)
 (:TITLE "Roses" :ARTIST "Kathy Mattea" :RATING 9 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读取数据库的函数与写入的函数是相类似的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun load-db (filename)
  (with-open-file (in filename)
    (with-standard-io-syntax
      (setf *db* (read in)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里在没有在WITH-OPEN-FILE中指定:direction选项，因为它的默认值就是:input。这里的READ函数用于从流in中读取。这个reader与REPL中使用的reader是相同的可以读取任何能在REPL中使用的Lisp表达式。但是在这个函数里只是读取和保存表达式，并没有对它求值。通过使用WITH-STANDARD-IO-SYNTAX宏确保了READ使用与save-db中的PRINT相同的规则来读取。&lt;/p&gt;
&lt;p&gt;SETF宏是Common Lisp中主要的赋值操作符。它设置它的第一个参数为第二个参数的求值结果。因此，load-db的&lt;code&gt;*db*&lt;/code&gt;变量将包含从文件中读取的对象，即由save-db写入的由list构成的多个list。&lt;/p&gt;
&lt;h2&gt;查询数据库&lt;/h2&gt;
&lt;p&gt;在有了用于添加数据的UI界面和保存、装载数据的功能后。你将需要一个查询数据库的方法。例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(select :artist "Dixie Chicks")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以获取artist为Dixie Chicks的记录的list。&lt;/p&gt;
&lt;p&gt;函数REMOVE-IF-NOT以predicate和list为参数返回list中与predicate匹配的元素的list。REMOVE-IF-NOT并不从list中删除元素而是创建一个新的list，原始的list并不会被改变。predicate参数可以是任何接收单个参数并返回boolean值（NIL为false，其它值为true）的函数。&lt;/p&gt;
&lt;p&gt;例如，提取list中的偶数元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (remove-if-not #'evenp '(1 2 3 4 5 6 7 8 9 10))
(2 4 6 8 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里predicate是函数EVENP，如果它的参数为偶数则返回true。#'标记的含义是&amp;ldquo;获取后面名称的函数&amp;rdquo;。如果没有#'，Lisp会将evenp变量名并查找这个变量的值，而不会把evenp函数。&lt;/p&gt;
&lt;p&gt;另外，也可以向REMOVE-IF-NOT函数传递匿名函数。比如，如果EVENP不存在，你可以将前面的表达式修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (remove-if-not #'(lambda (x) (= 0 (mod x 2))) '(1 2 3 4 5 6 7 8 9 10))
(2 4 6 8 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LAMBDA表达式看起来有点像一个DEFUN语句：关键字lambda后面跟参数列表，然后是函数体。&lt;/p&gt;
&lt;p&gt;为了使用REMOVE-IF-NOT函数从数据库中查找记录，还需要一个函数来检查记录的artist字段是否为&amp;ldquo;Dixie Chicks&amp;rdquo;。我们可以使用GETF从plist中获取特定的字段。使用EQUAL检查字符串是否相等。因此，&lt;code&gt;(equal (getf cd :artist) "Dixie Chicks")&lt;/code&gt;可以测试CD的artist字段是否为&amp;ldquo;Dixie Chicks&amp;rdquo;。现在只需要将这个表达式封装为lambda表达式并传递给REMOVE-IF-NOT。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (remove-if-not
  #'(lambda (cd) (equal (getf cd :artist) "Dixie Chicks")) *db*)
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将整个表达式封装到函数中，这个函数只需要artist参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun select-by-artist (artist)
  (remove-if-not
   #'(lambda (cd) (equal (getf cd :artist) artist))
   *db*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意匿名函数，它包含的代码只有在REMOVE-IF-NOT中被调用时才会运行，它能够访问artist变量。在这里，匿名函数不仅使得避免了编写正式的函数，也使得你编写的函数只在它所嵌入的上下文中才有含义。&lt;/p&gt;
&lt;p&gt;现在select-by-artist已经完成了。但通过artist查询只是你需要的查询方式中的一种。可以编写select-by-title，select-by-rating，select-by-title-and-artis，等等。但它们除了匿名函数外基本是相同的。我们可以写一个更通用的以一个函数为参数的select函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun select (selector-fn)
  (remove-if-not selector-fn *db*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里不需要#'。因为这里的REMOVE-IF-NOT需要使用selector-fn函数。这里需要使用匿名函数作为参数。因此，#'重新出现在对select的调用中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (select #'(lambda (cd) (equal (getf cd :artist) "Dixie Chicks")))
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这看起来仍然不美观。我们可以将匿名函数的创建封装起来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun artist-selector (artist)
  #'(lambda (cd) (equal (getf cd :artist) artist)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数返回一个指向函数的变量。对于不同的artist参数这个函数将返回不同的函数来匹配不同的artist。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (select (artist-selector "Dixie Chicks"))
((:TITLE "Home" :ARTIST "Dixie Chicks" :RATING 9 :RIPPED T)
 (:TITLE "Fly" :ARTIST "Dixie Chicks" :RATING 8 :RIPPED T))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们需要更多的函数来生成选择器函数。但这又将导致重复代码的产生，并且它们不能处理组合查询条件。我们需要一个函数根据字段或多个字段生成选择器函数。为实现这个目标，我们需要先了解keyword parameter。&lt;/p&gt;
&lt;p&gt;通常的函数结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (a b c) (list a b c))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它包含了一个参数列表。有时我们需要编写的函数支持可变数量的参数。Keyword parameter就是用于这个目的的。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (&amp;amp;key a b c) (list a b c))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与上一个例子不同之处在于&amp;amp;key。但是，在调用方式上却有些不同。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo :a 1 :b 2 :c 3)  ==&amp;gt; (1 2 3)
(foo :c 3 :b 2 :a 1)  ==&amp;gt; (1 2 3)
(foo :a 1 :c 3)       ==&amp;gt; (1 NIL 3)
(foo)                 ==&amp;gt; (NIL NIL NIL)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在面的代码中，传了值的将被绑定到对应的参数上，未传递的值为NIL。为了区分NIL值是传递过来的参数值还是由于没有传递参数而产生的默认NIL值，我们可以使用另一个称为supplied-p的参数。根据keyword parameter是否显式的传递了参数，suupplied-p参数将被设置为true或false。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (&amp;amp;key a (b 20) (c 30 c-p)) (list a b c c-p))
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo :a 1 :b 2 :c 3)  ==&amp;gt; (1 2 3 T)
(foo :c 3 :b 2 :a 1)  ==&amp;gt; (1 2 3 T)
(foo :a 1 :c 3)       ==&amp;gt; (1 20 3 T)
(foo)                 ==&amp;gt; (NIL 20 30 NIL)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回到上面通用选择器函数生成器的问题，我们可以像使用SQL数据库一样来使用select：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(select (where :artist "Dixie Chicks"))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(select (where :rating 10 :ripped nil))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun where (&amp;amp;key title artist rating (ripped nil ripped-p))
  #'(lambda (cd)
      (and
       (if title    (equal (getf cd :title)  title)  t)
       (if artist   (equal (getf cd :artist) artist) t)
       (if rating   (equal (getf cd :rating) rating) t)
       (if ripped-p (equal (getf cd :ripped) ripped) t))))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;更新数据库记录&amp;mdash;&amp;mdash;再次使用WHERE&lt;/h2&gt;
&lt;p&gt;更新函数的原理：使用传入的选择器函数选出需要修改的数据库记录并使用keyword arguments指定要修改的值。主要不同的一点在于使用MAPCAR来操作list，并返回一个新的包含调用结构的list。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun update (selector-fn &amp;amp;key title artist rating (ripped nil ripped-p))
  (setf *db*
        (mapcar
         #'(lambda (row)
             (when (funcall selector-fn row)
               (if title    (setf (getf row :title) title))
               (if artist   (setf (getf row :artist) artist))
               (if rating   (setf (getf row :rating) rating))
               (if ripped-p (setf (getf row :ripped) ripped)))
             row) *db*)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里另一个不同之处在于将SETF用于了一个复杂的form，如(getf row :title)。后面将详细讨论SETF，这里只需要知道它是一个通用赋值操作符可以用于很多情况而不只是变量。这里在执行(setf (getf row :title) title)后，row变量保存的plist的:title属性值将被设置为title变量的值。&lt;/p&gt;
&lt;p&gt;更新函数的使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (update (where :artist "Dixie Chicks") :rating 11)
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们甚至可以为数据库添加一个简单的delete函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun delete-rows (selector-fn)
  (setf *db* (remove-if selector-fn *db*)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;REMOVE-IF与REMOVE-IF-NOT相反；它返回的list中，在原始list中与selector-fn匹配的元素已经被删除了。&lt;/p&gt;
&lt;h2&gt;移除重复代码获取更大胜利&lt;/h2&gt;
&lt;p&gt;到现在数据库已经支持insert，select，update和delete，并且还有一个用户界面供添加新记录，支持保存到文件和从文件加载。&lt;/p&gt;
&lt;p&gt;但是仍然存在一些重复代码。重复代码存在于where函数中。where函数中对每个字段都编写了类似的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(if title (equal (getf cd :title) title) t)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们改变CD的字段，就需要添加或删除where条件。update中也存在着类似的重复。&lt;/p&gt;
&lt;p&gt;如果我们需要优化代码想像一下每次都检查title或其它keyword parameter是否存在是否会消耗过多的资源？你需要返回的匿名函数只执行必须的计算。例如，下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(select (where :title "Give Us a Break" :ripped t))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应该修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(select
 #'(lambda (cd)
     (and (equal (getf cd :title) "Give Us a Break")
          (equal (getf cd :ripped) t))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这里仍然只能针对特定查询。&lt;/p&gt;
&lt;p&gt;使用Lisp的macro系统能轻松的满足上面的要求。Lisp中的macro与C/C++中的macro只是使用了相同的名称其本质是不同的。C预处理器根据文本进行替换，对于C/C++结构并不了解。Lisp macro本质上是一个代码生成器，由编译自动为你运行。当Lisp表达式包含了一个macro调用时，Lisp不会对表达式求值并将它传递函数。Lisp编译器将传递未求值的参数给macro代码，它将返回新的Lisp表达式，然后在macro被调用的地方被求值。&lt;/p&gt;
&lt;p&gt;为了编写一个简单的macro示例，需要先介绍一个新函数：REVERSE它接收list为参数并返回一个新的逆序的list。(reverse '(1 2 3))求值为(3 2 1)。现在定义一个macro：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro backwards (expr) (reverse expr))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语法上来看函数和宏的定义区别在于DEFMACRO和DEFUN，后面的名称、参数列表、body表达式都与函数类似。但宏与函数是完全不同的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (backwards ("hello, world" t format))
hello, world
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的macro是如何工作的呢？当REPL开始对backwards语句求值时，它识别出backwards是一个宏的名字。因此它不对表达式("hello, world" t format)求值，这很好因为它不是一个合法Lisp form。然后它将这个list传到backwards的代码中。backwards中的代码将这个list传递给REVERSE函数，它返回新的list (format t "hello, world")。backwards将这个值返回给REPL，然后它被进行求值。&lt;/p&gt;
&lt;p&gt;backwards macro定义了一个新的语言它与Lisp类似只是逆序的。对于一个已经编译过的Lisp程序，这个新语言效率上与原始的Lisp同样有效因为所有的macro代码&amp;mdash;&amp;mdash;用于生成新表达式的代码&amp;mdash;&amp;mdash;在编译时被执行。换言之，编译器将对(backwards ("hello, world" t format))和(format t "hello, world")生成相同的代码。&lt;/p&gt;
&lt;p&gt;在数据库示例的选择器函数生成器中。我们可以编写macro来根据特殊的参数生成所需要的函数。我们手工针对某个字段的优化代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(equal (getf cd field) value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以编写一个函数，给定字段名和值，返回类似上面的表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun make-comparison-expr (field value)    ; wrong
  (list equal (list getf cd field) value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有一个问题：Lisp遇到某个名称，比如field或value它不会将它们作为list中的第一个元素，它会认为它是一个变量名并查找它的值。这对于field和value不会有问题。但是你应该知道如何阻止Lisp进行求值：在名称前添加单引号（'）。因些，如下编写make-comparison-expr将是需要的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun make-comparison-expr (field value)
  (list 'equal (list 'getf 'cd field) value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有一个更好的方法来完成上面的函数。使用反单引号（`）使得列表中只有少数表达式被求值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; `(1 2 3)
(1 2 3)
CL-USER&amp;gt; '(1 2 3)
(1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过在前面添加逗号（,）对表达式进行求值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;`(1 2 (+ 1 2))        ==&amp;gt; (1 2 (+ 1 2))
`(1 2 ,(+ 1 2))       ==&amp;gt; (1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用反单引号可以将make-comparison-expr编写为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun make-comparison-expr (field value)
  `(equal (getf cd ,field) ,value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面的手工编写的选择器函数使用AND表达式将多个field/value封装。在这里可以将参数组织为where macro的一个参数，这个参数只是一个list。我们还需要一个函数从list中获取成对的参数并在每对参数上调用make-comparison-expr。为了实现个功能，我们可以使用LOOP macro。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun make-comparisons-list (fields)
  (loop while fields
     collecting (make-comparison-expr (pop fields) (pop fields))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面将详细讨论LOOP。这里只需要知道：如果list中还有元素它将一直循环，在每个周期中将popping两将并将值传递给make-comparison-expr，将结果收集起来直到循环结束后作为返回值。POP macro执行与PUSH macro相反的操作。&lt;/p&gt;
&lt;p&gt;现在只需要将make-comparison-list的结果用AND封装到匿名函数中，这可以在where macro中定义。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro where (&amp;amp;rest clauses)
  `#'(lambda (cd) (and ,@(make-comparisons-list clauses))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在调用make-comparisons-list前使用了逗号（,）的一个变种&amp;ldquo;接合&amp;rdquo;（,@）。它将一个list连接到外部的list中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;`(and ,(list 1 2 3))   ==&amp;gt; (AND (1 2 3))
`(and ,@(list 1 2 3))  ==&amp;gt; (AND 1 2 3)
`(and ,@(list 1 2 3) 4) ==&amp;gt; (AND 1 2 3 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where macro上另一个重要的功能是在参数列表中使用了&amp;amp;rest。与&amp;amp;key类似&amp;amp;rest将修改参数的解析方式。通过在参数列表中使用&amp;amp;rest，函数或宏可以接收任意数量的参数，这些参数被收集到一个list中，它被命名为&amp;amp;rest后面名称。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(where :title "Give Us a Break" :ripped t)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;产生的变量将包含下面的list。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(:title "Give Us a Break" :ripped t)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个list被传递到make-comparisons-list中，它返回包含比较表达式的list。可以使用函数MACROEXPAND-1来查看将产生什么样的调用。如果传递给MACROEXPAND-1的form是macro，它将使用适当的参数调用macro代码并返回展开的表达式。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (macroexpand-1 '(where :title "Give Us a Break" :ripped t))
#'(LAMBDA (CD)
    (AND (EQUAL (GETF CD :TITLE) "Give Us a Break")
         (EQUAL (GETF CD :RIPPED) T)))
T
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;语法和语义&lt;/h1&gt;
&lt;h2&gt;关于括号&lt;/h2&gt;
&lt;p&gt;历史原因：当John McCarthy首次发明Lisp时，他正致力于实现个更Algol-like的语法，他称之为M-expression。但是，他从来就没有达成。&lt;/p&gt;
&lt;p&gt;Lisp使用这种语法已经超过45年了你将发现它的强大之处。&lt;/p&gt;
&lt;h2&gt;黑盒子&lt;/h2&gt;
&lt;p&gt;计算机语言处理器&amp;mdash;&amp;mdash;解释器或编译器的操作都像一个黑盒。其中有一个子系统将程序转换为abstract syntax tree然后将语法树进行解释或编译。由于语言处理器是一个黑盒，通常只有语言的实现者才感兴趣。&lt;/p&gt;
&lt;p&gt;而Common Lisp定义了两个黑盒，一个负责将文本转换为Lisp对象，另一个处理这些对象的语义。第一个黑盒称为reader，第二个称为evaluator。&lt;/p&gt;
&lt;p&gt;定义字符串如何被解释为Lisp对象的是s-expression语法，它与非Lisp语言的解析器（parser）生成的抽像语法树类似，可以描述任意的树状表达式。&lt;/p&gt;
&lt;p&gt;Lisp reader懂得s-expression的语法而Lisp evaluator懂得Lisp forms的语法。&lt;/p&gt;
&lt;h2&gt;S-expressions&lt;/h2&gt;
&lt;p&gt;由lists和atoms构成。List由括号分隔可以包含任意数量的以空白分隔的元素。Atoms是除list之外的任何东西。Lists的元素也是s-expressions（atoms或lists）。注释以分号开头直至行尾。&lt;/p&gt;
&lt;p&gt;最常用的几种atoms：数字、字符串和名字。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数字：以+或-号开头，包含.或/，或以指数标识结尾的数字序列被读取为数字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字符串：以双引号包含。内部可以有以\开头的转义字符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;名字：在Lisp程序中用于标识对象的符号。比如FORMAT、hello-world、&lt;em&gt;db&lt;/em&gt;等等。在读取名字时，reader将所有字符转换为大写。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为保证名字的唯一性，reader在读取名字并将它转为大写后将interns符号，reader从被称为package的table中查找是否存在同名的符号。如果未找到它就创建一个符，否则它将返回table中已经存在的符号。&lt;/p&gt;
&lt;h2&gt;S-expression作为Lisp Forms&lt;/h2&gt;
&lt;p&gt;最简单的Lisp forms是atoms，可以被分为两类：符号或其它。符号作为form被求值时它被当作变量名称并被求值为变量的当前值。&lt;/p&gt;
&lt;p&gt;数字和字符串被作为self-evaluating objects。&lt;/p&gt;
&lt;p&gt;符号本身也可以是self-evaluating的，它们的名字可以被赋给符号自身。&lt;/p&gt;
&lt;p&gt;另一类self-evaluating符号是keyword symbols&amp;mdash;&amp;mdash;以:开头的符号。&lt;/p&gt;
&lt;h2&gt;函数调用&lt;/h2&gt;
&lt;p&gt;函数调用forms的规则很简单：将list的剩余的元素作为Lisp forms进行求值并将结果传递给函数。&lt;/p&gt;
&lt;h2&gt;特殊操作符&lt;/h2&gt;
&lt;p&gt;当list中的第一个元素是一个特殊操作符时，表达式中的其它元素的求值是按这个操作符的规定来进行求值的。&lt;/p&gt;
&lt;h2&gt;宏&lt;/h2&gt;
&lt;p&gt;宏是一个接收s-expression作为参数并返回Lisp form然后对form求值的函数。求值过程分为两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;macro的form不会被求值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;macro函数返回的form（称为macro的expansion）将被按普通的求值规则被求值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;真值、假值和相等性&lt;/h2&gt;
&lt;p&gt;符号NIL是唯一的假值，其它为真值。符号T是经典的真值表示，用于需要返回non-NIL值时使用它。&lt;/p&gt;
&lt;p&gt;NIL的可以用nil,(),'nil,'()来表示。&lt;/p&gt;
&lt;p&gt;对t和't求值都将得到符号T。&lt;/p&gt;
&lt;p&gt;当使用&amp;ldquo;相同&amp;rdquo;这个词时它表示两个值是&amp;ldquo;同样的&amp;rdquo;（注：同一个东东）。&lt;/p&gt;
&lt;p&gt;四个常用的测试相等性的函数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;EQ测试两个对象的&amp;ldquo;对象标识（object identity）&amp;rdquo;是否相等，对象标识的值有可能为数字或字符，这取决于你使用的Lisp实现。因此不应该使用EQ来比较可能是number或character的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EQL的行为类似EQ但它会对比参数是否为同样的类型并表达同样的值。比如，(eql 1 1)为true，而(eql 1 1.0)为false，因为1.0为浮点类型，1为整型属于不同类的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EQUAL的识别宽松一些，如果被比较的对象有相同的递归结构和内容则是相等的。EQUAL将包含相同字符的字符串当作相等。对于其它类型的对象，它将使用EQL的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EQUALP比EQUAL的识别更宽松一些。它在比较字符串时将忽略大小写。比较数字时，只需要它们表述的数学值是相同的即可。因此，(equalp 1 1.0)为true。对于List和Array将使用EQUALP测试其中的元素。对于其它数据类型EQUALP将使用EQL。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Lisp代码的格式&lt;/h2&gt;
&lt;p&gt;在SLIME中将光标停留在左括号上输入C-M-q，或在函数体的任意位置输入C-c M-q可以格式化整段代码。&lt;/p&gt;
&lt;h1&gt;函数&lt;/h1&gt;
&lt;h2&gt;定义新函数&lt;/h2&gt;
&lt;p&gt;使用DEFUN宏来定义函数。DEFUN的基本框架如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun name (parameter*)
  "Optional documentation string."
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;任何符号都可以作为函数名称。通常函数名只包括字母和连字符，其它字符允许在某些约定命名情况下出现。例如，将一个类型的值转换为另一类型通常使用&lt;code&gt;-&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果函数没有参数则使用空列表&lt;code&gt;()&lt;/code&gt;。参数关键字有reqiured，optional，multiple和keyword。&lt;/p&gt;
&lt;p&gt;参数列表后面的字符串被作为文档字符串，它用于说明函数。函数定义后可以使用DOCUMENTATION函数来访问文档字符串。&lt;/p&gt;
&lt;p&gt;DEFUN的body部分可以包含任意数量的Lisp表达式。最后一个表达式的值作为函数返回值。或使用RETURN-FROM操作符立即返回。&lt;/p&gt;
&lt;h2&gt;函数参数列表&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;&amp;amp;optional&lt;/code&gt;定义可选参数列表，下面的函数可以接收2-4个参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo(a b &amp;amp;optional c d) (list a b c d))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未传递参数时可选参数为Nil。&lt;/p&gt;
&lt;p&gt;可以指定可选参数的默认值和传值标识。下面的函数中参数c的默认值为3，可以使用c-supplied-p来检查是否传递了c参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (a b &amp;amp;optional (c 3 c-supplied-p))
  (list a b c c-supplied-p))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;&amp;amp;rest&lt;/code&gt;定义可变长度参数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun format (stream string &amp;amp;rest values) ...)
(defun + (&amp;amp;rest numbers) ...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;&amp;amp;key&lt;/code&gt;定义关键字参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (&amp;amp;key a b c) (list a b c))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用时使用符号指定要设置的参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo)                ==&amp;gt; (NIL NIL NIL)
(foo :a 1)           ==&amp;gt; (1 NIL NIL)
(foo :b 1)           ==&amp;gt; (NIL 1 NIL)
(foo :c 1)           ==&amp;gt; (NIL NIL 1)
(foo :a 1 :c 3)      ==&amp;gt; (1 NIL 3)
(foo :a 1 :b 2 :c 3) ==&amp;gt; (1 2 3)
(foo :a 1 :c 3 :b 2) ==&amp;gt; (1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关键字参数也可以指定默认值和设置supplied-p变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (&amp;amp;key (a 0) (b 0 b-supplied-p) (c (+ a b)))
  (list a b c b-supplied-p))

(foo :a 1)           ==&amp;gt; (1 0 1 NIL)
(foo :b 1)           ==&amp;gt; (0 1 1 T)
(foo :b 1 :c 4)      ==&amp;gt; (0 1 4 T)
(foo :a 2 :b 1 :c 4) ==&amp;gt; (2 1 4 T)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;组合使用不同类型的参数时要按顺序来声明：首先是必须的参数，然后是可选参数，再接下来是可变长度的参数，最后使用关键字参数。通常会使用必须参数与其它参数类型组合，或者组合使用可选参数和可变长度参数。可选参数或可变长度参数与关键字参数组合使用时可能会引起奇怪的行为。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (x &amp;amp;optional y &amp;amp;key z) (list x y z))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以这样调用它：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo 1 2 :z 3) ==&amp;gt; (1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样调用也行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo 1)  ==&amp;gt; (1 nil nil)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这样调用时就会出错&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo 1 :z 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要组合使用可选参数和关键字参数时，应该转变为只使用关键字参数。&lt;/p&gt;
&lt;p&gt;可以安全的组合使用可变参数和关键字参数，但也仍然会导致奇怪的问题。参数既会被当作可变参数也会被作为关键字参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (&amp;amp;rest rest &amp;amp;key a b c) (list rest a b c))
(foo :a 1 :b 2 :c 3) ==&amp;gt; ((:A 1 :B 2 :C 3) 1 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;函数返回值&lt;/h2&gt;
&lt;p&gt;所有函数都将最后一个表达式的值作为函数值。&lt;/p&gt;
&lt;p&gt;需要在函数中间就返回则要使用&lt;code&gt;RETURN-FROM&lt;/code&gt;操作符来立即从函数中返回值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RETURN-FROM&lt;/code&gt;其实与函数并没有任何联系；它是用于从操作符&lt;code&gt;BLOCK&lt;/code&gt;定义的代码块返回的。但是，由于&lt;code&gt;DEFUN&lt;/code&gt;会自动将整个函数体包裹为与函数名同名的代码块。因此，在函数中执行&lt;code&gt;RETURN-FROM&lt;/code&gt;也将会导致函数立即退出并返回值。&lt;code&gt;RETURN-FROM&lt;/code&gt;是一个特殊操作符，它的第一个&amp;ldquo;参数&amp;rdquo;是要返回的块名。这个名称不会被求值不需要使用引号。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;RETURN_FROM&lt;/code&gt;时的第一个参数为要返回的块名，如果修改了函数名称要记得修改这个参数。在Lisp中使用&lt;code&gt;RETURN_FROM&lt;/code&gt;的情况并不多见。&lt;/p&gt;
&lt;h2&gt;函数作为数据，也称为高阶函数&lt;/h2&gt;
&lt;p&gt;当在Lisp中使用DEFUN定义函数时实际上做了两件事：用给定的名称创建了一个函数对象。也可以使用LAMBDA表达式创建没有名称的函数对象。函数对象实际表述为编译后的代码，通常为机器码。一旦得到它只需要知道如何引用它和调用它。&lt;/p&gt;
&lt;p&gt;FUNCTION操作符提供了获取函数对象的机制。它接收函数名作为参数并返回对应的函数对象。名称前不加引号。它可以被写作&lt;code&gt;#'&lt;/code&gt;，与QUOTE写作&lt;code&gt;'&lt;/code&gt;写法类似。&lt;/p&gt;
&lt;p&gt;得到函数对象后有两个函数可以用来调用函数对象：FUNCALL和APPLY。它们的区别在于：&lt;/p&gt;
&lt;p&gt;FUNCALL是用于你要调用的函数的参数个数的情况下。它的第一个参数是要被调用的函数对象，其它参数被传递到函数中。&lt;/p&gt;
&lt;p&gt;APPLY的第一个参数是函数对象。函数对象后面的参数不是调用这个函数的参数而是一个包含参数的list。APPLY并不关心参数是可选参数、可变参数或关键字参数，组合参数到list中的元素必须是调用函数对象的合法参数。（通常只适用于关键字参数。）F&lt;/p&gt;
&lt;h2&gt;匿名函数&lt;/h2&gt;
&lt;p&gt;LAMBDA表达式。&lt;/p&gt;
&lt;h1&gt;变量&lt;/h1&gt;
&lt;p&gt;Common Lisp支持两种类型的变量：lexical和dynamic。这两种类型大体类似于其它语言中的&amp;ldquo;local&amp;rdquo;和&amp;ldquo;global&amp;rdquo;变量。但仅仅是大体类似。&lt;/p&gt;
&lt;h2&gt;变量基础知识&lt;/h2&gt;
&lt;p&gt;Common Lisp中变量类型是运行期检查的。变量可以带任何类型的数据，变量的值带有类型信息。Common Lisp是强类型语言，它将检查所有类型错误。&lt;/p&gt;
&lt;p&gt;Common Lisp中所有的值从概念上恶报是对象的引用。因此，对一个变量赋新值不会修改变量之前所引用的对象。但是，如果变量持有一个可变对象（mutable）的引用，则可以通过这个引用修改对象，修改将反应到所有引用了相同对象的代码中。&lt;/p&gt;
&lt;p&gt;定义新变量的其中一种方法就是定义函数参数。&lt;/p&gt;
&lt;p&gt;每次函数调用时，Lisp创建新的绑定来保存从调用者传递过来的参数。绑定是变量在运行时的表象。一个变量在程序运行中可以有许多不同的绑定。单个变量在同一时刻也可以用多个绑定；例如递归调用的参数，在每次函数调用时将被重新绑定。&lt;/p&gt;
&lt;p&gt;通过变量，函数参数保持对象的引用。因此，你可以在函数体中给函数参数重新赋值，这不会影响另一个对这个函数的调用的绑定。但是如果传递给函数的对象是可变对象，并在函数中修改了这个对象，则修改将会对调用者可见，因为调用者和被调用者引用了同一个对象。&lt;/p&gt;
&lt;p&gt;另一个定义新变量的方法是LET操作符。&lt;/p&gt;
&lt;p&gt;当LET被求值时，所有初始值被先求值。新的绑定被创建并在body部分为执行前被初始化。在LET的body部分中，变量名指向新创建的绑定。在LET语句之后，这个名称指向其它东西，如果它存在则它指向LET语句之前所指向的东西。&lt;/p&gt;
&lt;p&gt;LET语句的body部分的最后一个表达式被作为LET语句的返回值。与函数参数类似，变量在进入LET时被引入，在每次进入LET时重新绑定。&lt;/p&gt;
&lt;p&gt;两种类型的变量lexical和dynamic变量作用范围有不同的作用范围机制，但是这两种情况下都是由绑定 form来限定的。&lt;/p&gt;
&lt;p&gt;同名变量的嵌套引用时，内部的变量将屏蔽掉外部的绑定。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;defun&lt;/span&gt; &lt;span class="nt"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;format&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="s2"&gt;"Parameter: ~a~%"&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;      &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;------&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="nt"&gt;is&lt;/span&gt; &lt;span class="nt"&gt;argument&lt;/span&gt; 
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;let&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="nt"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;                        &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;format&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="s2"&gt;"Outer LET: ~a~%"&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;    &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;|&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;----&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="nt"&gt;is&lt;/span&gt; &lt;span class="nt"&gt;2&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;let&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="nt"&gt;3&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;                      &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;format&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="s2"&gt;"Inner LET: ~a~%"&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;|&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;--&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt; &lt;span class="nt"&gt;is&lt;/span&gt; &lt;span class="nt"&gt;3&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;format&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="s2"&gt;"Outer LET: ~a~%"&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;   &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;format&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="s2"&gt;"Parameter: ~a~%"&lt;/span&gt; &lt;span class="nt"&gt;x&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;     &lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一个创建绑定的方式是LET*。后面定义的变量可以引用前面定义的变量的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let* ((x 10)
       (y (+ x 10)))
  (list x y))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Lexical变量和闭包&lt;/h2&gt;
&lt;p&gt;通常所有绑定都是lexically scoped变量。与C,Java中的local变量类似。&lt;/p&gt;
&lt;p&gt;Common Lisp的lexical变量存在一个不寻常的特点。在嵌套的函数和lexcial变量组合使用时将出现这个问题。通常lexical范围的变量，只存在于代码文本中绑定变量的范围才可以引用该变量。但当一个匿名函数在一个封闭范围内包含了lexical变量的引用时将发生什么呢？例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((count 0)) #'(lambda () (setf count (1+ count))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LAMBDA表达式内的count是lexical作用域的变量。但是匿名函数包含了对它的引用，匿名函数将作为let的返回值并能通过FUNCALL调用，能被那些不属于LET范围之内的代码调用。这个代码仍然能正常工作。count的绑定将在进入LET语句时被创建并将在需要它的期间一直存在下去。这种匿名函数被称为闭包，因为它&amp;ldquo;封闭（closes over）&amp;rdquo;了由LET创建的绑定。&lt;/p&gt;
&lt;p&gt;考虑闭包时要将它作为绑定来思考，不能把它当作变量。因为，闭包不仅仅能访问它封闭的变量的值也可以在不同的闭包调用时给变量赋新值，这个新值将能在不同的调用间被保留。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *fn* (let ((count 0)) #'(lambda () (setf count (1+ count)))))
CL-USER&amp;gt; (funcall *fn*)
1
CL-USER&amp;gt; (funcall *fn*)
2
CL-USER&amp;gt; (funcall *fn*)
3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;单个闭包通过引用变量可以封闭任意数量的变量绑定。多个闭包也可以共享相同的绑定。例如，下面的let返回的是一个闭包的列表，它们都引用了count的绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((count 0))
  (list
   #'(lambda () (incf count))
   #'(lambda () (decf count))
   #'(lambda () count)))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;动态变量，也称特殊变量&lt;/h2&gt;
&lt;p&gt;Common Lisp中创建全局变量的两个方法：DEFVAR和DEFPARAMETER。两个表达式都接收一个变量名和一个初始值，还有一个可选的字符串参数作为文档字符串。在使用DEFVAR和DEFPARAMETER后，全局变量的绑定可以在任何地方被使用。全局变量以&lt;code&gt;*&lt;/code&gt;开头和结尾。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defvar *count* 0
  "Count of widgets made so far.")

(defparameter *gap-tolerance* 0.001
  "Tolerance to be allowed in widget gaps.")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个定义方法的区别在于DEFPARAMETER在执行时总是会重新给变量赋值。DEFVAR只会在变量不存在时给它赋初值。DEFVAR也可以在定义全局变量时不赋初始值。这种变量被称为&amp;ldquo;未绑定（unbound）&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;全局变量的好处是不需要传递它们。多数语言都将标准输入和输出流作为全局变量。但是类似标准输出流这样的全局变量有时会需要通过修改这个变量来修改它们的行为。比如日志工具将它重定向到文件。有时在重定向到文件后时可能会忘记将它们重新定向到标准输出。&lt;/p&gt;
&lt;p&gt;解决这种问题的方法是使用动态变量。当你使用LET或函数参数绑定动态变量时，绑定将在进入绑定生存范围的时候被创建，这个绑定将在生存范围内替换全局绑定。这与Lexical绑定不同，它只在绑定生存周期内才能被引用，动态绑定可以任何代码的执行过程中被引用。所有全局变量都是动态变量。&lt;/p&gt;
&lt;p&gt;因此，你可以临时性的重新定义&lt;code&gt;*standard-output*&lt;/code&gt;，只需要使用LET重新绑定它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((*standard-output* *some-other-stream*))
  (stuff))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用stuff作为结果的任何代码在引用&lt;code&gt;*standard-output*&lt;/code&gt;时都将使用LET建立的绑定。当stuff返回执行过程离开LET范围时，&lt;code&gt;*standard-output*&lt;/code&gt;的绑定将被取消，随后的代码将看到执行LET之前的那个指向&lt;code&gt;*standard-output*&lt;/code&gt;的绑定。在任何时候，最近建立的绑定将屏蔽（shadows）掉之前的绑定。从概念上看，为动态变量创建的新绑定被压入那个变量对应的绑定堆栈中，引用那个变量时总是使用最近的绑定。当绑定范围结束时，前一个绑定再被弹出堆栈，如此继续。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defvar *x* 10)
(defun foo () (format t "X: ~d~%" *x*))

CL-USER&amp;gt; (foo)
X: 10
NIL

CL-USER&amp;gt; (let ((*x* 20)) (foo))
X: 20
NIL

CL-USER&amp;gt; (foo)
X: 10
NIL

(defun bar ()
  (foo)
  (let ((*x* 20)) (foo))
  (foo))

CL-USER&amp;gt; (bar)
X: 10
X: 20
X: 10
NIL

(defun foo ()
  (format t "Before assignment~18tX: ~d~%" *x*)
  (setf *x* (+ 1 *x*))
  (format t "After assignment~18tX: ~d~%" *x*))

CL-USER&amp;gt; (foo)
Before assignment X: 10
After assignment  X: 11
NIL

CL-USER&amp;gt; (bar)
Before assignment X: 11
After assignment  X: 12
Before assignment X: 20
After assignment  X: 21
Before assignment X: 12
After assignment  X: 13
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LET是如何知道绑定&lt;code&gt;*x*&lt;/code&gt;是一个动态绑定的呢？这是因为在申明&lt;code&gt;*x*&lt;/code&gt;是使用的是DEFVAR和DEFPARAMETER，它们会自动将变量申明为全局特殊变量。在任何时候在LET中或在函数参数中使用此变量的时候都将构造一个新的动态绑定。这也是为什么使用&lt;code&gt;*&lt;/code&gt;标识全局变量这个约定的非常重要的原因。&lt;/p&gt;
&lt;p&gt;也可以申明本地特殊变量。在binding form中，申明一个特殊变量，则将创建一个动态绑定的变量而不是lexical变量。其它代码可以在本地变量范围中申明一个特殊变量以便引用动态绑定。但是，本地特殊变量非常稀有，你不必考虑它们。&lt;/p&gt;
&lt;p&gt;动态绑定使得全局变量更加易于管理，绑定全局变量考虑它可能的两个影响：它将改变下游代码的行为，也可能出现下游代码给绑定赋新值断开了现有的绑定行为。只应该在需要的地方使用上面的这些特性。&lt;/p&gt;
&lt;h2&gt;常量&lt;/h2&gt;
&lt;p&gt;所有常量都是全局的，使用DEFCONSTANT定义。它的使用与DEFPARAMETER类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defconstant name initial-value-form [ documentation-string ])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常使用变量前后加&lt;code&gt;+&lt;/code&gt;作为全局变量的命名。另一种方式是使用前后添加&lt;code&gt;*-&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Lisp允许通过重新执行DEFCONSTANT并设置不同的初始值。, what exactly happens after the redefinition isn't defined。实际上，多数Lisp实现将会需要你重新对引用了这个常量的代码重新求值，以便应用新值，因为旧代码可能内联了旧的值。因此，最好只在真正的常量才使用DEFCONSTANT，例如NIL。&lt;/p&gt;
&lt;h2&gt;赋值&lt;/h2&gt;
&lt;p&gt;创建绑定后，你可以对它做两件事：得到当前值和给它设置一个新值。对符号求值时将得到符号对应的名字所指向的变量的值，因此你可以通过引用变量得到它的值。给绑定赋新值可以使用SETF宏，它是Common Lisp中的通用赋值操作符。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf place value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SETF是一个宏，它将被展开为低级操作，转变为对特殊操作符SETQ的调用，它可以操作lexical和动态绑定。&lt;/p&gt;
&lt;p&gt;前面讲过，给绑定赋新值不会影响其它绑定的值。例如；&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (x) (setf x 10))

(let ((y 20))
  (foo y)
  (print y))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将打印出20，而不是10。&lt;/p&gt;
&lt;p&gt;SETF可以给多个变量赋值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf x 1)
(setf y 2)

(setf x 1 y 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SETF将返回最后的赋值，因此可以嵌套使用SETF。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf x (setf y (random 10))) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;x和y将是同样的随机数值。&lt;/p&gt;
&lt;h2&gt;通用赋值&lt;/h2&gt;
&lt;p&gt;SETF可以对&amp;ldquo;SETFable places&amp;rdquo;的地方进行赋值操作，比如数组、变量、哈希表等等，甚至可以扩展SETF来允许它对用户定义的地方进行赋值操作，这里不作介绍。&lt;/p&gt;
&lt;p&gt;SETF的第一个参数是要赋值的位置，第二个参数是值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Simple variable:    (setf x 10) 
Array:              (setf (aref a 0) 10)
Hash table:         (setf (gethash 'key hash) 10)
Slot named 'field': (setf (field o) 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：SETF设置一个大对象的某个部分时不会影响到之前这个地方所存储的对象。这点上与Java，Perl和Python中的&lt;code&gt;=&lt;/code&gt;是相似的。&lt;/p&gt;
&lt;h2&gt;其它修改方式&lt;/h2&gt;
&lt;p&gt;通过INCF和DECF之类的modify macros来修改变量。使用这种宏不但看起来更加简明。并且，modify macros能安全的用于只允许对表达式进行一次求值的地方。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(incf (aref *array* (random (length *array*))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;转换为SETF表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf (aref *array* (random (length *array*)))
      (1+ (aref *array* (random (length *array*)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这两者是不同的，因为后者将会对RANDOM调用两次，这将返回不同的值。而INCF展开后将类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((tmp (random (length *array*))))
  (setf (aref *array* tmp) (1+ (aref *array* tmp))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常，modify macros将会对它的每个参数按从左至右的顺序求值一次。&lt;/p&gt;
&lt;p&gt;PUSH宏也是一个modify macro。&lt;/p&gt;
&lt;p&gt;两个神秘但非常有用的modify macro ROTATEF和SHIFTF。ROTATEF交换两个位置的值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(rotatef a b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;交换两个变量并返回NIL。由于a和b都是变量因此不需要担心side effects，前面的ROTATEF表达式类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((tmp a)) (setf a b b tmp) nil)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SHIFTF与之类似，但它不是交换，而是向左移动变量的值，下面的表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(shiftf a b 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((tmp a)) (setf a b b 10) tmp)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ROTATEF和SHIFTF都可以用于任意数量的变量，与所有modify macros一样，都只对这些参数按从左至右的顺序求值一次。&lt;/p&gt;
&lt;h1&gt;宏：标准控制结构&lt;/h1&gt;
&lt;p&gt;通常高级语言在实现的时候总是采用一个很小的核心加标准库的方式来实现，这样比较易于学习和实现。人们通过编写新程序库或新类来扩展出自己的程序。&lt;/p&gt;
&lt;p&gt;Common Lisp也支持这些扩展方式，宏给Common Lisp提供了另一种扩展方式。前面讨论过每个宏都定义自己的语法，决定如何将s-expression转换为Lisp forms。通过macro我们可以构建新的类似WHEN，DOLIST和LOOP这样的控制结构，或者DEFUN和DEFPARAMETER这样的定义语句。这也是这门语言自己的实现方式。Lisp程序员通常更关心它提供了另一种方法来扩展这门语言，以便更好的解决编程中的特殊问题。&lt;/p&gt;
&lt;h2&gt;WHEN和UNLESS&lt;/h2&gt;
&lt;p&gt;if是一个特殊的操作符，基本语法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(if condition then-form [else-form])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;condition将被求值，如果它的值是非NIL值，则then-form将求值并作为结果返回。否则，如果else-form存在，则它将被求值并作为结果返回。&lt;/p&gt;
&lt;p&gt;IF只支持执行单个语句。在需要执行多个语句时不得不使用另一个操作符PROGN。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(if (spam-p current-message)
    (progn
      (file-in-spam-folder current-message)
      (update-spam-database current-message)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lisp提供了标准宏WHEN来执行这种任务：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(when (spam-p current-message)
  (file-in-spam-folder current-message)
  (update-spam-database current-message))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果它不存在于标准库中，你也可以自己来定义WHEN:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro when (condition &amp;amp;rest body)
  `(if ,condition (progn ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与WHEN宏相对的是UNLESS宏，它只在条件为非真时才执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro unless (condition &amp;amp;rest body)
  `(if (not ,condition) (progn ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面简单的例子包含了一个重要的内容：由于macro系统是构建于语言中的，因此你可以编写WHEN和UNLESS这样的宏来节约你的时间。&lt;/p&gt;
&lt;h2&gt;COND&lt;/h2&gt;
&lt;p&gt;另一种难看的使用IF表达式的情况是在多重选择的情况下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(if a
    (do-x)
    (if b
       (do-y)
       (do-z)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要执行更多语句可能还需要使用PROGN等等。因此，Common Lisp提供了COND宏。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(cond
  (test-1 form*)
      .
      .
      .
  (test-N form*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个情况下的分支上的元素可以包含零个或多个form，它们将在分支被选择的情况下被执行。所有的条件判断将按顺序被执行直到遇到一个为true的条件，这个分支上的语句将被执行，最后一个form的值作为整个COND的返回值。如果这个分支上的条件后面没有form，则将返回条件的值。习惯上将最后一个条件写为T，任何非NIL值都能工作，但T更能表明它的分界作用。因此可以将开头的IF表达式写为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(cond (a (do-x))
      (b (do-y))
      (t (do-z)))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;AND，OR和NOT&lt;/h2&gt;
&lt;p&gt;NOT不是宏而是一个操作符，它与AND和OR关系密切才放到这里来介绍。它接收单个参数并反转它的真假值，如果参数为NIL则返回T，否则返回NIL。&lt;/p&gt;
&lt;p&gt;AND和OR都是宏。它们实现了对任意数量的form的和逻辑与和或，由于它们是通过宏定义的，因此它们可以实现&amp;ldquo;短路&amp;rdquo;操作。它们按从左至右的顺序依次执行。当AND遇到某个form的求值结果为NIL时它返回NIL。如果所有form都返回非NIL值，则它返回最后一个form的值。对于OR它将在遇到第一个非NIL值时返回这个form的值。如果没有哪个form的返回值为真，则OR将返回NIL。&lt;/p&gt;
&lt;h2&gt;循环&lt;/h2&gt;
&lt;p&gt;Lisp中的25个特殊操作符都不直接支持循环结构。所有的循环控制结构都是基于两个特殊操作符（TAGBODY和GO）通过宏构造出来的。&lt;/p&gt;
&lt;p&gt;DO使用特殊操作符提供了基本的循环结构，DOLIST和DOTIMES提供两个易于使用的通用型的循环结构。当DOLIST和DOTIMES不够用时，你可以通过DO来定义自己的循环结构。&lt;/p&gt;
&lt;p&gt;LOOP宏提供了易于使用的English-like（或Algol-like）的non-Lispy的循环结构。&lt;/p&gt;
&lt;h2&gt;DOLIST和DOTIMES&lt;/h2&gt;
&lt;p&gt;DOLIST遍历list中的元素，并执行body中的语句。下面是它的基本结构（去掉了一些神秘选项）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(dolist (var list-form)
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (dolist (x '(1 2 3)) (print x))
1
2
3
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这种方法使用时DOLIST整个返回NIL。&lt;/p&gt;
&lt;p&gt;如果需要在中途中断循环可以使用RETURN。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (dolist (x '(1 2 3)) (print x) (if (evenp x) (return)))
1
2
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DOTIMES的基本结构与DOLIST类似。通常用于计数类的循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(dotimes (var count-form)
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;count-form的值必须是整数。每次执行body时var保留了从0至小于这个数的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (dotimes (i 4) (print i))
0
1
2
3
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与DOLIST一样，也可以使用RETURN中断循环。&lt;/p&gt;
&lt;h2&gt;DO&lt;/h2&gt;
&lt;p&gt;DOLIST和DOTIMES易于使用，但它并不能满足所有类型的循环的要求。DOLIST和DOTIMES只提供了一个循环变量，DO允许你绑定任意数量的变量并且你能够完全控制每个变量如何改变。并且也可以定义用于循环结束测试的代码，并能提供一个语句用于产生整个DO的返回值。DO的基本结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do (variable-definition*)
    (end-test-form result-form*)
  statement*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每个variable-definition都引入了一个可以在循环体中访问的变量。单个变量定义的结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(var init-form step-form)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;init-form将在循环开始时被求值它的值将被绑定到var。在循环的每个迭代之前，step-form将被重新求值，并将结果赋给var。step-form是可选项，如果它不存在，则变量的值将一直保持不变，除非你在循环体中显式的给它赋值。与let中定义变量类似，如果init-form 指定，则变量将被绑定到NIL。你也可以像在LET中一样只是简单的在variable-definition中只定义变量名称。&lt;/p&gt;
&lt;p&gt;当end-test-form的求值结果为true时，result-form将被求值，它的结果将被作为DO表达式的返回值。&lt;/p&gt;
&lt;p&gt;在每次迭代前所有变量都会被求值。这意味着你可以在变量中引用其它变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do ((n 0 (1+ n))
     (cur 0 next)
     (next 1 (+ cur next)))
    ((= 10 n) cur))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这也揭示了DO的另一个特性&amp;mdash;&amp;mdash;因为你可以同时对多个变量进行操作，有时根本不会再需要循环体了。另外，你可以只保留result form，特别是如果你只需要使用循环控制结构时。&lt;/p&gt;
&lt;p&gt;记住DO语句基本结构中的6个括号：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do (variable-definition*)
    (end-test-form result-form*)
  statement*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在DO中即使你不需要使用循环变量，也仍然需要一个空的变量列表。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do ()
    ((&amp;gt; (get-universal-time) *some-future-date*))
  (format t "Waiting~%")
  (sleep 60)) 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;强大的LOOP&lt;/h2&gt;
&lt;p&gt;LOOP有两种风格。简单风格的不绑定任何变量，看起来像个无限循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(loop
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过RETURN才能跳出。&lt;/p&gt;
&lt;p&gt;另一种风格的LOOP。English风格，或者说un-Lispy风格。对于LOOP的这种风格存在一些争论，一些人喜欢，另一些人不喜欢这种风格认为它不那么Lispy。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(loop for i from 1 to 10 collecting i) ==&amp;gt; (1 2 3 4 5 6 7 8 9 10)
(loop for x from 1 to 10 summing (expt x 2)) ==&amp;gt; 385
(loop for x across "the quick brown fox jumps over the lazy dog"
      counting (find x "aeiou")) ==&amp;gt; 11
(loop for i below 10
      and a = 0 then b
      and b = 1 then (+ b a)
      finally (return  a))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;符号across,and,below,collecting,counting,finally,for,from,summing,then,和to都是LOOP循环的关键字。&lt;/p&gt;
&lt;h1&gt;宏：定义自己的宏&lt;/h1&gt;
&lt;p&gt;macro和函数操作于不同的层次。创建完全不同的抽像。&lt;/p&gt;
&lt;h2&gt;宏展开时与运行时&lt;/h2&gt;
&lt;p&gt;掌握宏的关键在于能清析的区分宏生成的代码和由这些代码构成的程序。当编写宏时，你是在编写由编译器运行的用于在编译时生成代码的程序。只有在所有宏被完全展开并且展开后的代码被编译后程序才被运行。宏被执行的时间被称为宏展开时，这与运行时（编写的代码和由宏生成的代码运行）是有区别的。&lt;/p&gt;
&lt;p&gt;宏展开时不能访问运行时的数据。即，宏展开时并不能执行程序，也不知道程序如何工作，宏展开时运行的代码只能处理程序代码中有的数据。比如，程序代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun foo (x)
  (when (&amp;gt; x 10) (print 'big)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常你将会把x作为变量它保存了传递给foo的参数。但在宏展开时，比如编译器在运行WHEN宏时，可用的数据只有代码。因为程序还没有运行，没有调用foo因此也没有数值与x关联。编译器传递给WHEN的值是Lisp lists描述的程序代码。&lt;code&gt;(&amp;gt; x 10)&lt;/code&gt;和&lt;code&gt;(print 'big)&lt;/code&gt;作为参数传递给WHEN。它的定义类似下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro when (condition &amp;amp;rest body)
  `(if ,condition (progn ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当foo被编译时，WHEN宏将获得上面那两个参数并运行。condition参数被绑定到&lt;code&gt;(&amp;gt; x 10)&lt;/code&gt;，&lt;code&gt;(print 'big)&lt;/code&gt;被绑定到&lt;code&gt;&amp;amp;rest&lt;/code&gt;参数。而反引号内的表达式将生成代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(if (&amp;gt; x 10) (progn (print 'big)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当Lisp以解释方式执行时，宏展开时和运行时的区别就不那么明显了，因为他们是交叉的。语言标准中并未明确指定解释器应该怎样处理宏&amp;mdash;&amp;mdash;它可以展开所有宏代然后解释出结果，或者它只在遇到宏的时候才展开宏并使用它。在这两种情况下，宏总是传递未被求值的Lisp对象，宏的工作仍然是生成执行实际操作的代码，而不是由宏本身来执行实际操作。&lt;/p&gt;
&lt;h2&gt;DEFMACRO&lt;/h2&gt;
&lt;p&gt;基本结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro name (parameter*)
  "Optional documentation string."
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与函数结构类似，宏包括名称，参数列表，可选的文档字符串和body部分的Lisp表达式。&lt;/p&gt;
&lt;p&gt;一旦有了调用的示例代码和对应的展开代码，你就可以进行下一步：编写实际的宏代码。&lt;/p&gt;
&lt;p&gt;在编写完将示例代码正确展开的代码后，你需要确保宏没有漏洞（leak）。有漏洞的宏在某些参数下能工作得很好，但是对于另一些情况则不能正常工作。&lt;/p&gt;
&lt;p&gt;编写宏的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写调用宏的示例代码和这个代码应该展开的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写能根据示例代码参数生成代码的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确保宏抽像没有漏洞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;一个简单的宏：do-primes&lt;/h2&gt;
&lt;p&gt;这个宏提供类似DOTIMES和DOLIST的循环结构，它迭代连续的素数。&lt;/p&gt;
&lt;p&gt;首先，你需要两个工具函数，一个用于检测给定的数字是否为素数，另一个函数用于返回大于或等于它的参数的下一个素数。这两个函数都使用逼近法蛮力计算。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun primep (number)
  (when (&amp;gt; number 1)
    (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

(defun next-prime (number)
  (loop for n from number when (primep n) return n))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来编写调用宏的示例代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes (p 0 19)
  (format t "~d " p))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它表示对大于等于0小于等于19的素数执行body中的代码，变量p保存对应的素数。&lt;/p&gt;
&lt;p&gt;在没有do-primes宏时，需要使用下面的DO循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do ((p (next-prime 0) (next-prime (1+ p))))
    ((&amp;gt; p 19))
  (format t "~d " p))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来需要编写宏代码将前面的示例代码转换为上面的代码。&lt;/p&gt;
&lt;h2&gt;宏参数&lt;/h2&gt;
&lt;p&gt;由于传递给宏的都是Lisp对象描述的源代码，宏的第一步是解析出需要用于展开计算的那些对象。对于将参数插入模板的简单的宏来说，这个步骤微不足到：简单的定义右边的参数列表来接收各个参数。&lt;/p&gt;
&lt;p&gt;对于do-primes并不合适。它的第一个参数是包含了循环变量p，下限0和上限19。而在展开的代码中，这个list参数并不是整体出现在展开代码中的；它的三个元素是分开出现在不同位置的。&lt;/p&gt;
&lt;p&gt;你可以为do-primes定义两个参数，一个保存list另一个&lt;code&gt;&amp;amp;rest&lt;/code&gt;参数保存body部分。然后将list拆分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes (var-and-range &amp;amp;rest body)
  (let ((var (first var-and-range))
        (start (second var-and-range))
        (end (third var-and-range)))
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
         ((&amp;gt; ,var ,end))
       ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面将解释如何生成正确的展开代码；现在只需要注意变量var，start，end每个保存了一个从var-and-range中解析出的值，然后他们被加入反引号表达式用于生成do-primes的展开代码。&lt;/p&gt;
&lt;p&gt;然而并不需要像这样手工的拆分var-and-range因为宏参数列表被称为&lt;code&gt;destructuring&lt;/code&gt;参数列表。它将按列表的结构拆分传递给宏的参数。&lt;/p&gt;
&lt;p&gt;在destructuring参数列表中，简单的参数可以被替换为嵌套的参数列表。嵌套参数列表中的每个元素被绑定到参数列表的一部分。例如使用(var start end)替换var-and-range，则列表中的3个元素将自动对应到3个参数。&lt;/p&gt;
&lt;p&gt;宏参数的另一个特殊功能是你可以使用&lt;code&gt;&amp;amp;body&lt;/code&gt;作为&lt;code&gt;&amp;amp;rest&lt;/code&gt;的同义词。语义上两者是相等的，但很多开发环境将会使用&lt;code&gt;&amp;amp;body&lt;/code&gt;来决定如何缩进&amp;mdash;&amp;mdash;通常使用&lt;code&gt;&amp;amp;body&lt;/code&gt;接收宏的body部分。&lt;/p&gt;
&lt;p&gt;上面的宏可以修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes ((var start end) &amp;amp;body body)
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
       ((&amp;gt; ,var ,end))
     ,@body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，destructuring参数列表还将给予自动的错误检查，Lisp将会检查调用这个宏的第一个参数是否是一个包含3个元素的列表，如果不是则将给出错误信息。在像SLIME这样的开发环境中使用destructuring参数列表将能在输入函数或宏的名字时更快的得到参数的提示信息。对于原来的那种定义方式，SLIME中只会有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes var-and-range &amp;amp;rest body)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而使用新的定义将得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes (var start end) &amp;amp;body body)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Destructuring参数列表可以包含&lt;code&gt;&amp;amp;optional&lt;/code&gt;，&lt;code&gt;&amp;amp;key&lt;/code&gt;和&lt;code&gt;&amp;amp;rest&lt;/code&gt;参数，并可以包含嵌套destructuring列表。&lt;/p&gt;
&lt;h2&gt;生成展开代码&lt;/h2&gt;
&lt;p&gt;由于do-primes是个简单的宏，因此在使用destructured参数后，就只需要将它们插入到模板中生成展开代码了。&lt;/p&gt;
&lt;p&gt;回顾反引号&lt;/p&gt;
&lt;p&gt;+--------------------+----------------------------------------+--------------------+
|  Backquote Syntax  |     Equivalent List-Building Code      |       Result       |
+--------------------+----------------------------------------+--------------------+
|&lt;code&gt;(a (+ 1 2) c)      |(list 'a '(+ 1 2) 'c)                   |(a (+ 1 2) c)       |
+--------------------+----------------------------------------+--------------------+
|&lt;/code&gt;(a ,(+ 1 2) c)     |(list 'a (+ 1 2) 'c)                    |(a 3 c)             |
+--------------------+----------------------------------------+--------------------+
|&lt;code&gt;(a (list 1 2) c)   |(list 'a '(list 1 2) 'c)                |(a (list 1 2) c)    |
+--------------------+----------------------------------------+--------------------+
|&lt;/code&gt;(a ,(list 1 2) c)  |(list 'a (list 1 2) 'c)                 |(a (1 2) c)         |
+--------------------+----------------------------------------+--------------------+
|`(a ,@(list 1 2) c) |(append (list 'a) (list 1 2) (list 'c)) |(a 1 2 c)           |
+--------------------+----------------------------------------+--------------------+&lt;/p&gt;
&lt;p&gt;要注意反引号只是一个简略形式。但是这是一个很方便的书写方式。如果没有反引号，代码将会变成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes-a ((var start end) &amp;amp;body body)
  (append '(do)
          (list  (list (list var
                             (list 'next-prime start)
                             (list 'next-prime (list '1+ var)))))
          (list (list (list '&amp;gt; var end)))
          body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子也可以工作，或者你可以直接使用MACROEXPAND-1直接展开。&lt;/p&gt;
&lt;p&gt;在SLIME中你可以将光标停在宏调用的右括号后面使用C-c RET来调用Emacs的slime-macroexpand-1，它会调用MACROEXPAND-1并将展开的结果显示在临时缓冲区中。&lt;/p&gt;
&lt;h2&gt;堵塞漏洞&lt;/h2&gt;
&lt;p&gt;在Joel Spolsky的文章&amp;ldquo;The Law of Leaky Abstractions&amp;rdquo;中制造了一个词汇&amp;ldquo;leaky abstraction&amp;rdquo;来描述an abstraction that "leaks" details it's supposed to be abstracting away。&lt;/p&gt;
&lt;p&gt;它也指出，宏有3种情况将产生漏洞。&lt;/p&gt;
&lt;p&gt;当前的宏定义有其中的一种漏洞：命名漏洞，它对end表达式进行了多次求值。所设在调用do-primes时不直接使用数字而是使用(random 100)替代19：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes (p 0 (random 100))
  (format t "~d " p))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它展开后将变成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (macroexpand-1 '(do-primes (p 0 (random 100)) (format t "~d " p)))
(DO ((P (NEXT-PRIME 0) (NEXT-PRIME (1+ P))))
    ((&amp;gt; P (RANDOM 100)))
  (FORMAT T "~d " P))
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当这段展开的代码运行时，RANDOM将在每次循环时都被执行。这个循环将只会在随机数字恰好小于P时才会中止。迭代执行的次数也将是随机的。&lt;/p&gt;
&lt;p&gt;这是宏抽像中的漏洞。一个解决这个漏洞的办法是简单的说明do-primes的行为。但这不满足最小惊讶原则。程序员通常会认为他传递给宏的表达式只会被求值一次。而且，do-primes是构建在标准宏DOTIMES和DOLIST的模型的基础上，这两者都只对表达式求值一次，绝大多数程序员都会认为do-primes会有相似的行为。&lt;/p&gt;
&lt;p&gt;可以在生成的代码中对表达式求值并保存于变量中放在后面的DO循环中使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes ((var start end) &amp;amp;body body)
  `(do ((ending-value ,end)
        (,var (next-prime ,start) (next-prime (1+ ,var))))
       ((&amp;gt; ,var ending-value))
     ,@body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不幸的是，这个修改产生了两个新的漏洞：&lt;/p&gt;
&lt;p&gt;第一个新漏洞与刚才修复的多次求值的漏洞相似。因为DO循环中的初始化部分是按定义的顺序求值的，当宏的展开代码被求值时，后面传递的表达式end将会被选于start被求值，这与它们在宏调用中出现的顺序是相反的。这个漏洞在使用0和19来调用时不会导致问题。但当它们是有side effects的表达式时，求值顺序将再次与最小惊讶原则冲突。&lt;/p&gt;
&lt;p&gt;通过交换两个变量的定义顺序可以修补这个漏洞：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes ((var start end) &amp;amp;body body)
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
        (ending-value ,end))
       ((&amp;gt; ,var ending-value))
     ,@body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一个需要修补的漏洞是创建并使用了变量名ending-value。问题在于这个名字，它应该是宏实现的细节，与宏调用的环境相关。由于这个漏洞下面的调用将不会正确的工作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes (ending-value 0 10)
  (print ending-value))

(let ((ending-value 0))
  (do-primes (p 0 10)
    (incf ending-value p))
  ending-value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过MACROEXPAND-1可以看到这个问题。第一个调用将被展开为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do ((ending-value (next-prime 0) (next-prime (1+ ending-value)))
     (ending-value 10))
    ((&amp;gt; ending-value ending-value))
  (print ending-value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里DO循环中ending-value这下变量名被使用了两次。&lt;/p&gt;
&lt;p&gt;第二个代码展开为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((ending-value 0))
  (do ((p (next-prime 0) (next-prime (1+ p)))
       (ending-value 10))
      ((&amp;gt; p ending-value))
    (incf ending-value p))
  ending-value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种情况下的展开代码是合法的，但是它的行为并不是你所希望的。因为循环外部由LET建立的对ending-value的绑定被DO中的同名变量屏蔽（shadowed）了，表达式(incf ending-value p)对循环变量ending-value的修改不会影响循环外的同名变量，这将造成另一个无限循环。&lt;/p&gt;
&lt;p&gt;修补这个漏洞需要生成一个不会被外部代码引用的符号。你可以尝试使用一个不大可能被外部使用的名字，但这并不能保证不冲突。你也可以使用包来在某种程度上保护你的代码Chapter21。但这里有个更好的解决方法。&lt;/p&gt;
&lt;p&gt;函数GENSYM将在每次调用它时产生一个唯一的符号。这个符号从未被Lisp reader读取过并且它也从未被interned到任何包中。因此可以使用它替换ending-value，你可以在每次展开时生成一个新的符号。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes ((var start end) &amp;amp;body body)
  (let ((ending-value-name (gensym)))
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
          (,ending-value-name ,end))
         ((&amp;gt; ,var ,ending-value-name))
       ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意代码中的GENSYM并不是展开表达式中的一部分；它是作为宏展开器的一部分运行的，在每次宏展开时创建出一个新的符号。这初看起来可能有点奇怪ending-value-name是一个变量它的值是另一个变量的名字。但这实际上与参数var的值是变量名没有区别&amp;mdash;&amp;mdash;差异在于var的值是在macro语句被reader读取的时候创建的，ending-value-name的值是在宏代码运行时被创建的。&lt;/p&gt;
&lt;p&gt;使用这个方法定义后展开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do-primes (ending-value 0 10)
  (print ending-value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将得到&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(do ((ending-value (next-prime 0) (next-prime (1+ ending-value)))
     (#:g2141 10))
    ((&amp;gt; ending-value #:g2141))
  (print ending-value))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在保存ending value的变量是生成的符号，&lt;code&gt;#:g2141&lt;/code&gt;。这个名字是由GENSYM生成的。生成的符号被打印为uninterned的符号的打工，前面带有&lt;code&gt;#:&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另一个调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((ending-value 0))
  (do-primes (p 0 10)
    (incf ending-value p))
  ending-value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将展开为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((ending-value 0))
  (do ((p (next-prime 0) (next-prime (1+ p)))
       (#:g2140 10))
      ((&amp;gt; p #:g2140))
    (incf ending-value p))
  ending-value)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按下面的规则编写宏：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;除非有特殊原因，应该按subforms出现在宏调用上的顺序在展开代码中包含subforms。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除非有特殊原因，应该在展开代码中创建变量保存subforms的值，确保subforms只被求值一次，并在其它展开代码的其它地方使用这个变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用GENSYM在宏展开时创建变更名，并将它用于展开代码中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;宏编写宏&lt;/h2&gt;
&lt;p&gt;没有理由只有在编写函数时使用宏。宏的工作是抽像通用的句法模式，某些模式对于编写宏同样有益处。&lt;/p&gt;
&lt;p&gt;实际上，你已经看到这种模式，比如do-primes中以LET开头引入少量变量保存生成的符号名。&lt;/p&gt;
&lt;p&gt;这节里你将编写一个宏with-gensyms，它来完成上个版本中LET的工作。即，你将用宏来编写宏：一个宏生成代码来生成代码。你可以这样使用这个宏：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro do-primes ((var start end) &amp;amp;body body)
  (with-gensyms (ending-value-name)
    `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
          (,ending-value-name ,end))
         ((&amp;gt; ,var ,ending-value-name))
       ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它与上一版本中的do-primes相同。with-gensyms需要将每个变量名展开为LET。最简单的办法是编写一个反引号模板。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro with-gensyms ((&amp;amp;rest names) &amp;amp;body body)
  `(let ,(loop for n in names collect `(,n (gensym)))
     ,@body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用LOOP生成变量名。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (loop for n in '(a b c) collect `(,n (gensym)))
((A (GENSYM)) (B (GENSYM)) (C (GENSYM)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样在with-gensyms内部你可以直接引用变量名了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((ending-value-name (gensym)))
  `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))
        (,ending-value-name ,end))
       ((&amp;gt; ,var ,ending-value-name))
     ,@body))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来不错。但这个宏相当的锁碎，重点在于清析的知道什么时候这两个宏被展开：当编译do-primes的DEFMACRO，with-gensyms被展开到代码并编译。因此，编译后的do-primes与使用LET编写的是相同的。当编译使用do-primes的函数时，由with-gensyms生成的代码执行并生成do-primes的展开代码，但是with-gensyms它自己并不需要编译了，因为它在编译do-primes时已经被展开了。&lt;/p&gt;
&lt;h1&gt;实践：构建一个单元测试框架&lt;/h1&gt;
&lt;p&gt;这章将构建一个测试框架。其主要设计目标是尽可能容易的添加新测试、运行测试套件、跟踪错误。&lt;/p&gt;
&lt;p&gt;这个自动化测试框架的主要职责是告诉你是否所有测试都通过。所以，所以每个测试都必须是一个产生布尔类型结果的表达式。&lt;/p&gt;
&lt;h2&gt;两次尝试&lt;/h2&gt;
&lt;p&gt;如果是在做简单的测试可以在REPL中直接输入表达式然后检查返回值是否为T。最简单的开始这个测试框架的办法是编写一些测试用例然后用AND将结果连接起来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (and
    (= (+ 1 2) 3)
    (= (+ 1 2 3) 6)
    (= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在执行这个函数时它将返回T，因此你知道测试通过了。但是这里存在一些问题，如果某个测试用例失败了，你只能知道出了问题，返回了NIL，但是你不会知道具体是哪个测试用例出了问题。&lt;/p&gt;
&lt;p&gt;因此，需要改进一下。要能知道每个测试用例的执行情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (format t "~:[FAIL~;pass~] ... ~a~%" (= (+ 1 2) 3) '(= (+ 1 2) 3))
  (format t "~:[FAIL~;pass~] ... ~a~%" (= (+ 1 2 3) 6) '(= (+ 1 2 3) 6))
  (format t "~:[FAIL~;pass~] ... ~a~%" (= (+ -1 -3) -4) '(= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以看到每个测试的情况了。但是这里有很多重复的FORMAT调用，需要进行重构。&lt;/p&gt;
&lt;p&gt;另一个问题是对于整个测试过程没有返回一个标识来标识是否所有测试都通过。&lt;/p&gt;
&lt;h2&gt;重构&lt;/h2&gt;
&lt;p&gt;我们需要的结果是既能像最先一个版本那样对整个测试返回一个结果，但是也需要能像第二个版本那样报告单个用例的执行情况。由于第二个版本更接近需求，因此可以在第二个版本的基础上重构，你最先想要做的一定是去掉重复的代码。&lt;/p&gt;
&lt;p&gt;去掉重复的FORMAT调用的最简单的方法是定义一个新函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun report-result (result form)
  (format t "~:[FAIL~;pass~] ... ~a~%" result form))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新编写的test-+，提升并不大，但是至少可以方便的修改结果报告的格式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (report-result (= (+ 1 2) 3) '(= (+ 1 2) 3))
  (report-result (= (+ 1 2 3) 6) '(= (+ 1 2 3) 6))
  (report-result (= (+ -1 -3) -4) '(= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来你需要去掉重复的测试用例表达式。在这里需要的是将表达式既作为代码（用于计算结果）又作为数据（用于报告结果）。每当你需要将代码作为数据时，这就是你需要使用宏的明确信号。可以编写一个宏来改进&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro check (form)
  `(report-result ,form ',form))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;test-+将变成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (check (= (+ 1 2) 3))
  (check (= (+ 1 2 3) 6))
  (check (= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然是在去掉重复代码，何必不将多余的check调用也去掉？你可以将check定义为可以接收任意数量的语句，将每个都包装成对report-result的调用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro check (&amp;amp;body forms)
  `(progn
     ,@(loop for f in forms collect `(report-result ,f ',f))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最新版本的test-+将变成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (check
    (= (+ 1 2) 3)
    (= (+ 1 2 3) 6)
    (= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它与下面的代码是等效的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (progn
    (report-result (= (+ 1 2) 3) '(= (+ 1 2) 3))
    (report-result (= (+ 1 2 3) 6) '(= (+ 1 2 3) 6))
    (report-result (= (+ -1 -3) -4) '(= (+ -1 -3) -4))))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;修正返回值&lt;/h2&gt;
&lt;p&gt;我们还需要修正一下test-+的返回值以标识出所有用例是否都通过了。由于check负责来生成代码，因此只需要修改它生成的代码就可以了。&lt;/p&gt;
&lt;p&gt;首先，需要让report-result返回测试的结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun report-result (result form)
  (format t "~:[FAIL~;pass~] ... ~a~%" result form)
  result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，看起来似乎只需要将PROGN修改为AND就可以了。但是AND有个问题，因为它有短路行为。如果某个测试用例失败，后面的测试用例将不会被执行。Common Lisp也没有提供这样的控制结构。因此我们需要编写一个宏提供这样的功能。它的行为类似于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(combine-results
  (foo)
  (bar)
  (baz))

(let ((result t))
  (unless (foo) (setf result nil))
  (unless (bar) (setf result nil))
  (unless (baz) (setf result nil))
  result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是这里引入了变量result。根据前面章节的介绍，这里会产生一个漏洞。我们需要使用with-gensyms来给它生成唯一的名字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro combine-results (&amp;amp;body forms)
  (with-gensyms (result)
    `(let ((,result t))
      ,@(loop for f in forms collect `(unless ,f (setf ,result nil)))
      ,result)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以将check修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro check (&amp;amp;body forms)
  `(combine-results
    ,@(loop for f in forms collect `(report-result ,f ',f))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样修改后test-+将在所有测试用例都通过时返回T。&lt;/p&gt;
&lt;h2&gt;更好报告测试结果&lt;/h2&gt;
&lt;p&gt;当我们使用下面的方式来使用combine-results时，如果test-+或&lt;code&gt;test-*&lt;/code&gt;中某个用例出现错误时，我们将无法知道这个错误是在test-+中还是在&lt;code&gt;test-*&lt;/code&gt;中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-* ()
  (check
    (= (* 2 2) 4)
    (= (* 3 5) 15)))

(defun test-arithmetic ()
  (combine-results
   (test-+)
   (test-*)))

CL-USER&amp;gt; (test-arithmetic)
pass ... (= (+ 1 2) 3)
pass ... (= (+ 1 2 3) 6)
pass ... (= (+ -1 -3) -4)
pass ... (= (* 2 2) 4)
pass ... (= (* 3 5) 15)
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于打印结果的代码位于report-result中，因此需要传递信息告诉report-result当前运行的函数的信息。可以在report-result中添加一个参数来传递这个信息，但是由宏生成的代码调用report-result，并不知道当前运行的函数的信息。这意味着要修改调用check的方法，将函数信息传递给check然后由它传递给report-result吗？&lt;/p&gt;
&lt;p&gt;解决这种问题的方法是使用动态变量。创建一个动态变量，在调用每个测试函数之前，将测试函数名称绑定到这个动态变量中，report-result并不需要添加参数。&lt;/p&gt;
&lt;p&gt;在最外部申明这个变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defvar *test-name* nil)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在report-result的FORMAT中使用这个变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(format t "~:[FAIL~;pass~] ... ~a: ~a~%" result *test-name* form)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样修改后再运行test-arithmetic将变成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (test-arithmetic)
pass ... NIL: (= (+ 1 2) 3)
pass ... NIL: (= (+ 1 2 3) 6)
pass ... NIL: (= (+ -1 -3) -4)
pass ... NIL: (= (* 2 2) 4)
pass ... NIL: (= (* 3 5) 15)
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是由于动态变量没有绑定。因此还需要修改两个测试函数，让它们在执行check前先绑定动态变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun test-+ ()
  (let ((*test-name* 'test-+))
    (check
      (= (+ 1 2) 3)
      (= (+ 1 2 3) 6)
      (= (+ -1 -3) -4))))

(defun test-* ()
  (let ((*test-name* 'test-*))
    (check
      (= (* 2 2) 4)
      (= (* 3 5) 15))))


CL-USER&amp;gt; (test-arithmetic)
pass ... TEST-+: (= (+ 1 2) 3)
pass ... TEST-+: (= (+ 1 2 3) 6)
pass ... TEST-+: (= (+ -1 -3) -4)
pass ... TEST-*: (= (* 2 2) 4)
pass ... TEST-*: (= (* 3 5) 15)
T
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;抽象概念的崛起&lt;/h2&gt;
&lt;p&gt;在修正测试函数的过程中，你又引入了一些重复。除函数包含了函数名两次之外&amp;mdash;&amp;mdash;一次是在defun中，另一次是将它绑定到&lt;code&gt;*test-name*&lt;/code&gt;变量上，还有两个测试函数的三行代码所使用的模式是一样的。你可以将这些重复简单的删除，理由是重复是不好的。但是如果你仔细观察产生重复的根源，你将学习到关于使用宏的重要的一课。&lt;/p&gt;
&lt;p&gt;这些函数以相同的方式开始是因为它们都是测试函数。产生重复的原因在于，在这时，测试函数还只是半抽象的。抽象只存在于你的意识中，但是代码里并没有方法表达&amp;ldquo;这是一个测试函数&amp;rdquo;，而是按某种特殊的模式在编写代码。&lt;/p&gt;
&lt;p&gt;不幸的是，局部抽象构建软件的低劣的工具。因为半抽象是由代码的模式来表达的，你需要保证大规模的重复代码，其后果就是可维护性差。由于抽象只存在于程序员的意识中，没有机制确保不同的程序员（甚至同一程序员在不同的工作时间里）都能以相同的方式理解这个抽象。为了完整的表达这个抽象，你需要一个方法来表达&amp;ldquo;这是一个测试函数&amp;rdquo;并且按某一模式生成需要的代码。换句话来说，你需要一个宏。&lt;/p&gt;
&lt;p&gt;你需要封装的是一个DEFUN加上一些样板式的代码，你需要编写一个宏能展开成DEFUN。然后使用这个宏，而不是DEFUN来定义测试函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defmacro deftest (name parameters &amp;amp;body body)
  `(defun ,name ,parameters
    (let ((*test-name* ',name))
      ,@body)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用这个宏重写test-+：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(deftest test-+ ()
  (check
    (= (+ 1 2) 3)
    (= (+ 1 2 3) 6)
    (= (+ -1 -3) -4)))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;测试的层次&lt;/h2&gt;
&lt;p&gt;现在你已经将测试函数变成了一等公民，新问题出现了，test-arithmetic是一个测试函数吗？如果用deftest定义它，则它的名字会被绑定到&lt;code&gt;*test-name*&lt;/code&gt;，但这将在显示测试结果时被&lt;code&gt;test-+&lt;/code&gt;和&lt;code&gt;test-*&lt;/code&gt;的绑定屏蔽掉。&lt;/p&gt;
&lt;p&gt;设想一下你有成千上万个测试用例需要整理。第一级被组织到类似&lt;code&gt;test-+&lt;/code&gt;和&lt;code&gt;test-*&lt;/code&gt;的测试函数中，它们直接调用check。但是针对成千上万的测试，你将会需要按层次来组织它们。类似test-arithmetic的函数可以将相关的测试函数组织到测试套件中。假设某些低层次的测试方法被多个不同的测试套件调用。没有信息能告诉你它是在哪个测试套件中出错的。&lt;/p&gt;
&lt;p&gt;针对test-arithmetic做一些小调整，你就能得到出错的测试用例的完整路径（包含测试套件的名称）。使得测试的输出类似下面的格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pass ... (TEST-ARITHMETIC TEST-+): (= (+ 1 2) 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这可以通过让&lt;code&gt;*test-name*&lt;/code&gt;保存测试函数的列表，而不是只保存最近一次定义中所使用的名称，只需要将下面的语句修改一下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(let ((*test-name* ',name))
(let ((*test-name* (append *test-name* (list ',name))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改后需要用deftest重新定义test-arithmetic。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(deftest test-arithmetic ()
  (combine-results
   (test-+)
   (test-*)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样整个测试的结果将显示为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (test-arithmetic)
pass ... (TEST-ARITHMETIC TEST-+): (= (+ 1 2) 3)
pass ... (TEST-ARITHMETIC TEST-+): (= (+ 1 2 3) 6)
pass ... (TEST-ARITHMETIC TEST-+): (= (+ -1 -3) -4)
pass ... (TEST-ARITHMETIC TEST-*): (= (* 2 2) 4)
pass ... (TEST-ARITHMETIC TEST-*): (= (* 3 5) 15)
T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样即使测试套件的层次增加，你在测试结果中仍然可以得到完整的路径：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(deftest test-math ()
  (test-arithmetic))

CL-USER&amp;gt; (test-math)
pass ... (TEST-MATH TEST-ARITHMETIC TEST-+): (= (+ 1 2) 3)
pass ... (TEST-MATH TEST-ARITHMETIC TEST-+): (= (+ 1 2 3) 6)
pass ... (TEST-MATH TEST-ARITHMETIC TEST-+): (= (+ -1 -3) -4)
pass ... (TEST-MATH TEST-ARITHMETIC TEST-*): (= (* 2 2) 4)
pass ... (TEST-MATH TEST-ARITHMETIC TEST-*): (= (* 3 5) 15)
T
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;上面测试框架的完整代码如下，只有26行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defvar *test-name* nil)

(defmacro deftest (name parameters &amp;amp;body body)
  "Define a test function. Within a test function we can call
   other test functions or use 'check' to run individual test
   cases."
  `(defun ,name ,parameters
    (let ((*test-name* (append *test-name* (list ',name))))
      ,@body)))

(defmacro check (&amp;amp;body forms)
  "Run each expression in 'forms' as a test case."
  `(combine-results
    ,@(loop for f in forms collect `(report-result ,f ',f))))

(defmacro combine-results (&amp;amp;body forms)
  "Combine the results (as booleans) of evaluating 'forms' in order."
  (with-gensyms (result)
    `(let ((,result t))
      ,@(loop for f in forms collect `(unless ,f (setf ,result nil)))
      ,result)))

(defun report-result (result form)
  "Report the results of a single test case. Called by 'check'."
  (format t "~:[FAIL~;pass~] ... ~a: ~a~%" result *test-name* form)
  result)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;值得回顾一下得到上面的代码的整个过程，因为它描绘出了通常情况下怎样编写Lisp程序。&lt;/p&gt;
&lt;p&gt;我们开始于为这个问题定义一个简单的版本&amp;mdash;&amp;mdash;如何执行一堆布尔类型的表达式并检查它们是否都返回true。这只需要使用AND将它们连接起来，但是还需要更好的显示测试结果。所以我们又编写了一些充满重复和容易出错的代码能以我们需要的方式显示测试结果。&lt;/p&gt;
&lt;p&gt;下一步我们重构了第二个版本得到了简洁的代码。首先是使用标准的重构技术将一些代码放到了函数report-result中。不幸的是，我们发现使用report-result时仍然是乏味且容易出错的，因为需要传递两次测试表达式，一次用于得到表达式的值另一次是将表达式本身作为数据。因此我们又编写了check宏自动生成对report-result调用的细节。&lt;/p&gt;
&lt;p&gt;当编写check时，我们意识到可以在单次check调用中可以生成多次对report-result的调用，这让我们回到了最初的最精简的使用AND的版本。&lt;/p&gt;
&lt;p&gt;这时check API已经固定下来，因为你可以直接修改它的内部来影响它的工作方式。下一个任务是修正代码让它返回一个值来标识整个测试是否全部通过。我们没有立即来hacking check方法，而是幻想设计一个小型的语言。幻想有一个没有AND的短路行为的控制结构。但是我们意识到没有那样的结构，但是我们可以编写一个这样的结构。编写完combine-results后，才发现对check的修正确实是微不足道的。&lt;/p&gt;
&lt;p&gt;现在只需要提升显示测试结果了。开始修改test函数时，我们认识到这些函数代表了一个特殊的函数分类，它们应该要有自己的抽象。因此我们编写了deftest来抽象测试函数的编码模式。&lt;/p&gt;
&lt;p&gt;deftest提供了抽象测试定义和下层机构间的抽象屏障，我们可以提升测试结果的显示而不需要动测试函数。&lt;/p&gt;
&lt;h1&gt;数字、字符和字符串&lt;/h1&gt;
&lt;h1&gt;集合&lt;/h1&gt;
&lt;p&gt;Lisp不光只是提供了List类型，同样有类似其它语言中的arrays、vectors、maps等结构。&lt;/p&gt;
&lt;h2&gt;Vectors&lt;/h2&gt;
&lt;p&gt;Vector是Common Lisp中以整数作为索引的集合，有两种口味。固定长度的类似于其它语言中的数组：一块连续的内存保存了vector的元素。另一种是可变长度的vectors，它与Perl或Ruby中的数组或Java中的ArrayList类更接近：它们抽象了初建的存储，允许vector增长和收缩以增加或删除元素。&lt;/p&gt;
&lt;p&gt;可以向VECTOR函数传递任意数量的参数以构建固定长度的vector。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(vector)     ==&amp;gt; #()
(vector 1)   ==&amp;gt; #(1)
(vector 1 2) ==&amp;gt; #(1 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;#(...)&lt;/code&gt;标记法能被Lisp printer和reader使用。这种语法让你可以通过PRINTing输出和READing读入来保存和恢复vector。你也可以在代码中直接使用这种标记方法，但是你应该使用VECTOR或更为通用的函数MAKE_ARRAY来创建需要修改的vectors。&lt;/p&gt;
&lt;p&gt;MAKE-ARRAY是比VECTOR更通用是因为使用它可以创建任意维度的固定长度或可变长度的vector。MAKE-ARRAY需要一个list参数，它包含数组的维度。由于vector是一维数组，这个list将只包含一个数字，即vector的长度。为了方便使用，MAKE-ARRAY在接收单个元素的list参数的位置可以只接收一个数字作为参数。如果没有其它参数，MAKE-ARRAY将创建一个元素未初初始化的vector。为了将元素初始化为特定的值，你可以传递&lt;code&gt;:initial-element&lt;/code&gt;作为参数。例如，创建包含5个NIL元素的vector：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(make-array 5 :initial-element nil) ==&amp;gt; #(NIL NIL NIL NIL NIL)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MAKE-ARRAY也可以用于构建可变长度的vector。可变长度的vector比固定长度的vector稍复杂一些，它不仅需要跟踪用于保存实际使用了的元素的使用，还需要跟踪可用元素槽的数量。这个数字保存在vector的fill pointer里，这样称乎是因为它是下一次向vector中添加元素时将被填充的位置。&lt;/p&gt;
&lt;p&gt;为了构建一个带fill pointer的vector，你需要向MAKE-ARRAY中传递一个&lt;code&gt;:fill-pointer&lt;/code&gt;参数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(make-array 5 :fill-pointer 0) ==&amp;gt; #()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用VECTOR-PUSH函数向可变长度的vector尾部添加元素。它将元素添加到当前fill pointer指向的索引位置，并将fill pointer加1，并返回新添加的元素的索引位置。VECTOR-POP返回最近推入的元素，并将fill pointer的位置减1。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *x* (make-array 5 :fill-pointer 0))

(vector-push 'a *x*) ==&amp;gt; 0
*x*                  ==&amp;gt; #(A)
(vector-push 'b *x*) ==&amp;gt; 1
*x*                  ==&amp;gt; #(A B)
(vector-push 'c *x*) ==&amp;gt; 2
*x*                  ==&amp;gt; #(A B C)
(vector-pop *x*)     ==&amp;gt; C
*x*                  ==&amp;gt; #(A B)
(vector-pop *x*)     ==&amp;gt; B
*x*                  ==&amp;gt; #(A)
(vector-pop *x*)     ==&amp;gt; A
*x*                  ==&amp;gt; #()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，即使带fill pointer的vector也不完全是可变长度的。前面的&lt;code&gt;*x*&lt;/code&gt;最多只能保存5个元素。为了构建一个可变长度的vector，还需要向MAKE-ARRAY传递另一个关键字参数：&lt;code&gt;:adjustable&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(make-array 5 :fill-pointer 0 :adjustable t) ==&amp;gt; #()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样构建的可变长度的vector它的下层的内存可以按需要进行调整。使用VECTOR-PUSH-EXTEND向这种vector中添加元素，它与VECTOR-PUSH类似，但是它在向一个已经填满了的vector中推入新元素时它将自动扩展，它的fill pointer与下层存储的大小相同。&lt;/p&gt;
&lt;h2&gt;Vector的子类型&lt;/h2&gt;
&lt;p&gt;前面看到的vector是通用的可以保存任何类型的对象。可以创建某些特殊的vector限制它只能保存某些类型的元素。使用这种特殊的vector的原因是它们可以被存储者更紧凑可以比通用的vector提供更快的访问速度。&lt;/p&gt;
&lt;p&gt;字符串就是一种特殊的保存字符的vector。字符串的专用的操作函数。但是由于它们也是vector，因此下面讨论的接收vector参数的函数也可以用于字符串。&lt;/p&gt;
&lt;p&gt;字面量类型的字符串，例如&amp;ldquo;foo&amp;rdquo;，与字面量vector的&lt;code&gt;#()&lt;/code&gt;写法是一样的&amp;mdash;&amp;mdash;它的长度是固定的，并且不允许修改。但是，你可以向MAKE-ARRAY中传递关键字参数&lt;code&gt;:element-type&lt;/code&gt;构建可变长度的字符串。这个参数接收一个类型描述。这里不讨论它所有它可以接收的描述符；传递符号CHARACTER可以构建一个字符串。注意这个符号前要加引号以免它被当作变量名称。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(make-array 5 :fill-pointer 0 :adjustable t :element-type 'character)  ""
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bit vectors的元素都是零或一&amp;mdash;&amp;mdash;也得到了一些特殊的对待。它的read/print语法类似&lt;code&gt;#*00001111&lt;/code&gt;并且有相当多的函数可以使用。比如：对两个bit array执行&amp;ldquo;与&amp;rdquo;操作。创建bit vector时传递的&lt;code&gt;:element-type&lt;/code&gt;的符号为BIT。&lt;/p&gt;
&lt;h2&gt;Vector作为Sequence&lt;/h2&gt;
&lt;p&gt;Vector和list都是抽象类型sequence下的两个具体子类型。下面的章节所讨论的关于sequence的函数，都适用于普通或特殊类型的vector，也可以适用于list。&lt;/p&gt;
&lt;p&gt;LENGTH函数返回sequence的长度，ELT允许你根据整数索引访问序列中的元素。LENGTH只接收一个sequence参数并返回它包含的元素数量。对于fill pointer类型的vector，这个值将是fill pointer的值。ELT，是element的简写，接收一个sequence和整数索引号（零到sequence的长度之间）并返回相应位置的元素。如果索引越界，ELT将产生错误。与LENGTH类似ELT将带fill pointer的vector当作fill pointer指定长度的vector。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *x* (vector 1 2 3))

(length *x*) ==&amp;gt; 3
(elt *x* 0)  ==&amp;gt; 1
(elt *x* 1)  ==&amp;gt; 2
(elt *x* 2)  ==&amp;gt; 3
(elt *x* 3)  ==&amp;gt; error
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ELT也是一个SETFable的地方，因此你可以设置某个特定元素的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf (elt *x* 0) 10)

*x* ==&amp;gt; #(10 2 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Sequence迭代函数&lt;/h2&gt;
&lt;p&gt;理论上说对于sequence的操作将归结为LENGTH，ELT和对ELT的SETF操作的结合，Common Lisp提供了大量的用于sequence的函数库。&lt;/p&gt;
&lt;p&gt;每类函数允许你表达某一类sequence操作。例如不显式的编写循环来查找或过滤特定的元素。&lt;/p&gt;
&lt;p&gt;表11-1。基础sequence函数&lt;/p&gt;
&lt;p&gt;Name || Required Arguments || Returns
COUNT | Item and sequence | Number of times item appears in sequence
FIND | Item and sequence | Item or NIL
POSITION | Item and sequence | Index into sequence of NIL
REMOVE | Item and sequence | Sequence with instances of item removed
SUBSTITUTE | New item, item, and sequence | Sequence with instances of item replaced with new item&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(count 1 #(1 2 1 2 3 1 2 3 4))         ==&amp;gt; 3
(remove 1 #(1 2 1 2 3 1 2 3 4))        ==&amp;gt; #(2 2 3 2 3 4)
(remove 1 '(1 2 1 2 3 1 2 3 4))        ==&amp;gt; (2 2 3 2 3 4)
(remove #\a "foobarbaz")               ==&amp;gt; "foobrbz"
(substitute 10 1 #(1 2 1 2 3 1 2 3 4)) ==&amp;gt; #(10 2 10 2 3 10 2 3 4)
(substitute 10 1 '(1 2 1 2 3 1 2 3 4)) ==&amp;gt; (10 2 10 2 3 10 2 3 4)
(substitute #\x #\b "foobarbaz")       ==&amp;gt; "fooxarxaz"
(find 1 #(1 2 1 2 3 1 2 3 4))          ==&amp;gt; 1
(find 10 #(1 2 1 2 3 1 2 3 4))         ==&amp;gt; NIL
(position 1 #(1 2 1 2 3 1 2 3 4))      ==&amp;gt; 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意REMOVE和SUBSTITUTE总是返回与它的参数sequence类型一致的sequence。&lt;/p&gt;
&lt;h2&gt;高阶函数的变种&lt;/h2&gt;
&lt;p&gt;对于刚才讨论过的函数，Common Lisp提供了两个高阶函数变种，在接收的参数前添加一个函数参数，这个参数将对sequence的每个元素都调用一次。其中一套变种函数是在基础函数的后面添加&lt;code&gt;-IF&lt;/code&gt;后缀。这些函数将在作为参数的函数返回true时计数、查找、删除或者替换sequence中的元素。另一套变种函数是以&lt;code&gt;-IF-NOT&lt;/code&gt;结尾的，它将在参数函数不返回true时计数、查找、删除或者替换sequence中的元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(count-if #'evenp #(1 2 3 4 5))         ==&amp;gt; 2

(count-if-not #'evenp #(1 2 3 4 5))     ==&amp;gt; 3

(position-if #'digit-char-p "abcd0001") ==&amp;gt; 4

(remove-if-not #'(lambda (x) (char= (elt x 0) #\f))
  #("foo" "bar" "baz" "foom")) ==&amp;gt; #("foo" "foom")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;-IF&lt;/code&gt;和&lt;code&gt;-IF-NOT&lt;/code&gt;与前面讨论的那些不带后缀的函数接收相同的关键字参数除了：&lt;code&gt;:test&lt;/code&gt;参数不需要，因为带后缀的函数的第一个参数就是这个函数。&lt;code&gt;:key&lt;/code&gt;参数，它用于将从序列中得到的元素转换为传递给&lt;code&gt;:test&lt;/code&gt;函数的参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(count-if #'evenp #((1 a) (2 b) (3 c) (4 d) (5 e)) :key #'first)     ==&amp;gt; 2

(count-if-not #'evenp #((1 a) (2 b) (3 c) (4 d) (5 e)) :key #'first) ==&amp;gt; 3

(remove-if-not #'alpha-char-p
  #("foo" "bar" "1baz") :key #'(lambda (x) (elt x 0))) ==&amp;gt; #("foo" "bar")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;REMOVE族的函数还支持第四种变种，REMOVE-DUPLICATES，它只需要一个sequence参数，它会从中删除所有重复的元素。它与REMOVE函数接收相同的关键字参数，但是&lt;code&gt;:count&lt;/code&gt;除外，因为它总是会移除重复的元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(remove-duplicates #(1 2 1 2 3 1 2 3 4)) ==&amp;gt; #(1 2 3 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;处理整个Sequence&lt;/h2&gt;
&lt;p&gt;有少量函数可以在同一时间操作整个sequence（或多个sequence）。比如，COPY-SEQ和REVERSE都只接收一个sequence作为参数，并返回相同类型的sequence。OPY-SEQ返回的sequence包含它的参数相同的元素。REVERSE返回的sequence也包含与参数相同的元素但是元素顺序是相反的。注意，它们都复制元素&amp;mdash;&amp;mdash;返回的sequence是一个新的对象。&lt;/p&gt;
&lt;p&gt;CONCATENATE函数创建新的sequence，这个sequence包含所连接的任意数量的sequence。但是与REVERSE和COPY-SEQ不同，它们返回与参数类型相同的sequence。CONCATENATE必须显式的被告知在参数类型不同的情况下应该返回哪个类型的sequence。它的第一个参数是类型描述符，与MAKE-ARRAY的&lt;code&gt;:element-type&lt;/code&gt;参数类似。在这里，类型描述符通常是：VECTOR、LIST或STRING。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(concatenate 'vector #(1 2 3) '(4 5 6))    ==&amp;gt; #(1 2 3 4 5 6)
(concatenate 'list #(1 2 3) '(4 5 6))      ==&amp;gt; (1 2 3 4 5 6)
(concatenate 'string "abc" '(#\d #\e #\f)) ==&amp;gt; "abcdef"
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;排序和合并&lt;/h2&gt;
&lt;p&gt;SORT和STABLE-SORT函数提供了两个对sequence排序的方法。它们都接收一个sequence和一个predicate函数作为参数并返回排序后的sequence。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(sort (vector "foo" "bar" "baz") #'string&amp;lt;) ==&amp;gt; #("bar" "baz" "foo")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个函数不同之处在于STABLE-SORT保证不会重新排序相等的元素，而SORT有可能会对相等的元素重新排序。&lt;/p&gt;
&lt;p&gt;这些函数是&amp;ldquo;破坏性&amp;rdquo;函数的例子。破坏性函数允许&amp;mdash;&amp;mdash;通常是基于效率原因&amp;mdash;&amp;mdash;以任意方法或多或少的修改它们的参数。这有两个含义：其一，你总是应该对这些函数的返回值做某些处理（比如将它赋值给变量或将它传递到其它的函数），其二，除非你对将要传递给破坏性函数的参数已经操作完毕了，否则你应该传递它的拷贝。&lt;/p&gt;
&lt;p&gt;通常在排序后你不会关心未排序的版本，因此有意允许SORT和STABLE-SORT在排序过程中销毁sequence。这意味着你需要记得将代码写成下面的样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf my-sequence (sort my-sequence #'string&amp;lt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf my-sequence (sort my-sequence #'string&amp;lt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些函数也接收一个关键字参数，&lt;code&gt;:key&lt;/code&gt;，它与其它sequence函数中的&lt;code&gt;:key&lt;/code&gt;参数类似，它是一个可以将元素转换为传递给predicate函数作参数的函数。这个解析出来的key只是用于决定元素的排序；返回原sequence仍将包含参数sequence中的元素。&lt;/p&gt;
&lt;p&gt;MERGE函数接收两个sequence和一个predicate，并返回一个根据predicate由两个sequence合并而成的sequence。这与两个排序函数有关如果两个sequence都已经由相同的predicate排序过，则MERGE所返回的sequence将也被排序。与排序函数类似，MERGE也接收&lt;code&gt;:key&lt;/code&gt;关键字参数。与CONCATENATE函数类似，基于同样的原因，传递给MERGE的第一个参数用于指定要构造的sequence的类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(merge 'vector #(1 3 5) #(2 4 6) #'&amp;lt;) ==&amp;gt; #(1 2 3 4 5 6)
(merge 'list #(1 3 5) #(2 4 6) #'&amp;lt;)   ==&amp;gt; (1 2 3 4 5 6)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;subsequence处理&lt;/h2&gt;
&lt;p&gt;最基础的函数是SUBSEQ，它从一个sequence中从特定的开始位置到结束位置提取子sequence。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(subseq "foobarbaz" 3)   ==&amp;gt; "barbaz"
(subseq "foobarbaz" 3 6) ==&amp;gt; "bar"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SUBSEQ也是SETFable的，但是它不会扩展或缩短sequence；如果新值和将被替换的subsequence的长度不同，较短的那个将决定实际将替换多少个。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *x* (copy-seq "foobarbaz"))

(setf (subseq *x* 3 6) "xxx")  ; subsequence and new value are same length
*x* ==&amp;gt; "fooxxxbaz"

(setf (subseq *x* 3 6) "abcd") ; new value too long, extra character ignored.
*x* ==&amp;gt; "fooabcbaz"

(setf (subseq *x* 3 6) "xx")   ; new value too short, only two characters changed
*x* ==&amp;gt; "fooxxcbaz"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用FILL函数将sequence中的多个元素设置为同一个值。需要的参数是一个sequence和将被填充的值。默认情况下sequence的所有元素都会被设置为这个值；&lt;code&gt;:start&lt;/code&gt;和&lt;code&gt;:end&lt;/code&gt;关键字参数可以限制它所影响的subsequence。&lt;/p&gt;
&lt;p&gt;如果你需要在sequence中查找subsequence，可以像使用POSITION一样使用SEARCH函数，除了它的第一个参数是一个sequence而不是单个元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(position #\b "foobarbaz") ==&amp;gt; 3
(search "bar" "foobarbaz") ==&amp;gt; 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了查找出两个sequence是从哪里开始有不同元素的可以使用MISMATCH函数。它接收两个sequence并返回第一个不匹配的元素的索引。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(mismatch "foobarbaz" "foom") ==&amp;gt; 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果字符串匹配它将返回NIL。MISMATCH也可以接收许多标准的关键字参数&lt;code&gt;:key&lt;/code&gt;参数指定提取进行比较的值的函数；&lt;code&gt;:test&lt;/code&gt;参数指定比较函数；&lt;code&gt;:start1&lt;/code&gt;，&lt;code&gt;:end1&lt;/code&gt;，&lt;code&gt;:start2&lt;/code&gt;，&lt;code&gt;:end2&lt;/code&gt;用于指定两个sequence中的subsequence。&lt;code&gt;:from-end&lt;/code&gt;参数为T时表示应该从后面开始搜索，这时将返回从后面开始查找直到遇到不同元素时的在第一个sequence中的索引。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(mismatch "foobar" "bar" :from-end t) ==&amp;gt; 3
(mismatch "fooobar" "bar" :from-end t) ==&amp;gt; 4
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Sequence Predicates&lt;/h2&gt;
&lt;p&gt;有四个方便的函数EVERY、SOME、NOTANY和NOTEVERY，它们迭代整个sequence并使用predicate进行测试。它们的第一个参数是一个preicate函数，后面的参数是sequencesp。Predicate函数应该能接收sequence传递给它的所有参数。每次从sequence中取一个元素传递给predicate&amp;mdash;&amp;mdash;直到元素都处理完或者遇到终止测试：在遇到某个predicate失败时整个EVERY终上，并返回false。如果predicate总是成立，则它返回true。SOME返回第一个由predicate返回的非NIL值，或者在所有predicate都不成立时返回false。NOTANY在遇到某个predicate满足条件时返回true或者在所有predicate都不成立时返回false。NOTEVERY在predicate失败时返回true或者在所有predicate都成立时返回false。一些例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(every #'evenp #(1 2 3 4 5))    ==&amp;gt; NIL
(some #'evenp #(1 2 3 4 5))     ==&amp;gt; T
(notany #'evenp #(1 2 3 4 5))   ==&amp;gt; NIL
(notevery #'evenp #(1 2 3 4 5)) ==&amp;gt; T
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(every #'&amp;gt; #(1 2 3 4) #(5 4 3 2))    ==&amp;gt; NIL
(some #'&amp;gt; #(1 2 3 4) #(5 4 3 2))     ==&amp;gt; T
(notany #'&amp;gt; #(1 2 3 4) #(5 4 3 2))   ==&amp;gt; NIL
(notevery #'&amp;gt; #(1 2 3 4) #(5 4 3 2)) ==&amp;gt; T
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Sequence Mapping函数&lt;/h2&gt;
&lt;p&gt;MAP与predicate函数类似，接收一个n-argument函数和n个sequences。但是它不是返回boolean值，MAP返回新的sequence包含将函数应用到sequence元素的返回值。与CONCATENATE、MERGE类似，MAP也需要知道要构建出什么样的sequence。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(map 'vector #'* #(1 2 3 4 5) #(10 9 8 7 6)) ==&amp;gt; #(10 18 24 28 30)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MAP-INTO与MAP类似它不是构建一个给定类型的sequence，而是它将结果放到一个sequence并将它作为第一个参数传递。这个sequence可以是向函数提供值的sequence。例如，汇总多个vectors&amp;mdash;&amp;mdash;a、b和c，可以写成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(map-into a #'+ a b c)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果sequences的长度不相等，MAP-INTO只会影响最短的sequence那个长度的元素数量，包括将要mapped into的那个sequence。但是，如果将要mapped into的vector是fill pointer的，则受影响的元素个数不限制于fill pointer而是受限于vector实际的大小。在调用完MAP-INTO，fill pointer将被设置为mapped的元素的数量。但是，MAP-INTO不会扩展一个可扩展的vector。&lt;/p&gt;
&lt;p&gt;最后一个sequence函数是REDUCE，它执行另一类型的mapping：它遍历单个sequence，调用一个接收两个参数的函数，首先使用sequence的头两个元素作为参数，然后使用返回值和sequence中后面的元素作为参数。因此，下面的语句表达的是对1到10进行求和：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(reduce #'+ #(1 2 3 4 5 6 7 8 9 10)) ==&amp;gt; 55
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;REDUCE在当你需要将一个sequence处理为单一值时非常有用，当你使用它来表达时也非常的简洁。例如，查找sequence中的最大值，你可以写作&lt;code&gt;(reduce #'max numbers)&lt;/code&gt;。REDUCE也可以接收所有的关键字参数&lt;code&gt;(:key, :from-end, :start, :end)&lt;/code&gt;，并能接收一个独特的&lt;code&gt;(:initial-value)&lt;/code&gt;参数。它指定一个逻辑上放在sequence最前面的值（或者在你指定了&lt;code&gt;:from-end&lt;/code&gt;时放在sequence的最后面）。&lt;/p&gt;
&lt;h2&gt;Hash Tables&lt;/h2&gt;
&lt;p&gt;Common lisp提供的另一种通用集合是hash table。vector提供整型索引的数据结构，Hash table则允许你使用任意类型的对象作为索引，或keys。当你向hash table中添加新值时，你将它存储于一个特定的key下。后面你可以使用相同的key来访问这个值。或者你也可以使用相同的key来关联新值&amp;mdash;&amp;mdash;每个key对应于单个值。&lt;/p&gt;
&lt;p&gt;当使用无参数的MAKE-HASH-TABLE构建hash table时会使用EQL来判断两个key是否相等。这是一个很好的默认值，除非你需要使用字符串作为key，因为两个包含相同内容的字符串并不一定是EQL的。这种情况下你需要告诉hash table使用EQUAL来检查key是否相等，你可以向MAKE-HASH-TABLE函数传递一个关键字参数&lt;code&gt;:test&lt;/code&gt;，它的值为EQUAL符号。&lt;code&gt;:test&lt;/code&gt;的另外两个可能的值为符号EQ和EQUALP。这些是标准对象的比较函数的名称。与传递给sequence函数的&lt;code&gt;:test&lt;/code&gt;参数不同，MAKE-HASH-TABLE的&lt;code&gt;:test&lt;/code&gt;参数不允许传递任意的函数&amp;mdash;&amp;mdash;只允许EQ，EQL，EQUAL和EQUALP。这是因为hash table实际上需要两个函数，一个用于测试相等性，另一个hash函数用于从key计算出数值类型的hash code值，它能用于最终作为比较两个keys的值。尽管语言标准只允许使用标准的相等性测试函数，但是多数实现中都提供了某些机制自定义hash table。&lt;/p&gt;
&lt;p&gt;GETHASH函数提供了访问hash table元素的功能。它接收两个参数&amp;mdash;&amp;mdash;key和hash table&amp;mdash;&amp;mdash;并返回值，如果不存在则返回NIL。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *h* (make-hash-table))

(gethash 'foo *h*) ==&amp;gt; NIL

(setf (gethash 'foo *h*) 'quux)

(gethash 'foo *h*) ==&amp;gt; QUUX
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于GETHASH将在key不存在时返回NIL，因此没有办法从返回值知道hash table中是不存在那个key还是key所对应的值为NIL。GETHASH使用了一个我们还没有使用过的特性来解决这个问题&amp;mdash;&amp;mdash;多返回值。GETHASH实际上返回了两个值；主要的值是存储于key下的值或者NIL。次要的值是一个boolean类型的值标识key是否存在于hash table中。由于多返回值的工作方式，这个特殊的返回值被丢弃掉除非调用者显式的处理它才能&amp;ldquo;看到&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;后面的章节将讨论多返回值，但这里我们将了解一下如何使用MULTIPLE-VALUE-BIND宏来从GETHASH中得到特殊的返回值。MULTIPLE-VALUE-BIND将与LET类似创建一个变量，并使用多返回值来填充它们。&lt;/p&gt;
&lt;p&gt;下面的函数展示了你可以使用MULTIPLE-VALUE-BIND；变量将绑定到value和present：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun show-value (key hash-table)
  (multiple-value-bind (value present) (gethash key hash-table)
    (if present
      (format nil "Value ~a actually present." value)
      (format nil "Value ~a because key not found." value))))

(setf (gethash 'bar *h*) nil) ; provide an explicit value of NIL

(show-value 'foo *h*) ==&amp;gt; "Value QUUX actually present."
(show-value 'bar *h*) ==&amp;gt; "Value NIL actually present."
(show-value 'baz *h*) ==&amp;gt; "Value NIL because key not found."
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于设置某个key对应的值为NIL后，这个key仍然会存在于table中，因此你需要另一个函数将键值对完全从hash table中删除。REMHASH接收GETHASH相同的参数并将移除相应的键值对。你也可以使用CLRHASH来清空hash table中的所有键值对。&lt;/p&gt;
&lt;h2&gt;Hash Table迭代&lt;/h2&gt;
&lt;p&gt;Common Lisp提供了一些方法迭代hash table的所有entries。最简单的是通过MAPHASH函数。类似MAP函数，MAPHASH接收一个接收两个参数的函数和一个hash table并使用hash table中的键值对依次调用这个函数。例如，打印hash table中的所有键值对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(maphash #'(lambda (k v) (format t "~a =&amp;gt; ~a~%" k v)) *h*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在迭代过程中向hash table中添加或删除元素的结果不明确（通常会是不好的）：你可以使用SETF和GETHASH修改当前entry的值，使用REMHASH移除当前的entry。例如，移除所有值小于10的entries，可以写成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(maphash #'(lambda (k v) (when (&amp;lt; v 10) (remhash k *h*))) *h*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一迭代整个hash table的方法是使用扩展过的LOOP宏，下面的LOOP与第一个MAPHASH表达式是等效的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(loop for k being the hash-keys in *h* using (hash-value v)
  do (format t "~a =&amp;gt; ~a~%" k v))
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;叫作LISP的原因：List Processing&lt;/h1&gt;
&lt;p&gt;List在Lisp中扮演了一个重要的角色&amp;mdash;&amp;mdash;这是由于历史原因也是由于实际的需要。历史上，lists是Lisp原来的复合数据类型，尽管它已经存在十年了。现在，Common Lisp程序员可以使用vector、hash table或用户定义的类或结构而不只是使用list。&lt;/p&gt;
&lt;p&gt;从实际上来说，lists仍然存在于语言中因为它们对某些问题来说是优秀的解决方法。比如&amp;mdash;&amp;mdash;在使用宏时将代码当作数据来处理，这也可以解释为什么其它语言中不会觉得缺少Lisp风格的lists。更一般的来说，lists是一种用于描述混合的和/或有层次结构的数据优秀的结构。它也很轻量级并且支持函数式编程风格。&lt;/p&gt;
&lt;h2&gt;"There Is No List"&lt;/h2&gt;
&lt;p&gt;List的大部分特性是基于cons cells的，使用CONS函数可以构建它。&lt;/p&gt;
&lt;p&gt;CONS接收两个参数返回一个包含这两个值的cons cell。这两个值可以是指向任何对象。除非第二个值是NIL或另一个cons cell，cons总是被打印为括号中的以点号分开的两个值，因此也被称作dotted pair。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(cons 1 2) ==&amp;gt; (1 . 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cons cell的两个值被称作CAR和CDR，可以用同名的函数来访问它们。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(car (cons 1 2)) ==&amp;gt; 1
(cdr (cons 1 2)) ==&amp;gt; 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CAR和CDR都是SETFable的，例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *cons* (cons 1 2))
*cons*                 ==&amp;gt; (1 . 2)
(setf (car *cons*) 10) ==&amp;gt; 10
*cons*                 ==&amp;gt; (10 . 2)
(setf (cdr *cons*) 20) ==&amp;gt; 20
*cons*                 ==&amp;gt; (10 . 20)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于cons cell中的值可以指向任何类型的对象，因此可以通过将cons cells连接起来构建大型的数据结构。List是通过将cons cells链接成链。list中的元素保存在cons cell的CAR中，后面的subsequence保存在cons cell的CDR中。最后一个cell的CDR为NIL&amp;mdash;&amp;mdash;它表示空的list或boolean值false。&lt;/p&gt;
&lt;p&gt;单向链表。&lt;/p&gt;
&lt;p&gt;因此在讲到某个值为list时，它可能为NIL也可能指向一个cons cell。Lisp printer不会将lists打印成dotted pair格式，而是打印成括号包含的list格式。&lt;/p&gt;
&lt;p&gt;FIRST和REST是CAR和CDR的同义词。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *list* (list 1 2 3 4))
(first *list*)        ==&amp;gt; 1
(rest *list*)         ==&amp;gt; (2 3 4)
(first (rest *list*)) ==&amp;gt; 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为cons cells可以保存任意类型的值，因此单个list中可以包含不同类型的对象。&lt;/p&gt;
&lt;h2&gt;函数式编程和List&lt;/h2&gt;
&lt;p&gt;函数式编程的本质是构建不带副作用的函数，它只依赖于它的参数计算出结果。好处是让程序易于理解。消除副作用消除了所有可能的超距离作用。因为函数的结果只取决于它的参数，因此它的行为易于理解和测试。&lt;/p&gt;
&lt;p&gt;处理数字的函数自然就是函数式的因为数字本身就是不可变的。但是List则是可变的，比如在cons cell的CAR和CDR上使用SETF。但是list也可以被当作是函数式的数据类型，如果你将它们的值当作由它们所包含的元素来决定。因此(1 2 3 4)这个list与任何包含这4个数的list是函数性（functionally）相等的，而不管它们是否由相同的cons cells构成。接收这个list作为参数，并依照这个list的内容生成返回值的函数就被认为是函数式的。例如，REVERSE函数，给予参数(1 2 3 4)，后总是返回(4 3 2 1)。以不同的函数性相等的list参数调用REVERSE时得到的是函数性相等的list。函数式编程的另一方面是，使用高阶函数：函数将其它函数当作数据，将它们作为参数或返回值。&lt;/p&gt;
&lt;p&gt;多数list函数被编写为函数式是因为它们的返回值与它们的参数共享cons cells。比如APPEND接收任意数量的list参数并返回一个新的包含了所有参数中的元素的list。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(append (list 1 2) (list 3 4)) ==&amp;gt; (1 2 3 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从函数式的观点来看，APPEND的工作是返回list (1 2 3 4)而不修改list(1 2)和(3 4)中的任何cons cells。很显然达到这一目的的方法是构建一个包含4个新cons cells的全新的list。但这必然要做更多的工作。因此，APPEND实际上只创建了两个新的cons cells保存1和2，然后将它们与最后一个参数(3 4)的CDR连接起来。然后返回包含1的cons cell。原始的cons cells都没有改变，结果也是正确的list (1 2 3 4)。唯一的瑕疵是返回的list与list (3 4)共享了一些cons cells。&lt;/p&gt;
&lt;p&gt;按前面的办法APPEND必须复制所有它的参数，但它可以的返回值与最后一个参数共享了结构。&lt;/p&gt;
&lt;p&gt;其它函数也以类似的方式从共享结构中得到好处。APPEND总是返回共享结构。其它函数则依赖于具体的实现了。&lt;/p&gt;
&lt;h2&gt;"Destructive"操作&lt;/h2&gt;
&lt;p&gt;如果Common Lisp是一种纯函数式语言，那故事到此就结束了。但是它允许使用SETF修改CAR或CDR，我们要更多的考虑共享结构的副作用。&lt;/p&gt;
&lt;p&gt;因为Lisp的函数式传统，修改已有对象的操作被称为destructive，改变对象的状态&amp;ldquo;destroys&amp;rdquo;了它因为它不再表述与原值相同的值了。但是，使用相同术语描述所有状态改变的操作将导致某种困惑因此有两种不同类型的destructive操作，for-side-effect操作和recycling操作。&lt;/p&gt;
&lt;p&gt;For-side-effect操作是那些使用它们是因为需要它们的副作用。所有使用SETF都是这种情况，其它使用了SETF的函数也是这种情况，比如VECTOR-PUSH或VECTOR-POP。但是将这些操作当作destructive操作些不公平&amp;mdash;&amp;mdash;它们并不是在函数式风格的代码中故意被编写，因此它们不应该讨论它们是否使用函数式技术。但是，如果你混合了非函数式风格，for-side-effect操作的函数返回了共享结构的结果，则你要小心而不要去修改共享结构。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *list-1* (list 1 2))
(defparameter *list-2* (list 3 4))
(defparameter *list-3* (append *list-1* *list-2*))

*list-1*                  ==&amp;gt; (1 2)
*list-2*                  ==&amp;gt; (3 4)
*list-3*                  ==&amp;gt; (1 2 3 4)

(setf (first *list-2*) 0) ==&amp;gt; 0
*list-2*                  ==&amp;gt; (0 4)     ; as expected
*list-3*                  ==&amp;gt; (1 2 0 4) ; maybe not what you wanted
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种类型的destructive操作，recycling操作，是有意出现在函数式代码中的。它们的副作用是由于优化。特别是重用参数中的某些cons cells来构建结果。然而与APPEND之类的函数不同的是，在APPEND中是征用并包含cons cells，不修改参数的list，recycling函数会将cons cells作为原材料，修改CAR和CDR来构建想要的结果。因此，recycling函数只在原始的lists不再被需要时才能被安全的使用。&lt;/p&gt;
&lt;p&gt;为了解recycling函数如何工作，让我们比较一下REVERSE，它是nondestructive的，返回一个排过序的sequence，NREVERSE是这个函数的recycling版本。由于REVERSE不修改它的参数，它必须要给需要被排序的list中的每个元素都分配一个新的cons cell。但你可以会编写下面这样的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf *list* (reverse *list*))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过将REVERSE的结果重新赋给&lt;code&gt;*list*&lt;/code&gt;，这将会移除&lt;code&gt;*list*&lt;/code&gt;原始指向的值的引用。list中原来的值将不再被引用，它们将有可能被垃圾收集器收集。但是，在许多Lisp实现中更有效的做法是立即使用已经存在的cons cells而不是重新分配一个新的而让原来的变成垃圾。&lt;/p&gt;
&lt;p&gt;NREVERSE允许你执行这样的操作。N表示non-consing，意味着你不需要分配任何新的cons cells。NREVERSE的副作用细节在这里不进行细究&amp;mdash;&amp;mdash;它允许修改list中任何cons cell的CAR和CDR&amp;mdash;&amp;mdash;但是通常的实现可能会遍历list来修改每个cons cell的CDR让它指向前一个cons cell，最后返回旧的list的最后一个cons cell，它现在变成了逆序后的list的头。这个过程没有必要分配新的cons cells，也没有产生垃圾。&lt;/p&gt;
&lt;p&gt;多数类似NREVERSE的recycling函数，都有nondestructive的对等的函数。通常recyling函数有non-destructive相同的名字除了它们前面以N开头。但是，并不全是这样的，这包含了一些常用的更常用的recyling函数，比如NCONC，它是APPEND的recyling版本，DELETE，DELETE-IF，DELETE-IF-NOT和DELETE-DUPLICATES，它是REMOVE族函数的recyling版本。&lt;/p&gt;
&lt;p&gt;通常，可以像使用nondestructive函数一样使用recyling函数但是你要知道函数返回后参数不再需要被作用。不要依赖于recyling函数的副作用。&lt;/p&gt;
&lt;p&gt;但是一小撮recyling函数的副作用却可以依赖。比如NCONC，APPEND的recyling版本，和NSUBSTITUTE和它的-IF和-IF-NOT变种，它们是SUBSTITUTE等的recyling版本。&lt;/p&gt;
&lt;p&gt;与APPEND一样，NCONC返回拼接了参数的list，但它以下面的方式构建返回值：对于每个非空list，NCONC将这个list的最后一个cons cell的CDR指向下一个非空list的第一个cons cell。它返回第一个list，这个list是整个结果的头部了。因此：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defparameter *x* (list 1 2 3))

(nconc *x* (list 4 5 6)) ==&amp;gt; (1 2 3 4 5 6)

*x* ==&amp;gt; (1 2 3 4 5 6)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NSUBSTITUTE及其变种也可以依赖，它遍历list结构将保存旧值的cons cells设置为新值或者让它保存不变。然后返回原始的list，它与SUBSTITUTE返回的值相同。&lt;/p&gt;
&lt;p&gt;关键是要记得对于不依赖于recyling函数的副作用这条规则来说&amp;mdash;&amp;mdash;NCONC和NSUBSTITUTE的是个例外。比较理想的办法是与其它recyling函数一样忽略它们的副作用，只使用它们的返回值。&lt;/p&gt;
&lt;h2&gt;组合recyling和共享结构&lt;/h2&gt;
&lt;p&gt;尽管你可以在调用完recycling函数后不再使用参数，但是值得注意的是每个recyling函数都是一把指向脚面的上了膛的枪：如果你不小心在后面使用了recyling函数的参数，你可能会丢掉几个脚趾。&lt;/p&gt;
&lt;p&gt;为了让事情变得更糟，共享结构和recyling函数通常是目的相反的。Nondestructive list函数返回共享结构的list符合cons cells没有被修改的意愿，但是recyling函数的工作方式则违背了这个意愿。或者，换一种说法，共享结构的前提是基于你不在意到底是哪些cons cells构成了list但使用recyling函数则需要你明确的知道cons cells指向了哪里。&lt;/p&gt;
&lt;p&gt;实际上，recyling函数往往使用在几个惯用的地方。最常见的情况是使用使用&amp;ldquo;consing&amp;rdquo;将元素加到list的前面构建一个list，通常是PUSH元素到list并保存于本地变量然后返回将它NREVERSE后的结果。&lt;/p&gt;
&lt;p&gt;这是一种高效的构建list的做法因为每次PUSH都只创建了一个cons cell修改了一个局部变量并且NREVERSE只是zip down the list并修改它的CDR。因为这个list只在函数内部被创建，因此对函数的外部对任何cons cells有引用的代码来说没有危险。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(defun upto (max)
  (let ((result nil))
    (dotimes (i max)
      (push i result))
    (nreverse result)))

(upto 10) ==&amp;gt; (0 1 2 3 4 5 6 7 8 9)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一个惯用的地方是立即重新赋值给潜在的将被回收的变量。比如DELETE函数，REMOVE的recyling版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf foo (delete nil foo))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将让foo指向它的旧值，只是所有的NIL都被删除了。但是，即使是这种用法也要小心&amp;mdash;&amp;mdash;如果foo与其它地方的list共享结构，使用DELETE替代REMOVE可能会破坏那些list结构。例如，假定&lt;code&gt;*list-2*&lt;/code&gt;和&lt;code&gt;*list-３*&lt;/code&gt;共享他们的最后两个cons cells。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*list-2* ==&amp;gt; (0 4)
*list-3* ==&amp;gt; (1 2 0 4)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下面的方法从&lt;code&gt;*list-3*&lt;/code&gt;中删除4：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf *list-3* (delete 4 *list-3*)) ==&amp;gt; (1 2 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DELETE将第三个cons cell的CDR设置为NIL，将它与第4个cons cell从list中断开。因为&lt;code&gt;*list-3*&lt;/code&gt;中的第3个cons cell也是&lt;code&gt;*list-2*&lt;/code&gt;中的第1个cons cell，&lt;code&gt;*list-2*&lt;/code&gt;将变为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*list-2* ==&amp;gt; (0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果使用REMOVE来代替DELETE，将构造出包含值1,2和0的list，创建新的cons cells而不会修改&lt;code&gt;*list-3*&lt;/code&gt;中的cons cells。这种情况下，&lt;code&gt;*list-2*&lt;/code&gt;将不会受影响。&lt;/p&gt;
&lt;p&gt;对于PUSH/NREVERSE和SETF/DELETE，80%的都习惯于使用recyling函数。其它的使用情况也是可能的，但是需要谨慎的跟踪哪个返回的是共享结构，哪个不是。&lt;/p&gt;
&lt;p&gt;通常，在处理list时，最好是用函数式风格编写你的代码&amp;mdash;&amp;mdash;你的函数应该只依赖于list参数的内容而不去修改它们。按这个规则，排除使用destructive函数，recyling或其它方式。一旦代码能工作后，如果profiling显示你需要进行优化，你可以将非destructive操作替换成recyling的版本。但是这只应该在你确信参数中的list不会被其它地方引用时。&lt;/p&gt;
&lt;p&gt;最后一个需要注意的是排序函数SORT，STABLE-SORT和MERGE也都是recyling函数。这些函数没有非destructive版本，因此如果你需要对list进行排序而不破坏它，你需要使用COPY-LIST复制一份需要排序的list，再传递给排序函数。在这两种情况下你都需要保证保留排序函数的结果因为原始的参数已经破损了。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (defparameter *list* (list 4 3 2 1))
*LIST*
CL-USER&amp;gt; (sort *list* #'&amp;lt;)
(1 2 3 4)                      ; looks good
CL-USER&amp;gt; *list*
(4)                            ; whoops!
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;List处理函数&lt;/h2&gt;
&lt;p&gt;FIRST和REST返回list中的第一个和其它元素。为了便于使用Common Lisp还提供了从SECOND到TENTH来返回list中相应的元素。还有更为通用的NTH函数，它接收两个参数，一个索引和一个list，返回list中索引（从0开始）对应的元素。类似的还有NTHCDR接收一个索引和一个list返回n次调用CDR的结果。（因此，(nthcdr 0 ...)将返回原始的list，而(nthcdr 1 ...)则相当于REST）。这些函数的操作只是FIRST和REST的组合。&lt;/p&gt;
&lt;p&gt;28个由CAR/CDR组合而成的函数是另一族函数。每个函数名都将多至4个的A和D放在C和R之间，每个A表示一个CAR每个D代表一次CDR。因此：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(caar list) === (car (car list))
(cadr list) === (car (cdr list))
(cadadr list) === (car (cdr (car (cdr list))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些函数都会认为它的list包含了其它list，如果参数不包含其它list元素，这些函数处理的是trees而不是lists：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(caar (list 1 2 3))                  ==&amp;gt; error
(caar (list (list 1 2) 3))           ==&amp;gt; 1
(cadr (list (list 1 2) (list 3 4)))  ==&amp;gt; (3 4)
(caadr (list (list 1 2) (list 3 4))) ==&amp;gt; 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些函数在现在已经用得较少了。即使是顽固派的Lisp hacker也会避免使用过长的这种组合。但是，这些组合可能会出现在旧的Lisp代码中。&lt;/p&gt;
&lt;p&gt;如果你以非函数式风格使用lists，FIRST-TENTH和CAR，CADR这些函数可以用于SETFable的地方。&lt;/p&gt;
&lt;p&gt;其它函数：
函数         || 描述
LAST         | 返回list的最后一个con cell。如果带有整型参数，则返回最后的第n个cons cells。
BUTLAST      | 返回除list中最后一个con cell的复制品。带有整数参数时则排除最后的第n个cells。
NBUTLAST     | BUTLAST的recyling版本；将会修改并返回参数list但是没有可靠的side effects。
LDIFF        | 返回到达给定cons cell的list的复制品。
TAILP        | 如果给定的对象是一个cons cell并且它属于list的结构的一部分则返回true。
LIST*        | 构建一个包含所有元素的list但是最后一个参数将作为最后一个cell的CDR。即对最后一个元素使用append。
MAKE-LISt    | 构建一个包含n个元素的list。这个list各元素的初始值是NIL或使用&lt;code&gt;:initial-element&lt;/code&gt;关键字参数指定的值。
REVAPPEND    | 合并REVERSE和APPEND；用REVERSE对第一个参数逆序然后append第二个参数。
NRECONC      | REVAPPEND的recyling版本；用NREVERSE对第一个参数逆序然后append第二个参数。
CONSP        | 判断某个对象是否为cons cell。
ATOM         | 判断某个对象是否不是cons cell。
LISTP        | 判断某个对象是否为cons cell或NIL。
NULL         | 判断某个对象是否为NIL。功能上等同于NOT，但最好的风格是在测试空的list而不是布尔值FALSE时使用。&lt;/p&gt;
&lt;h2&gt;Mapping&lt;/h2&gt;
&lt;p&gt;对高阶函数的使用是函数式编程风格的另一个重要方面，函数接收其它函数作为参数或者返回使用函数作为返回值。尽管MAP可以用于list和vector（任何sequence），Common Lisp也提供了六个专门处理list的mapping函数。这六个函数的不同之处在于如何构建返回值以及是否将函数应用于list元素或list结构中的cons cells。&lt;/p&gt;
&lt;p&gt;MAPCAR是最像MAP的。因为它总是返回一个list，它不像MAP需要result-type参数。它的第一个参数是将要应用到元素上的函数，其它参数是lists，它们中的元素作为参数提供给函数参数。在它方面，它与MAP类似：函数被应用到list参数的每个元素，每次从每个list中提取一个元素。每次函数调用的结果收集到一个新的list作为返回值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(mapcar #'(lambda (x) (* 2 x)) (list 1 2 3)) ==&amp;gt; (2 4 6)
(mapcar #'+ (list 1 2 3) (list 10 20 30)) ==&amp;gt; (11 22 33)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MAPLIST与MAPCAR类似只是每次传递的不是list中的元素。第一次执行时将整个list作为参数传递，然后是每个list的cdr，然后是cdr的cdr。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(maplist #'append '(1 2 3 4) '(1 2) '(1 2 3)) 
==&amp;gt;  ((1 2 3 4 1 2 1 2 3) (2 3 4 2 2 3)) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MAPCAN和MAPCON与MAPCAR和MAPLIST类似，只是构建结果的方式不同。MAPCAR和MAPLIST将每次函数调用的结果保存到一个新的list里，类似于用LIST方法构建一个新的LiST，MAPCAN和MAPCON则是类似于使用NCONC来构建这个保存结果的list。MAPCAN与MAPCAR类似传递CAR给函数，MAPCON与MAPLIST类似传递cons cells（CDR）。&lt;/p&gt;
&lt;p&gt;利用NCONC的特性可以实现从LIST中REMOVE元素&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(mapcan #'(lambda (x) (if (= x 10) nil (list x)))  list) === (remove 10 list)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MAPC和MAPL是装扮为函数的控制结构&amp;mdash;&amp;mdash;它们是只简单的返回它们的第一个list参数，不收集函数结果，因此它们只用于有side effects的mapped函数。MAPC用于MAPCAR和MAPCAN，而MAPL用于MAPLIST和MAPCON。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;setq&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="n"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="n"&gt;NIL&lt;/span&gt; 
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mapc&lt;/span&gt; &lt;span class="c1"&gt;#'(lambda (&amp;amp;rest x) (setq dummy (append dummy x)))&lt;/span&gt;
        &lt;span class="s"&gt;'(1 2 3 4)&lt;/span&gt;
&lt;span class="s"&gt;        '&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
 &lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;Z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;其它结构&lt;/h2&gt;
&lt;p&gt;虽然cons cells和lists经常被当作同义词，但这并不完全正确&amp;mdash;&amp;mdash;正如前面提到的，你可以使用包含lists的lists构建树。与本章讨论过的函数允许你将cons cells构成的结构当作lists，其它函数允许你使用cons cells描述trees、sets和两种类型的key/value maps。下章讨论这些函数。&lt;/p&gt;
&lt;h1&gt;除了Lists：Cons Cells的其它用途&lt;/h1&gt;
&lt;p&gt;本章讨论由cons cells构成的trees，sets和lookup tables结构的处理函数。&lt;/p&gt;
&lt;h2&gt;Trees&lt;/h2&gt;
&lt;p&gt;包含list的list。&lt;code&gt;((1 2) (3 4) (5 6))&lt;/code&gt;的结构。&lt;/p&gt;
&lt;p&gt;&lt;img alt="list-or-tree" src="/practical_common_lisp/list-or-tree.png"/&gt;&lt;/p&gt;
&lt;p&gt;通过COPY-LIST和COPY-TREE来了解list函数和tree函数的区别。&lt;/p&gt;
&lt;p&gt;COPY-LIST只复制构造出list结构的cons cells。而不复制list中的子list。新创建的cons cells仍然指向原来的cons cells指向的list结构。对上面的结构COPY-LIST的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="copy-list-list-or-tree" src="/practical_common_lisp/copy-list-list-or-tree.png"/&gt;&lt;/p&gt;
&lt;p&gt;COPY-TREE复图中的每个cons cells并将它们连接为同样的结构。COPY-TREE的结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="copy-tree-list-or-tree" src="/practical_common_lisp/copy-tree-list-or-tree.png"/&gt;&lt;/p&gt;
&lt;p&gt;原cons cells指向一个atomic值时，新建的cons cells将指向相同的值。比如数字5、6和符号NIL。&lt;/p&gt;
&lt;p&gt;另一个tree函数是TREE-EUQAL，它比较两个tree是否具有相同的结构并且叶节点都EQL（或者使用:test关键字指定的参数）。&lt;/p&gt;
&lt;p&gt;另一些处理tree的函数类似SUBSTITUTE和NSUBSTITUTE及其-IF和-IF-NOT变种。函数SUBST与SUBSTITUTE类似，它接收一个新项、一个旧项和一个tree，支持:key和:test关键字参数，返回一个新的tree，这个tree中的旧项被替换成了新的项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (subst 10 1 '(1 2 (3 2 1) ((1 1) (2 2))))
(10 2 (3 2 10) ((10 10) (2 2)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SUBST-IF与SUBSTITUTE-IF类似。只是在旧项参数处它接收一个接收单个参数的函数，这个函数将在tree的每个atomic值上调用，如果调用返回true，则在SUBST-IF所返回的新tree中相同的位置将会用新项代替。SUBST-IF-NOT与它相反，在函数返回NIL时进行替换。NSUBST，NSUBST-IF和NSUBST-IF-NOT是SUBST函数的recycling版本。&lt;/p&gt;
&lt;h2&gt;Sets&lt;/h2&gt;
&lt;p&gt;Sets也可以由cons cells来实现。实际上你可以将任何list当作set&amp;mdash;&amp;mdash;Common Lisp提供了好几个在list上执行set类操作的函数。但是，应该记住由于list的结构方式，与在大的sets上操作相比这些操作只能得到较差的效率。&lt;/p&gt;
&lt;p&gt;也就是说，使用内置的set函数很容易编写处理set的代码。相对于其它方法，对小型set的操作将更有效率。如果profiling显示这些函数操作是你的代码的瓶颈，你可以将这些list替换成构建于hash tables或bit vectors之上的sets。&lt;/p&gt;
&lt;p&gt;使用ADJOIN构造set。ADJOIN接收一个项和一个用于表示set的list，并返回一个包含这个项和参数list中的所有项的描述set的list。&lt;/p&gt;
&lt;p&gt;ADJOIN也接收:key和:test关键字参数，它们用于决定项是否存在于list中。与CONS类似，ADJOIN不影响原始的list&amp;mdash;&amp;mdash;如果你需要修改某个list你应该将ADJOIN的返回值赋给它。PUSHNEW宏会自动的完成这个操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (defparameter *set* ())
*SET*
CL-USER&amp;gt; (adjoin 1 *set*)
(1)
CL-USER&amp;gt; *set*
NIL
CL-USER&amp;gt; (setf *set* (adjoin 1 *set*))
(1)
CL-USER&amp;gt; (pushnew 2 *set*)
(2 1)
CL-USER&amp;gt; *set*
(2 1)
CL-USER&amp;gt; (pushnew 2 *set*)
(2 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以用MEMBER及MEMBER-IF和MEMBER-IF-NOT来检查某个项是否在set中。这些函数与sequence函数FIND，FIND-IF和FIND-IF-NOT类似，只是FIND函数只能用于lists。MEMBER函数不会在项存在时返回这个项而是返回包含这个项的cons cell&amp;mdash;&amp;mdash;即描述这个项的子元素。当希望得到的项不是描述为list时，所有这三个函数都返回NIL。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; cl hyper spec

(member 2 '(1 2 3)) =&amp;gt;  (2 3)                                 
 (member 2 '((1 . 2) (3 . 4)) :test-not #'= :key #'cdr) =&amp;gt;  ((3 . 4))
 (member 'e '(a b c d)) =&amp;gt;  NIL
 (member-if #'listp '(a b nil c d)) =&amp;gt;  (NIL C D)
 (member-if #'numberp '(a #\Space 5/3 foo)) =&amp;gt;  (5/3 FOO)
 (member-if-not #'zerop 
                 '(3 6 9 11 . 12)
                 :key #'(lambda (x) (mod x 3))) =&amp;gt;  (11 . 12)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它set类的函数提供了批量操作：INTERSECTION、UNION、SET-DIFFERENCE和SET-EXCLUSIVE-OR。这些函数都接收两个lists和:key、:test这两个关键字参数并返回一个新的描述结果set的list。INTERSECTION返回一个包含两个参数中所有元素的list。UNION包含两个参数中虽一元素的list。SET-DIFFERENCE返回的列表中包含第一个list中出现但没有出现在第二个参数中的元素。SET-EXCLUSIVE-OR返回的list包含仅在一个list中出现，或者在另一个list中出现但是未同时出现在两个list中的元素。这些函数也都有recycling版本，函数名为在这些函数前加N。&lt;/p&gt;
&lt;p&gt;函数SUBSETP接收两个list和:key、:test关键字参数。如果第一个list是第二个list的子集则返回true。只需要元素都出现，与元素出现的次序无关。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (subsetp '(3 2 1) '(1 2 3 4))
T
CL-USER&amp;gt; (subsetp '(1 2 3 4) '(3 2 1))
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Lookup Tables: Alists and Plists&lt;/h2&gt;
&lt;p&gt;Association lists即alists和property lists即plists。不应该在很大的table中使用它们&amp;mdash;&amp;mdash;应该使用hash table&amp;mdash;&amp;mdash;应当知道如何在小型table中使用它们，在小型的table中使用时它们会比hash tables更有效率，并且它们都有自己的特点。&lt;/p&gt;
&lt;p&gt;Alists是将keys映射到values的结构并且支持逆向查找，通过key查找value。Alists也支持添加key/value映射来屏蔽已经存在的映射。屏蔽key/value的映射被移除后原来的映射将重新呈现出来。&lt;/p&gt;
&lt;p&gt;在alist的内部它的元素也是由cons cells组成。可以把它的每个元素的CAR和CDR当作key/value对。例如&lt;code&gt;((A . 1) (B . 2) (C . 3))&lt;/code&gt;的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="alist-abc-123" src="/practical_common_lisp/alist-abc-123.png"/&gt;&lt;/p&gt;
&lt;p&gt;除非CDR部分是一个list，cons cells总是被表示为dotted pairs格式的s表达式来描述键值对。&lt;/p&gt;
&lt;p&gt;查找alist主要是使用ASSOC方法，它接收一个key和alist作为参数并返回第一个CAR与key匹配的cons cells，如果无key匹配则返回NIL。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (assoc 'a '((a . 1) (b . 2) (c . 3)))
(A . 1)
CL-USER&amp;gt; (assoc 'c '((a . 1) (b . 2) (c . 3)))
(C . 3)
CL-USER&amp;gt; (assoc 'd '((a . 1) (b . 2) (c . 3)))
NIL
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为获取到value只需要将ASSOC的结果传递给CDR。&lt;/p&gt;
&lt;p&gt;默认情况下使用EQL来比较key，如果你使用:key和:test关键字参数可以改变这个。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (assoc "a" '(("a" . 1) ("b" . 2) ("c" . 3)) :test #'string=)
("a" . 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为ASSOC是从头至尾搜索list的，因此一个key/value对可以屏蔽另一个拥有相同key的key/value对。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (assoc 'a '((a . 10) (a . 1) (b . 2) (c . 3)))
(A . 10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用CONS将key/value对加到alist的前面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(cons (cons 'new-key 'new-value) alist)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Common Lisp也提供了ACONS函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(acons 'new-key 'new-value alist)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与CONS一样，ACONS函数不会修改这个alist。如果你需要修改它，则需要写成下面的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf alist (acons 'new-key 'new-value alist))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(push (cons 'new-key 'new-value) alist)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，使用ASSOC搜索所花的时间依赖于匹配的键值对在list中的深度。由于alist的机制是非常轻量级的，对于小的tablesalist可以用过hash table。在如何查找方面alist也提供了更多弹性。可以使用ASSOC-IF和ASSOC-IF-NOT函数来查找，它们返回第一个使用test函数与CAR匹配的键值对（ASSOC-IF-NOT表示不匹配）RASSOC、RASSOC-IF和RASSOC-IF-NOT与ASSOC类函数类似只是它们执行的是逆序的查找。&lt;/p&gt;
&lt;p&gt;COPY-ALIST与COPY-TREE类似，只是它不复制整个tree结构，它只复制构成list结构的cons cells和这些cons cells的CAR直接引用的cons cells。即原alist和复制的alist都包含相同的键值对象，即使这些键值刚好是由cons cells构成。&lt;/p&gt;
&lt;p&gt;你可以使用PAIRLIS函数将两个分别作为键和值的list构造成alist。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (pairlis '(a b c) '(1 2 3))
((C . 3) (B . 2) (A . 1))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可能得到&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (pairlis '(a b c) '(1 2 3))
((A . 1) (B . 2) (C . 3))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种look table是plist。结构上来讲plist只是标准的list。将A B和C映射为1 2 3的plist结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="plist-abc-123" src="/practical_common_lisp/plist-abc-123.png"/&gt;&lt;/p&gt;
&lt;p&gt;但是，plist的弹性比alist小些。实际上，plist只支持一个基础的GETF查找操作。GETF函数接收一个plist和key作为参数并返回相应的vaue或者在未找到时返回NIL。&lt;/p&gt;
&lt;p&gt;与ASSOC不同，GETF总是使用EQ比较key是否匹配。因此，你不应该使用数字或字符作为plist的key；这些类型的EQ行为是不确定的。实际上应该总是使用符号来作为plist的key。&lt;/p&gt;
&lt;p&gt;可以使用SETF和GETF来设置或取key相关的value。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CL-USER&amp;gt; (defparameter *plist* ())
*PLIST*
CL-USER&amp;gt; *plist*
NIL
CL-USER&amp;gt; (setf (getf *plist* :a) 1)
1
CL-USER&amp;gt; *plist*
(:A 1)
CL-USER&amp;gt; (setf (getf *plist* :a) 2)
2
CL-USER&amp;gt; *plist*
(:A 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用REMF宏从plist中移除键值对。如果找到了对应的key它返回true。&lt;/p&gt;
&lt;p&gt;与GETF类似REMF也是使用EQ来比较key的。&lt;/p&gt;
&lt;p&gt;由于plist经常用于从同一个plist中提取多个不同的属性，Common Lisp提供了GET-PROPERTIES函数，这使得它从单个plist中提取多个属性时更有效率。它接收一个plist和一个包含key的list作为参数搜索并返回多个值，它一次查找多个值，可以避免多次扫描plist。&lt;/p&gt;
&lt;p&gt;plist与符号的关系：每个符号对象都有与之相关联的plist可以用于保存与符号相关的信息。可以使用函数SYMBOL-PLIST获得这个plist。但我们通常很少关心整个plist，更常见的是使用GET函数，它接收一个符号和一个key，它等同于使用GETF和SYMBOL-PLIST。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(get 'symbol 'key) === (getf (symbol-plist 'symbol) 'key)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与GETF类似，GET也是SETFable的，因此你可以向符号添加任意信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(setf (get 'some-symbol 'my-key) "information")
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用REMF和SYMBOL-PLIST来移除属性或者使用REMPROP。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(remprop 'symbol 'key) === (remf (symbol-plist 'symbol key))
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;DESTRUCTURING-BIND&lt;/h2&gt;
&lt;p&gt;DESTRUCTURING-BIND宏是用于切割lists的。这个宏提供了一个方法destructure任意lists，类似于宏的参数列表可以接收它的list参数的一部分。它的基本结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(destructuring-bind (parameter*) list
  body-form*)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数parameter list可以包含任何类型的参数，例如：&amp;amp;optional，&amp;amp;rest和&amp;amp;key参数。在parameter lists中任何参数都可以被替换为嵌套的destructuring参数list，它接收list的一部分。list form将被求值一次并应该返回一个list，然后被destructured并将对应的值绑定到parameter指定的变量中。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(destructuring-bind (x y z) (list 1 2 3)
  (list :x x :y y :z z)) ==&amp;gt; (:X 1 :Y 2 :Z 3)

(destructuring-bind (x y z) (list 1 (list 2 20) 3)
  (list :x x :y y :z z)) ==&amp;gt; (:X 1 :Y (2 20) :Z 3)

(destructuring-bind (x (y1 y2) z) (list 1 (list 2 20) 3)
  (list :x x :y1 y1 :y2 y2 :z z)) ==&amp;gt; (:X 1 :Y1 2 :Y2 20 :Z 3)

(destructuring-bind (x (y1 &amp;amp;optional y2) z) (list 1 (list 2 20) 3)
  (list :x x :y1 y1 :y2 y2 :z z)) ==&amp;gt; (:X 1 :Y1 2 :Y2 20 :Z 3)

(destructuring-bind (x (y1 &amp;amp;optional y2) z) (list 1 (list 2) 3)
  (list :x x :y1 y1 :y2 y2 :z z)) ==&amp;gt; (:X 1 :Y1 2 :Y2 NIL :Z 3)

(destructuring-bind (&amp;amp;key x y z) (list :x 1 :y 2 :z 3)
  (list :x x :y y :z z)) ==&amp;gt; (:X 1 :Y 2 :Z 3)

(destructuring-bind (&amp;amp;key x y z) (list :z 1 :y 2 :x 3)
  (list :x x :y y :z z)) ==&amp;gt; (:X 3 :Y 2 :Z 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有一种类型的参数可以用于DESTRUCTURING-BIND也可以用于宏参数列表，即&amp;amp;whole参数。如果指定了这种类型的，则它必须是参数列表中的第一个，它将被绑定到整个list form。在&amp;amp;whole参数后面，其它参数可以按正常情况出现就像&amp;amp;whole参数不存在一样。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(destructuring-bind (&amp;amp;whole whole &amp;amp;key x y z) (list :z 1 :y 2 :x 3)
  (list :x x :y y :z z :whole whole))
==&amp;gt; (:X 3 :Y 2 :Z 1 :WHOLE (:Z 1 :Y 2 :X 3))
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;异常处理：conditions和restarts&lt;/h1&gt;
&lt;p&gt;多数语言中错误的处理方式是通过返回值和异常机制。&lt;/p&gt;
&lt;p&gt;这两种机制的缺点在于，当调用栈的底层出现问题，想要进行其进行修复时会由于堆栈已经被清除，用来恢复错误的代码将无法获得出问题之前的上下文环境而出现问题。&lt;/p&gt;
&lt;p&gt;例如，一个三层的调用，如果底层调用失败，中间层不能修复，控制权传到了高层代码。高层代码在处理错误时，它只能有两个项：在没有中层和底层协助的情况下来完成修复或者做出某种修改，以使得再次调用中层代码时能成功。第一个选项需要高层代码实现许多额外的工作&amp;mdash;&amp;mdash;实现整个中间层所做的操作。并且由于堆栈被恢复了，会有更多的工作需要做。第二个选项则需要进行某种修补和重新调用&amp;mdash;&amp;mdash;即改变某些东西使得再次调用底层代码时不会产生错误，这需要高层代码了解中间层和底层代码的工作方式，这与将函数当作黑盒处理的理念是相冲突的。&lt;/p&gt;
&lt;h2&gt;Lisp的处理方式&lt;/h2&gt;
&lt;p&gt;Common Lisp的处理方式是将恢复错误的代码与决定如何恢复的代码分离。可以将恢复错误的代码放在底层函数中而不执行任何实际的恢复策略，将这个决定权留给高层函数。&lt;/p&gt;
&lt;h2&gt;Conditions&lt;/h2&gt;
&lt;p&gt;类似于异常，可以用DEFINE-CONDITION宏来定义，与定义DEFCLASS类似，它默认的父类为CONDITION而不是STANDARD-OBJECT。Slots的指定与类定义相似。但是condition的slots不能使用SLOT-VALUE访问；必须为你需要使用的值指定:reader或:accessor。使用MAKE-CONDITION定义新的condition。使用参数:initargs来初始化slots，没有类似INITIALIZE-INSTANCE的机制来初始化。&lt;/p&gt;
&lt;p&gt;使用condition系统处理错误时，应该将condition定义为ERROR的子类，它是CONDITION的子类。&lt;/p&gt;</content><category term="lisp"></category></entry><entry><title>Programming in Scala 的读书笔记</title><link href="/programming-in-scala-de-du-shu-bi-ji.html" rel="alternate"></link><published>2010-12-27T00:00:00+08:00</published><updated>2010-12-27T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-12-27:/programming-in-scala-de-du-shu-bi-ji.html</id><summary type="html">&lt;h1&gt;语言基础&lt;/h1&gt;
&lt;h2&gt;变量定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scala的两种变量：val和var。val类似Java中的final变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scala中使用类型推断：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Hello, world"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;scala根据后面的字符串推断出msg是String类型的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在变量名后添加冒号和变量类型可以显式指定变量类型：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello, world"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;函数定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;例&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;括号外等号之前的类型为max的返回类型。这里可以不用显式的指定返回类型，编译器会推断出类型。但有时会需要显式的指定，比如函数是递归的时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果函数仅由一个句子组成，可以不写等号后的大括号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max2&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;else …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;语言基础&lt;/h1&gt;
&lt;h2&gt;变量定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scala的两种变量：val和var。val类似Java中的final变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scala中使用类型推断：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Hello, world"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;scala根据后面的字符串推断出msg是String类型的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在变量名后添加冒号和变量类型可以显式指定变量类型：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"hello, world"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;函数定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;例&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;括号外等号之前的类型为max的返回类型。这里可以不用显式的指定返回类型，编译器会推断出类型。但有时会需要显式的指定，比如函数是递归的时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果函数仅由一个句子组成，可以不写等号后的大括号&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max2&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;不带参数也无返回值的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;greet&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释器回应&lt;code&gt;greet: ()Unit&lt;/code&gt;。空括号表示函数不带参数。Unit是greet的结果类型。相当于Java中的void。&lt;/p&gt;
&lt;h2&gt;Scala脚本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在脚本中使用args(0)来访问命令行参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;while循环&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scala默认的缩进风格是缩进2格。&lt;/li&gt;
&lt;li&gt;Java风格的i++和++i在Scala无效，自增必须写成&lt;code&gt;i = i + 1&lt;/code&gt;或&lt;code&gt;i += 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Scala和Java一样，while或if的布尔表达式要放在括号里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;foreach和for表达式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;foreach&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;foreach的参数被称作function literal。它的标准格式是&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子中arg的类型也可以去掉，因为编译器可以根据args的类型推断出arg的类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;foreach偏应用函数版本&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;for表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to是一个带Int参数的方法。&lt;code&gt;0 to 2&lt;/code&gt;被解释为&lt;code&gt;(0).to(2)&lt;/code&gt;。这里arg和i没有说明它是var还是val，但它总会是val，因为在循环体中不能修改它们的值。&lt;/p&gt;
&lt;h2&gt;类型参数化数组&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类型化参数类似Java中的泛型类型参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;greetStrings&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;](&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;greetStrings&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Hello"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scala里访问数组元素时是将索引放在圆括号里。从这里也可以看出来val的不可变。定义的val不能重新赋值，但并不代表val对象本身不可变。如上面给数组的第1个元素赋值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala没有操作符重载，都是方法调用。&lt;code&gt;+-*/&lt;/code&gt;都可以作为方法名称。包括对数组的访问也是使用()，而不是方括号，它实际上调用是是数组的apply方法，因为当在一个变量上使用括号时，默认将调用这个变量的apply方法。如&lt;code&gt;greetString(0)&lt;/code&gt;将被转化为&lt;code&gt;greetString.apply(0)&lt;/code&gt;。而当对带括号并包含一个到多个参数的变量赋值时，将调用变量的update方法。如&lt;code&gt;greetString(0)="Hello"&lt;/code&gt;将被转化为&lt;code&gt;greetString.update(0,"Hello")&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过伴生对象中的工厂方法创建数组：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;numNames&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"zero"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"one"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"two"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个代码调用了class Array的伴生对象object Array的apply方法，这个apply方法能接收可变数量的参数。&lt;/p&gt;
&lt;h2&gt;List&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;scala.List不同于Java的List它是不可变的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用cons方法&lt;code&gt;::&lt;/code&gt;将元素添加到原来的List之前产生新的List。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;:::&lt;/code&gt;可以将两个List连接起来产生新的List。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义空类可以使用Nil，而定义新的List可以将所有元素用cons（即::）连接，最后再连接一个Nil。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;List不支持append，append将随列表长度变长耗时将线性增长。使用cons连接的耗时是常量时间。可以通过cons连接后再调用reverse，或使用ListBuffer，ListBuffer支持以append方式操作可变列表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Tuple&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;元组也不可变，它与List不同的时它可以保存不同类型的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pair&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Luftballons"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pair&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;元组的类型取决于它的元素数量。pair的类型是Tupe2[Int, String]。而('u','r','the',1,4,"me")则是Tupe6(Char,Char,String,Int,Int,String)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访元组元素问时从_1开始。当前版本的Scala只支持到_22。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元组没有使用括号来访问元素，因为apply方法返回的元素是同一类型的。而元组中访问不同元素时，返回类型是不同的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Set和Map&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala中有两套Set和Map，分别支持可变和不可变的方式使用Set和Map。不可变类型是默认的，不需要导入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两套Set特质都扩展了scala.collection.Set这个特质。分别是scala.collection.immutable.Set和scala.collection.mutable.Set。这两个特质都可以调用+方法添加元素，但两者的行为不同，可变集将会把元素添加到自身，而不可变集将会创建一个包含了新元素的新集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用可变集时变量可以是val，但变量内部的元素数量仍然可以改变。而使用不可变集添加元素时如果要将新集保存到原来的变量上，则要使用var，因为不可变集在添加新元素后将返回一个新的集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Set伴生对象定义了apply工厂方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个Map特质都扩展了scala.collection.Map这个特质。分别是scala.collection.immutable.Map和scala.collection.mutable.Map。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Map元素使用&lt;code&gt;-&amp;gt;&lt;/code&gt;方法来添加元素。在任何对象上调用&lt;code&gt;-&amp;gt;&lt;/code&gt;将产生一个包含键和值的二元元组，这个是通过隐式转换来实现的。Map的基本操作：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;scala.collection.mutable.Map&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;treasureMap&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;, &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]()&lt;/span&gt;
&lt;span class="n"&gt;treasureMap&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Go to island"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;treasureMap&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Find big X on ground"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;treasureMap&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Dig."&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用不可变Map，不需要导入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;romanNumeral&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;
 &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"I"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"II"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"III"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"IV"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"V"&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;romanNumeral&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;函数式风格&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;崇尚val，不可变对象和没有副作用的方法。只在特定情况下才使用var，可变对象和有副作用的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;从文件里读取行&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;List对象的reduceLeft方法接收的函数将会应用于List的头两个元素，然后再把函数应用于第一次计算的结果和第三个元素，依次下去，并返回最后一次的计算结果。例如，计算长度最长的行：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;longestLine&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lines&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reduceLeft&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;
  &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;类、字段和方法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类定义包含字段（val或var）和方法（用def定义）统称为：成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传递给方法的参数都是val，不能重新赋值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法最后的return语句是可选的，如果没有发现任何显式的返回语句，Scala方法将返回方法中最后一个计算得到的值。推荐的风格是避免显式的尤其是多个返回语句。代之以把每个方法当作是创建返回值的表达式。鼓励构建很小的方法，把大的方法分解成多个更小的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法如果仅计算单个结果表达式，可以去掉大括号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ChecksumAccumulator&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Byte&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Unit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;checksum&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;没有参数的方法很像是过程（procedure），是一种为了副作用而执行的方法。表示这种方法的另一种方式是去掉结果类型和等号。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ChecksumAccumulator&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Byte&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;checksum&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;~(&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;去掉方法体前的等号后，方法的结果将注定是Unit。即使方法最后一行的结果不是Unit，仍然将返回Unit。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;public是Scala方法的默认访问级别。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨行的表达式中，操作符要放在上一行的行末。或者将表达式包含在括号中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; 
&lt;span class="n"&gt;y&lt;/span&gt;

&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;分号推断的规则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;疑问行由一个不能合法作为语句结尾的字结束，如句点或中缀操作符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下一行开始于不能作为语句开始的字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行结束于括号或方括号内部，因为这些符号不可能容纳多个语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Singletone对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala没有静态成员，而是提供了单例对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当单例对象与类同名时，被称作类的伴生对象。它们必须在同一个源文件里定义。类和它的伴生对象可以互相访问私有成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单例对象不带参数，而类可以，因为它不能用new来初始化。每个单例对象都被作为由一个静态变量指向的虚构类的一个实例来实现，因此它们与Java静态类有着相似的初始化语法。它会在第一次访问时初始化。虚构类的名称是对象名加一个美元符号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不与伴生类共享相同名称的单例对象被称为孤立对象。程序的入口main函数要求被定义在孤立对象中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Scala程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;要执行Scala程序，一定要提供一个main方法，它仅带一个参数，Array[String]，且结果类型为Unit的孤立单例对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala隐式的导入了java.lang和scala的成员，和名为Predef的单例对象中的成员到每个Scala源文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala里并不要求类名和文件名相同。如果不是脚本，推荐的风格是像Java那样按类名来命名文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Application特质&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大括号之间的代码被收集进了单例对象的主构造器，并在类被初始化时执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Application特质中不能访问传递给main的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为某些JVM线程模型的局限，如果程序是多线程的就需要显式的main方法。通常只在程序较简单和单线程的情况下才使用Application特质。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;基本类型的操作&lt;/h1&gt;
&lt;h2&gt;基本类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Byte，Short，Int，Long和Char被称为integral类型。Float和Double被称为numeric类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除String位于java.lang包外，其余所有基本类型都是scala的成员。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;文本表示&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;整数、浮点、字符、字符串的表示与Java类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;raw String用三引号包含，不需要转义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;符号文本写作&lt;code&gt;'标识符&lt;/code&gt;，这里标识符可以是任何字母或数字标识符。这种文本被映射成预定义类scala.Symbol的实例。;&lt;code&gt;'cymbal&lt;/code&gt;将被编译器扩展为工厂方法调用：Symbol("cymbal")。符号对象可以访问它的name属性。符号是被interned的，即把同一符号文本写两次时，两个表达式将指向同一个Symbol对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;布尔类型只有true和false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;操作符和方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala中任何方法都可以当作操作符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中缀操作符前后带两个操作数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;前缀操作符和后缀操作符都是unary的，它们仅有一个操作数。这些前缀操作符是在值类型对象上调用方法的简写方式。在这种情况下，方法名在操作符上前缀了&amp;ldquo;unary_&amp;rdquo;。例如Scala会把表达式&lt;code&gt;-2.0&lt;/code&gt;转换成方法调用&lt;code&gt;(2.0).unary_-&lt;/code&gt;。可以当作前缀操作符的标识符只有&lt;code&gt;+ - ! ~&lt;/code&gt;。如果使用其它其它符号，如&lt;code&gt;unary_*&lt;/code&gt;则不能像&lt;code&gt;*p&lt;/code&gt;这样调用，只能写作&lt;code&gt;p.unary_*&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后缀操作符是不用点或括号调用的不带任何参数的方法。Scala里可以省略方法调用的空括号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数学运算&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以通过中缀操作符，&lt;code&gt;+ - * / %&lt;/code&gt;在任何数字类型上调用数学方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字类型还提供了一元前缀操作符&lt;code&gt;+ -&lt;/code&gt;，即方法&lt;code&gt;unary_+&lt;/code&gt;和&lt;code&gt;unary_-&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关系和逻辑操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;与Java一样，逻辑与和逻辑或都有短路的概念。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala中短路机制是因为Scala方法都有延迟对参数求值甚至是取消求值的机制。这个机制被称作by-name parameter。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;位操作符&lt;/h2&gt;
&lt;h2&gt;对象相等性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相等性检测会处理null，它使用了一个简单的规则：首先检查左侧是否为null，如果不是，则调用equals方法。这种类型的比较对于不同的对象也会产生true，只要他们的内容相同并且它们的equals方法是基于内容编写的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala与Java里&lt;code&gt;==&lt;/code&gt;的区别。在Java里对于原始类型是直接比较值的相等性，与Scala一样。然而对于参考类型，Java是比较两个变量是否都指向JVM堆里的同一个对象。Scala也提供了这种机制，名字是eq。不过，eq和它的反义词ne，仅仅可以用于直接映射到Java的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;操作符优先级和关联性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无论如何，使用括号都是好的风格。或许唯一不用查书就可以知道的优先级关系就是乘除法操作比加减法操作的优先级要高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;富包装器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scala的基本类型上调用的方法多于之前所介绍的。很多方法是通过隐式转换（implicit conversion）来实现的。每个基本类型都有一个&amp;ldquo;富包装器&amp;rdquo;，要查看基本类型的所有方法时，还应该看下每个基本类型的富包装器的API文档。类名都是&amp;ldquo;Rich基本类型名&amp;rdquo;，位于scala.runtime包中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;函数式对象&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果类没有主体，就不一定需要一对空括号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据类参数Scala编译器会收集这类参数并创造一个带同样参数类型和数量的主构造器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可变对象有可能因为要复制很大的对象图而产生性能瓶颈。有时会需要提供可变对象的版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象构造的先决条件，在主构造器中使用require函数来检查条件是否都满足，当它返回false时将抛出IllegalArgumentException来阻止对象被构造。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在进行方法覆盖时override关键字是必须的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数化对象的参数只可以在对象内部访问。在对象外部只能访问对象的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this关键字指向当前执行方法被调用的对象实例，如果使用在构造器里就是指正被创建的对象实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala里主构造器之外的构造器称为从构造器。每个从构造器的第一个动作都是调用同一个类里其它的构造器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala编译器将按字段在源码中出现的次序进行初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标识符的约定：构成标识符的有字母数字式和操作符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字母数字标识符起始于一个字母或下划线，之后可以跟字母、数字或下划线。&amp;lsquo;$&amp;rsquo;字符也被当作字母，但是被保留作为编译器产生的标识符之用。Scala遵循Java驼峰式标识的习惯。不同的Java的在于常量命名，scala里constant并不同于val。Java常量命名通常都使用大写，Scala里常量命名习惯也是使用驼峰式风格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作符是如：+、:、?、~或#的可打印ASCII字符。这些标识字符将在转换为以&amp;lsquo;$&amp;rsquo;分隔的方法名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;混合标识符：由字母数字组成，后面跟前下划线和一个操作符标识符。如，unary_+被用于定义一元的&amp;lsquo;+&amp;rsquo;操作符的方法名。myvar_=被用于定义赋值操作符的方法名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文本标识符：是用反引号&lt;code&gt;...&lt;/code&gt;包含的任意字符串。例如yield是Scala保留字，如果我们要调用Java中Thread的静态方法yield就需要写作：Thread.&lt;code&gt;yield&lt;/code&gt;()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐式转换能在需要的时候自动把一种类型转换为另一种类型。隐匿转换要起作用需要定义在作用范围之内。它的转换是由编译器完成的，不会显式的出现在代码中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;内置控制结构&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;几乎所有Scala的控制结构都会产生值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala中所有赋值语句总是返回Unit。因此下面的代码将出问题：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;readLine&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//不起作用&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Read: "&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里用!=比较Unit和String将永远为true。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for语句&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例1 :: 常见例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"."&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;listFiles&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例2 :: 不常见用法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filesHere&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例3 :: to（包含上限）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Iteration "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例4 :: until（不含上限）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;until&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Iteration "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例5 :: 过滤&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"."&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;listFiles&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例6 :: 多个过滤条件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"."&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;listFiles&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isFile&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例7 :: 嵌套枚举（多层嵌套循环）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;fileLines&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;java.io.File&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Source&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fromFile&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;getLines&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toList&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;grep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;fileLines&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;": "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;grep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".*gcd.*"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例8 :: mid-stream变量绑定，代替上例中两次调用trim。变量作为val引入和使用，但不带关键字val。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;grep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;fileLines&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;trimmed&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pattern&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;": "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;grep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".*gcd.*"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例9 :: 使用yield创建新集合。格式&lt;code&gt;for {子名} yield {循环体}&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;scalaFiles&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;forLineLengths&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".scala"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;fileLines&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;trimmed&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trim&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;".*for.*"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;trimmed&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;异常不需要申明在throws子名中。异常的catch子名中使用模式匹配来处理异常。try-catch-finally也可以产生值。应该避免在finally中返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;match表达式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala中没有break和continue语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量作用范围与Java区别在于Java不允许你在内部范围内创建与外部范围变量同名的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;函数和闭包&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地函数就像使用本地变量，它仅在包含它的代码块中可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以把函数写成函数文本（literal）并把它们像值（value）一样传递。函数文本被编译为类，类在运行期实例化的时候是一个函数值（function value）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数基础信息&lt;/h2&gt;
&lt;p&gt;完整的函数定义格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有时函数定义会要求显示定义返回类型。比如函数是递归的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果函数仅由一个句子组成，可以不写大括号。&lt;code&gt;def max2(x: Int, y: Int) = if (x&amp;gt;y) x else y&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数中可以定义函数，就像定义局部变量，称为本地函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数文本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数文本基本格式：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;括号里是参数，右箭头右边是函数体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数被编译成一个类，类在运行时是一个函数值：function value。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数文本（literal）也被编译为函数值，例&lt;code&gt;(x: Int) =&amp;gt; x + 1&lt;/code&gt;。函数文本中超过一个语句时，用大括号包住函数体。函数的返回值是最后一行的表达式的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数文本短格式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;函数文本的短格式，例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;someNumbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的someNumbers中的元素是整数类型的，因为类型推断系统可以得知x的类型，因此不需要说明x的类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;甚至可以进一步省去函数文本短格式中被推断的参数外的括号，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;someNumbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;占位符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果参数在函数文本内仅出现一次，则可以将参数省略为下划线。如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;someNumbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;当将下划线作为占位符时，编译器可能没有足够的信息推断缺失的参数类型。这时需要指定参数类型，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="k"&gt;_:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这里的多个下划线是指代不同的参数，每个参数在函数文本中只出现一次的情况下才能使用这种格式。多个下划线按顺序代表第一个参数，第二个....&lt;/p&gt;
&lt;h2&gt;偏应用函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用下划线代表全部或部分参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编译器根据这些信息产生一个新的函数类。新类的apply方法的参数个数和类型由占位符信息而决定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你写一个省略所有参数的偏应用程序表达式，而在代码的那个地方正需要一个函数，则你可以去掉下划线。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;someNumbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;someNumbers&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;foreach&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;闭包&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;名称来源：通过&amp;ldquo;捕获&amp;rdquo;自由变量的绑定对函数文本执行的&amp;ldquo;关闭&amp;rdquo;动作。不带自由变量的函数文本：&lt;code&gt;(x: Int) =&amp;gt; x + 1&lt;/code&gt;被称为closed term（小段源码），这在严格意义上讲不是闭包，因为这个代码在编写的时候就已经封闭了。但任何带自由变量的函数文本，如&lt;code&gt;(x: Int) =&amp;gt; x + more&lt;/code&gt;都是open term。因此任何类似&lt;code&gt;(x: Int) =&amp;gt; x + more&lt;/code&gt;需要在运行时创建的函数必须捕获自由变量more的绑定。由于这个函数值是关闭&lt;code&gt;(x: Int) =&amp;gt; x + more&lt;/code&gt;这个open term的行动的最终产物，得到的函数值将包含一个指向捕获的more变量的参考，因此被称为闭包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果more在闭包创建后改变了，闭包将看到这个变化。闭包对捕获变量的作出的改变在闭包外也可见。如果在闭包中修改了more，则more在闭包外也可见。Scala的闭包捕获了变量本身，而不是变量指向的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;addMore&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt;
&lt;span class="n"&gt;addMore&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//11&lt;/span&gt;
&lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;9999&lt;/span&gt;
&lt;span class="n"&gt;addMore&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//10009&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果闭包访问了某些在程序运行时有若干不同备份的变量，例如，闭包使用了某个函数的本地变量，而这个函数又被调用了很多次。每次访问使用的将是闭包在被创建的时候活跃的变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;makeIncreaser&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;more&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;inc1&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;makeIncreaser&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;inc9999&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;makeIncreaser&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9999&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;inc1&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//11&lt;/span&gt;
&lt;span class="n"&gt;inc9999&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//10009&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;上例中Scala编译器重新安排了makeIncreaser的参数使得捕获的参数继续存在于堆中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;重复参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;函数的最后一个参数可以是重复的，用于支持可变长度参数列表。通过在参数类型后放一个星号来标明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数内部，重复参数的类型是声明参数类型的数组。但是你不能直接使用数组作为重复参数传入，这在编译时将出错。如果需要这样做，则要在调用时在数组参数后面添加一个冒号和一个_*符号。&lt;code&gt;echo(arr: _*)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;尾递归&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala编译器检测到尾递归时将使用新值更新函数参数，然后把它替换成一个回到开头的跳转。（类似while，但更代码更优美和简明）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于JVM的约束，在两个函数间相间的进行递归调用将得到到优化。如果递归中的最后一个调用是函数值也不能获得优化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isEven&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Boolean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;isOdd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isOdd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Boolean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;isEven&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;funValue&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nestedFun&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;nestedFun&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="n"&gt;funValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;控制抽象&lt;/h1&gt;
&lt;h2&gt;减少重复代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
    &lt;span class="n"&gt;matcher&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;matcher&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
    &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesEnding&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesContaining&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesRegex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;FileMatcher&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"."&lt;/span&gt;&lt;span class="o"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;listFiles&lt;/span&gt; 
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matcher&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;filesHere&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;matcher&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
      &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; 
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesEnding&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;endsWith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesContaining&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contains&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;filesRegex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;filesMatching&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;query&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;简化客户代码&lt;/h2&gt;
&lt;h2&gt;Curry化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过Curry化我们可以创建&amp;ldquo;感觉像是原生语言支持&amp;rdquo;的控制抽象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原始的例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;plainOldSum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="n"&gt;plainOldSum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;curry化后&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;curriedSum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="n"&gt;curriedSum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里实际相当于下面的调用过程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;first&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;编写新的控制结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以通过创建以函数作为参数的方法来定义新的控制结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;twice&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;twice&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//7.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;自定义控制结构版本1&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;withPrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;File&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;PrintWriter&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;PrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;finally&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;withPrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; 
  &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"date.txt"&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; 
  &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果方法调用只传入一个参数，可以使用大括号替代小括号包围的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Hello, world!"&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;withPrintWriter带两个参数，因此不能使用大括号。我们可以curry化第一个参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;withPrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;File&lt;/span&gt;&lt;span class="o"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;PrintWriter&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Unit&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;PrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;finally&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;File&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"date.txt"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;withPrintWriter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="n"&gt;writer&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;by-name参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用by-name参数可以实现像if或while那样的控制结构。没有参数传入大括号之间的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原始的例子，需要使用参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;var&lt;/span&gt; &lt;span class="n"&gt;assertionsEnabled&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;myAssert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assertionsEnabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;AssertionError&lt;/span&gt;

&lt;span class="c1"&gt;//使用它有点难看&lt;/span&gt;
&lt;span class="n"&gt;myAssert&lt;/span&gt;&lt;span class="o"&gt;(()&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用by-name参数修改。by-name参数在定义参数类型的时候使用&lt;code&gt;=&amp;gt;&lt;/code&gt;而不是&lt;code&gt;() =&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;byNameAssert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assertionsEnabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;AssertionError&lt;/span&gt;

&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;byNameAssert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例3&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;boolAssert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assertionsEnabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;predicate&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;AssertionError&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子与byNameAssert存在重要的区别。由于boolAssert的参数是Boolean，括号中的表达式将先于boolAssert的调用被执行。当assertionEnabled为false时，boolAssert仍将产生副作用，而byNameAssert不会。&lt;/p&gt;
&lt;h1&gt;组合与继承&lt;/h1&gt;
&lt;h2&gt;抽象类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;抽象成员的类本身必须被声明为抽象，抽象成员本身不需要添加abstract关键字。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定义无参数方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无参数方法在Scala中是非常普通的。带有空括号的方法定义，被称为空括号方法。推荐的习惯是在没有参数并且方法仅通过读含的方式访问可变状态（不改变可变状态）时，使用无参数方法。这个惯例支持统一访问原则，即客户代码不应受通过字段还是方法实现属性的决定的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面两组不同的定义对于用户来讲并没有区别。区别在于方法调用可能要稍慢一些，而属性访问则在初始化的时候已经计算了。其重点在于Element类的客户不应在其内部实现发生改变的时候受影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala中可以使用空括号方法重载无参数方法，反之亦可。可以在调用任何不带参数的方法时省略空的括号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原则上Scala上的函数调用中可以省略所有空括号。但在调用的方法存在副作用时，推荐仍然写一对空括号。例如，方法执行了I/O，或写入了var变量，或读取了不属于接收参数内的var变量，直接或间接的使用了可变对象。这种情况下括号作为线索说明了这个调用触发了一些计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总的来说，Scala里定义不带参数也没有副使用的方法为无参数方法，省略空的括号是鼓励的风格，另一方面不要定义没有括号的带副作用的方法，因为那样的话方法调用看上去会像选择一个字段，这样客户在看到副作用时会觉得奇怪。同样的，当你调用带副使用的函数时请添加上空括号。另一种考虑这个问题方法是：如果你调用的函数执行了操作就使用括号，如果仅提供了对某个属性的访问就省略括号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;扩展类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;extends子句有两个效果：使子类从父类继承所有非私有的成员，使子类成为父类的子类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果忽略extends子句，Scala编译器隐式的假设你的类从scala.AnyRef继承。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;重载方法和字段&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala中字段和方法属于相同的命名空间。这使得字段重载无参数方法成为可能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala里禁止在同一个类里有同样的名称定义字段和方法。而在Java中方法名可以与字段同名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala仅为定义准备了两个命名空间（值（字段、方法、包、单例对象）、类型（类、特质）），而Java有四个（字段、方法、类型、包）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定义参数化字段&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在定义中组合参数和字段避免同时编写参数和赋值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;调用超类构造器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在定义子类时，直接将父类的构造器的参数放在父类名后面的括号里。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;使用override修饰符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala里所有重载了父类具体成员的成员都需要这个修饰符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译器根据这个信息，可以避免不安全的方法覆盖。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;多态和动态绑定&lt;/h2&gt;
&lt;h2&gt;定义final成员&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当要确保成员不被子类重载时，使用final修饰符。&lt;/li&gt;
&lt;li&gt;要确保类不被重载时，在类上使用final修饰符。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;使用组合与继承&lt;/h2&gt;
&lt;h2&gt;实现above，beside和toString&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Scala里的数组表示为Java数组，但支持更多的方法。特别是Scala里的数组继承自类scala.Seq，能够表现象序列这样的结构并包含许多访问的转换序列的方法。&lt;/li&gt;
&lt;li&gt;zip操作符可以将两个参数变成Tuple2。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;zip&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"a"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"b"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res1&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[(&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;, &lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;)]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面可以看出如果两个操作数组的其中一个比另一个长，zip将舍弃余下的元素。
 - for循环中将this.contents和that.contents两个数组的元素zip到line1和line2，然后使用for表达式的yield部分来产生结果。结果类型的枚举遍历的表达式类型一致。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;line1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;line2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;zip&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"a"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"b"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;line1&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;line2&lt;/span&gt;
&lt;span class="n"&gt;res0&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;序列中定义了mkString方法，它能返回序列中所有元素组成的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;mkString&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt;
&lt;span class="n"&gt;res4&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;定义工厂对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可以在基类的伴生对象中定义多个工厂方法来产生不同子类型的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;ArrayElements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;UniformElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;LineElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;伴生类里可以直接调用伴生对象中的方法，可以缩短代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Element.elem&lt;/span&gt; 
&lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;above&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;beside&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; 
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; 
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="n"&gt;zip&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt; 
&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;line1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;line2&lt;/span&gt; 
&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="n"&gt;mkString&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;使用工厂方法后，使得子类型可以是私有的。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;object&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ArrayElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; 
    &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; 
  &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; 
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LineElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
    &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt; 
    &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt; 
  &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UniformElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; 
    &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
    &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; 
  &lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt; 
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt; 

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;ArrayElements&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Char&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;UniformElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Element&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;LineElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Scala的类层级&lt;/h1&gt;
&lt;p&gt;-　每个类都继承自Any类。Scala还在类层级的底端定义了Null和Nothing，主要都扮演通用的子类。Nothing是所有类的子类。&lt;/p&gt;
&lt;h2&gt;Scala类层级&lt;/h2&gt;
&lt;p&gt;-　Any中定义了&lt;code&gt;==,!=,equals&lt;/code&gt;，还有&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;toString&lt;/code&gt;。Any中的&lt;code&gt;==,!=&lt;/code&gt;方法，被声明为final，因此它们不能在子类里重载。实际上&lt;code&gt;==&lt;/code&gt;总与equals相同，&lt;code&gt;!=&lt;/code&gt;总是于equals相反。
　-　Any有两个子类：AnyVal和AnyRef。
　-　AnyVal是九个内建值类（Byte、Short、Char、Int、Long、Float、Double、Boolean、Unit）的父类。内建值类除Unit外，其它的都对应于Java原始类型。Scala里这些类的实例都写成文本。不能用new创建这些类的实例，因为这些值类都被定义成既是抽象的又是final的。Unit大约对应于Java中的void；被用途不返回任何有效结果的方法的结果类型。Unit只有一个实例值，写作()。所有值类都是scala.AnyVal的子类型，它们之间互相没有继承关系。值类之间可以进行隐式转换。隐匿转换还为值类增加了功能，如min,max,until,to和abs都是定义在类scala.runtime.RichInt里的，并且有一个从类Int到RichInt的隐式转换。
 - AnyRef是Scala里所有引用类的基类。在Java里AnyRef实际上就是类java.lang.Object的别名。Scala类与Java类不同在于它们还继承自ScalaObject物特别的标记特质。ScalaObject包含了scala编译器定义和实现的方法，作用是让Scala程序执行更有效。到现在为止，ScalaObject只包含了单个方法&lt;code&gt;$tag&lt;/code&gt;，用于内部以提高模式匹配的速度。&lt;/p&gt;
&lt;h2&gt;原生类型是如何实现的&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当数据需要被当作对象看侍时，Scala使用对象类型，如java.lang.Integer。它与Java5的自动装箱机制差异在于Scala里的装箱比Java里的更少见。&lt;/li&gt;
&lt;li&gt;AnyRef类型定义了eq方法，它不能被重载且实现为对比对象的引用（类似Java里的&lt;code&gt;==&lt;/code&gt;）。它的反义方法为ne。&lt;/li&gt;
&lt;li&gt;Scala中的&lt;code&gt;==&lt;/code&gt;被设计为透明的参考类型代表的东西。对值类型来说，就是自然（数学或自然）相等。对引用类型，&lt;code&gt;==&lt;/code&gt;被视为继承自Object的equals方法的别名。这个方法被初始地定义为引用相等，但被许多子类重载实现它们的相等概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;底层类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;scala.Null和scala.Nothing是用于统一方式处理某些&amp;ldquo;边界情况&amp;rdquo;的特殊类型。&lt;/li&gt;
&lt;li&gt;Null是null类型的引用；它是每个引用类的子类。Null不能赋值给值类型。&lt;/li&gt;
&lt;li&gt;Nothing是Scala类层级中最底端；它是任何类型的子类型。没有这个类型的值。Nothing的一个用处是标明不正常的终止。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Nothing&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;RuntimeException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;divide&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; 
  &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"can't divide by zero"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;特质&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;物质是Scala中代码复用的基础单元。特质封装了方法和字段定义，并且可以通过混入到类中重用它们。类可以混入任意个特质。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;特质如何工作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;特质的定义使用关键字trait，其它与类定义无异。&lt;/li&gt;
&lt;li&gt;特质与类一样会有默认超类AnyRef。&lt;/li&gt;
&lt;li&gt;可以使用extends或with关键字把特质混入到类中。Scala&amp;ldquo;混入&amp;rdquo;特质而不是继承，特质的混入与其它语言中的多继承有重要的差别。&lt;/li&gt;
&lt;li&gt;使用extends关键字混入特质时，隐式地继承了特质的超类。例如下例中，Frog是AnyRef（Philosophical的超类）的子类并混入了Philosophical。从特质继承的方法可以像从超类继承的方法那样使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Frog&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Philosophical&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"green"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;如果想把特质混入到扩展自超类的类里，可以用extends指明父类，用with混入特质。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Animal&lt;/span&gt; 
&lt;span class="k"&gt;trait&lt;/span&gt; &lt;span class="nc"&gt;HasLegs&lt;/span&gt; 
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Frog&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Animal&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;Philosophical&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nc"&gt;HasLegs&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;override&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;toString&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"green"&lt;/span&gt; 
&lt;span class="o"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;特质就像是带有具体方法的Java接口，不过它可以做得更多。比如，它可以声明字段和维持状态值。实际上，可以用特质定义任何用类定义做的事，并且语法也一样，除了两点：第一，特质不能有任何&amp;ldquo;类&amp;rdquo;参数，也就是说传递给类的主构造器的参数。另一个差别在于不论在类的哪个角落，super调用都是静态绑定的，在特质中，它们是动态绑定的。调用的实现将在每一次特质被混入到具体类的时候才被决定。这种处理super的行为使得特质能以可堆叠的改变方式：stackable modifications工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;瘦接口对阵胖接口&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;要使用特质丰满接口，只要简单地定义一个具有少量抽象方法的特质&amp;mdash;&amp;mdash;特质接口的瘦部分&amp;mdash;&amp;mdash;和潜在的大量具体方法，所有的都实现在抽象方法上。然后你就可以把丰满了的特质混入到类中，实现接口的瘦部分，并最终得到具有全部胖接口内容的类。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;特质用来做可堆叠的改变&lt;/h2&gt;
&lt;p&gt;下面部分用FreeMind写的
[[scala-tip/Programming In Scala.png]]&lt;/p&gt;
&lt;h1&gt;Case Class和模式匹配&lt;/h1&gt;
&lt;p&gt;Case Class是Scala中用于匹配对象的一种方法。通常情况下只要在需要使用模式匹配的类的class关键字前添加case关键字就可以了。&lt;/p&gt;
&lt;h2&gt;Case Class的例子&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上例也可以看出Scala中class定义时类体部分可以为空。&lt;/p&gt;
&lt;h3 id="case-classes"&gt;Case classes&lt;/h3&gt;
&lt;p&gt;每个Expr的子类都有一个case修饰符。有这个修饰符的类被称为Case class。使用这个修饰符后Scala编译器将会为这个类添加特殊的语法效果。&lt;/p&gt;
&lt;p&gt;首先，它会给这个类添加一个工厂方法。比如使用Var("x")来构造对象而不需要new Var("x")。这个工厂方法在嵌套使用这个类时更显方便。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;op&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个语法效果是所有参数列表中的参数被隐式的添加了val前缀，因此它们被当作了类的字段。&lt;/p&gt;
&lt;p&gt;第三，编译器将为Case class添加toString，hashCode和equals方法。它们可用于打印，计算hash值或递归的按对象结构中的字段进行对比。由于Scala中==总是会使用equals，这意味case class中的元素也将会按结构进行对比。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(+,&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res3&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="mo-shi-pi-pei"&gt;模式匹配&lt;/h3&gt;
&lt;p&gt;Case class的另一个好处是支持模式匹配。例如要实现下面的规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Doublenegation&lt;/span&gt;
&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Addingzero&lt;/span&gt;
&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Multiplyingbyone&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用模式匹配来实现这些规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;simplifyTop&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;))))&lt;/span&gt;
&lt;span class="n"&gt;res4&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;simplifyTop&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Doublenegation&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Addingzero&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="c1"&gt;//Multiplyingbyone&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例中的simplifyTop包含匹配表达式。匹配表达类似于Java中的switch，但它通常出现在selector表达式的后面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;alternatives&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;switch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;alternatives&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模式匹配包含于一个alternatives序列中，每个匹配都以关键字case开头。每个alternative包含了一个模式和一个以上的表达式，它将在匹配时被执行。箭头符号=&amp;gt;将模式和表达式分开。&lt;/p&gt;
&lt;p&gt;匹配表达式将按模式匹配的书写顺序执行。当=&amp;gt;左边的模式匹配上时，=&amp;gt;右边的表达式将被执行。&lt;/p&gt;
&lt;p&gt;常量匹配比如"+"或1的匹配与使用==是等效的。类似e这样的变量匹配将匹配所的值。然后变量指向case语句右边的值。在这个例子中，前三个例子中，在匹配范围内，e变量都绑定到了变量上。通配符匹配s模式（_）也匹配所有值，但它不会绑定变量值。在例中的最后是默认匹配，它只是返回expr，不对表达式做任何操作。&lt;/p&gt;
&lt;p&gt;构造器模式如UnOp("-",e)。这个模式匹配所有第一个参数匹配"-"第二个参数匹配e且类型为UnOp的值。构造器的参数自身也是匹配模式。这允许我们使用简单的标记写出深度匹配。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="mo-shi-pi-pei-yu-switchde-bi-jiao"&gt;模式匹配与switch的比较&lt;/h4&gt;
&lt;p&gt;匹配表达式可以被看作Java风格的switch。Java风格的switch可以很自然的用匹配表达式来表示，每个模式都是常量最后的模式可以是一个通配符（它用于表示switch中的default）。switch与模式匹配有三处不同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Scala中的匹配是表达式，它总会产生一个值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Scala的alternative表达式不会&amp;ldquo;fall through&amp;rdquo;到下一个匹配情况（不需要break）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有任何模式匹配，将会抛出MatchError异常。这意味着你总会需要有一个默认的匹配，即使它什么也不做。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
  &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;"isabinaryoperation"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子中的第二种情况没有代码，因此它不会执行任何操作。这个例子中的两种情况都会返回空值&amp;lsquo;()&amp;rsquo;，这也是整个匹配表达式的结果。&lt;/p&gt;
&lt;h2&gt;模式类型&lt;/h2&gt;
&lt;h3 id="tong-pei-fu-pi-pei-mo-shi_1"&gt;通配符匹配模式&lt;/h3&gt;
&lt;p&gt;通配符模式（_）匹配所有对象。常用于作为默认值，捕获所有的情况，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;"isabinaryoperation"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通配符也可用于忽略对象的某些部分。比如，在前面的例子中并不需要关心BinOp的元素。只需要检查它是不是BinOp。因此可以使用通配符匹配：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;"isabinaryoperation"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"It'ssomethingelse"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="chang-liang-pi-pei-mo-shi"&gt;常量匹配模式&lt;/h3&gt;
&lt;p&gt;常量模式只匹配自身。任何字面量（literal）都可以用于常量模式。比如，5，true和"hello"都是常量模式。任何val或singleton对象也可以用作常量模式。比如，Nil是一个singleton对象，它可以用于匹配空列表（empty list）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"five"&lt;/span&gt;
  &lt;span class="n"&gt;casetrue&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"truth"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="s"&gt;"hello"&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"hi!"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Nil&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"theemptylist"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"somethingelse"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res5&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;five&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res6&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;truth&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"hello"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res7&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Nil&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res8&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;theemptylist&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res9&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;somethingelse&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bian-liang-pi-pei-mo-shi"&gt;变量匹配模式&lt;/h3&gt;
&lt;p&gt;变量模式匹配任何对象，与通配符模式类似。与通配符不同之处在于，Scala将会绑定对象到变量。你可以在后面使用这个变量来操作匹配的对象。比如下例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"zero"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;somethingElse&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"notzero:"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;somethingElse&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量还是常量？&lt;/p&gt;
&lt;p&gt;常量模式可以有符号名称。比如前面以经看到的使用Nil作为模式。下例中，模式匹配常量E(2.71828...)和Pi(3.14159...)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Math.&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Pi&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;importMath&lt;/span&gt;&lt;span class="o"&gt;.{&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Pi&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"strange math? Pi = "&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nc"&gt;Pi&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"OK"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;res10&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;E不会匹配Pi，因此&amp;ldquo;strange math"的情况不会发生。&lt;/p&gt;
&lt;p&gt;Scala编译器如何知道Pi是从java.lang.Math对象中导入的常量，而不是一个变量呢？Scala使用了一个简单的规则来区分：以小写字母开头的名称将作为模式变量；其它情况将作为常量。上例如果改为小写的pi将出现不同的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;
&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;3.141592653589793&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"strangemath?Pi="&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;res11&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;strangemath&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;2.7182818&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种情况下编译器将不会允许你添加default case。因为pi是变量模式，它将匹配所有输入，因此它后面的情况将不可达：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"strangemath?Pi="&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"OK"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;error:unreachablecode&lt;/span&gt;
    &lt;span class="n"&gt;case_=&amp;gt;&lt;/span&gt;&lt;span class="s"&gt;"OK"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如有必要通过使用两个反单引号（~上的那个）你仍然可以使用小写的名称作为常量模式。比如常量是某些对象的字段时。例如，pi是一个变量模式，但是this.pi或obj.pi是常量。我们可以使用反单引号解决这个问题，通过使用&lt;code&gt;pi&lt;/code&gt;，pi将被作为常量模式，而不是变量模式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;`pi`&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"strangemath?Pi="&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;
      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"OK"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;res13&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;反单引号在Scala中被用于两种不同目的。前面已经介绍过使用它可以将关键字作为普通的标识符。比如&lt;code&gt;yield&lt;/code&gt;()会将yield作为标识符而不是关键字。&lt;/p&gt;
&lt;h3 id="gou-zao-qi-pi-pei-mo-shi"&gt;构造器匹配模式&lt;/h3&gt;
&lt;p&gt;构造器匹配模式使得模式匹配变得真正强大。例如&amp;ldquo;BinOp("+", e, Number(0))&amp;rdquo;。这个匹配选检查Case class的名称是否为BinOp然后检查它的构造器参数是否匹配额外的模式。&lt;/p&gt;
&lt;p&gt;这些额外的模式意味着Scala的模式支持深度匹配。这些模式不只是检查最顶级的对象，也检查这个对象的内容是否匹配额外的模式。由于这些额外的模式也可以是构造器模式，你可以使用它检查任意深度的对象。比如上面提到的例子先检查顶层的对象是否为BinOp，它的第三个构造器参数是否为Number，value字段是否为数字0。这个模式在一行中检查了三级深度的数据。&lt;/p&gt;
&lt;h3 id="xu-lie-pi-pei-mo-shi"&gt;序列匹配模式&lt;/h3&gt;
&lt;p&gt;可以像匹配case class那样使用序列匹配模式来匹配List或Array这样的序列类型。使用的是同样的语法，但你可以在模式中指定任意数量的元素。比如，下例显示了如何匹配以0开头的含有3个元素的list：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foundit"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要匹配不指定长度的序列模式，可以在模式的最后一个元素使用&lt;code&gt;_*&lt;/code&gt;。这个模式匹配序列中任意数量的元素，包括0个元素。下例将匹配任何以0开头的list，不管list有多长。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foundit"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="yuan-zu-pi-pei-mo-shi"&gt;元组匹配模式&lt;/h3&gt;
&lt;p&gt;也可以匹配元组。例如(a,b,c)匹配任意3元素的元组。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;tupleDemo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;
  &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"matched"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="lei-xing-pi-pei-mo-shi"&gt;类型匹配模式&lt;/h3&gt;
&lt;p&gt;可以使用类型匹配模式来代替类型测试和类型转换。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;generalSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;,&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是使用generalSize的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;generalSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res14&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;generalSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="sc"&gt;'a'&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="sc"&gt;'b'&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res15&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;generalSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Math&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;Pi&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res16&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里要注意，尽管s和x指的是同一个值，x的类型是Any，但是s的类型是具体类型。因此在调用具体类型的方法时不能直接使用x.method，而是要使用s.method。&lt;/p&gt;
&lt;p&gt;如果不使用模式匹配，Scala中使用了不同于Java的方式进行进行类型测试和类型转换。例如测试expr是否为String：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isInstanceOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将expr转换为String，使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;asInstanceOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作符isInstanceOf和asInstanceOf是作为Any类的预定义函数，它们在方括号中接收一个类型参数。实际上，x.asInstanceOf[String]是参数String的隐式类型参数的方法调用的一个特殊情况。&lt;/p&gt;
&lt;p&gt;从这里可以看出在Scala中进行类型测试和类型转换更繁锁。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isInstanceOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]){&lt;/span&gt;
  &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;asInstanceOf&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种类型匹配模式：&amp;ldquo;m: Map[&lt;em&gt;, &lt;/em&gt;]&amp;rdquo;。这个匹配模式匹配任意Map类型的值，这个Map的key和value可以是任意类型的，m指向这个Map。因此，m.size将返回map的size。下划线与其它匹配模式中一样。&lt;/p&gt;
&lt;h3 id="lei-xing-ca-chu"&gt;类型擦除&lt;/h3&gt;
&lt;p&gt;能测试Map元素的类型吗？例如测试map的key和value是否都为Int：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isIntIntMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;,&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;therewereuncheckedwarnings&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;re&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;runwith&lt;/span&gt;
   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;uncheckedfordetails&lt;/span&gt;
&lt;span class="n"&gt;isIntIntMap&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释器给出了&amp;ldquo;unchecked warning.&amp;rdquo;。可以在启动解释器时添加-unchecked参数来了解详细信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="n"&gt;quit&lt;/span&gt;
&lt;span class="nc"&gt;$scala&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;unchecked&lt;/span&gt;
&lt;span class="nc"&gt;WelcometoScalaversion2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mf"&gt;7.2&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;JavaHotSpot&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;TM&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nc"&gt;ClientVM&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nc"&gt;Java1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="n"&gt;_13&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;
&lt;span class="nc"&gt;Typeinexpressionstohavethemevaluated&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nc"&gt;Type&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;helpformoreinformation.&lt;/span&gt;
&lt;span class="kt"&gt;scala&amp;gt;&lt;/span&gt; &lt;span class="kt"&gt;def&lt;/span&gt; &lt;span class="kt"&gt;isIntIntMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;x:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;,&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;warning:non&lt;/span&gt; &lt;span class="kt"&gt;variable&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="kt"&gt;-argument&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;in&lt;/span&gt;
&lt;span class="k"&gt;type&lt;/span&gt; &lt;span class="kt"&gt;pattern&lt;/span&gt; &lt;span class="kt"&gt;is&lt;/span&gt; &lt;span class="kt"&gt;unchecked&lt;/span&gt; &lt;span class="kt"&gt;since&lt;/span&gt; &lt;span class="kt"&gt;it&lt;/span&gt; &lt;span class="kt"&gt;is&lt;/span&gt; &lt;span class="kt"&gt;eliminated&lt;/span&gt; &lt;span class="kt"&gt;by&lt;/span&gt; &lt;span class="kt"&gt;erasure&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;,&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;
       &lt;span class="o"&gt;^&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与Java泛型类型Scala使用了擦除模式。这意味着在运行时不会维护类型参数。因此，没有办法在运行时决定map对象在构建时是否使用了两个Int类型参数。系统可以做的只是检查值是否匹配带任意类型参数的Map。可以使用不同类型的参数调用isIntIntMap来验证这个问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isIntIntMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res17&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isIntIntMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc"&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"abc"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res18&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;唯一的例外是数组，因为与Java中一样Scala对数组作了特殊处理。数组元素的类型被保存在数组中，因此可以进行模式匹配。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isStringArray&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"yes"&lt;/span&gt;
      &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"no"&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;isStringArray&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Any&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abc"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isStringArray&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res19&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;yes&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;ai&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;ai&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isStringArray&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ai&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res20&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;no&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bian-liang-bang-ding"&gt;变量绑定&lt;/h3&gt;
&lt;p&gt;对于变量匹配模式，你可以向任何匹配模式添加变量。只需要在匹配模式前添加@符号。这将会将匹配成功的变量绑定到变量上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abs"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;@&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"abs"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量e被绑定到&lt;code&gt;UnOp("abs", _)&lt;/code&gt;这个匹配模式上。如果整个模式匹配成功，则整个匹配的&lt;code&gt;UnOp("abs", _)&lt;/code&gt;部分将被作为变量e。&lt;/p&gt;
&lt;h3 id="pattern-guard"&gt;Pattern guard&lt;/h3&gt;
&lt;p&gt;有些情况下，句法上的匹配并不够精确。比如，给你一个任务将&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;转换为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"x"&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可能会写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;simplifyAdd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;error:x&lt;/span&gt; &lt;span class="kt"&gt;is&lt;/span&gt; &lt;span class="kt"&gt;already&lt;/span&gt; &lt;span class="kt"&gt;defined&lt;/span&gt; &lt;span class="kt"&gt;as&lt;/span&gt; &lt;span class="kt"&gt;value&lt;/span&gt; &lt;span class="kt"&gt;x&lt;/span&gt;
         &lt;span class="n"&gt;caseBinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将会失败，因为Scala约束了模式匹配为线性的：模式变量在同一个匹配模式中只允许出现一次。但，你可以使用pattern guard重写为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;simplifyAdd&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
       &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;simplifyAdd&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pattern guard是在匹配模式后添加if。Guard可以是任意类型的boolean表达式，它通常会引用模式变量。如果pattern guard存在，则匹配只在guard的if条件满足时才会成功。使用pattern guard的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//match only positive integers&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt; &lt;span class="kt"&gt;if&lt;/span&gt; &lt;span class="err"&gt;0&lt;/span&gt; &lt;span class="kt"&gt;&amp;lt;n&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;...&lt;/span&gt;

&lt;span class="c1"&gt;//match only strings starting with the letter 'a'&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="kt"&gt;if&lt;/span&gt; &lt;span class="kt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)=&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;'a'&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;匹配模式重叠&lt;/h2&gt;
&lt;p&gt;匹配模式将按书写次序依次尝试。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//&amp;lsquo;-&amp;rsquo;isitsowninverse&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"+"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//&amp;lsquo;0&amp;rsquo;isaneutralelementfor&amp;lsquo;+&amp;rsquo;&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//&amp;lsquo;1&amp;rsquo;isaneutralelementfor&amp;lsquo;*&amp;rsquo;&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="n"&gt;simplifyAll&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个版本的simplify会将规则应用到表达式的任何位置，不管它是否是顶层对象。在这个例子中要注意catch-all的情况应该放在最后。否则下面的匹配模式将不可达，编译时将出现unreachable code错误。&lt;/p&gt;
&lt;h2&gt;Sealed classes&lt;/h2&gt;
&lt;p&gt;在编写模式匹配时，必要要保证能覆盖所有可能的情况。有些时候我们可以末尾处添加默认情况的匹配，但这只在存在合理的默认匹配的情况下才适合。如果没有默认匹配？你还会认为你安全的覆盖了所有可能的情况吗？&lt;/p&gt;
&lt;p&gt;实际上，你可以从Scala编译器来获得支持来检测缺失的匹配模式。为了达到这个目的，编译器需要知道会有哪些可能的匹配。通常情况下这在Scala中是不可能的，因为我们可以任意的定义新的case class。比如，我们可以一个编译单元中在Expr的类继承结构中随意的定义5个case class，而在另一个编译单元中只定义4个。&lt;/p&gt;
&lt;p&gt;可取的方法是使case class的超类为sealed class。Sealed class不允许在定义sealed class的文件之外定义新的子类。这对于使用模式匹配是非常重要的，因为这意味着你不需要考虑子类的问题，因为所有的子类类型你都已经知道了。sealed关键字通常用于模式匹配。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;sealed&lt;/span&gt; &lt;span class="k"&gt;abstract&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Double&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nc"&gt;Expr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在定义模式匹配&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"anumber"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"avariable"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在编译时Scala将检查缺失的匹配情况并给出警告信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;match&lt;/span&gt; &lt;span class="kt"&gt;is&lt;/span&gt; &lt;span class="kt"&gt;not&lt;/span&gt; &lt;span class="kt"&gt;exhaustive!&lt;/span&gt;
&lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;combination&lt;/span&gt; &lt;span class="nc"&gt;UnOp&lt;/span&gt;
&lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;combination&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时我们可能会遇到编译器发邮过多的这种警告。例于，你可以确保在某个环境下某些情况不可能会发生。我们能确保不会发生MatchError。为了避免出现这些警告，我们可以添加catch-all case：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"anumber"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"avariable"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;RuntimeException&lt;/span&gt; &lt;span class="c1"&gt;//Shouldnothappen&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种修改方式能工作，但未必是你所满意的，因为你被迫添加了不可能被执行的代码，我们也可以直接让编译器闭嘴。&lt;/p&gt;
&lt;p&gt;即在模式匹配的selector上添加@unchecked注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;describe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt; &lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;:@&lt;/span&gt;&lt;span class="n"&gt;unchecked&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"anumber"&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Var&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;_&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"avariable"&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常你可以使用给添加注释的方式给selector表达式添加注释：在表达式后面加上冒号和注释。如上面的e:@unchecked。@unchecked对于模式匹配有特殊含义。如果selector表达式带有这个注释，则编译器将不会检查匹配模式是否覆盖所有可能。&lt;/p&gt;
&lt;h2&gt;Option&lt;/h2&gt;
&lt;p&gt;对于可选值Scala有一个标准类型Option。它的值只有两种情况。一种为Some(x)，x是实际的值。另一种为None对象，它表示没有值。&lt;/p&gt;
&lt;p&gt;在对Scala的集合类型的一些操作会生成可选值。比如，Scala的Map的get方法将在key对应的值存在时将生成Some(value)，如果key对应的值不存在则返回None。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;capitals&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;
         &lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"France"&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Paris"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Japan"&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Tokyo"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;capitals&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;
  &lt;span class="kt"&gt;scala.collection.immutable.Map&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;,
  &lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Map&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;France&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Paris&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nc"&gt;Japan&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nc"&gt;Tokyo&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;capitalsget&lt;/span&gt; &lt;span class="s"&gt;"France"&lt;/span&gt;
&lt;span class="n"&gt;res21&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Paris&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;capitalsget&lt;/span&gt; &lt;span class="s"&gt;"NorthPole"&lt;/span&gt;
&lt;span class="n"&gt;res22&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最常见的获取可选值的方式是使用模式匹配。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
     &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"?"&lt;/span&gt;
       &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="nc"&gt;String&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;capitalsget&lt;/span&gt; &lt;span class="s"&gt;"Japan"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res23&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Tokyo&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;capitalsget&lt;/span&gt; &lt;span class="s"&gt;"France"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res24&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Paris&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;capitalsget&lt;/span&gt; &lt;span class="s"&gt;"NorthPole"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res25&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;=?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Option类型在Scala程序中很常见。比较它与Java中使用null标识没有值。例如，java.util.HashMap的get方法将返回存储于HashMap中的值，在未找到值是返回null。这种方式使得HashMap中不能保存null值。如果某个变量允许为null，则你总是需要在使用它时检查它是否为null。如果你忘记检查就可能在运行时产生NullPointerException。由于这种异常并不是总会发生，因此难于发现和调试。而对于Scala而言则不会发生这种情况，因为它允许在hash map上存储值的类型，而null不是合法的类型。例如，HashMap[Int, Int]不能返回null来表示&amp;ldquo;没有这个元素&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;Scala鼓励使用Option来标识可选值。这与Java中直接使用类型有很多好处。首先，增加了可读性，Option[String]标明了变量可能为null的字符串。更重要的是，使用未检查的空值变量在Scala中变成了类型错误。如果将类型为Option[String]的变量用于String则编译将不能通过。&lt;/p&gt;
&lt;h2&gt;无处不在的匹配模式&lt;/h2&gt;
&lt;p&gt;匹配模式被用于Scala中的很多地方，而不仅仅是用于匹配表达式。&lt;/p&gt;
&lt;h3 id="mo-shi-yong-yu-bian-liang-ding-yi"&gt;模式用于变量定义&lt;/h3&gt;
&lt;p&gt;当定义val或var时，你可以使用模式来代替标识符。例如，你可以使用下面的例子来提取元组中的数据，将元组的不同部分赋给不同的变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"abc"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;myTuple&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;)=(&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;myTuple&lt;/span&gt;
&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;
&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使用case class时，如果你明确的了解这个case class，则你可以使用模式来析构对象。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;exp&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(*,&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="nc"&gt;BinOp&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="n"&gt;exp&lt;/span&gt;
&lt;span class="n"&gt;op&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Expr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="casexu-lie-zuo-wei-pian-ying-yong-han-shu"&gt;Case序列作为偏应用函数&lt;/h3&gt;
&lt;p&gt;大括号中的case序列可以用于任何允许使用function literal的地方。与只有一个入口点和参数列表的函数不同，case序列可以有多个入口，每个入口有自己的参数列表。每个case都有进入函数的入口，参数由模式来指定。函数在每个入口点case的右边。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;withDefault&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;={&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数休有两个case。第一个匹配Some，并返回Some内部的数值。第二个case匹配None，返回数值0。下面是使用这个函数的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;withDefault&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res25&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;withDefault&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;None&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;res26&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种机制对于actor库非常有用。下面是一些典型的actor的代码。它传递模式匹配到react方法中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;react&lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;actor&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Actor&lt;/span&gt;&lt;span class="o"&gt;)=&amp;gt;{&lt;/span&gt;
    &lt;span class="n"&gt;actor&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;getip&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;act&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;{&lt;/span&gt;
    &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Unhandledmessage:"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;act&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Case序列的另一个应用是偏应用函数（partial function）。如果你将这个函数应用到一个值它将产生运行时错误。例如，下面是一个返回list中第二个元素中的整数的偏应用函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="nc"&gt;Int&lt;/span&gt; &lt;span class="o"&gt;={&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="k"&gt;_=&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当编译时这个函数时，编译器将产生下面的警告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;warning:&lt;/span&gt; &lt;span class="kt"&gt;match&lt;/span&gt; &lt;span class="kt"&gt;is&lt;/span&gt; &lt;span class="kt"&gt;not&lt;/span&gt; &lt;span class="kt"&gt;exhaustive!&lt;/span&gt;
 &lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;combination&lt;/span&gt; &lt;span class="nc"&gt;Nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果传递空的list给它，它将产生错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res24&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;MatchError&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
      &lt;span class="kt"&gt;at$anonfun$1.apply&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;&amp;lt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="err"&gt;17&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="kt"&gt;at$anonfun$1.apply&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;&amp;lt;console&lt;/span&gt;&lt;span class="k"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="err"&gt;17&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你需要检查某个偏应用函数是否定义，你必须先告诉编译器你需要使用偏应用函数。类型说明&lt;code&gt;List[Int] =&amp;gt; Int&lt;/code&gt;包含了整型List的所有函数，无论它是否是偏应用函数。只包含整型List的所有偏应用函数应该写作&lt;code&gt;PartialFunction[List[Int],Int]&lt;/code&gt;。下面是新编写的函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;PartialFunction&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;,&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用偏应用函数的isDefinedAt测试是否定义了函数。在这里，可以测试到接收两个以上元素的List作为参数的second函数被定义了，而接收空List的second函数不存在：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isDefinedAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;res27&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;

&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isDefinedAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;res28&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上，上面的表达式被Scala编译器编译为偏应用函数是通过将模式进行了两次转换&amp;mdash;&amp;mdash;一次是为了实现匹配函数，另一次是实现&lt;code&gt;isDefinedAt&lt;/code&gt;函数。例如，&lt;code&gt;{case x :: y :: _ =&amp;gt; y}&lt;/code&gt;将被翻译为下面的偏应用函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nc"&gt;PartialFunction&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;,&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;]{&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;isDefinedAt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt; &lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="n"&gt;xs&lt;/span&gt; &lt;span class="k"&gt;match&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="k"&gt;_&lt;/span&gt; &lt;span class="k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当function literal被申明为PartialFunction时这个转换就产生。如果申明的类型为Function1，或未申明则将被转换为完整的函数。&lt;/p&gt;
&lt;p&gt;通常，如果可能应该尽可能的使用完整的函数，因为使用偏应用函数时允许运行时错误，编译器无法给予帮助。尽管如此，但在有些时候偏应用函数确实有用。你可能确保不提供未被处理的值。其中一个办法是可以使用检查偏应用函数的框架，总是在调用函数前使用isDefinedAt进行检查。例如，上面的react中，参数是一个偏应用，它精确定义了调用都要处理的消息。&lt;/p&gt;
&lt;h3 id="forbiao-da-shi-zhong-de-pi-pei-mo-shi"&gt;for表达式中的匹配模式&lt;/h3&gt;
&lt;p&gt;你也可以在for表达式中使用模式匹配。下例中的表达式遍历capitals map中的键/值对。每个键值对匹配(country, city)模式，这将会定义两个变量country和city。&lt;/p&gt;
&lt;p&gt;键值对匹配模式在匹配时是一种特殊的模式，它永远不会失败。capitals是map它的的键值对总会匹配键值对模式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;country&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;city&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="n"&gt;capitals&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
         &lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"The capital of"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;country&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;"is"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;city&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="nc"&gt;The&lt;/span&gt; &lt;span class="n"&gt;capital&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;Franceis&lt;/span&gt; &lt;span class="nc"&gt;Paris&lt;/span&gt;
&lt;span class="nc"&gt;The&lt;/span&gt; &lt;span class="n"&gt;capital&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="nc"&gt;Japanis&lt;/span&gt; &lt;span class="nc"&gt;Tokyo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是生成的数据也有可能不能匹配。例如下面的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt; &lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"apple"&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="nc"&gt;None&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
           &lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"orange"&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt;&lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Option&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;java.lang.String&lt;/span&gt;&lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="k"&gt;=&lt;/span&gt;&lt;span class="nc"&gt;List&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;apple&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt;
     &lt;span class="nc"&gt;None&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;orange&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;scala&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nc"&gt;Some&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fruit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="k"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fruit&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;apple&lt;/span&gt;
&lt;span class="n"&gt;orange&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子中None元素不会匹配Some(fruit)，因此它不会显示出来。&lt;/p&gt;
&lt;h2&gt;一个大型的示例&lt;/h2&gt;</content><category term="scala"></category></entry><entry><title>OAF开发笔记</title><link href="/oafkai-fa-bi-ji.html" rel="alternate"></link><published>2010-12-09T00:00:00+08:00</published><updated>2010-12-09T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-12-09:/oafkai-fa-bi-ji.html</id><summary type="html">&lt;h1&gt;开发advancedTable in advancedTable&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置两个VO，建立两个VO之间的View Link对象。在页面中以两个VO中的主VO创建outerTable，在outerTable上创建detail，在这个detail中再以主从关系中的从VO创建innerTable。outerTable和inerTable都为advancedTable类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从关系中主VO需要增加一个属性用于标识下innerTable是否展开，它的值为字符串Y或N。将outerTable的Detail View Attribute设置为这个属性的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将outterTable的Child View Attribute设置为关联字段的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将outterTable的View Link Instance设置为主从关系的View Link实例名（不是类名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将innerTable和Detail View Attribute设置为对应的属性（如果有）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将innerTable的View Link Instance设置为主从关系的View Link实例名（不是类名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些设置与OAF Guide中下面这段代码起的作用是一样的，这样设置以后下面CO中的代码就不需要了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(...)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;outerTable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAWebBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"outerTable"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;innerTable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAWebBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"innerTable …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;开发advancedTable in advancedTable&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;配置两个VO，建立两个VO之间的View Link对象。在页面中以两个VO中的主VO创建outerTable，在outerTable上创建detail，在这个detail中再以主从关系中的从VO创建innerTable。outerTable和inerTable都为advancedTable类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从关系中主VO需要增加一个属性用于标识下innerTable是否展开，它的值为字符串Y或N。将outerTable的Detail View Attribute设置为这个属性的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将outterTable的Child View Attribute设置为关联字段的名称。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将outterTable的View Link Instance设置为主从关系的View Link实例名（不是类名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将innerTable和Detail View Attribute设置为对应的属性（如果有）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将innerTable的View Link Instance设置为主从关系的View Link实例名（不是类名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些设置与OAF Guide中下面这段代码起的作用是一样的，这样设置以后下面CO中的代码就不需要了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(...)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;outerTable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAWebBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"outerTable"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;innerTable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAWebBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"innerTable"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outerTable&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;outerTable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CHILD_VIEW_ATTRIBUTE_NAME&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"Deptno"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;outerTable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;VIEW_LINK_NAME&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"DeptEmpVL"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;innerTable&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;innerTable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CHILD_VIEW_ATTRIBUTE_NAME&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"Deptno"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;innerTable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;VIEW_LINK_NAME&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s"&gt;"DeptEmpVL"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;开发HGrid和Tree组件&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;以自关联的VO为例，添加一个VL以关联自身。但并不要求必须是自关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建一个hGrid区域，在其中添加tree和其它的项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在tree的nodeDef中设置好View Instance和View Attribute以作为节点的标题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在tree和childNode中设置Ancestor Node为需要递归显示的区域，例如：/dtxxsoft/oracle/apps/cux/dpt/task/webui/DptTaskMainPG.TreeColumnRN。不要使用View Link Instance，它已经deprecated，只需要设置View Link Accessor，它的值为VL的定义中Destination一方的Accessor Name。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HGrid的查询。多次尝试未成功。替代的方法是另做一个列表页面进行查询，在列表中选中节点后，计算出该节点在树中的路径，再转到HGrid页面，并Focus到这个节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HGrid的初始焦点路径，例如设置到根节点的第5个子节点下的第2个节点上。查询时也是通过设置该属性来定位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;focusRootPath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;setInitialFocusPath&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;focusRootPath&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;HGrid列表在数据库中的新数据时不能刷新，即使将HGrid对应的vo缓存清空也无效。只能在页面跳转时不保存am，或者手工调用pageContext.releaseRootApplicationModule方法让页面的AM失效，这样HGrid界面才能刷新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果设置焦点路径要注意HGrid根节点有多个节点和只有一个节点时的区别，如果只有一个节点则它将是根节点。如果有多个根极节点，则HGrid将自动产生一个根节点。如果只有一个根级节点，则计算路径时，不要将根节点自身计算进去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;关于RetainAM&lt;/h1&gt;
&lt;p&gt;开发手册中所说的RetainAM的情况必须是在两个页面使用相同类型的根应用模块时才能使用。而在实际使用过程中，我发现两个页面使用了不同的AM，在使用RetainAM=Y时同样有效。例如，从A页面Forward到B页面时RetainAM=Y，然后在B页面进行一些操作，此过程中总是使用RetainAM=Y，当从B页面回到A页面时仍然使用RetainAM=Y，这样A页面的AM的状态仍然能够保留。即使我在B页面中使用pageContext.releaseRootApplicationModule()，这时失效的也只是B页面自己的AM，回到A页面时，A页面的AM仍然有效。&lt;/p&gt;
&lt;h1&gt;基于SQL的只读VO的一个Bug&lt;/h1&gt;
&lt;p&gt;如果使用&lt;code&gt;select t.* from aaa t&lt;/code&gt;之类的SQL来创建VO，当aaa表中添加了新的字段后，VO不能自动同步，页面中的项有可能出现与VO的属性不匹配的情况。&lt;/p&gt;
&lt;h1&gt;取库存组织&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;select oav.organization_id org_id,
       oav.organization_code org_code,
       oav.organization_name org_name,
       oav.responsibility_id resp_id,
       oav.resp_application_id resp_app_id
from   org_access_view oav,
       mtl_parameters mp,
       wip_eam_parameters wep
where  oav.organization_id = mp.organization_id
and    NVL(mp.eam_enabled_flag,'N') = 'Y'
and    oav.organization_id = wep.organization_id
order by org_code
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;日志&lt;/h1&gt;
&lt;p&gt;OAF日志不支持日志级别的处理。没有日志的优先级。日志级别的有效值是OAFwkConstant中的UNEXPECTED, ERROR, EXCEPTION, EVENT, ROCEDURE, STATEMENT, PERFORMANCE。&lt;/p&gt;
&lt;h1&gt;开发包含train的多步处理页面&lt;/h1&gt;
&lt;p&gt;开发文档中有个错误：&lt;/p&gt;
&lt;p&gt;Step CE-5.3 Add Links to the navigationBar中Destination URI /&lt;yourname&gt;/oracle/apps/ak/employee/webui/ EmpUpdatePG的Destination URI的值应该与应该包含OA.jsp?page=。该值应该与Step CE-4.2 Add Three Train Nodes to the EmpTrainRN Region中设置的Destination URI的值保持一致。&lt;/yourname&gt;&lt;/p&gt;
&lt;p&gt;该错误将导致点击&amp;ldquo;下一步&amp;rdquo;时train最多只能到第二步，NavButtonBar中的下拉列表中的当前步骤始终显示为第一步。&lt;/p&gt;
&lt;h1&gt;OAF页面缓存&lt;/h1&gt;
&lt;h2&gt;清除高速缓存&lt;/h2&gt;
&lt;p&gt;页面缓存将被清理
Functional Adminstrator &amp;gt; Core services &amp;gt; Caching Framework &amp;gt; Clear cache.&lt;/p&gt;
&lt;h2&gt;开发中的页面缓存&lt;/h2&gt;
&lt;p&gt;在JSP页面中使用oracle.apps.jtf.cache.CacheManager.invalidate()方法可以清空页面缓存。&lt;/p&gt;
&lt;h1&gt;由链接弹出的页面&lt;/h1&gt;
&lt;p&gt;将链接的target属性为_blank时页面将在弹出窗口中打开。这时要注意，链接上要加上retainAM=Y否则在窗口弹出后，在原页面中进行操作时将出错。&lt;/p&gt;
&lt;p&gt;有可能是因为oaf中的am实际是与用户session关联的，当与服务器有交互时，如果没有retainAM则上一个am将丢失。ebs中除了lov之类的弹出页面外，也没有其它的弹出页面。估计也是因为这个原因，oaf不能维护在同一个http session中进行两个AM相关的操作。这是根据以下分析得来的：&lt;/p&gt;
&lt;p&gt;在弹出的窗口中，如果所有操作都是post或retainAM=Y的操作，则原窗口中仍可继续操作。如果在弹出窗口中点击了&amp;ldquo;主页&amp;rdquo;等会让AM失效的链接时，则父窗口的AM也将失效。&lt;/p&gt;
&lt;h1&gt;JSP相关&lt;/h1&gt;
&lt;h2&gt;在JSP中获取JDBC连接&lt;/h2&gt;
&lt;p&gt;来源：http://www.itjaj.com/thread-3994-1-1.html&lt;/p&gt;
&lt;p&gt;方法一：使用FWAppsContext获取连接&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"java.sql.Connection"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.jtf.base.session.FWAppsContext"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.jtf.base.session.ServletSessionManager"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.jtf.base.session.FWSession"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;

&lt;span class="x"&gt;String appName = request.getParameter("appName");&lt;/span&gt;
&lt;span class="x"&gt;String stateless = request.getParameter("stateless");&lt;/span&gt;

&lt;span class="x"&gt;if (appName == null) appName = "JTF";&lt;/span&gt;
&lt;span class="x"&gt;if (stateless == null) stateless = "T";&lt;/span&gt;

&lt;span class="x"&gt;FWSession _fwSession;&lt;/span&gt;
&lt;span class="x"&gt;try {&lt;/span&gt;
&lt;span class="x"&gt;  _fwSession = oracle.apps.jtf.base.session.ServletSessionManager.startRequest(request,response,appName,statelessB);&lt;/span&gt;
&lt;span class="x"&gt;} catch(oracle.apps.jtf.base.session.ServletSessionManagerException e) {&lt;/span&gt;
&lt;span class="x"&gt;  throw e;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="x"&gt;FWAppsContext cont = _fwSession.getFWAppsContext();&lt;/span&gt;
&lt;span class="x"&gt;Connection conn = cont.getJDBCConnection();&lt;/span&gt;

&lt;span class="x"&gt;try {&lt;/span&gt;
&lt;span class="x"&gt;  // 程序代码逻辑&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="x"&gt;finally {&lt;/span&gt;
&lt;span class="x"&gt;  if (conn != null)&lt;/span&gt;
&lt;span class="x"&gt;    conn.close();&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;

&lt;span class="x"&gt;/**** End Request ****/&lt;/span&gt;
&lt;span class="x"&gt;try {&lt;/span&gt;
&lt;span class="x"&gt;  oracle.apps.jtf.base.session.ServletSessionManager.endRequest(request, false);&lt;/span&gt;
&lt;span class="x"&gt;} catch(oracle.apps.jtf.base.session.ServletSessionManagerException e) {&lt;/span&gt;
&lt;span class="x"&gt;  throw e;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FWAppsContext可以获取很多环境数据，如UserID、RespId、RespApplId等，还可以设置和获取Session值。&lt;/p&gt;
&lt;p&gt;方法二：使用EBS的SSO类库获取数据库连接&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.fnd.common.WebAppsContext"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="vi"&gt;@page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.fnd.common.ProfileStore"&lt;/span&gt;&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="n"&gt;page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.fnd.sso.*"&lt;/span&gt; &lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;

&lt;span class="x"&gt;boolean isCtxAvailable = false;&lt;/span&gt;
&lt;span class="x"&gt;WebAppsContext wctx = null;&lt;/span&gt;

&lt;span class="x"&gt;if (Utils.isAppsContextAvailable())&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;  isCtxAvailable = true;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="x"&gt;wctx = Utils.getAppsContext();&lt;/span&gt;
&lt;span class="x"&gt;Connection conn = Utils.getConnection();&lt;/span&gt;
&lt;span class="x"&gt;ProfileStore profilestore = wctx.getProfileStore();&lt;/span&gt;

&lt;span class="x"&gt;try&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;  // 程序代码逻辑&lt;/span&gt;

&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="x"&gt;finally&lt;/span&gt;
&lt;span class="x"&gt;{&lt;/span&gt;
&lt;span class="x"&gt;  conn.close();&lt;/span&gt;
&lt;span class="x"&gt;  if (!isCtxAvailable)&lt;/span&gt;
&lt;span class="x"&gt;  {&lt;/span&gt;
&lt;span class="x"&gt;    Utils.releaseAppsContext();&lt;/span&gt;
&lt;span class="x"&gt;  }&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法三：其它方法
上面两种方法是我常用的方法，除此之外，还可以使用以下任一种方法来获取连接，其实每种方式最终都是调用AppsContext来获取数据库连接的
1、调用oracle.apps.jtf.aom.transaction.TransactionScope.getConnection();&lt;/p&gt;
&lt;p&gt;2、使用WebRequestUtil来获取WebAppsContext，并最终获取数据库连接&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="n"&gt;page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.fnd.common.WebAppsContext"&lt;/span&gt; &lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt; &lt;span class="n"&gt;page&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"oracle.apps.fnd.common.WebRequestUtil"&lt;/span&gt; &lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;

&lt;span class="cp"&gt;&amp;lt;%&lt;/span&gt;
&lt;span class="no"&gt;WebAppsContext&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;WebRequestUtil&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;validateContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="no"&gt;WebRequestUtil&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setClientEncoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="no"&gt;Connection&lt;/span&gt; &lt;span class="n"&gt;conn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getJDBCConnection&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="cp"&gt;%&amp;gt;&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;JSP文件编译&lt;/h2&gt;
&lt;p&gt;相关环境变量：
 - $FND_TOP/patch/115/bin/ojspCompile.pl JSP编译脚本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$OA_HTML JSP保存目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$OAD_TOP/_pages JSP编译为class后的保存目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译命令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强制重新编译所有JSP文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ojspCompile.pl &amp;ndash;compile &amp;ndash;flush -p
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;编译单个文件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ojspCompile.pl --compile -s a.jsp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a.jsp为文件名匹配表达式。&lt;/p&gt;
&lt;h1&gt;设置表格中汇总数据的值&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OAMessageStyledTextBean&lt;/span&gt; &lt;span class="n"&gt;salaryBean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAMessageStyledTextBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"item1"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;salaryBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TABULAR_FUNCTION_VALUE_ATTR&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例中iem1为，设置了Total Value为True的列。&lt;/p&gt;
&lt;h1&gt;UI控制&lt;/h1&gt;
&lt;h2&gt;不同UI效果的例子&lt;/h2&gt;
&lt;p&gt;对于不同的UI效果可以参考范例包oracle.apps.fnd.framework.toolbox.samplelib中的例子。&lt;/p&gt;
&lt;h2&gt;自定义xss文件来设置CSS定义&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="nt"&gt;&amp;lt;style&lt;/span&gt; &lt;span class="na"&gt;selector=&lt;/span&gt;&lt;span class="s"&gt;".CuxIssueLevel02"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"color"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;#ff6600&lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改OA_HTML/cabo/custom.xss或者添加新的xss文件然后在custom.xss中引用。然后通过设置WebBean的CSSClass属性来使用所定义的样式。&lt;/p&gt;
&lt;p&gt;使用中发现有bug，在其中定义颜色使用"orange"时不能正确生成到css文件中去，而使用rgb方法来表示则正常。&lt;/p&gt;
&lt;h2&gt;使用UrlInclude引入CSS定义&lt;/h2&gt;
&lt;p&gt;使用UrlInclude组件包含CSS文件或包含带样式定义的文件。然后通过设置WebBean的CSSClass属性来使用所定义的样式。&lt;/p&gt;
&lt;h2&gt;设置内联样式&lt;/h2&gt;
&lt;p&gt;直接设置WebBean的InlineStyle来设置内联样式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;CSSStyle&lt;/span&gt; &lt;span class="n"&gt;cellStyle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;CSSStyle&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;cellStyle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setProperty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"border"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"#cc0000 solid"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;cellStyle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setProperty&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"border-width"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"0 1 1 0"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;cellFormatBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setInlineStyle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cellStyle&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;编程方式实现动态绑定属性&lt;/h2&gt;
&lt;p&gt;默认情况下Required, Rendered, Disabled, and Read Only的值可以设置为SPEL表达式。如果有其它属性需要动态绑定则要使用动态绑定技术。OAF提供了三种类型的绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fnd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;framework&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;webui&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;OADataBoundValueViewObject&lt;/span&gt;
&lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fnd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;framework&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;webui&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;OADataBoundValueAppModule&lt;/span&gt;
&lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;apps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;fnd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;framework&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;webui&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;OAFunctionSecurityBoundValue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;使用动态绑定控制组件样式&lt;/h2&gt;
&lt;p&gt;通过使用OADataBoundValueViewObject将组件的style Class绑定到VO属性上来控制颜色。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;bean&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"bean"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bean&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;bean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAMessageStyledTextBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STYLE_CLASS_ATTR&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
                           &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OADataBoundValueViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bean&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; 
                                                          &lt;span class="s"&gt;"ViewAttrName"&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;样式可以使用上节中介绍的方法进行定义。&lt;/p&gt;
&lt;h1&gt;新建记录后在保存后，部分LOV带出来的只读字段丢失&lt;/h1&gt;
&lt;p&gt;这是因为只读字段的数据不会被保存到VO中，因此需要在保存完后刷新一次当前的VO，让数据重新加载一次，这通常可以调用AM中编辑记录的方法，让它重新执行一次查询，使VO中的只读字段重新从数据库加载。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>Writing GNU Emacs Extensions笔记</title><link href="/writing-gnu-emacs-extensionsbi-ji.html" rel="alternate"></link><published>2010-12-07T00:00:00+08:00</published><updated>2010-12-07T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-12-07:/writing-gnu-emacs-extensionsbi-ji.html</id><summary type="html">&lt;h1&gt;定制Emacs&lt;/h1&gt;
&lt;h2&gt;全局按键绑定&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="nv"&gt;keysequence&lt;/span&gt; &lt;span class="nv"&gt;command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;keysequence 中普通字符按键直接用相应的字符表示。&lt;code&gt;\&lt;/code&gt;应该被写作&lt;code&gt;\\&lt;/code&gt;。特殊字符如META-问号应该写作&lt;code&gt;\M-?&lt;/code&gt;。CONTROL-x应该写作&lt;code&gt;\C-x&lt;/code&gt; CONTROL META-x写作&lt;code&gt;\C-\M-x&lt;/code&gt;。CONTROL-x在文档中也被缩写为&lt;code&gt;^x&lt;/code&gt;，相应的应该表示为&lt;code&gt;\^x&lt;/code&gt;。&lt;code&gt;\M-?&lt;/code&gt;也可以表示为&lt;code&gt;\e?&lt;/code&gt;字符串&lt;code&gt;\e&lt;/code&gt;是转义字符。&lt;/p&gt;
&lt;h2&gt;查询按键绑定&lt;/h2&gt;
&lt;p&gt;C-h b命令来查询按键绑定信息，这个命令被绑定到了describe-bindings。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\M-?"&lt;/span&gt; &lt;span class="ss"&gt;'help-command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;对Lisp表达式求值的方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将表达式放到文件中然后load这个一拥而入。M-x load-file RET rebind.el RET。&lt;/li&gt;
&lt;li&gt;使用eval-last-sexp，它被绑定到C-x C-e。&lt;/li&gt;
&lt;li&gt;使用eval-express，它被绑定到&lt;code&gt;M-:&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;*scratch*&lt;/code&gt;缓冲构 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;定制Emacs&lt;/h1&gt;
&lt;h2&gt;全局按键绑定&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="nv"&gt;keysequence&lt;/span&gt; &lt;span class="nv"&gt;command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;keysequence 中普通字符按键直接用相应的字符表示。&lt;code&gt;\&lt;/code&gt;应该被写作&lt;code&gt;\\&lt;/code&gt;。特殊字符如META-问号应该写作&lt;code&gt;\M-?&lt;/code&gt;。CONTROL-x应该写作&lt;code&gt;\C-x&lt;/code&gt; CONTROL META-x写作&lt;code&gt;\C-\M-x&lt;/code&gt;。CONTROL-x在文档中也被缩写为&lt;code&gt;^x&lt;/code&gt;，相应的应该表示为&lt;code&gt;\^x&lt;/code&gt;。&lt;code&gt;\M-?&lt;/code&gt;也可以表示为&lt;code&gt;\e?&lt;/code&gt;字符串&lt;code&gt;\e&lt;/code&gt;是转义字符。&lt;/p&gt;
&lt;h2&gt;查询按键绑定&lt;/h2&gt;
&lt;p&gt;C-h b命令来查询按键绑定信息，这个命令被绑定到了describe-bindings。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\M-?"&lt;/span&gt; &lt;span class="ss"&gt;'help-command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;对Lisp表达式求值的方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将表达式放到文件中然后load这个一拥而入。M-x load-file RET rebind.el RET。&lt;/li&gt;
&lt;li&gt;使用eval-last-sexp，它被绑定到C-x C-e。&lt;/li&gt;
&lt;li&gt;使用eval-express，它被绑定到&lt;code&gt;M-:&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;*scratch*&lt;/code&gt;缓冲构。在这个缓冲区处于Lisp Interaction模式。这个模式下，按C-j将调用eval-print-last-sexp，它与eval-lastsexp类似，但是它会将执行的结果插到光标位置。Lisp Interaction模式下的另一个作用是按M-TAB将能自动完成Lisp符号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Apropos&lt;/h2&gt;
&lt;p&gt;使用apropos来查找命令。
&lt;example&gt;
M-x apropos RET delete RET
&lt;/example&gt;
查找符合"delete"的Emacs变量和函数。&lt;/p&gt;
&lt;p&gt;可以给apropos传递前缀参数。在Emacs中，在执行一个命令前按C-u可以向命令传递特殊信息。C-u通常跟数字参数；例如，C-u 5 C-b表示将光标向左移动5个字符。有些情况下，这个额外信息只是表明你按过了C-u。当调用apropos时使用了前缀参数时，它不光会报告匹配到的函数和变量，还会报告每个命令所使用的按键绑定。&lt;/p&gt;
&lt;p&gt;当知道要搜索的目标是Emacs命令时，可以直接使用command-apropos（M-? a）代替apropos。命令和函数的区别在于命令可以交互的执行。&lt;/p&gt;
&lt;h2&gt;想法&lt;/h2&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;h1&gt;简单的新命令&lt;/h1&gt;</content><category term="emacs"></category></entry><entry><title>Learn VI 笔记</title><link href="/learn-vi-bi-ji.html" rel="alternate"></link><published>2010-09-29T00:00:00+08:00</published><updated>2010-09-29T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-09-29:/learn-vi-bi-ji.html</id><summary type="html">&lt;h1&gt;VI编辑器&lt;/h1&gt;
&lt;p&gt;vi默认模式为命令模式&lt;/p&gt;
&lt;p&gt;基本编辑命令都是1到2个字母，如i和cw（change word）&lt;/p&gt;
&lt;p&gt;命令特点：
 - 命令大小写敏感
 - 输入的时候没有回显
 - 不需要回车&lt;/p&gt;
&lt;p&gt;也有一些命令有回显如/、:和?等。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h2&gt;打开关闭文件&lt;/h2&gt;
&lt;p&gt;在命令行上指定路径和文件名。&lt;/p&gt;
&lt;p&gt;使用vi时可能会出现一些问题如：
 - 终端类型引起的问题
 - 文件已经存在
 - 处理ex line-editing模式
 - 文件只读的提示
 - 不能编辑的文件（目录、非ascii、可执行文件等等）&lt;/p&gt;
&lt;p&gt;遇到这些问题时可以用:quit!强制退出。&lt;/p&gt;
&lt;p&gt;:w命令保存文件，:wq、ZZ保存并退出。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h2&gt;不保存而退出&lt;/h2&gt;
&lt;p&gt;:e!放弃自打开文件以来所做的编辑操作。&lt;/p&gt;
&lt;p&gt;:q!不保存而强制退出。&lt;/p&gt;
&lt;p&gt;保存文件可能遇到：
 - 文件已经存在。可以用:w!强制覆盖文件，或:w newfile写入其它文件。
 - 没有权限写文件。同上用 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;VI编辑器&lt;/h1&gt;
&lt;p&gt;vi默认模式为命令模式&lt;/p&gt;
&lt;p&gt;基本编辑命令都是1到2个字母，如i和cw（change word）&lt;/p&gt;
&lt;p&gt;命令特点：
 - 命令大小写敏感
 - 输入的时候没有回显
 - 不需要回车&lt;/p&gt;
&lt;p&gt;也有一些命令有回显如/、:和?等。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h2&gt;打开关闭文件&lt;/h2&gt;
&lt;p&gt;在命令行上指定路径和文件名。&lt;/p&gt;
&lt;p&gt;使用vi时可能会出现一些问题如：
 - 终端类型引起的问题
 - 文件已经存在
 - 处理ex line-editing模式
 - 文件只读的提示
 - 不能编辑的文件（目录、非ascii、可执行文件等等）&lt;/p&gt;
&lt;p&gt;遇到这些问题时可以用:quit!强制退出。&lt;/p&gt;
&lt;p&gt;:w命令保存文件，:wq、ZZ保存并退出。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h2&gt;不保存而退出&lt;/h2&gt;
&lt;p&gt;:e!放弃自打开文件以来所做的编辑操作。&lt;/p&gt;
&lt;p&gt;:q!不保存而强制退出。&lt;/p&gt;
&lt;p&gt;保存文件可能遇到：
 - 文件已经存在。可以用:w!强制覆盖文件，或:w newfile写入其它文件。
 - 没有权限写文件。同上用:w newfile。
 - 文件系统满了。用:!rm junkfile删除不需要的文件腾出空间。:!df查看硬盘空间。
 - 临时文件系统满了。
 - 硬盘空间限制达到上限。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h1&gt;简单编辑&lt;/h1&gt;
&lt;h2&gt;vi命令&lt;/h2&gt;
&lt;p&gt;vi有两个模式：命令模式和插入模式。进入时默认为命令模式。按ESC一到二次可退回命令模式。&lt;/p&gt;
&lt;h2&gt;移动光标&lt;/h2&gt;
&lt;p&gt;命令模式下h j k l分别代表左、下、上和右。&lt;/p&gt;
&lt;p&gt;移动前可以加数字参数比如4l代表按4次l。&lt;/p&gt;
&lt;p&gt;通过:set wm=10这样的选项可以让vi在距右边10个字符时自动插入换行符。&lt;/p&gt;
&lt;p&gt;行内移动：0移到行首，$移到行末。&lt;/p&gt;
&lt;p&gt;:set nu显示行号。&lt;/p&gt;
&lt;p&gt;块移动：w和W向前移动一个单词，b和B向后移动一个单词。两组的区别在于移动时大写的命令将包含标点。块移动命令也可以带数字参数。&lt;/p&gt;
&lt;p&gt;问答 ::&lt;/p&gt;
&lt;p&gt;总结 ::&lt;/p&gt;
&lt;h2&gt;简单编辑指令&lt;/h2&gt;
&lt;p&gt;a追加，c修改，d删除。&lt;/p&gt;</content><category term="vi"></category><category term="vim"></category></entry><entry><title>记笔记的方法</title><link href="/ji-bi-ji-de-fang-fa.html" rel="alternate"></link><published>2010-09-19T00:00:00+08:00</published><updated>2010-09-17T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-09-19:/ji-bi-ji-de-fang-fa.html</id><summary type="html">&lt;p&gt;所有笔记记法都有优缺点。当你自己已经熟悉这些种技法时，你会发现自己其实也在做同样的事情。这是因为在不同的演讲和会议上，你会自动地意识到究竟哪一种方法才是记下笔记的最佳途径。&lt;/p&gt;
&lt;h1&gt;列提纲&lt;/h1&gt;
&lt;p&gt;在这种技巧中，所记下的内容是有等级顺序的。你开始时写下大意，然后在其之下写下更多更具体的相关内容。按这种方式，你将能列出一个从整体概念到具体知识的知识的清单。而这种技巧的最大不足是很难显示不同概念之间的联系。为了弥补这一点，我们必须用到箭头，而这又使得笔记凌乱不堪。&lt;/p&gt;
&lt;h1&gt;思路图析&lt;/h1&gt;
&lt;p&gt;这种方法可使列提纲的方法优势最大化。当不同概念之间的关联需要直观表现时，我们用得到这种思路图析的方法。找出一张白纸，把演讲或讨论会的核心话题放在纸的正中间。然后开始用箭头把分概念与主概念相连。把每一个概念用相互独立的泡泡圈起来，以使概念之间更好分辨。当所有的概念都被连接之后，你应该对这个特定的话题形成一个路线图（这样就是为什么叫&amp;ldquo;思路图析&amp;rdquo;的原因）。&lt;/p&gt;
&lt;h1&gt;康乃尔笔记法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;(1).上课时记笔记：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用大张活页笔记本，在距离左边6公分处划一条垂直线。在线的右边记下上课的重要内容（重要事件、想法、定义等有助了解主题的细节）。对重复出现字或词组，以代号或简写代替。只用笔记纸的其中一面,在另一主题开始前，留下几行空白让自己了解这是另一主题的开始。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(2).整理：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下列原则整理笔记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;①上完课后尽快将简写代号拼凑完整。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;②画清楚图表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;③在新词语和重要句子旁划记号强调 …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;所有笔记记法都有优缺点。当你自己已经熟悉这些种技法时，你会发现自己其实也在做同样的事情。这是因为在不同的演讲和会议上，你会自动地意识到究竟哪一种方法才是记下笔记的最佳途径。&lt;/p&gt;
&lt;h1&gt;列提纲&lt;/h1&gt;
&lt;p&gt;在这种技巧中，所记下的内容是有等级顺序的。你开始时写下大意，然后在其之下写下更多更具体的相关内容。按这种方式，你将能列出一个从整体概念到具体知识的知识的清单。而这种技巧的最大不足是很难显示不同概念之间的联系。为了弥补这一点，我们必须用到箭头，而这又使得笔记凌乱不堪。&lt;/p&gt;
&lt;h1&gt;思路图析&lt;/h1&gt;
&lt;p&gt;这种方法可使列提纲的方法优势最大化。当不同概念之间的关联需要直观表现时，我们用得到这种思路图析的方法。找出一张白纸，把演讲或讨论会的核心话题放在纸的正中间。然后开始用箭头把分概念与主概念相连。把每一个概念用相互独立的泡泡圈起来，以使概念之间更好分辨。当所有的概念都被连接之后，你应该对这个特定的话题形成一个路线图（这样就是为什么叫&amp;ldquo;思路图析&amp;rdquo;的原因）。&lt;/p&gt;
&lt;h1&gt;康乃尔笔记法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;(1).上课时记笔记：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用大张活页笔记本，在距离左边6公分处划一条垂直线。在线的右边记下上课的重要内容（重要事件、想法、定义等有助了解主题的细节）。对重复出现字或词组，以代号或简写代替。只用笔记纸的其中一面,在另一主题开始前，留下几行空白让自己了解这是另一主题的开始。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(2).整理：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下列原则整理笔记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;①上完课后尽快将简写代号拼凑完整。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;②画清楚图表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;③在新词语和重要句子旁划记号强调 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;④以星号或惊叹号标出重点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;⑤订正错字。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直线左边字段为复习栏，将右边上课笔记整理完后在此写下关键词或词、简短标题、重要概念摘要及加上批注。可强化印象及提供复习架构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(3).演练：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以手盖住右边笔记，只看左边练习栏内容，问自己问题并进可能大声说出记得的笔记内容，然后拿开手对照答案是否完整，有助将所学传递至长期记忆。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(4).复习：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多做几次自问自答（每次时间勿太长）。短但多次的复习效果较佳。每节课后花十分钟做简短复习可将上课内容稳稳留在长期记忆内。对于程序性内容必须重做。&lt;/p&gt;
&lt;p&gt;教师模拟，自我讲解。&lt;/p&gt;
&lt;p&gt;&lt;img alt="学习方法" src="/cornell_method/cornell_method.jpg"/&gt;&lt;/p&gt;
&lt;h1&gt;文学作用的笔记方法&lt;/h1&gt;
&lt;h2&gt;摘录式&lt;/h2&gt;
&lt;p&gt;读书时，把书报上精彩的、有意义的、富有哲理的语句、重要的片断摘抄下来。摘录时要注意，不能全抄，而要把书中的优美词语按人物类、景物类、状物类、警句类等摘抄下来。日积月累，积少成多，积沙成塔，写作文需要时，就可以从&amp;ldquo;词语仓库&amp;rdquo;里搬出来，参考使用。&lt;/p&gt;
&lt;h2&gt;体会式&lt;/h2&gt;
&lt;p&gt;读书之后，有自己的收获、心得、体会或认识、感想等，再联系自己实际写下来，这叫读书体会或读后感。这种体会式的笔记，应以自己的语言为主，适当地引用原文作例证，表达自己的看法、想法，写出真情实感来。&lt;/p&gt;
&lt;h2&gt;提纲式&lt;/h2&gt;
&lt;p&gt;我们读一篇文章，要逐段地把作者隐含的提纲找出来，记下来，弄清楚文章的主要内容和写作思路。编提纲可以采用文中语句和自己语言相结合的方式写，提纲的语言要简洁扼要，具有高度的概括性。提纲式笔记可以帮助我们抓住中心，记住要点，理清思路，加深对文章的理解。&lt;/p&gt;
&lt;h2&gt;批注式&lt;/h2&gt;
&lt;p&gt;在阅读自己订阅的报刊和购买的书籍时，为了加深对文章内容的理解，可边读边在书中重要的地方和自己体会最深的地方，写写画画，把书中的重点词句和重要内容用圈、点、画等标记勾划出来，或在空白处写上批语、心得体会、意见，或者是折页、夹纸条作记号等等。这是一种最简易的笔记作法。&lt;/p&gt;
&lt;h2&gt;书签式&lt;/h2&gt;
&lt;p&gt;平时读书时，遇到需要背诵的内容，可以记在书签上。把书签夹在课本里、放在口袋里或插在房间专放书签的袋子里，一有空就读一读、念一念、背一背，直到背得滚瓜烂熟，记得牢为止，再把它存放起来。这种书签式的方法，可以帮助我们记忆。如此反复，脑子里积累的东西就会越来越多了。&lt;/p&gt;
&lt;h2&gt;卡片式&lt;/h2&gt;
&lt;p&gt;就是用厚纸剪成大小一样的卡片。读书时，可按照写人、记事、写景、状物分门别类地摘记下来，再按书卡分类存放。存放的位置还要按类别，编上号码，写出标题，以便使用时查找。卡片还有携带、使用方便的特点。每天拿出几张卡片读一读，背一背，日积月累，脑子积累的词汇材料就越来越丰富。写作时，就可以从脑子的&amp;ldquo;储蓄库&amp;rdquo;里搬出来用，就不愁写不好作文了。做卡片时有四点小的要求：一是每张卡片最好只写一个问题，一个事例。这样既灵活，又不乱，便于分类整理装订成册。二是每张卡片须注明资料来源、书名、篇名、版本、卷首、页码等，便于查找。三是随着学习水平的提高，应注意积累卡片向某些方面集中，使之更加系统化和深化。四是一定要养成定期整理的习惯，按性质或需要把卡片编上页码，分类插放。既为查找使用提供方便，又可在整理过程中使自己平时分散、零碎的知识系统、条理起来。&lt;/p&gt;
&lt;h2&gt;剪报式&lt;/h2&gt;
&lt;p&gt;凡是遇到处理的废报、废书，在完全抛弃之前，可以检查一下其中是否有适合留下的文章。不管是一句名言还是一幅图画，都可以剪下在粘贴在自己准备好的剪报本上，空闲时象翻相夹那样随意阅读，也是一种享受呢。&lt;/p&gt;
&lt;h2&gt;索引式&lt;/h2&gt;
&lt;p&gt;即写下有关的论文题目或书名等。在阵习中可能经常会碰到这种情况；看到某些东西感到十分有用，但内容却太多，上述三种笔记法又都不易采用．或者是这个内容，你本身就有这本书，所以也不必采用上述方法。但是往往到要用这个内容时，你却忘记了或找不到了。诸如此类问题，只要搞好素引，便可顺手拈来。&lt;/p&gt;</content><category term="cornel"></category></entry><entry><title>汇编语言（王爽）读书笔记</title><link href="/hui-bian-yu-yan-wang-shuang-du-shu-bi-ji.html" rel="alternate"></link><published>2010-09-01T00:00:00+08:00</published><updated>2010-09-01T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-09-01:/hui-bian-yu-yan-wang-shuang-du-shu-bi-ji.html</id><summary type="html">&lt;h1&gt;基础知识&lt;/h1&gt;
&lt;h2&gt;存储单元&lt;/h2&gt;
&lt;p&gt;最小信息单位是bit（比特、二进制位），8bit为1Byte（字节）。存储单元以字节为单位计。128个存储单元的存储器可以存储128字节。&lt;/p&gt;
&lt;h2&gt;CPU对存储器的读写&lt;/h2&gt;
&lt;h3 id="du-xie-shi-cpuyu-wai-bu-qi-jian-jin-xing-3lei-xin-xi-jiao-hu"&gt;读写时CPU与外部器件进行3类信息交互：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;存储单元的地址（地址信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;器件的选择，读或写的命令（控制信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读或写的数据（数据信息）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="du-xie-guo-cheng"&gt;读写过程&lt;/h3&gt;
&lt;h4 id="cpucong-3hao-dan-yuan-zhong-du-qu-shu-ju-guo-cheng"&gt;CPU从3号单元中读取数据过程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU通过地址线将地址信息3发出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过控制线发出内存读取命令，选中存储芯片，并通知它，将要从中读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储器将3号单元中的数据通过数据线送入CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="cpuxiang-3hao-dan-yuan-xie-ru-shu-ju"&gt;CPU向3号单元写入数据&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU通过地址线将地址信息3发出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过数据线将数据送入内存的3号单元中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="di-zhi-zong-xian_1"&gt;地址总线&lt;/h3&gt;
&lt;p&gt;一个CPU有N根地址线，则可以立这个CPU的地址总线宽度为N。这样CPU可以最多寻找2的N次方个内存单元。&lt;/p&gt;
&lt;h3 id="shu-ju-zong-xian"&gt;数据总线&lt;/h3&gt;
&lt;p&gt;CPU与内存或其它器件之间的数据传递是通过数据总线进行的。数据总线宽度决定了CPU和外界的数据传送速度（宽度不足时将需要进行多次传送）。8088CPU数据总线宽度为8，8086CPU的数据总线宽度为16。&lt;/p&gt;
&lt;h3 id="kong-zhi-zong-xian"&gt;控制总线&lt;/h3&gt;
&lt;p&gt;控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。它决定了CPU对外部器件的控制能力。&lt;/p&gt;
&lt;h3 id="di-zhi-kong-jian-gai-shu"&gt;地址空间概述&lt;/h3&gt;
&lt;p&gt;主板上的核心器件通过总线 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;基础知识&lt;/h1&gt;
&lt;h2&gt;存储单元&lt;/h2&gt;
&lt;p&gt;最小信息单位是bit（比特、二进制位），8bit为1Byte（字节）。存储单元以字节为单位计。128个存储单元的存储器可以存储128字节。&lt;/p&gt;
&lt;h2&gt;CPU对存储器的读写&lt;/h2&gt;
&lt;h3 id="du-xie-shi-cpuyu-wai-bu-qi-jian-jin-xing-3lei-xin-xi-jiao-hu"&gt;读写时CPU与外部器件进行3类信息交互：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;存储单元的地址（地址信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;器件的选择，读或写的命令（控制信息）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读或写的数据（数据信息）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="du-xie-guo-cheng"&gt;读写过程&lt;/h3&gt;
&lt;h4 id="cpucong-3hao-dan-yuan-zhong-du-qu-shu-ju-guo-cheng"&gt;CPU从3号单元中读取数据过程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU通过地址线将地址信息3发出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过控制线发出内存读取命令，选中存储芯片，并通知它，将要从中读取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储器将3号单元中的数据通过数据线送入CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="cpuxiang-3hao-dan-yuan-xie-ru-shu-ju"&gt;CPU向3号单元写入数据&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU通过地址线将地址信息3发出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU通过数据线将数据送入内存的3号单元中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="di-zhi-zong-xian_1"&gt;地址总线&lt;/h3&gt;
&lt;p&gt;一个CPU有N根地址线，则可以立这个CPU的地址总线宽度为N。这样CPU可以最多寻找2的N次方个内存单元。&lt;/p&gt;
&lt;h3 id="shu-ju-zong-xian"&gt;数据总线&lt;/h3&gt;
&lt;p&gt;CPU与内存或其它器件之间的数据传递是通过数据总线进行的。数据总线宽度决定了CPU和外界的数据传送速度（宽度不足时将需要进行多次传送）。8088CPU数据总线宽度为8，8086CPU的数据总线宽度为16。&lt;/p&gt;
&lt;h3 id="kong-zhi-zong-xian"&gt;控制总线&lt;/h3&gt;
&lt;p&gt;控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。它决定了CPU对外部器件的控制能力。&lt;/p&gt;
&lt;h3 id="di-zhi-kong-jian-gai-shu"&gt;地址空间概述&lt;/h3&gt;
&lt;p&gt;主板上的核心器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有：CPU、存储器、外围芯片组、扩展插槽（插有RAM内存条和各类接口卡）等。&lt;/p&gt;
&lt;p&gt;PC上的存储器芯片从读写属性上分为两类：RAM和ROM。从功能和连接上分为：RAM、BIOS及接口卡上的RAM（例如：显存）。&lt;/p&gt;
&lt;p&gt;这些存储器在物理上是独立的器件，但它们都和CPU的总线相连；CPU对它们进行读或写的时候都通过控制线发出内存读写命令。即CPU在操纵和控制它们的时候，把它们都当作内存来对侍，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。&lt;/p&gt;
&lt;p&gt;所有物理存储器被看作由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段。CPU在这段地址空间中读写数据，实际上就是在对相应的物理存储器中读写数据。&lt;/p&gt;
&lt;p&gt;内存地址空间的大小受CPU地址总线宽度的限制。8086CPU的地址总线宽度为20,可以传送2的20次方个不同的地址信息（内存单元），地址空间大小为1MB。80386CPU的地址总线宽度为32,则内在地址空间最大约为4GB。&lt;/p&gt;
&lt;h1&gt;寄存器（CPU工作原理）&lt;/h1&gt;
&lt;p&gt;CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章所说的总线相对于CPU内部来说是外部总线。在CPU中：运算器进行信息处理；寄存器进行信息存储；控制器控制各种器件进行工作；内部总线连接各种器件，在它们之间进行数据的传送。&lt;/p&gt;
&lt;p&gt;对于汇编程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。程序员通过改变各种上寄存器中的内容来实现对CPU的控制。&lt;/p&gt;
&lt;p&gt;8086CPU中有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。&lt;/p&gt;
&lt;h2&gt;通用寄存器&lt;/h2&gt;
&lt;p&gt;8086CPU的所有寄存器都是16位的，可以存储两个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性的数据，被称为通用寄存器。&lt;/p&gt;
&lt;p&gt;8086CPU的上代CPU中寄存器是8位的，为保证兼容性，8086CPU中的AX、BX、CX、DX四个寄存器都可以分为两个独立的8位寄存器来使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AX可分为AH和AL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BX可分为BH和BL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CX可分为CH和CL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DX可分为DH和DL&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;8086CPU可以一次性处理两种尺寸的数据：byte（字节，8位），可存在8位寄存器中，word（字，16位），可存在16位寄存器中。&lt;/p&gt;
&lt;h2&gt;物理地址&lt;/h2&gt;
&lt;p&gt;CPU访问内存单元时，要给出内存单元的地址。所有内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有惟一的地址，这个地址被称为物理地址。&lt;/p&gt;
&lt;p&gt;CPU通过地址总线卷入存储器的必须是一个内在单元的物理地址。在CPU向地址总线上发出物理地址之前，必须在内部先形成这个物理地址。&lt;/p&gt;
&lt;h2&gt;16位结构的CPU&lt;/h2&gt;
&lt;p&gt;16位结构的CPU有下面几方面的结构特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;运算器一次最多可以处理16位的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存器的最大宽度为16位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;寄存器和运算器之间的通路为16位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次处理、传输、暂存16位地址。&lt;/p&gt;
&lt;h2&gt;8086CPU给出物理地址的方法&lt;/h2&gt;
&lt;p&gt;8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂存的地址为16位。如果将地址从内部简单的发出，那就只能送出16位地址，表现出的寻址能力只有64KB。&lt;/p&gt;
&lt;p&gt;8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。&lt;/p&gt;
&lt;p&gt;当8086CPU要读写内存时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段地址和偏移地址通过内部总线送入一个称为地址加法器的部件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址加法器将两个16位地址合并成为一个20位的物理地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地址加法器通过内部总线将20位物理地址送入输入输出控制电路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入输出控制电路将20位物理地址送上地址总线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;20位物理地址被地址总线传送到存储器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;地址加法器采用 &lt;em&gt;物理地址＝段地址X16+偏移地址&lt;/em&gt; 的方法用段地址和偏移地址合成物理地址。&lt;/p&gt;
&lt;h2&gt;段的概念&lt;/h2&gt;
&lt;p&gt;将若干地址连续内在单元看作一个段，用段地址X16的起始地址（基础地址），用领衔地址定位段中的内在单元。有两点需要注意：段地址X16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位的寻址能力为64KB，所以一个段的长度最大为64KB。&lt;/p&gt;
&lt;h2&gt;段寄存器&lt;/h2&gt;
&lt;p&gt;8086CPU有4个段寄存器：CS、DS、SS、ES。&lt;/p&gt;
&lt;h2&gt;CS和IP&lt;/h2&gt;
&lt;p&gt;CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS主代码段寄存器，IP为指令指针寄存器。&lt;/p&gt;
&lt;p&gt;在8086CPU中，任意时刻，设CS中内容为M，IP中的内容为N，8086CPU将从内存MX16+N单元开始，读取下一条指令并执行。&lt;/p&gt;
&lt;p&gt;8086CPU加电启动或复位后CS和IP被设置为CS=F000H，IP=FFF0H，CPU从内存FFFF0H单元中读取指令执行。&lt;/p&gt;
&lt;h2&gt;修改CS、IP的指令&lt;/h2&gt;
&lt;p&gt;大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。&lt;/p&gt;
&lt;p&gt;但是mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。8086CPU提供了jmp指令来改变CS、IP的内容。&lt;/p&gt;
&lt;p&gt;若想同时修改CS、IP的内容，可用指令&amp;ldquo;jmp 段地址: 偏移地址&amp;rdquo;完成，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;jmp&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="no"&gt;AE3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;
&lt;span class="nf"&gt;jmp&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="no"&gt;B16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若想仅修改IP的内容，可以用指令&amp;ldquo;jmp 某一合法寄存器&amp;rdquo;完成，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;jmp&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;代码段&lt;/h2&gt;
&lt;p&gt;在编程时，可根据需要，将一组内存单元定义为一个段。长度为&lt;code&gt;N(N&amp;lt;=64KB)&lt;/code&gt;的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。&lt;/p&gt;
&lt;p&gt;将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS:IP指向的内存单元中的内容为指令。&lt;/p&gt;
&lt;h3 id="debugcheng-xu"&gt;Debug程序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;R命令查看、改变CPU寄存器的内容，&amp;ldquo;r&amp;rdquo;查看，&amp;ldquo;r ax&amp;rdquo;修改ax的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;D命令查看内存中的内容，&amp;ldquo;d 段地址:偏移地址&amp;rdquo;将显示指定的内存单元开始的128个内存单元的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;E命令改写内存中的内容，&amp;ldquo;e 起始地址 数据 数据 数据......&amp;rdquo;，实际上也可以用它来直接写入机器码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;T指令逐条执行代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P执行中断调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A命令以汇编指令的形式在内存中写入机器指令。简单的A命令从一个预设的地址开始输入指令。&amp;ldquo;A 1000:0&amp;rdquo;从1000:0开始的内存中写入指令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;寄存器（内存访问）&lt;/h1&gt;
&lt;h2&gt;内存中字的存储&lt;/h2&gt;
&lt;p&gt;CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元，则一个字要用两个地址连续的内存单元来存放，这个字的低位字节放在低地址单元中，高位字节存放在高地址单元中。&lt;/p&gt;
&lt;p&gt;字单元，即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。&lt;/p&gt;
&lt;h2&gt;DS和[address]&lt;/h2&gt;
&lt;p&gt;CPu要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。8086中有一个DS寄存器，通常用来存放要访问数据的段地址。&lt;/p&gt;
&lt;p&gt;前面使用mov指令，可以完成两种传送：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将数据直接送入寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将一个寄存器中的内容送入另一个寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也可以使用mov将一个内存单元中的内容送入一个寄存器中。格式：mov 寄存器名，内在单元地址。&lt;/p&gt;
&lt;p&gt;内存单元偏移地址放在[]中。段地址由CPU自动取ds中的数据。&lt;/p&gt;
&lt;p&gt;不能使用类似mov ds, 1000h来将1000h送入ds。只能通过寄存器中转。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从寄存器送入内存单元。例如，使用mov [0],al可以将al的数据传送到当前数据段中偏移地址为0的内存单元里。&lt;/p&gt;
&lt;h2&gt;字的传送&lt;/h2&gt;
&lt;p&gt;我们只要在mov指令中给出16位寄存器就可以进行16位数据的传送了。&lt;/p&gt;
&lt;h2&gt;mov、add、sub指令&lt;/h2&gt;
&lt;p&gt;mov指令形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mov 寄存器, 数据     如：mov ax, 8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 寄存器, 寄存器   如：mov ax,bx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 寄存器, 内存单元   如：mov ax,[0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 内存单元, 寄存器   如：mov [0],bx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 段寄存器, 寄存器   如：mov ds,bx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 寄存器, 段寄存器   如：mov bx,ds&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 内存单元, 段寄存器 如：mov [0],cs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov 段寄存器, 内存单元 如：mov ds,[0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能使用 mov 段寄存器, 数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;add和sub指令同mov一样，都操作两个对象。它们可以有以下几种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;add 寄存器, 数据     如：add ax,8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;add 寄存器, 寄存器   如：add ax,bx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;add 寄存器, 内存单元  如：add ax, [0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;add 内存单元, 寄存器  如：add [0],ax&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sub 寄存器, 数据     如：sub ax,8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sub 寄存器, 寄存器   如：sub ax,bx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sub 寄存器, 内存单元  如：sub ax, [0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sub 内在单元, 寄存器  如：sub [0],ax&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据段&lt;/h2&gt;
&lt;p&gt;将一段内存将作数据段，是编程时的一种安排，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。&lt;/p&gt;
&lt;h2&gt;栈&lt;/h2&gt;
&lt;p&gt;栈是一种具有特殊的访问方式的存储空间。栈的操作规则为LIFO（Last In First Out），先进先出。&lt;/p&gt;
&lt;h2&gt;CPU提供的栈机制&lt;/h2&gt;
&lt;p&gt;8086CPU提供的入栈和出栈指令为PUSH和POP。&lt;/p&gt;
&lt;p&gt;8086CPU中有两个寄存器来存放栈顶的地址，段寄存器SS和寄存器SP，栈顶的段地址放在SS中，偏移地址放在SP中。栈为空时，栈中没有元素，也就不存在栈顶的元素，所以SS:SP只指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2。栈操作时变化的是SP的值，内存中的数据不会被清空，只会被覆盖。&lt;/p&gt;
&lt;h2&gt;栈顶超界的问题&lt;/h2&gt;
&lt;p&gt;当栈满时再使用push指令，或栈空时再使用pop指令都将发生栈顶超界的问题，这将覆盖栈空间外的数据。&lt;/p&gt;
&lt;p&gt;8086CPU不保证对栈的操作不会超界。&lt;/p&gt;
&lt;p&gt;在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，执行出入栈的时候要注意防止超界。&lt;/p&gt;
&lt;h2&gt;push和pop指令&lt;/h2&gt;
&lt;p&gt;指令格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;push 寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pop 寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push 段寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pop 段寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push 内存单元&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pop 内存单元&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令执行时，可以只给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中取得。&lt;/p&gt;
&lt;p&gt;push和pop指令同mov指令不同，CPU执行mov指令时只需要一步操作，就是传送，而执行push、pop指令时需要两步操作。执行push时，先改变SP，然后向SS:SP处传送。执行pop时，先读取SS:SP的数据，然后改变SP。&lt;/p&gt;
&lt;h2&gt;栈段&lt;/h2&gt;
&lt;p&gt;栈段也仅仅是编程时的一种安排。我们可以将长度为&lt;code&gt;N(N&amp;lt;=64K)&lt;/code&gt;的组地址连续，起始地址为16的倍数的内存单元当作栈空间来使用。&lt;/p&gt;
&lt;h1&gt;第一个程序&lt;/h1&gt;
&lt;h2&gt;源程序&lt;/h2&gt;
&lt;h3 id="wei-zhi-ling"&gt;伪指令&lt;/h3&gt;
&lt;p&gt;汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译的机器指令，是终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行。伪指令由编译器来执行，编译器根据伪指令来进行相关的编译工作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;segment和ends是一对成对使用的伪指令，这是在写可被编译的汇编程序时，必须要用到的一对伪指令。它的功能是定义一个段，segment说明段开始，ends说明段结束。使用格式为：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;段名&lt;/span&gt; &lt;span class="nf"&gt;segment&lt;/span&gt;
&lt;span class="err"&gt;.&lt;/span&gt;
&lt;span class="err"&gt;.&lt;/span&gt;
&lt;span class="err"&gt;段名&lt;/span&gt; &lt;span class="nf"&gt;ends&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个汇编程序由多个段组成，这些段被用来存放代码、数据或当作栈空间来使用。&lt;/p&gt;
&lt;p&gt;一个有意义的汇编程序中至少有一个段，这个段用来存放代码。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;end是一个汇编程序的结束标记，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;assume这条伪指令的含义为&amp;ldquo;假设&amp;rdquo;。它假设某一段寄存器和程序中的某一个用segments...ends定义的段相关联。通过assume说明这种关联，在情况下，编译程序可以将段寄存器和某一个具体的段联系。assume并不是一条非要深入理解不可的伪指令，以后我们编程时，记着用assume将有特定用途的段和相关的段寄存器关联起来即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如我们用codes segment ... codesg ends定义了名为codseg的段。我们在程序开头，用assume cs:codeseg将用作代码段的段codesg和CPU中的段寄存器cs联系起来。&lt;/p&gt;
&lt;h3 id="yuan-cheng-xu-zhong-de-cheng-xu"&gt;源程序中的&amp;ldquo;程序&amp;rdquo;&lt;/h3&gt;
&lt;p&gt;汇编语言写的源程序，包括伪指令和汇编指令，伪指令由编译器来处理，它们并不实现我们编程的最终目的。我们这里所说的程序是指源程序中最终由计算机执行、处理的指令或数据。&lt;/p&gt;
&lt;h3 id="biao-hao"&gt;标号&lt;/h3&gt;
&lt;p&gt;汇编源程序中，除了汇编指令和伪指令外，还有一些标号，如&amp;ldquo;codesg&amp;rdquo;。一个标号指代了一个地址。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。&lt;/p&gt;
&lt;h3 id="cheng-xu-de-jie-gou"&gt;程序的结构&lt;/h3&gt;
&lt;p&gt;源程序由一些段构成。我们可以在这些段中存放代码、数据、或将某个段当作栈空间。基本要素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;assume&lt;/span&gt; &lt;span class="no"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="no"&gt;abc&lt;/span&gt;
&lt;span class="nf"&gt;abc&lt;/span&gt; &lt;span class="no"&gt;segment&lt;/span&gt;
  &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ax&lt;/span&gt;
  &lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ax&lt;/span&gt;

&lt;span class="nf"&gt;abc&lt;/span&gt; &lt;span class="no"&gt;ends&lt;/span&gt;

&lt;span class="nf"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="cheng-xu-fan-hui"&gt;程序返回&lt;/h3&gt;
&lt;p&gt;通过下面的两条指令返回：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="no"&gt;c00H&lt;/span&gt;
&lt;span class="nf"&gt;int&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="yu-fa-cuo-wu-he-luo-ji-cuo-wu"&gt;语法错误和逻辑错误&lt;/h3&gt;
&lt;h2&gt;编译源程序&lt;/h2&gt;
&lt;p&gt;编译过程中将得到3个输出文件：目标文件（.obj）、列表文件（.lst）、交叉引用文件（.crf）。目标文件是我们最终要得到的结果，另外两个只是中间结果。&lt;/p&gt;
&lt;h2&gt;连接器的简单解释&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个源文件编译后，得到了存有机器码的目标文件，目标文件中有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="yi-jian-hua-de-fang-shi-jin-xing-bian-yi-he-lian-jie"&gt;以简化的方式进行编译和连接&lt;/h3&gt;
&lt;p&gt;编译和连接1.asm&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;masm&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="c"&gt;;&lt;/span&gt;
&lt;span class="no"&gt;link&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="c"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;可执行文件中的程序将入内存并运行的原理&lt;/h2&gt;
&lt;p&gt;DOS中如果用户要执行一个程序，则输入该程序的可执行文件名，command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS:IP指向程序的入口，此后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，command再次显示当前盘符和当前路径组成的提示符，等侍用户的输入。&lt;/p&gt;
&lt;h2&gt;程序执行过程的跟踪&lt;/h2&gt;
&lt;p&gt;用Debug将程序加载入内存。&lt;/p&gt;
&lt;p&gt;DOS中EXE加载的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;找到一段起始地址为SA:0000的容量足够的空闲内存区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这段内存区的前256字节中，创建一个称为程序段的前缀 （PSP）的数据区，DOS要利用PSP来和被加载的程序进行通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从PSP的后面将程序装入，程序的地址被设置为SA+10H:0；（空闲的内存区从SA:0开始，0-255字节为PSP，从256字节处开始存放程序，为更好地区分PSP和程序。DOS一般将它们划分到不同的段中，所以，有了这样的地址安排：空闲内存区：SA:0，PSP区：SA:0，程序区SA+10H:0。注意：PSP区和程序区虽然物理地址连接，却有不同的段地址。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将内存区的段地址存入DS中，初始化其它相关寄存器后，设置CS:IP指向程序入口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为9，则程序所在的内存区的地址为ds:0&lt;/p&gt;
&lt;p&gt;这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信。从256字节处向后的空间存放的是程序。&lt;/p&gt;
&lt;h1&gt;[bx]和loop指令&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;[bx]和内存单元的描述&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[bx]同样表示一个内存单元，它的偏移地址在bx中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;loop&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;循环指令&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们定义的描述性的符号&amp;ldquo;()&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在下面的内容中，将使用&amp;ldquo;()&amp;rdquo;来表示一个寄存器或内存单元中的内容。它所表示的内容有两种类型：字节或字。是哪种类型将由寄存器名或具体的运算决定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;约定符号idata表示常量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后面，将使用idata表示常量。&lt;/p&gt;
&lt;h2&gt;[bx]&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;mov ax,[bx]&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mov [bx],ax&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bx中存放的数据作为一个偏移地址，段地址SA默认在ds中，将ax中的数据送入SA:EA处。&lt;/p&gt;
&lt;h2&gt;Loop指令&lt;/h2&gt;
&lt;p&gt;指令格式是：loop 标号。CPU执行loop指令时，要进行两步操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;(cx)=(cx)-1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;在Debug中跟踪用loop指令实现的循环程序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在汇编程序中数据不能以字母开头。所以A000h要写为0A000h。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Debug中使用G来继续执行程序。或者g 0012之类的指令转到cs:0012处开始跟踪。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Debug和汇编编译器Masm对指令的不同处理&lt;/h2&gt;
&lt;p&gt;Debug和编译器masm对形如&amp;ldquo;mov ax,[0]&amp;rdquo;这类的指令在解释上不同。Debug会将[0]解释为一个内存单元。而0是内存单元的偏移地址；而编译器将[0]就解释为了0。&lt;/p&gt;
&lt;p&gt;当前我们将偏移地址送入bx寄存器，用[bx]的方式来访问内存单元。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ax&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;al&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果希望像在Debug中那样，在&amp;ldquo;[]&amp;rdquo;中直接给出内存单元的偏移地址。只需要在&amp;ldquo;[]&amp;rdquo;的前面显式的给出段地址所在的寄存器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ax&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;al&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;段前缀&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;mov ax,ds:[bx]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov ax,cs:[bx]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov ax,ss:[bx]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov as,es:[bx]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov ax,ss:[0]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mov ax,cs:[0]&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的&amp;ldquo;ds:&amp;rdquo;、&amp;ldquo;cs&amp;rdquo;、&amp;ldquo;ss&amp;rdquo;或&amp;ldquo;es&amp;rdquo;，称为段前缀。&lt;/p&gt;
&lt;h2&gt;一段安全的空间&lt;/h2&gt;
&lt;p&gt;在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。&lt;/p&gt;
&lt;p&gt;一般在PC机中，DOS和其他合法程序一般都不会使用0:200~0:300的256个字节的空间。所以我们使用这段空间是安全的。&lt;/p&gt;
&lt;h1&gt;包含多个段的程序&lt;/h1&gt;
&lt;p&gt;程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行过程中间向操作系统申请。&lt;/p&gt;
&lt;p&gt;若要一个程序在加载的时候取得所需的空间，则必须要在源程序中做出说明。我们通过在源程序中定义段来进行内存空间的获取。&lt;/p&gt;
&lt;h2&gt;在代码段中使用数据&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;assume&lt;/span&gt; &lt;span class="no"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="no"&gt;code&lt;/span&gt;
&lt;span class="nf"&gt;code&lt;/span&gt; &lt;span class="no"&gt;segment&lt;/span&gt;
  &lt;span class="nf"&gt;dw&lt;/span&gt; &lt;span class="mi"&gt;0123&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0456&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0789&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="no"&gt;abcH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="no"&gt;defH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="no"&gt;fedH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="no"&gt;cbaH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0987&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
  &lt;span class="nl"&gt;start:&lt;/span&gt;    &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
            &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
            &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;cx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
      &lt;span class="nl"&gt;s:&lt;/span&gt;    &lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
           &lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
           &lt;span class="nf"&gt;loop&lt;/span&gt; &lt;span class="no"&gt;s&lt;/span&gt;
  &lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="no"&gt;c00h&lt;/span&gt;
  &lt;span class="nf"&gt;int&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
&lt;span class="nf"&gt;code&lt;/span&gt; &lt;span class="no"&gt;ends&lt;/span&gt;
&lt;span class="nf"&gt;end&lt;/span&gt; &lt;span class="no"&gt;start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里代码段定义了一些字型数据。因此代码段的起始位置不再是代码，代码的起始位置由start来标明，代码结束由end start来标明。&lt;/p&gt;
&lt;h2&gt;在代码段中使用栈&lt;/h2&gt;
&lt;h2&gt;将数据、代码、栈放入不同的段&lt;/h2&gt;
&lt;h1&gt;更灵活的定位内存地址的方法&lt;/h1&gt;
&lt;h2&gt;and和or指令&lt;/h2&gt;
&lt;h2&gt;以字符形式给出数据&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;db&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="no"&gt;unIX&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;   &lt;span class="err"&gt;相当于&lt;/span&gt; &lt;span class="no"&gt;db&lt;/span&gt; &lt;span class="mi"&gt;75&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="no"&gt;EH&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;49&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;58&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;al&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="no"&gt;a&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt; &lt;span class="err"&gt;相当于&lt;/span&gt; &lt;span class="no"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;al&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;61&lt;/span&gt;&lt;span class="no"&gt;H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;[bx+idata]&lt;/h2&gt;
&lt;p&gt;它的偏移地址为(bx)+idata（bx中的数值加上idata）。也可以写作idata[bx]。&lt;/p&gt;
&lt;h2&gt;SI和DI&lt;/h2&gt;
&lt;p&gt;SI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8位寄存器来使用。&lt;/p&gt;
&lt;h2&gt;[bx+si]和[bx+di]&lt;/h2&gt;
&lt;p&gt;这两者的含义相似。表示一个内存单元，它的偏移地址为(bx)+(si)，即bx中的数值加上si中的数值。&lt;/p&gt;
&lt;h2&gt;[bx+si+idata]和[bx+di+idata]&lt;/h2&gt;
&lt;p&gt;这两者的含义相似。表示一个内存单元，它的偏移地址为(bx)+(si)+idata，即bx中的数值加上si中的数值再加上idata。&lt;/p&gt;
&lt;h2&gt;不同的寻址方式的灵活应用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;[idata]用一个常量来表示地址，可用于直接定位一个内存单元；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[bx+si]用两个变量表示地址；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[bx+si+idata]用两个变量和一个常量表示地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般来说，在需要暂存数据的时候，我们都应该使用栈。&lt;/p&gt;
&lt;h1&gt;数据处理的两个基本问题&lt;/h1&gt;
&lt;p&gt;下面将使用reg来表示寄存器，sreg表示段寄存器。&lt;/p&gt;
&lt;p&gt;reg包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di&lt;/p&gt;
&lt;p&gt;sreg包括：ds,ss,cs,es&lt;/p&gt;
&lt;h2&gt;bx、si、di、bp&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在8086CPU中，只有这4个寄存器可以用在&amp;ldquo;[...]&amp;rdquo;中来进行内存单元的寻址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在[...]中，这4个寄存器可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只要在[...]中使用寄存器bp，而指令没有显式的给出段地址，段地址默认在ss中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;机器指令处理的数据所在位置&lt;/h2&gt;
&lt;p&gt;绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类：读取、写入、运算。在机器指令这一层来讲，关不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。&lt;/p&gt;
&lt;h2&gt;汇编语言中数据位置的表达&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;立即数（idata）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于直接包含在机器指令中的数据，在汇编指令中直接给出，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nf"&gt;add&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="no"&gt;h&lt;/span&gt;
&lt;span class="nf"&gt;or&lt;/span&gt; &lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;00010000&lt;/span&gt;&lt;span class="no"&gt;b&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;al&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="no"&gt;a&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;寄存器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段地址（SA）和偏移地址（EA）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。存放段寄存器可以是默认的，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;di&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等指令，段地址默认在ds中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,[&lt;/span&gt;&lt;span class="no"&gt;bp&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等指令，段地址默认在ss中。&lt;/p&gt;
&lt;p&gt;存放段地址的寄存器也可以显性的给出，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="no"&gt;bp&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;es&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nf"&gt;mov&lt;/span&gt; &lt;span class="no"&gt;ax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="no"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="no"&gt;bx&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="no"&gt;si&lt;/span&gt;&lt;span class="err"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;寻址方式&lt;/h2&gt;
&lt;p&gt;当数据存放在内在中的时候，我们可以用多种方式来给定这个内存单元的偏移地
址，这种定位内存单元的方法一般被称为寻址方式。
&lt;table class="table table table-condensed table-bordered table-hover"&gt;
&lt;tr&gt;
&lt;td&gt;寻址方式&lt;/td&gt;
&lt;td&gt;含义&lt;/td&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;常用格式举例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[idata]&lt;/td&gt;
&lt;td&gt;EA=idata;SA=(ds)&lt;/td&gt;
&lt;td&gt;直接寻址&lt;/td&gt;
&lt;td&gt;[idata]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
     [bx]&lt;br/&gt;
     [si]&lt;br/&gt;
     [di]&lt;br/&gt;
     [bp]&lt;br/&gt;
&lt;/td&gt;
&lt;td&gt;
     EA=(bx);SA=(ds)&lt;br/&gt;
     EA=(si);SA=(ds)&lt;br/&gt;
     EA=(di);SA=(ds)&lt;br/&gt;
     EA=(bp);SA=(ss)&lt;br/&gt;
&lt;/td&gt;
&lt;td&gt;寄存器相对寻址&lt;/td&gt;
&lt;td&gt;
     用于结构体：         &lt;br/&gt; 
     [bx].idata          &lt;br/&gt;
     用于数组：           &lt;br/&gt;
     idata[si],idata[di] &lt;br/&gt;
     用于二维数组         &lt;br/&gt;
     [bx][idata]         &lt;br/&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;&lt;/p&gt;</content><category term="asm"></category></entry><entry><title>SICP读书笔记</title><link href="/sicpdu-shu-bi-ji.html" rel="alternate"></link><published>2010-08-31T00:00:00+08:00</published><updated>2010-08-31T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-08-31:/sicpdu-shu-bi-ji.html</id><summary type="html">&lt;h1&gt;Chap.1 Building Abstractions with Procedures&lt;/h1&gt;
&lt;p&gt;在思考活动中通过简单的想法尽力实现强大能量，首要有三： 1. 将多个简单的想法组合成单个的复杂的想法，因而可以完成所有复杂的想法。2. 将两个想法，不论它们是简单或复杂，放到一起，将他们彼此设置并立即观察他们，而不将它们组织成一个想法，通过这种方法可以得到想法之间的关系。3. 将他们从现实的已经存在的其它想法中分离出来：这称为抽象，这样可以构成这些想法的通用想法。&lt;/p&gt;
&lt;p&gt;计算机语言完成任务的三个机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原生表达式，它描述了语言所关心的最简单的实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合的方法，复合元素是从简单元素构成的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象的方法，通过抽象复合元素可以被命名和作为单元被处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编程过程中，我们处理两种类型的元素：过程和数据。数据是要处理的&amp;ldquo;原材料&amp;rdquo;，而过程是处理数据的规则的描述。因此，任何一门强大的编程语言应该能够 描述原生数据类型和原生过程，应该有组合和抽象过程和数据的方法。&lt;/p&gt;
&lt;h2&gt;Exercise 1.2 将下面的表达式转换为form&lt;/h2&gt;
&lt;p&gt;&lt;img alt="ch1-z-g-3" src="/SICP/ch1-z-g-3.gif"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Chap.1 Building Abstractions with Procedures&lt;/h1&gt;
&lt;p&gt;在思考活动中通过简单的想法尽力实现强大能量，首要有三： 1. 将多个简单的想法组合成单个的复杂的想法，因而可以完成所有复杂的想法。2. 将两个想法，不论它们是简单或复杂，放到一起，将他们彼此设置并立即观察他们，而不将它们组织成一个想法，通过这种方法可以得到想法之间的关系。3. 将他们从现实的已经存在的其它想法中分离出来：这称为抽象，这样可以构成这些想法的通用想法。&lt;/p&gt;
&lt;p&gt;计算机语言完成任务的三个机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原生表达式，它描述了语言所关心的最简单的实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合的方法，复合元素是从简单元素构成的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象的方法，通过抽象复合元素可以被命名和作为单元被处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编程过程中，我们处理两种类型的元素：过程和数据。数据是要处理的&amp;ldquo;原材料&amp;rdquo;，而过程是处理数据的规则的描述。因此，任何一门强大的编程语言应该能够 描述原生数据类型和原生过程，应该有组合和抽象过程和数据的方法。&lt;/p&gt;
&lt;h2&gt;Exercise 1.2 将下面的表达式转换为form&lt;/h2&gt;
&lt;p&gt;&lt;img alt="ch1-z-g-3" src="/SICP/ch1-z-g-3.gif"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Exercise 1.3 定义一个过程接收3个参数返回最大的两个参数的平方和&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sum-max-square&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt;= &lt;/span&gt;&lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Exercise 1.4 观察下面的求值模型它整合了操作符和表达式。&lt;/h2&gt;
&lt;p&gt;这个例子体现了 scheme 与 common lisp 的区别。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;a-plus-abs-b&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它将根据 b 是否大于 0 来决定对 a 和 b 进行加或减操作。&lt;/p&gt;
&lt;h2&gt;Exercise 1.5 应用序或正则序测试&lt;/h2&gt;
&lt;p&gt;Ben Bitdiddle 发明了一种检测解释器是应用序还是正则序的方法。先定义两个过程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;0&lt;/span&gt;
      &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后对下面的表达式求值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;test&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然 p 的定义是不正确的，当解释器是应用序的时候会先对参数求值。因此对 (p) 求值时程序将出错。如果程序是正则序则 (p) 不会被立即求值，因为 (= x 0) 将返回真值，整个 test 表达式将返回 0 。&lt;/p&gt;
&lt;h2&gt;Section 1.17 牛顿法求平方根&lt;/h2&gt;
&lt;p&gt;如果猜想y是x的平方，则下一个更接近x平方根的值是((y+x/y))/2&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mf"&gt;0.001&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;guess&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"第一种平方根算法："&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="mf"&gt;21.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Exercise 1.6 能否通过 cond 来定义 if&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;new-if&lt;/span&gt; &lt;span class="nv"&gt;predicate&lt;/span&gt; &lt;span class="nv"&gt;then-clause&lt;/span&gt; &lt;span class="nv"&gt;else-clause&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;predicate&lt;/span&gt; &lt;span class="nv"&gt;then-clause&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="nv"&gt;else-clause&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当测试用 new-if 来实现 Section 1.17 中的求平方根的方法时有可能会出现错误。因为通常 if 是一个特殊的 form 。它只会在条件为真时才对 then 子句求值。而 new-if 只是一个函数，它有可能会对所有参数都求值（比如解释器使用应用序）。在这用于 1.17 中的 sqrt-iter 中时将导致无限循环。&lt;/p&gt;
&lt;h2&gt;Exercise 1.7&lt;/h2&gt;
&lt;p&gt;原来的 section 1.17 中的 good-enough? 是比较猜测值的平方与被开方数的差的绝对值小于某个值。这种方法在对那些很小的数求平方根时并不是很有效。一个更好的办法是将它改进成比较两次猜测值之差是否小于某个给定的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="nv"&gt;last-value&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;average&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;last-guess表示上一次猜测的值&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mf"&gt;0.000001&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;修改了这个递归计算过程的参数，添加了上次猜测结果&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;guess&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;保证将猜测值设置为与上个猜测值之差的绝对值大于那个比较值0.000001&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"第二种平方根算法："&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="mf"&gt;9.0&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sqrt-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="mf"&gt;21.0&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Exercise 1.8 牛顿法求立方根&lt;/h2&gt;
&lt;p&gt;如果 y 接近 x 的立方根，那么更接近的值是 (x/y*y+2y)/3 。对应的求立方根的程序为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;逼近算法&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;/ &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;square&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;;精度检查&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;abs &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mf"&gt;0.000001&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;;迭代过程&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cube-iter&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;good-enough?&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;last-guess&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;guess&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cube-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;improve&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;guess&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"求立方根算法求27的立方根:"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cube-iter&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="mi"&gt;27&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只是在 exercise 1.7 的基础上替换了 improve 方法。&lt;/p&gt;
&lt;h2&gt;Section 1.2 过程和它们所产生的计算&lt;/h2&gt;
&lt;h3 id="section-122-xian-xing-di-gui-he-die-dai"&gt;Section 1.2.2 线性递归和迭代&lt;/h3&gt;
&lt;h4 id="exercise-19-miao-hui-xian-xing-die-dai-he-xian-xing-di-gui-de-ji-suan-guo-cheng"&gt;Exercise 1.9 描绘线性迭代和线性递归的计算过程&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-rec&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;b&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-rec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;dec&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="c1"&gt;;(add-rec 4 5)&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (add-rec 3 5))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (add-rec 2 5)))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (inc (add-rec 1 5))))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (inc (inc (add-rec 0 5)))))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (inc (inc 5))))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (inc 6)))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc (inc (7)))&lt;/span&gt;
&lt;span class="c1"&gt;;(inc 8)&lt;/span&gt;
&lt;span class="c1"&gt;;9&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-iter&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;b&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;add-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;dec&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;inc&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="c1"&gt;;(add-iter 4 5)&lt;/span&gt;
&lt;span class="c1"&gt;;(add-iter 3 6)&lt;/span&gt;
&lt;span class="c1"&gt;;(add-iter 2 7)&lt;/span&gt;
&lt;span class="c1"&gt;;(add-iter 1 8)&lt;/span&gt;
&lt;span class="c1"&gt;;(add-iter 0 9)&lt;/span&gt;
&lt;span class="c1"&gt;;9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="exercise-110-a-ke-man-han-shu"&gt;Exercise 1.10 阿克曼函数&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;g&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;h&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;A&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;k&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过使用 f,g,h 和正整数 n ，给出计算 5 乘以 n 的 2 次方的函数 &lt;code&gt;(k n)&lt;/code&gt; 的定义。
 - TODO:&lt;/p&gt;
&lt;h3 id="section-122-shu-xing-di-gui_1"&gt;Section 1.2.2 树形递归&lt;/h3&gt;
&lt;p&gt;树形递归也是一种常见的计算模式。例如Fibonacci数的计算。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Fib(n) = 0                   if n = 0
Fib(n) = 1                   if n = 1
Fib(n) = Fib(n-1) + Fib(n-2) otherwise
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它所产生的计算过程是树状的。会随着n的变大计算规模也逐渐变大。并且在计算过程中间会产生许多重复的计算。例如，计算Fib(3)和Fib(4)时都会需要计算Fib(2)和Fib(1)，这样随着n变大会产生许多重复的计算。&lt;/p&gt;
&lt;p&gt;如果将它转换成递归方式计算规模就不会随n变大而变大。计算的方法是引入两个中间变量a和b，将它们初始化为Fib(0)和Fib(1)，然后a=a+b，b=a，进而计算出Fib(2)，如此递归直至计算出Fib(n)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib-iter&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib_iter&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;b&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fib-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;TODO:找零钱的算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="exercise-111-fen-bie-yi-di-gui-he-die-dai-de-fang-shi-bian-xie-fn"&gt;Exercise 1.11 分别以递归和迭代的方式编写f(n)&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f(n)=n if n&amp;lt;3 and f(n) = f(n-1)+2f(n-2)+3f(n-3) if n &amp;gt;=3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归方式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
      &lt;span class="nv"&gt;n&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; 
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; 
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;迭代方式。这里我引入了3个变量a、b和c分别代表f(n-1)、f(n-2)和f(n-3)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f1&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f1-iter&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f1-iter&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
      &lt;span class="nv"&gt;c&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;f1-iter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;* &lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="exercise-112-pa-si-qia-san-jiao"&gt;Exercise 1.12 帕斯卡三角&lt;/h4&gt;
&lt;p&gt;编写递归过程计算帕斯卡三角的元素。&lt;/p&gt;
&lt;p&gt;我首先归纳帕斯卡三角的元素的计算方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f(n,level) = 1                              如果n=1或n=level
f(n,level) = 0                              如果n&amp;lt;1或n&amp;gt;level则元素不存在
f(n,level) = f(n,level-1) + f(n-1,level-1)  otherswise
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中level为层次，n为在某层中的位置。&lt;/p&gt;
&lt;p&gt;转换成函数定义&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;define &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;pascal-triangle&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nv"&gt;level&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nb"&gt;= &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nv"&gt;level&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;or &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;lt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&amp;gt; &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nv"&gt;level&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;else &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;+ &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;pascal-triangle&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;level&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;pascal-triangle&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;- &lt;/span&gt;&lt;span class="nv"&gt;level&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="exercise-113-zheng-ming-fibnshi-zui-jie-jin-mou-shu-de-zheng-shu"&gt;Exercise 1.13 证明Fib(n)是最接近某数的整数&lt;/h4&gt;
&lt;p&gt;&lt;literal style="html"&gt;HTML&lt;/literal&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TODO:&lt;/li&gt;
&lt;/ul&gt;</content><category term="lisp"></category><category term="scheme"></category></entry><entry><title>Android Dev Guide学习笔记 User Interface</title><link href="/android-dev-guidexue-xi-bi-ji-user-interface.html" rel="alternate"></link><published>2010-08-20T00:00:00+08:00</published><updated>2010-08-20T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-08-20:/android-dev-guidexue-xi-bi-ji-user-interface.html</id><summary type="html">&lt;h1&gt;用户界面&lt;/h1&gt;
&lt;p&gt;在Android应用程序中，用户界面是使用View和ViewGroup对象构造的。有许多类型的view和viewgroup，它们都是View类的子类。&lt;/p&gt;
&lt;p&gt;View对象是Android平台表达用户界面的基本单元。View class作为被称作&amp;ldquo;构件（widget）&amp;rdquo;的基类，这些构件实现UI对象，如文本域和按钮。ViewGroup类被作为&amp;ldquo;布局（layout）&amp;rdquo;类的基类，它用于描述不同的布局方式，如线型、页签等。&lt;/p&gt;
&lt;p&gt;View对象的属性中存储了布局参数和屏幕中特定的矩形框中的内容。View对象自己处理自己的度量、布局、绘制、焦点变化、滚动、和在它的矩形范围内的按键/手势交互。用户界面中的View对象也是用户和交互事件接收器的交互点。&lt;/p&gt;
&lt;h1&gt;View层级结构&lt;/h1&gt;
&lt;p&gt;在Android平台上，你可以用一组包含View和ViewGroup节点的层级结构来定义Activity的UI，如下图。这个层级树根据需要可以很简单也可以很复杂，你可以使用Android中预定义的构件和布局来构建它，也可以用自定义的View来构建。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/android-dev-guide/viewgroup.png"/&gt;&lt;/p&gt;
&lt;p&gt;为了让view层级树渲染到屏幕上，你的Activity必须调用setContentView()方法并传递一个根节点的引用。Android系统接收到这个引用来废止、度量和绘制这个树。根节点请求它的子节点绘制自己&amp;mdash;&amp;mdash;每个view group节点负责调用它自己的子节点绘制自己。子节点可能会从父节点中请求得到某个位置的一块区块，但是父节点有最终决定分配哪个位置的多大的区域给子节点。Android从树的顶部开始解析布局元素，并实例华它们并将它们添加到它们的父节点。由于这些元素的绘制是按顺序进行的，如果出现元素重叠 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;用户界面&lt;/h1&gt;
&lt;p&gt;在Android应用程序中，用户界面是使用View和ViewGroup对象构造的。有许多类型的view和viewgroup，它们都是View类的子类。&lt;/p&gt;
&lt;p&gt;View对象是Android平台表达用户界面的基本单元。View class作为被称作&amp;ldquo;构件（widget）&amp;rdquo;的基类，这些构件实现UI对象，如文本域和按钮。ViewGroup类被作为&amp;ldquo;布局（layout）&amp;rdquo;类的基类，它用于描述不同的布局方式，如线型、页签等。&lt;/p&gt;
&lt;p&gt;View对象的属性中存储了布局参数和屏幕中特定的矩形框中的内容。View对象自己处理自己的度量、布局、绘制、焦点变化、滚动、和在它的矩形范围内的按键/手势交互。用户界面中的View对象也是用户和交互事件接收器的交互点。&lt;/p&gt;
&lt;h1&gt;View层级结构&lt;/h1&gt;
&lt;p&gt;在Android平台上，你可以用一组包含View和ViewGroup节点的层级结构来定义Activity的UI，如下图。这个层级树根据需要可以很简单也可以很复杂，你可以使用Android中预定义的构件和布局来构建它，也可以用自定义的View来构建。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/android-dev-guide/viewgroup.png"/&gt;&lt;/p&gt;
&lt;p&gt;为了让view层级树渲染到屏幕上，你的Activity必须调用setContentView()方法并传递一个根节点的引用。Android系统接收到这个引用来废止、度量和绘制这个树。根节点请求它的子节点绘制自己&amp;mdash;&amp;mdash;每个view group节点负责调用它自己的子节点绘制自己。子节点可能会从父节点中请求得到某个位置的一块区块，但是父节点有最终决定分配哪个位置的多大的区域给子节点。Android从树的顶部开始解析布局元素，并实例华它们并将它们添加到它们的父节点。由于这些元素的绘制是按顺序进行的，如果出现元素重叠，则最后绘制的元素将位于先前绘制的元素的上面。&lt;/p&gt;
&lt;p&gt;要了解View层级结构的度量和绘制，参见How Android Draws Views。&lt;/p&gt;
&lt;h1&gt;布局&lt;/h1&gt;
&lt;p&gt;最常见的定义布局和表达view层次结构的是使用XML布局文件。XML布局文件提供了类似HTML的可读性。每个元素表示一个View或ViewGroup对象。View对象是树中的叶节点，ViewGroup对象是树中的分支节点。&lt;/p&gt;
&lt;p&gt;XML中的元素代表各自的Java类。因此&lt;code&gt;&amp;lt;TextView&amp;gt;&lt;/code&gt;元素将在UI中创建一个TextView，&lt;code&gt;&amp;lt;LinearLayout&amp;gt;&lt;/code&gt;元素将创建一个LinearLayout view group。当加载布局资源时，Android系统将初始化这些运行时对象，并将它们与布局中的元素对应。&lt;/p&gt;
&lt;p&gt;例如，一个简单的virtical类型的布局中有一个text view和一个按钮：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;LinearLayout&lt;/span&gt; &lt;span class="na"&gt;xmlns:android=&lt;/span&gt;&lt;span class="s"&gt;"http://schemas.android.com/apk/res/android"&lt;/span&gt;
              &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;"fill_parent"&lt;/span&gt; 
              &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;"fill_parent"&lt;/span&gt;
              &lt;span class="na"&gt;android:orientation=&lt;/span&gt;&lt;span class="s"&gt;"vertical"&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;TextView&lt;/span&gt; &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;"@+id/text"&lt;/span&gt;
              &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;"wrap_content"&lt;/span&gt;
              &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;"wrap_content"&lt;/span&gt;
              &lt;span class="na"&gt;android:text=&lt;/span&gt;&lt;span class="s"&gt;"Hello, I am a TextView"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;Button&lt;/span&gt; &lt;span class="na"&gt;android:id=&lt;/span&gt;&lt;span class="s"&gt;"@+id/button"&lt;/span&gt;
            &lt;span class="na"&gt;android:layout_width=&lt;/span&gt;&lt;span class="s"&gt;"wrap_content"&lt;/span&gt;
            &lt;span class="na"&gt;android:layout_height=&lt;/span&gt;&lt;span class="s"&gt;"wrap_content"&lt;/span&gt;
            &lt;span class="na"&gt;android:text=&lt;/span&gt;&lt;span class="s"&gt;"Hello, I am a Button"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/LinearLayout&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这里的LinearLayout元素包含了TextView和Button。你可以在其中嵌套一另一个LinearLayout（或其它类型的ViewGroup），来创建更加复杂的布局。&lt;/p&gt;
&lt;p&gt;关于创建UI布局，请参见Declaring Layout。&lt;/p&gt;
&lt;p&gt;有多种方法可以进行布局。使用不同类型的view group，你可以构建不限数量的子类型的view和view group。Android系统提供了大量预定义的布局类型，包括：LinearLayout，RelativeLayout，TableLayout，GridLayout等等。每个布局都提供了一套独特的定义子view和布局结构位置的参数。&lt;/p&gt;
&lt;p&gt;要了解用于布局的各种view groups，参见Common Layout Objects。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tips：你也可以在Java代码中使用addView(View)方法绘制View和ViewGroups，它可以动态的插入新的View和ViewGroup对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;构件&lt;/h1&gt;
&lt;p&gt;构件是作为界面与用户交互的View对象。Android提供了一套完整的构件实现，如：按钮、复选框、文本域等，以便快速构建UI。某些Android提供的构件更加复杂，如日期选择、时钟、缩放控件等。但是你并不需要受限于Android平台提供的这些构件。如果你想要进行一些个性化和创建自己的动作元素，你可以通过扩展或组合已有的构件定义自己的View对象。&lt;/p&gt;
&lt;p&gt;请阅读Building Custom Components以了解更多。&lt;/p&gt;
&lt;p&gt;Android提供的构件位于android.widget包中。&lt;/p&gt;
&lt;h1&gt;UI事件&lt;/h1&gt;
&lt;p&gt;一旦你添加了某些Views（构件）到UI中，你就会需要知道用户与它们的交互，以便执行一些操作。为了得到UI事件通知，你需要做两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定义一个事件监听器并注册到View中。这是如何监听事件的方法。View类包含了一个&lt;code&gt;&amp;lt;something&amp;gt;Listener&lt;/code&gt;接口的集合，每个里面都有一个名为&lt;code&gt;On&amp;lt;something&amp;gt;()&lt;/code&gt;的回调方法。例如，View.OnClickListener（用于在处理View中的&amp;ldquo;click&amp;rdquo;），View.OnTouchListener（用于处理View中触屏幕事件），View.OnKeyListener（用于处理View中的按键）。因此如果你希望在View中发生&amp;ldquo;click&amp;rdquo;（比如按钮被选中）动作时得到通知，应该实现OnClickListener并定义它的onClick()回调方法（在这里执行你的点击动作），并用setOnClickListener()方法将它注册到View。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;覆盖View中已存在的回调方法。这在你实现自己的View类并且需要监听某些特定动作时需要进行。例如这些事件：屏幕被接触时（onTouchEvent()），轨迹球动作时（onTrackballEvent()），或当设备上的按键被按下时（onKeyDown()）。这能让你定义在你的自定义View中对于这些事件的默认行为并决定这些事件是否被传递到其它子View。同样，这些都是View类的回调，只在建立自定义组件时才需要定义。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解关于处理View用户交互的详情请参考Handling UI Events。&lt;/p&gt;
&lt;h1&gt;菜单&lt;/h1&gt;
&lt;h1&gt;高级主题&lt;/h1&gt;
&lt;h2&gt;适配器&lt;/h2&gt;
&lt;h2&gt;风格和主题&lt;/h2&gt;</content><category term="android"></category></entry><entry><title>Android Dev Guide学习笔记 Application Fundamentals</title><link href="/android-dev-guidexue-xi-bi-ji-application-fundamentals.html" rel="alternate"></link><published>2010-07-30T00:00:00+08:00</published><updated>2010-07-30T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-07-30:/android-dev-guidexue-xi-bi-ji-application-fundamentals.html</id><summary type="html">&lt;h1&gt;Application基础&lt;/h1&gt;
&lt;p&gt;Android应用程序是用Java语言编写的。被编译的代码和数据以及应用程序需要的资源文件被打包aapt tool打包为Android package格式，打包的文件以.apk结尾。这种文件是应用程序发布和安装到移动设备的方法；也是用户下载到设备上的文件。同一个.apk文件中的所有代码被当作是一个应用程序。&lt;/p&gt;
&lt;p&gt;在很多方面，每个Android应用生存在自己的世界中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认情况下，所有应用程序运行在自己的Linux进程中。Android在应用程序的代码需要执行时启动进程，当它不再被需要和系统资源被其它应用程序需要时停止。&lt;/li&gt;
&lt;li&gt;每个进程有自己的虚拟机，因此应用程序代码与其它应用程序的代码是隔离的。&lt;/li&gt;
&lt;li&gt;默认情况下，每个应用程序被赋予了一个唯一的Linux用户ID。这使得只能访问应用程序自己的文件&amp;mdash;&amp;mdash;尽管有方法将它们导出给其它的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有可能将两个应用程序组织为使用相同的用户ID，在这种情况下它们将可以互相看到对方的文件。为了保护系统资源，拥有相同ID的的应用程序也可以被组织到相同的Linux进程中，共享同一个虚拟机。&lt;/p&gt;
&lt;h1&gt;应用程序组件&lt;/h1&gt;
&lt;p&gt;Android的一个主要的功能是某个应用程序可以使用其它应用程序的元素（在这个应用程序许可时）。比如，如果你的应用程序需要显示滚动的图片列表而另一个应用程序已经开发了一个并且将它对外开放，这时你可以使用它，而不是重新开发一个。你的应用程序不需要包含这个应用程序的代码或者链接（link to）它。而只是在这个需求出现时运行那个应用程序的那段代码。&lt;/p&gt;
&lt;p&gt;为实现这个目的，系统必须在需要应用程序的一部分时启动应用程序进程，并实例化那部分Java对象。因此，与绝大多数的操作系统不同，Android应用程序没有单一的程序入口（比如没有main()函数）。而是拥有可以根据需要实例化和运行的组件。有4种类型的组件 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Application基础&lt;/h1&gt;
&lt;p&gt;Android应用程序是用Java语言编写的。被编译的代码和数据以及应用程序需要的资源文件被打包aapt tool打包为Android package格式，打包的文件以.apk结尾。这种文件是应用程序发布和安装到移动设备的方法；也是用户下载到设备上的文件。同一个.apk文件中的所有代码被当作是一个应用程序。&lt;/p&gt;
&lt;p&gt;在很多方面，每个Android应用生存在自己的世界中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认情况下，所有应用程序运行在自己的Linux进程中。Android在应用程序的代码需要执行时启动进程，当它不再被需要和系统资源被其它应用程序需要时停止。&lt;/li&gt;
&lt;li&gt;每个进程有自己的虚拟机，因此应用程序代码与其它应用程序的代码是隔离的。&lt;/li&gt;
&lt;li&gt;默认情况下，每个应用程序被赋予了一个唯一的Linux用户ID。这使得只能访问应用程序自己的文件&amp;mdash;&amp;mdash;尽管有方法将它们导出给其它的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有可能将两个应用程序组织为使用相同的用户ID，在这种情况下它们将可以互相看到对方的文件。为了保护系统资源，拥有相同ID的的应用程序也可以被组织到相同的Linux进程中，共享同一个虚拟机。&lt;/p&gt;
&lt;h1&gt;应用程序组件&lt;/h1&gt;
&lt;p&gt;Android的一个主要的功能是某个应用程序可以使用其它应用程序的元素（在这个应用程序许可时）。比如，如果你的应用程序需要显示滚动的图片列表而另一个应用程序已经开发了一个并且将它对外开放，这时你可以使用它，而不是重新开发一个。你的应用程序不需要包含这个应用程序的代码或者链接（link to）它。而只是在这个需求出现时运行那个应用程序的那段代码。&lt;/p&gt;
&lt;p&gt;为实现这个目的，系统必须在需要应用程序的一部分时启动应用程序进程，并实例化那部分Java对象。因此，与绝大多数的操作系统不同，Android应用程序没有单一的程序入口（比如没有main()函数）。而是拥有可以根据需要实例化和运行的组件。有4种类型的组件：&lt;/p&gt;
&lt;h3 id="activities"&gt;Activities&lt;/h3&gt;
&lt;p&gt;一个Activity描述一个可聚焦（focused）的并可被用户操作的用户界面。比如，某个activity可能描述了菜单列表项用户可以从中选择，或它显示单个图片及它的标题。一个文本消息应用程序可能有一个activity来显示联系人列表，另一个activity用于编写消息，其它的activities用于浏览旧消息或修改设置。尽管它们组合在一起构造出了聚合性的用户界面，但每个activity与其它activity间仍然是独立的。每个activity都被实现为Activity类的子类。&lt;/p&gt;
&lt;p&gt;一个应用程序可能包含单个或多个activity。有多少个activities依赖于应用程序和它的设计。通常，有一个作为应用程序启动时的第一个。从一个activity到另一个是由当前的这个启动另一个。&lt;/p&gt;
&lt;p&gt;每个activity被设置了一个默认的窗口对象用于绘图。通常，这个窗口填充整个屏幕，但也可以小于屏幕浮动于其它窗口之上。一个activity也可以使用额外的窗口&amp;mdash;&amp;mdash;比如，弹出式对话框或者当用户从屏幕中选择某些特殊的项时向用户显示重要提示信息的窗口。&lt;/p&gt;
&lt;p&gt;窗口中的可视化内容是由一组有层次结构的views提供的&amp;mdash;&amp;mdash;这些对象从View类派生。每个view控制窗口中的一个长方形区域。父view包含和控制它的子view的布局。作为叶节点的view被绘制到长方形区域中，在这个区域中它们控制和响应用户动作。因此，view是activity中与用户交互发生的地方。比如，一个view可能显示了一个图像并在用户点击图像时发生动作。Android有大量的预定义的view，如： 按钮、文本框、滚动条、菜单项、checkbox等等。&lt;/p&gt;
&lt;p&gt;窗口中的这个有层次结构的views通过activity提供的Activity.setContentView()方法被设置到窗口中。这个content view位于层次结构的根节点上。&lt;/p&gt;
&lt;h3 id="services"&gt;Services&lt;/h3&gt;
&lt;p&gt;服务没有用户界面，但它可以一直在后台运行。比如，服务可以后台播放音乐，或从网络下载数据或者将计算结果提供给activities。每个服务都从Service类继承。&lt;/p&gt;
&lt;p&gt;一个典型的例子就是媒体播放器从播放列表中播放歌曲。播放器应用程序可能有一个或多个activities来让用户选择歌曲和开始播放。但是，音乐音乐播放过程本身不能由activity来处理，因为用户希望在退出播放器进入其它界面时仍然能播放音乐。为了使音尔播放继承进行，播放器的activity将启动一个后台服务。系统将在播放器的activity未显示在屏幕上时继续播放音乐。&lt;/p&gt;
&lt;p&gt;系统允许连接（绑定）到正在运行的服务（如果服务没有运行，则将会启动它）。当连接上服务后，你可以通过服务暴露的接口（interface）来与服务通讯。比如音乐服务，这个接口可能允许用户暂停、倒带、停止和重新开始播放。&lt;/p&gt;
&lt;p&gt;与activities和其它组件类似，服务运行于应用程序的主线程。因此它们不会其它组件和用户界面，它们在处理耗时任务（比如音乐播放）时通常产生另一个进程。&lt;/p&gt;
&lt;h3 id="broadcast-receivers"&gt;Broadcast receivers&lt;/h3&gt;
&lt;p&gt;Broadcast receiver是一个组件，它用于接收和对广播信息作出反应。许多广播信息来源于系统的代码&amp;mdash;&amp;mdash;比如，广播时区信息被修改，电源电量低，拍了一个照片或用户修改了语言首选项。应用程序也可以发出广播信息&amp;mdash;&amp;mdash;比如，让其它应用程序知道某些数据被下载到设备并且已经可以使用。&lt;/p&gt;
&lt;p&gt;应用程序可以有任意数量的broadcast receivers来响应任何信息。所有的receivers都继承于BroadcastReceiver类。&lt;/p&gt;
&lt;p&gt;Broadcast receivers不显示用户界面。但它们可以在收到信息进行响应时启动一个activity，或者可以使用NotificationManager来向通知用户。通知可以通过闪烁背光、振动、播放音乐等方式提醒用户注意。典型的方式是在状态条上显示一个图标，从这里用户可以从这里打开并获取消息。&lt;/p&gt;
&lt;h3 id="content-providers"&gt;Content providers&lt;/h3&gt;
&lt;p&gt;Content provider可以指定应用程序数据允许共享给其它应用程序的数据。数据可以被存储在文件系统或SQLite数据库中，或者以其它允许的方式存储。Content provider继承自ContentProvider类并实现了标准的一组方法允许应用程序接收和存储数据。但是，应用程序并不会直接调用这些方法。而是使用ContentResolver对象的方法调用来实现。ContentResolver可以与任何content provider通讯，它与provider协作管理进程间的复杂通讯。&lt;/p&gt;
&lt;p&gt;无论何时一个请求都应该由一个特定的组件来处理，Android确保这个组件所属的应用程序运行，如果没有运行就启动它，如果对应的组件没有可用的实例就创建新的实例。&lt;/p&gt;
&lt;h2&gt;Activating components: intents&lt;/h2&gt;
&lt;p&gt;Content providers在它们被作为从ContentResolver发出的请求的目标时被激活。其它三个组件&amp;mdash;&amp;mdash;activities、services和broadcast receivers&amp;mdash;&amp;mdash;则通过被称为intends的异步消息来激活。一个Intent是一个Intent对象包含了消息内容。对于activities和services，它标明要请求的动作和并指定要操作的数据的URI，等等。例如，它可以表达请求一个activity展示图片给用户或让用户编辑文本。对于broadcast receivers，intent对象标明将要发生的动作。例如，它可以声明它对相机按钮被按下的动作感兴趣。&lt;/p&gt;
&lt;p&gt;不同的方法来激活每种类型的组件：
 - Activity通过传递给Context.startActivity()或Activity.startActivityForResult()一个intent对象来激活。响应的activity可以通过getIntent()方法看到调用它时初始的intent。Android通过调用activity的onNewIntent()方法来将它传递后续的intent。&lt;/p&gt;
&lt;p&gt;一个activity通常会启动下一个。如果它需要它启动的activity的返回值，要调用startActivityForResult()而不是startActivity()。比如，它启动一个activity让用户选择一个照片，它可能返回选中的照片。返回值是保存在intent对象中的，在调用onActivityResult()方法时被传递进来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Service通过传递一个intent对象到Context.startService()来启动。Android调用service的onStart()方法并传递intent对象给它。类似的是，可以通过将intent传递给Context.bindService()方法建立目标服务和调用组件之间的连接。服务在onBind()调用中接收intent对象。（如果服务没有运行，bindService()可以选择启动它）。例如，有个activity可以与先前启动的音乐播放服务建立连接以便提供用户界面给用户控制播放。这个activity可以调用bindService()来建立连接，然后调用service定义的方法影响音乐播放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用程序可以传递一个intent对象到类似Context.sendBroadcast()、Context.sendOrderedBroadcast()和Context.sendStickyBroadcast()等方法中来开始一个广播。Android通过调用接收者的onReceive()方法投递这个intent到任何对这个广播感兴趣的接收者。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关闭组件&lt;/h2&gt;
&lt;p&gt;Content provider只在响应ContentResolver的请求时才是活动的。Broadcast Receiver只在需要响应广播信息时才是活动的。因此，不需要显式的关闭这些组件。&lt;/p&gt;
&lt;p&gt;Activities和Services都是有可能长期运行的。Android提供了方法来关闭activities和services：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Activity可以调用它的finish()方法。一个Activity可以使用finishActivity()关闭另一个activity（这个activity由startActivityForResult()启动）。&lt;/li&gt;
&lt;li&gt;Service可以调用它的stopSelf()方法，或者调用Context.stopService()。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;组件在不再被使用或者Android进行垃圾收集时也可能被系统关闭。&lt;/p&gt;
&lt;h2&gt;Mainfest文件&lt;/h2&gt;
&lt;p&gt;在Android启动一个应用程序组件之前，它必须知道组件的存在。因此，应用程序需要在mainfest文件中申明这些组件并把它打包到.apk文件中。&lt;/p&gt;
&lt;p&gt;Mainfest文件是XML文件，它的名字被固定为AndroidMainfest.xml。它不仅仅申明了应用程序中的组件，还设定了其它的信息，如：应用程序需要的程序库（除默认的Android库外）和希望得到的特权信息。&lt;/p&gt;
&lt;p&gt;但是mainfest文件主要的任务是将应用程序的组件信息告诉Android。例如下面的一个Activity的申明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;manifest&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;application&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;activity&lt;/span&gt; &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;"com.example.project.FreneticActivity"&lt;/span&gt;
                  &lt;span class="na"&gt;android:icon=&lt;/span&gt;&lt;span class="s"&gt;"@drawable/small_pic.png"&lt;/span&gt;
                  &lt;span class="na"&gt;android:label=&lt;/span&gt;&lt;span class="s"&gt;"@string/freneticLabel"&lt;/span&gt; 
                  &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt;  &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/activity&amp;gt;&lt;/span&gt;
        . . .
    &lt;span class="nt"&gt;&amp;lt;/application&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/manifest&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt;元素的&lt;code&gt;name&lt;/code&gt;属性标明了实现了这个activity的Activity的子类。&lt;code&gt;icon&lt;/code&gt;和&lt;code&gt;label&lt;/code&gt;属性指向包含了显示给用户的图标和标签的资源文件。&lt;/p&gt;
&lt;p&gt;其它组件的申明方式与这类似&amp;mdash;&amp;mdash;用于services的&lt;code&gt;&amp;lt;service&amp;gt;&lt;/code&gt;元素，用户broadcast receivers的&lt;code&gt;&amp;lt;receiver&amp;gt;&lt;/code&gt;元素和用于content providers和&lt;code&gt;&amp;lt;provider&amp;gt;&lt;/code&gt;元素。未出现在mainfest中的activities、services和content providers对系统是不可见的并且永远不会被运行。但是，broadcast receivers可以在mainfest中申明也可以在代码中动态的创建（作为BroadcastReceiver对象）并使用系统提供的Context.registerReceiver()注册。&lt;/p&gt;
&lt;h2&gt;Intent filters&lt;/h2&gt;
&lt;p&gt;Intent对象可以显示的指出目标组件。如果它指明了，Android将查找出那个组件（根据mainfest中的申明信息）并激活它。但是如果目标未明确的给出，则Android需要定位到最佳的一个组件来响应这个intent。它通过比较intent对象可能的目标的intent filters来决定。一个组件的intent filters告诉Android这个组件可以处理的intents的类型。与组件的其它信息一样，它也放在mainfest文件中申明。例如，下例在上面的activity的mainfest文件中添加了两行intent filters：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?xml version="1.0" encoding="utf-8"?&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;manifest&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;application&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;activity&lt;/span&gt; &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;"com.example.project.FreneticActivity"&lt;/span&gt;
                  &lt;span class="na"&gt;android:icon=&lt;/span&gt;&lt;span class="s"&gt;"@drawable/small_pic.png"&lt;/span&gt;
                  &lt;span class="na"&gt;android:label=&lt;/span&gt;&lt;span class="s"&gt;"@string/freneticLabel"&lt;/span&gt; 
                  &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt;  &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;intent-filter&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;action&lt;/span&gt; &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;"android.intent.action.MAIN"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;category&lt;/span&gt; &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;"android.intent.category.LAUNCHER"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/intent-filter&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;intent-filter&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="err"&gt;.&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;action&lt;/span&gt; &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;"com.example.project.BOUNCE"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;data&lt;/span&gt; &lt;span class="na"&gt;android:mimeType=&lt;/span&gt;&lt;span class="s"&gt;"image/jpeg"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;category&lt;/span&gt; &lt;span class="na"&gt;android:name=&lt;/span&gt;&lt;span class="s"&gt;"android.intent.category.DEFAULT"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/intent-filter&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/activity&amp;gt;&lt;/span&gt;
        . . .
    &lt;span class="nt"&gt;&amp;lt;/application&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/manifest&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个filter&amp;mdash;&amp;mdash;组合了&amp;ldquo;android.intent.action.MAIN&amp;rdquo;和&amp;ldquo;android.intent.category.LAUNCHER&amp;rdquo;&amp;mdash;&amp;mdash;这是一个常用的方法。它表明这个activity应该显示在launcher中。换言之，这个activity是这个应用程序的入口，用户从应用程序launcher中选择到的属于这个应用程序的第一个activity。&lt;/p&gt;
&lt;p&gt;第二个filter申明了这个activity可以操作的数据类型。&lt;/p&gt;
&lt;p&gt;一个组件可以有任意多的intent filters，每个申明一组不同的功能。果它没有filters，则它只允许被那些显示的申明了目标组件的intents激活。&lt;/p&gt;
&lt;p&gt;对于那些在代码中创建和注册的broadcast receiver，intent filter是直接作为IntentFilter对象实例化的。所有其它filter都是在mainfest中设置的。&lt;/p&gt;
&lt;h1&gt;Activities和Tasks&lt;/h1&gt;
&lt;p&gt;前面说过，一个activity可以启动另一个，这包括定义于不同应用程序中的另一个。设想一下，你想要让用户在street map中显示一些位置。已经有一个activity可以实现这个功能，因此你的activity需要做的就是将需要的信息放到一个intent对象中并将它传递给startActivity()。地图将显示相关的信息。当用户点击&lt;code&gt;BACK&lt;/code&gt;键后，原来的activity重新显示到屏幕上。&lt;/p&gt;
&lt;p&gt;对于用户而言，它会将map view当作你应用程序的一部分，即使它是由另一个应用程序定义并运行于那个应用程序的进程中。Android给用户提供的这种用户体验是通过将这两个Activity组织到相同的task中。简单来说，task就是用户体验到的&amp;ldquo;application&amp;rdquo;。它由一组相关的activities组成，被组织为一个堆栈。堆栈中的根activity是开始任务的那个&amp;mdash;&amp;mdash;通常，它是用户从launcher中选择的那个activity。位于堆栈顶端的activity是当前在运行的展示给用户的这个。当一个activity启动另一个时，新的activity被推入堆栈中。新启动的这个变成正在运行的activity。前一个activity仍然在堆栈中。当用户按下&lt;code&gt;BACK&lt;/code&gt;时，当前的activity从堆栈中弹出前一个activity恢复成为正在运行的activity。&lt;/p&gt;
&lt;p&gt;堆栈包含对象，如果任务对于同一个Activity有多个实例被打开&amp;mdash;&amp;mdash;多个map view&amp;mdash;&amp;mdash;堆栈中对于每个实例都有单独的入口。堆栈中的activities永远不会重新被整理排序，只会推入和弹出。&lt;/p&gt;
&lt;p&gt;一个任务就是一个activities堆栈，而不是一个类或mainfest文件中的一个元素。因此，没有办法不依赖于activities来设置任务的值。任务的值整体上是在根activity处设置的。&lt;/p&gt;
&lt;p&gt;任务中的所有activities是作为一个整体移动的。整个任务（整个activity堆栈）可以被放到前台或后台。设想一下当前的任务有4个activities在它的堆栈中&amp;mdash;&amp;mdash;在当前的activity下有3个activity。当用户按下;&lt;code&gt;HOME&lt;/code&gt;键时回到launcher，然后选择了一个新的应用程序（实际上是一个新的任务）。当前的任务转到后台，新任务的root activity被显示出来。然后，隔一段时间后，用户回到主界面重新选择了选前的应用程序（前一个task）。那个有4个activities的任务将回到前台。这时用户按下;&lt;code&gt;BACK&lt;/code&gt;，屏幕将不会显示刚才离开的那个activity（之前那个任务的root activity）。而是当前任务的activities堆栈的顶部弹出并显示之前的一个activity。&lt;/p&gt;
&lt;p&gt;上面描述的是activites和tasks的默认行为。但是也有方法修改它的几乎所有方面。Tasks与activities的关联，和task中activity的行为是由启动activity的intent对象里的标识位和mainfest文件中&lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt;元素的属性决定的。请求者和响应都有权决定将发生什么样的情况。&lt;/p&gt;
&lt;p&gt;主要的intent标识有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FLAG_ACTIVITY_NEW_TASK 
FLAG_ACTIVITY_CLEAR_TOP 
FLAG_ACTIVITY_RESET_TASK_IF_NEEDED 
FLAG_ACTIVITY_SINGLE_TOP
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要的&lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt;属性有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;taskAffinity 
launchMode 
allowTaskReparenting 
clearTaskOnLaunch 
alwaysRetainTaskState 
finishOnTaskLaunch
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的章节将描述这些标识和属性，以及它们如何互相影响，如何考虑和应用它们。&lt;/p&gt;
&lt;h2&gt;Affinities and new tasks&lt;/h2&gt;
&lt;p&gt;默认情况下，应用程序中的所有的activities都有一个affinity&amp;mdash;&amp;mdash;有个选项标识它们属于相同的任务。但是，可以在&lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt;元素可以设置每个activity的&lt;code&gt;taskAffinity&lt;/code&gt;属性。定义于不同应用程序的activities可以共享同一个affinity，或者，定义于同一个应用程序的activities可以赋予不同的affinities。Affinity通常在两种情况下出现：当启动activity的Intent对象包含了FLAG_ACTIVITY_NEW_TASK标识，和当activity的allowTaskReparenting属性设置为&amp;ldquo;true&amp;rdquo;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FLAG_ACTIVITY_NEW_TASK标识&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面说过，新的activity总是被放到调用startActivity()启动它的任务中。它被推入调用者相同的堆栈。但是，如果传递给startActivity()的intent对象包含了FLAG_ACTIVITY_NEW_TASK标识；系统会将把它作为一个不同的任务来安置这个新的activity。就像这个标识名所表达的，它将是一个新的任务。但是，这并不是总会创建新的任务。如果已经有存一个与这个activity的affinity相同的任务，则会将这个activity归于那个任务。如果不存在才开始一个新任务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allowTaskReparenting属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个activity的allowTaskReparenting属性被设置为&amp;ldquo;true&amp;rdquo;，在与它具有相同的affinity相同的任务进入前台时，它可以从启动它的任务转移到与它的affinity相同的这个任务里。例如，假设某个旅行应用程序中选择某个城市后会有个activity报告天气情况。它与这个应用程序里的其它activities有相同的affinity，并且它允许reparent（allows reparenting）。如果你的某个activities启动了这个activity，则它将初始化为与你的activity属于同一个任务。但是，如果这个旅行程序下次切换到前台时，显示天气信息的这个activity将被重新赋给旅行程序，并在旅行程序中显示。&lt;/p&gt;
&lt;p&gt;如果一个.apk文件中包含多个&amp;ldquo;应用程序&amp;rdquo;（从用户角度来看），你可能会需要给不同的activites赋予不同的affinities。&lt;/p&gt;
&lt;h2&gt;Launch Modes&lt;/h2&gt;
&lt;p&gt;有4种launcher Modes可以赋给&lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt;元素的launcherMode属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"standard" (the default mode) 
"singleTop" 
"singleTask" 
"singleInstance"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些modes的区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哪个任务将hold响应intent的activity。对于&amp;ldquo;standard&amp;rdquo;和&amp;ldquo;singleTop&amp;rdquo; modes，它将是发起intent的那个任务（并调用了startActivity()）&amp;mdash;&amp;mdash;除非intent对象包含FLAG_ACTIVITY_NEW_TASK标识。在这种情况下，将按上一节描述的方式选择一个不同的任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;singleTask&amp;rdquo;和&amp;ldquo;singleInstance&amp;rdquo; modes标明了activities总是们于task的根节点。它们定义了一个任务；它们永远不会launched到另一个任务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否允许出现这个activity的多个实例。&amp;ldquo;standard&amp;rdquo;和&amp;ldquo;singleTop&amp;rdquo; activity可以被实例化多次。它们可以属于多个不同的任务，同一个任务中也可以有相同的activity的多个实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ldquo;singleTask&amp;rdquo;和&amp;ldquo;singleInstance&amp;rdquo;则只允许一个实例。由于这些activities位于任务的根节点，这也限制了同一时刻同一个任务在设备上只能有单个实例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例在其所属的任务中是否可以有其它activities。&amp;ldquo;singleInstance&amp;rdquo;的activity在它所属的任务中是否只允许有一个实例。如果它启动另一个activity，则这个activity是否将被设置为另一个任务依赖于它的launch mode&amp;mdash;&amp;mdash;如果intent中设置了FLAG_ACTIVITY_NEW_TASK。则这时，&amp;ldquo;singleInstance&amp;rdquo;mode与&amp;ldquo;singleTask&amp;rdquo;是等效的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其它三种模式允许多个activities属于（同一）任务。&amp;ldquo;singleTask&amp;rdquo;activity将总是任务的根activity，但它可以启动其它activities，并将这些activities设置为与它相同的task。&amp;ldquo;standard&amp;rdquo;和&amp;ldquo;singleTop&amp;rdquo;的activites可以出现在任务堆栈的任何地方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是否需要一个新的实例来处理一个新的intent。对于默认的&amp;ldquo;standard&amp;rdquo;mode，总是会创建新的实例来响应新的intent。每个实例处理一个intent。对于&amp;ldquo;singleTop&amp;rdquo;mode，一个已经存在的实例将会重用于处理新的intent，如果它位于目标任务的activity堆栈的顶部。如果它不在顶部，它将不会被重用，会为这个新的intent对象创建一个新的实例然后将这个实例推入堆栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，假设有一个任务的activity堆栈包含了一个root activity A以及B activity和C activity，堆栈的内容是A-B-C-D。一个intent到达了需要一个类型的D的activity。如果是在默认的&amp;ldquo;standard&amp;rdquo;模式下，将产生一个新的实例堆栈的内容会变成A-B-C-D-D。但是，如果D的launch mode为&amp;ldquo;singleTop&amp;rdquo;；则有已有的实例将用于处理这个intent（由于已有的这个实例位于栈顶），因此堆栈仍然是A-B-C-D。&lt;/p&gt;
&lt;p&gt;但是，如果到达的intent需要类型为B的activity，则会产生一个新的B类型的实例而不会管B的mode是&amp;ldquo;standard&amp;rdquo;或&amp;ldquo;singleTop&amp;rdquo;（因为B并不在栈顶），因此堆栈的内容会变为A-B-C-D-B。&lt;/p&gt;
&lt;p&gt;前面提过，永远不会有多个&amp;ldquo;singleTask&amp;rdquo;或&amp;ldquo;singleInstance&amp;rdquo;的activity，因此这个实例将被用于处理所有新的intents。&amp;ldquo;singleInstance&amp;rdquo;的activity总是位于堆栈的顶部（因为它是任务中唯一的activity），因此它总是位于处理intent的位置。但是&amp;ldquo;singleTask&amp;rdquo;类型的activity却并不一定会位于堆栈的顶部。如果它没有位于栈顶，则相应的intent将被丢弃。（即使intent被丢弃，它仍然会导致task切换到前台）&lt;/p&gt;
&lt;p&gt;当一个已经存在的activity被请求处理一个新的intent时，这个intent对象被传递到activity的onNewIntent()调用中。（最初启动这个activity的intent可以通过调用getIntent()来获取）&lt;/p&gt;
&lt;p&gt;注意，当创建了新的activity来处理新的intent时，用户总是可以使用BACK键返回前一个状态（回到前一个activity）。但是当使用已经存在的activity处理新的intent时，用户不可以按BACK键回到这个activity实例接收到这个intent对象之前的界面。&lt;/p&gt;
&lt;h2&gt;Clearing the stack&lt;/h2&gt;
&lt;p&gt;如果用户离开某个任务较长时间，系统会清理掉除根activity之外的其它activities。当用户再次返回任务时，任务与用户离开前相同，只是它会显示初始的那个activity。这意味着，过一段时间后，用户重新回到任务时有可能要放弃之前所做的一些操作。&lt;/p&gt;
&lt;p&gt;上面的情况是默认的情况。也有些activity属性可以用于控制和修改这种行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;alwaysRetainTaskState属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当任务的root activity的这个属性被设置为&amp;ldquo;true&amp;rdquo;时，前面所说的默认行为不会发生。即使过很长时间，任务仍将保留整个activities堆栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clearTaskOnLaunch属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当任务的root activity的这个属性被设置为&amp;ldquo;true&amp;rdquo;时，当用户离开task并重新回来时，root activity之外的activity将被清理掉。即与alwaysRetainTaskState是相反的。用户返回task时总是回到初始的状态，即使只过很短的时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;finishOnTaskLaunch属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个属性与clearTaskOnLaunch类似，但它只工作在单个activity，而不是整个task。它可以导致任何activity消失，也包括root activity。当它被设置为&amp;ldquo;true&amp;rdquo;时，activity只会存在于当前的会话。如果用户离开任务又重新回到任务，它将不会再存在。&lt;/p&gt;
&lt;p&gt;有另一个方法强制从堆栈中删除activities。如果intent对象包含FLAG_ACTIVITY_CLEAR_TOP标识，目标任务堆栈中已经有一个相应类型的activity来处理这个intent，所有位于那个实例之上的activities将被清除以便那个activity位于堆栈顶部来响应这个intent。如果指定的activity的launch mode是&amp;ldquo;standard&amp;rdquo;类型的，它也将被从堆栈删除，然后创建一个新的实例来处理这个intent。这是因为launch mode为&amp;ldquo;standard&amp;rdquo;的activity总是会创建新的实例来处理新的intent对象。&lt;/p&gt;
&lt;p&gt;FLAG_ACTIVITY_CLEAR_TOP通常与FLAG_ACTIVITY_NEW_TASK一起使用。当同时使用时，这些标识总是会找到另一个任务中已经存在的activity然后将它设置到响应intent的位置。&lt;/p&gt;
&lt;h2&gt;Starting tasks&lt;/h2&gt;
&lt;p&gt;一个activity可以设置为task的入口，给它一个intent filter &amp;ldquo;android.intent.action.MAIN&amp;rdquo;作为action，&amp;ldquo;android.intent.category.LAUNCHER&amp;rdquo;作为category。这个类型的filter将会导致在application launcher中显示图标和标签，让用户可以启动这个应用程序或重新进入已经启动的应用程序。&lt;/p&gt;
&lt;p&gt;后者相当重要：用户必须可以离开任务后能重新回到任务。因此，&amp;ldquo;singleTask&amp;rdquo;和&amp;ldquo;singleInstance&amp;rdquo;这两种launch mode总是会导致初始化新的task，应该只用于有MAIN和LAUNCHER filter的activity。设想下下，当没有这个filter时将发生什么：一个intent启动了一个&amp;ldquo;singleTask&amp;rdquo;的activity，初始化了一个新的task，用户在这个task上使用了一段时间。然后按HOME键。这时这个task在主屏幕上变得不可见。因为它没有被显示在application launcher上，用户不能再回到这个task了。&lt;/p&gt;
&lt;p&gt;类似还有FLAG_ACTIVITY_NEW_TASK标识。如果这个标识导致一个activity启动了一个新的task用户按HOME键离开，则必须要有一些方法让用户返回来。某些情况下（比如通知管理）总是在外部任务中启动activities，而不会在自身中启动，因此它总是在传递给startActivity()的intent中设置FLAG_ACTIVITY_NEW_TASK。如果你有一个activity可能被外部的实体调用时有可能使用这个标识，注意那个用户会有一个独立的方法返回到它启动的task中。&lt;/p&gt;
&lt;p&gt;如果你不希望在那种情况下用户返回到那个activity，就需要设置&lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt;元素的finishOnTaskLaunch为&amp;ldquo;true&amp;rdquo;。&lt;/p&gt;
&lt;h1&gt;进程和线程&lt;/h1&gt;
&lt;p&gt;当应用程序的第一个组件需要运行时，Android启动一个带有单个线程的Linux进程来执行。默认情况下，这个应用程序的所有组件运行时那个进程和线程中。&lt;/p&gt;
&lt;p&gt;当然，你也可以将组件运行到其它进程中，也可以在任何进程中生成额外的线程。&lt;/p&gt;
&lt;h2&gt;进程&lt;/h2&gt;
&lt;p&gt;组件运行的进程是通过mainfest文件控制的。组件元素&amp;mdash;&amp;mdash;&lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;service&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;receiver&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;provider&amp;gt;&lt;/code&gt;&amp;mdash;&amp;mdash;每个都有一个process属性可以指定组件运行的进程。这些属性可以设置每个组件运行在自己的进程中，或者一些组件共享同一进程，而其它组件不。他们也可以设置让不同应用程序的组件运行在相同的进程中&amp;mdash;&amp;mdash;提供了应用程序共享相同的Linux用户ID并且有相同的授权。&lt;code&gt;&amp;lt;application&amp;gt;&lt;/code&gt;元素也有process属性，可以设置一个默认值给所有组件。&lt;/p&gt;
&lt;p&gt;所有组件都在初始化到特定进程的主线程中，系统调用组件时从这个线程分派。不会为每个实例单独创建线程。所以，响应那些调用的方法&amp;mdash;&amp;mdash;像View.onKeyDown()，这个方法用于报告用户的动作和生命周期通知&amp;mdash;&amp;mdash;总是运行在进程的主线程中。这意味着在被系统调用时组件不应该执行长时间或阻塞的操作（比如网络操作或计算循环），因为这将阻塞这个进程中的任何其它组件。你也可以为长时间的操作生成新的线程。&lt;/p&gt;
&lt;p&gt;Android可以决定在某些点关闭进程，比如当内存不足并且其它进程需要立即为用户提供服务时。运行在进程中的应用程序组件因此被销毁。当重新需要它们时将重新启动这些组件。&lt;/p&gt;
&lt;p&gt;当决定要关闭哪个进程时，Android衡量它们对用户的重要性。比如，相比那些显示在屏幕上的activity相关的进程，它将更有可能关闭那些不再显示的activity相关的进程。决定是否关闭一个进程，依赖于组件运行于其中的进程的状态。&lt;/p&gt;
&lt;h2&gt;线程&lt;/h2&gt;
&lt;p&gt;即使你可以限制你的应用程序到单个进程，它们也有可能在某些时候执行一些后台的工作。因为用户界面必须总是快速的响应用户动作，包含activity的线程也不应该是像网络下载这样的时间消费型的操作。任何不能快速完成的工作应该放到不同的线程中。&lt;/p&gt;
&lt;p&gt;线程的创建是使用Java中标准的Thread对象。Android提供了大量便利的类来管理线程&amp;mdash;&amp;mdash;用于在纯种中运行消息循环的Looper，用于处理消息的Handler，和用于为消息循环设置线程的HandlerThread。&lt;/p&gt;
&lt;h2&gt;远程过程调用&lt;/h2&gt;
&lt;p&gt;Android有一个轻量级的RPC机制&amp;mdash;&amp;mdash;当调用的方法是本地调用，但是执行的是远程方法调用的形式（在另一个进程中），执行结果被返回到调用者。这需要分解方法调用和所有相关的数据到操作系统可以理解的层面，将它从本地进程地址空间到远程进程的地址空间，并在那里重新组装和重新进行调用。返回值必须被传输到相反的方向。Android提供了执行这些工作的所有代码，你可以关注于定义和实现RPC接口本身。&lt;/p&gt;
&lt;p&gt;一个RPC接口可以只包含方法。默认情况下，所有方法是同步执行的（本地方法被阻塞直到远程方法执行完成），即使没有返回值。&lt;/p&gt;
&lt;p&gt;工作机制如下：使用IDL（接口定义语言）申明你需要实现的RPC接口。使用aidl工具从那个申明中生成可以被本地和远程进程使用的Java接口定义。它包含两个内部类，如图：
&lt;img alt="" src="/android-dev-guide/binder_rpc.png"/&gt;&lt;/p&gt;
&lt;p&gt;内部类的代码有管理远程调用你在IDL中申明的接口需要的所有代码。两个内部类都实现了IBinder接口。一个用于本地internally by the system；你编写的代码可以忽略它。另一个称为Stub，继承自Binder类。除了为有效进行RPC调用的代码，它还包含你申明的RPC接口中申明的方法。你应该在Stub的子类中实现这些方法，像上图标出的。&lt;/p&gt;
&lt;p&gt;通常，远程进程可以被由service管理（因为service可以通知系统关于进程和它到其它进程的连接）。它将同时有由aidl工具生成的接口和实现RPC方法的Stub子类。Service的客户端可以只有由aidl工具生成的接口。&lt;/p&gt;
&lt;p&gt;下面是service和客户端建立连接的过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务的客户端（在本地侧）需要实现onServiceConnected和onServiceDisconnected()方法以便在建立远程service的连接成功时收到通知，当成功后。将调用bindService()设置连接。&lt;/li&gt;
&lt;li&gt;Service的onBind()方法可以被实现为接受或拒绝连接，依赖于它接收到的intent（intent传递到bindService()）。如果连接被接受，它将返回一个Stub子类的实例。&lt;/li&gt;
&lt;li&gt;如果service接受了连接，Android调用客户端的onServiceConnected()方法并将它传递给它一个IBinder对象，一个由service管理的Stub子类的代理。通过这个代理，客户端可以调用远程的service。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;线程安全的方法&lt;/h2&gt;
&lt;p&gt;有些情况下，你实现的方法可能会被多个线程调用，因此必须将它们编写为线程安全的。&lt;/p&gt;
&lt;p&gt;这主要是针对于远程调用&amp;mdash;&amp;mdash;上节讨论过的RPC机制。当调用一个实现在IBinder对象中的方法（起源于同一进程中的IBinder），方法执行在调用者自己的线程中。但是，调用起源于另一进程时，方法执行于从线程中中选择的线程Android将它维护在与IBinder相同的进程中，它不会执行于进程的主线程。例如，然而service的onBind()方法将被从service的进程的主线程调用，从onBind()返回的实现了那些方法的对象（例如，实现RPC方法的Stub的子类）将被从线程池中的线程调用。由于service可以有多个客户端，同一时刻线程池中将会有多个线程同时预定了IBinder中的方法。因此，IBinder的方法必须实现线程安全。&lt;/p&gt;
&lt;p&gt;类似的，content provider可以接收源于其它进程的数据请求。尽管ContentResolver和ContentProvider隐藏了如何管理进程间通讯的细节。ContentProvider的那些用于响应这些请求的方法&amp;mdash;&amp;mdash;query()，insert()，delete()，update()和getType()&amp;mdash;&amp;mdash;被content provider的进程的线程池调用，而不是进程的主线程。由于这些方法可以被从任意数量的线程同时调用，因此它们也应该是线程安全的。&lt;/p&gt;
&lt;h1&gt;组件生命周期&lt;/h1&gt;
&lt;p&gt;应用程序组件有自己的生命周期&amp;mdash;&amp;mdash;开始于Android初始化它们来响应intent对象直到结束时实例被销毁。在这期间，它们有时可能是活动的有时是不活动的，或者在活跃的某些时候，对于用户可见或不可见。这节讨论activities，services和broadcast receivers的生命周期&amp;mdash;&amp;mdash;包括它们在生命周期内的状态，以及通知状态改变的方法，和在进程中这些状态有可能因为中断和销毁而受到的影响。&lt;/p&gt;
&lt;h2&gt;Activity的生命周期&lt;/h2&gt;
&lt;p&gt;一个activity本质上有3个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它在前台时（位于当前task的activity堆栈的顶部）时它处于activity或running状态。这使得activity可以获取用户动作。&lt;/li&gt;
&lt;li&gt;如果它失去焦点但仍然显示给用户则它处于paused状态。另一个activity位于这个activity的上面它不是透明的也不覆盖整个屏幕，因此一些paused状态可以显示。Paused状态的activity是完全存活的（它它维护所有状态和成员信息并仍然与窗口管理器关联），但是可以在系统内存极低的情况下被系统杀掉。&lt;/li&gt;
&lt;li&gt;如果它被另一个activity完全掩盖则它变成stopped状态。它仍然包含状态和成员信息。但是它不再对用户可见它的窗口被隐藏并有可能在系统内存不足的时候被杀掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果某个activity是paused或stopped状态，系统可以将它从内存中删除或要求它完成（调用它的finish()方法），或简单的杀掉它的进程。当它再次显示给用户时，它必须完全的重新启动和恢复到前一个状态。&lt;/p&gt;
&lt;p&gt;当activity从一个状态迁移到另一个状态时，它会通过调用下面的方法进行通知：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void onCreate(Bundle savedInstanceState) 
void onStart() 
void onRestart() 
void onResume() 
void onPause() 
void onStop() 
void onDestroy()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些方法都是勾子方法你可以覆盖它在状态变化时执行相应的工作。所有activities必须实现onCreate()在对象初始化后执行初始化设置。很多activity还会实现onPause()来提交数据变化或准备停止与用户交互。&lt;/p&gt;
&lt;p&gt;这7个方法放一起定义了activity的整个生命周期。有3个嵌套循环你可以实现它们来实现监控。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Activity的整个生存周期（entire lifetime）处于第一个调用onCreate()和最后一个调用onDestroy()之间。一个Activity在onCreate()方法中设置它的&amp;ldquo;全局&amp;rdquo;状态，并在onDestroy()中释放所有的资源。例如，如果它有一个线程运行于后台进行网络数据下载，它可以在onCreate()中创建这个线程然后在onDestroy()中停止这个线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Activity的可见的生命周期处于onStart()和onStop()之间。在这期间，用户可以在屏幕上看到activity，尽管它可能不会显示在前台与用户交互。在这两个方法之间，你可以维护需要通过activity显示给用户的资源。比如，你可以在onStart()中注册BroadcastReceiver监听一些影响UI的变化，在onStop()中取消注册，这时用户将不会再看到你显示的东西。onStart()和onStop()方法可能被调用多次，activity交替的显示或隐藏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Activity的前台生命周期处于onResume()和onPause()调用之间。在些期间，activity显示于屏幕上处于其它activities之前与用户交互。Activity可以经常在resumed和paused状态间转换&amp;mdash;&amp;mdash;比如，当设备休眠时或新的activity启动时onPause()被调用，当一个新的activity result或新的intent被交付时onResume()被调用。因此，在这两个方法中的代码应该是非常轻量级的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下图描述了一个activity的在不同状态间转换的路径。彩色椭圆形的是activity的主要状态。方形的代表的是回调方法，你可以实现它在状态变更的时候执行一些操作。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/android-dev-guide/activity_lifecycle.png"/&gt;&lt;/p&gt;
&lt;p&gt;下表描述了每个方法的细节和它在activity的整个生命周期中的位置：&lt;/p&gt;
&lt;p&gt;方法 || 描述 || Killable? || 下一个方法
onCreate() | 在activity初次被创建时被调用。这里应该是执行所有静态设置的地方&amp;mdash;&amp;mdash;创建views，将数据绑定到list，等等。这个方法被传入一个Bundle对象，它包含了activity的前一个状态（如果那个状态被捕获了，参见后面讲到的保存activity的状态）。它后面总是执行onStart()。 | 否 | onStart()
onResart() | 在activity被停止，而被再次启动之前。后面执行onStart()。 | 否 | onStart()
onStart() | 在activity被显示给用户之前被调用。如果activity要被切换到前台，则后面执行onResume()，如果它activity变为隐藏则执行onStop()。 | 否 | onResume()或onStop()
onResume() | 在activity与用户交互之前被调用。在这个时候activity位于activity堆栈的顶部，接下来调用的方法是onPause() | 否 | onPause()
onPause() | 当系统需要开始恢复另一个activity时它被调用。这个方法通常用于提交未保存的数据为持久化数据，停止动画和其它消耗CPU的操作。它应该要执行得很快，因为下一个activity在它返回之前不能被恢复。如果activity回到前台执行，则接下来执行的是onResume()，如果它变为对用户不可见，则接下来要执行的是onStop()。 | 是 | onResume()或onStop()
onStop() | 当activity不再对用户可见时被调用。这可能是因为它将被销毁或由于另一个activity（已经存在的actiivty或是新建的）已经恢复并将它覆盖了。如果activity恢复于用户交互则接下来将执行onRestart()，如果这个activity离开，则将执行onDestroy() | 是 | onRestart()或onDestroy()
onDestroy() | 当activity被销毁后被执行。这是那个activity执行的最后一个调用。它可能是由于activity完成而被执行（在上面调用了finish()方法），或者由于系统销毁了这个activity实例以节约空间。你可以通过isFinishing()方法来区分这两种情景。 | 是 | 无&lt;/p&gt;
&lt;p&gt;注意上表中Killable这列。它标明了系统是否可以在这个方法返回,而未执行任何其它代码的的时候杀掉持有这个activity的进程。有三个方法（onPause()，onStop()和onDestroy()）被设置为&amp;ldquo;是&amp;rdquo;。因为onPause是第一个，因此它是唯一一个保证在进程被杀掉之前执行的&amp;mdash;&amp;mdash;onStop()和onDestroy()则有可能不被执行。因此，你应该在onPause()中进行数据的持久化。&lt;/p&gt;
&lt;p&gt;标明为&amp;ldquo;否&amp;rdquo;的方法保护持有activity的进程，在它们被执行期间不会被杀死。因此activity处于killable状态，是在从onPause()返回onResume()的时间。它不会再次处于killable状态直到再次调用onPause()返回。&lt;/p&gt;
&lt;p&gt;上节进程生命周期中提到，技术上来说activity的killable的是根据上来的定义来决定的，但是它仍然有可能会被系统杀掉&amp;mdash;&amp;mdash;但那只在极端的情况下。&lt;/p&gt;
&lt;h3 id="bao-cun-activityzhuang-tai"&gt;保存activity状态&lt;/h3&gt;
&lt;p&gt;当系统而非用户关闭activity以节约内存时，用户可能会希望返回activity之前的状态。&lt;/p&gt;
&lt;p&gt;为了捕获activity被杀掉之前的状态，你可以实现activity的onSaveInstanceState()方法。Android会在让activity变得易于销毁之前会执行这个方法&amp;mdash;&amp;mdash;它会先于onPause()被调用。它被传递给一个Bundle对象，使用这个对象你可以将activity的状态记录为键值对。当activity再次被启动时，Bundle对象会被传递给onCreate()和onStart()方法之后被调用的一个方法，onRestoreInstanceState()，因此这两个方法都可以重建之前所捕获的状态。&lt;/p&gt;
&lt;p&gt;与onPause和之前讨论的其它方法不同，onSaveInstanceState()和onRestoreInstanceState()都不是生命周期方法。它们不会总是被调用。例如，Android只会在activity变得易于被系统销毁之前才调用onSaveInstanceState()，但它不会在activity是由用户操作（比如按下BACK键）销毁的情况下被调用。在那种情况下，用户不会期望返回之前的状态，因此没有必要保存它的状态。&lt;/p&gt;
&lt;p&gt;因为onSaveInstanceState()并不总会被调用，因此你应该只用它来记录activit的临时（transient）状态，而不是保存持久化数据。应该使用onPause()来达到这个目的。&lt;/p&gt;
&lt;h3 id="xie-diao-activities"&gt;协调activities&lt;/h3&gt;
&lt;p&gt;当一个activity启动另一个时，它们都经历生命周期转换。一个暂停并可能会停止，而其它启动。有时，你可能需要协调这些activities。&lt;/p&gt;
&lt;p&gt;生命周期回调的顺序是明确界定的，特别是当这两个activities牌同一进程中时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前activity的onPause()方法被调用。&lt;/li&gt;
&lt;li&gt;接下来，要启动的activity的onCreate()，onStart()和onResume()方法被依次调用。&lt;/li&gt;
&lt;li&gt;当启动的activity不再显示在屏幕上时，它的onStop()方法被调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;服务的生命周期&lt;/h2&gt;
&lt;p&gt;服务可以用于两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它被启动后会一直运行直到有人停止它或它停止自己。在这种模式下，通过调用Context.startService()方法被启动，通过调用Context.stopService()被停止。它可以通过调用Service.stopSelf()或Service.stopSelfResult()停止自己。停止服务的stopService()方法只需要调用一次，而不用管startService()被调用过多少次。&lt;/li&gt;
&lt;li&gt;可以使用它提供的接口以编程的方式对它进行操作。客户端建立到服务对象的连接并使用那个连接调用服务。通过调用Context.bindService()建立连接，并用Context.unbindService()关闭连接。多个客户端可以绑定到同一服务。如果服务还没有被启动，bindService()可以选择将它启动。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种模式并不是完全分离的。你可以绑定到一个由startService()启动的服务。比如，一个后台播放音乐的服务可能是调用startService()启动的，并接收了一个包含要播放的音乐的标识的intent对象。后来，可能用户想要进行一些播放控制或者获取当前播放的歌曲的信息，activity可以使用bindService()连接到服务。在这种情况下，stopService()将不会停止这个服务，而是要到最后一个binding被关闭。&lt;/p&gt;
&lt;p&gt;与activity类似，服务也有生命周期方法你可以实现它来监控它的状态改变。但它比activity的方法少得多&amp;mdash;&amp;mdash;只有3个&amp;mdash;&amp;mdash;并且它们都是public的，而不是protected的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void onCreate()
void onStart(Intent intent)
void onDestroy()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过实现这3个方法，你可以监控服务生命周期中的两个嵌套循环：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整个服务的完全的生命期（entire lifetime）处于onCreate()被调用和onDestroy()方法返回。与activity类似，服务在onCreate()中进行初始化，在onDestroy()中释放资源。比如，音乐播放服务可以在onCreate()方法中创建播放线程，而在onDestroy()中停止线程。&lt;/li&gt;
&lt;li&gt;服务的活动生命期（active lifetime）开始于对onStart()的调用。这个方法会被传入传递给startService()方法的intent对象。音乐服务可以打开intent发现要播放哪些音乐，并开始播放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有对应的服务停止回调&amp;mdash;&amp;mdash;没有onStop()方法&lt;/p&gt;
&lt;p&gt;onCreate()和onDestroy()方法被所有服务所调用，不管它是由Context.startService()还是由Context.bindService()启动的。但是，onStart()只会被由startService()启动的服务所调用。&lt;/p&gt;
&lt;p&gt;如果一个服务允许其它人bind到它，则可以实现这些额外的回调方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;IBinder onBind(Intent intent)
boolean onUnbind(Intent intent)
void onRebind(Intent intent)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;onBind()回调被传入传递给bindService的intent对象，onUnbind()方法可以得到传递给unbindService()的intent对象。如果服务允许binding，onBind()返回供客户端与服务交互的通讯通道。如果新的客户端连接到服务onUnbind()方法可以要求onRebind()被调用。&lt;/p&gt;
&lt;p&gt;下图描述了服务的回调方法。尽管，图中区分了startServicet()和bindService()创建的的服务，但是要记住任何服务，不论它是如何被启动的，都可以允许客户端bind到它，因此任何服务都可以接收onBind()和onUnbind()调用。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/android-dev-guide/binder_rpc.png"/&gt;&lt;/p&gt;
&lt;h2&gt;广播接收者生命周期&lt;/h2&gt;
&lt;p&gt;Broadcast receiver有单个回调方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void onReceive(Context curContext, Intent broadcastMsg)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当广播信息到达接收者时，Android将调用它的onReceive()方法并将包含消息的intent对象传递给它。广播接收者被作为只在执行这个方法时才是活动状态的。当onReceive()返回后，它不再处于激活状态。&lt;/p&gt;
&lt;p&gt;与活动状态的广播信息接收者相关的进程会被保护而不被杀掉。但是如果接收者不是活动状态时可以在任何时候被系统杀掉，比如当其它进程需要内存时。&lt;/p&gt;
&lt;p&gt;这带来了一个问题，当一个广播消息的响应是费时的操作时，一些操作应该在单独的线程中完成，与用户界面所在的主线程是不同的线程。如果onReceive()产生线程然后返回时，整个进程，包括新建的这个线程，被认为是非激活的（除非进程中的其它应用程序组件处于激活状态），它有可能会被杀掉。解决这个问题的办法是在onReceive()中启动一个服务让这个服务执行那些操作，这样系统会认为进程中仍然是激活的有操作在执行。&lt;/p&gt;
&lt;h2&gt;进程和生命周期&lt;/h2&gt;
&lt;p&gt;Android系统试图让应用程序进程尽可能长时间的运行，但是最终它在内存不足时仍然需要移除旧的进程。决定哪个进程需要保留哪个需要被杀掉，Android将根据每个进程中运行的组件和这些组件的状态，将进程放入&amp;ldquo;importance hierarchy&amp;rdquo;。重要性最低的进程将被先被淘汰，然后是下一个最低的，如此继续。有一个级别描述重要性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前台进程（foreground process）是当前用户需要做的。当满足下面某个条件时进程被当作是前台进程：&lt;/li&gt;
&lt;li&gt;它运行了一个activity与用户交互（Activity对象的onResume()方法已经被调用了）。&lt;/li&gt;
&lt;li&gt;它包含了一个用户正与之进行交互的服务。&lt;/li&gt;
&lt;li&gt;它拥有一个服务对象正在执行它的生命周期回调（onCreate()，onStart()或onDestroy()）。&lt;/li&gt;
&lt;li&gt;它拥有一个广播接收者对象正在执行它的onReceive()方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在任意时刻仅有少量前台进程存在。他们被杀掉是被当作最后的手段&amp;mdash;&amp;mdash;如果内存不足它们不能继续执行。通常来说，在这一时刻，设备已经达到内存分页的状态，因此杀掉一些前台进程是为了保持对用户响应。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可见进程（visible process）是在前台没有任何显示组件，但是仍然可以影响用户在屏幕上看到的内容。如果进程满足下面的任何条件则进程被作为是可见的：&lt;/li&gt;
&lt;li&gt;它包含了一个不在前台显示的activity，但是仍然对于用户可见（它的onPause()方法已经被调用）。这有可能发生，比如，如果前台的activity是一个对话框前一个activity仍然在它后面可见。&lt;/li&gt;
&lt;li&gt;它包含了一个绑定到可见activity的服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可见进程被认为是非常重要的，不会被杀死，除非是为了保持所有前台进程（foreground process）的运行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;服务进程是正在运行用startService()启动的服务的进程并且不属于上面的两类。尽管服务进程不直接与用户看到的任何信息挂钩，它们通常与用户关注的东西相关（比如后台播放mp3或下载网络数据），因此系统保持它们运行除非没有足够内存保持他们与可见进程和前台进程同时运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后台进程（background process）是包含当前不向用户显示的activity（Activity对象的onStop()方法已经被调用）的进程。这些进程不直接影响用户体验，可以在任何时间被杀掉为前台进程、可见进程或服务进程节约出内存。通常有许多后台进程在运行，它们被保存在LRU（last recently used）列表中，以确保最近与用户交互过的activity相关的进程最后被杀掉。如果一个activity正确的实现了神经质生命周期方法，捕获了它的当前状态，杀掉它的进程将不会对用户体验产生有害的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空进程（empty process）是不包含任何activity的应用程序组件。保持这种进程的唯一原因就是作为缓存以提高下次在它里面执行组件时的启动速度。系统通常会杀掉这些进程以在进程缓存和下层内核缓存间平衡整个系统的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Android基于当前处于活动状态的组件的重要性将进程排在它可能的最高级别。例如，如果进程包含了一个服务和一个可见的activity，则这个进程将被排作可见进程，而不是服务进程。&lt;/p&gt;
&lt;p&gt;另外，进程的排名可能因为其它进程依赖它而提升。服务于其它进程的进程的排名不会低于它所服务的进程。比如，如果内容提供者进程A服务于一个客户进程B，或一个服务进程A被绑定到组件进程B，进程A将总会被认为重要性至少与B相同。&lt;/p&gt;
&lt;p&gt;因为运行服务的进程的排名高于运行后台activites的进程，一个要启动长时间操作的activity最好是为这次操作启动一个服务，而不是简单的产生一个线程&amp;mdash;&amp;mdash;特别是有可能拖垮activity的操作。比如后台音乐播放和上传相机拍摄的图片到一个网站上。使用服务保证该行动至少有&amp;ldquo;服务过程（service process）&amp;rdquo;优先级，不论activity发生了什么。前面讲过的广播接收者生命周期一节中提到的，这也是同样的原因广播接收者应该采用服务而不是简单的将时间消耗型操作放到线程中。&lt;/p&gt;</content><category term="android"></category></entry><entry><title>Android Dev Guide学习笔记 What is Android?</title><link href="/android-dev-guidexue-xi-bi-ji-what-is-android.html" rel="alternate"></link><published>2010-07-30T00:00:00+08:00</published><updated>2010-07-30T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-07-30:/android-dev-guidexue-xi-bi-ji-what-is-android.html</id><summary type="html">&lt;h1&gt;Android是什么？&lt;/h1&gt;
&lt;h1&gt;功能&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Application framework允许重用和替换的组件&lt;/li&gt;
&lt;li&gt;Dalvik虚拟机&lt;/li&gt;
&lt;li&gt;集成了基于WebKit引擎的浏览器&lt;/li&gt;
&lt;li&gt;基于2D图形库的优化过的图形；基于OpenGL ES 1.0规范的3D图形（可选的硬件加速）。&lt;/li&gt;
&lt;li&gt;SQLite来支持结构化数据存储&lt;/li&gt;
&lt;li&gt;多媒体方面 支持：音频、视频和图像支持（MPEG4、H.264、MP3、AAC、AMR、JPG、PNG、GIF）&lt;/li&gt;
&lt;li&gt;GSM通讯（依赖于硬件）&lt;/li&gt;
&lt;li&gt;蓝牙、EDGE、3G和WiFi（依赖于硬件）&lt;/li&gt;
&lt;li&gt;摄像头、GPS、罗盘和加速感应（依赖于硬件）&lt;/li&gt;
&lt;li&gt;丰富的开发环境，包括：设备模拟器，用于调试的工具，内存和性能分析，和Eclipse IDE插件&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Android架构&lt;/h1&gt;
&lt;p&gt;下图展示了Android操作系统的主要组件。
&lt;img alt="system architecture" src="/android-dev-guide/system-architecture.jpg"/&gt;&lt;/p&gt;
&lt;h1&gt;应用程序&lt;/h1&gt;
&lt;p&gt;Android发布时一般带有一套核心应用程序，包括email客户端，SMS程序，日历 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Android是什么？&lt;/h1&gt;
&lt;h1&gt;功能&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Application framework允许重用和替换的组件&lt;/li&gt;
&lt;li&gt;Dalvik虚拟机&lt;/li&gt;
&lt;li&gt;集成了基于WebKit引擎的浏览器&lt;/li&gt;
&lt;li&gt;基于2D图形库的优化过的图形；基于OpenGL ES 1.0规范的3D图形（可选的硬件加速）。&lt;/li&gt;
&lt;li&gt;SQLite来支持结构化数据存储&lt;/li&gt;
&lt;li&gt;多媒体方面 支持：音频、视频和图像支持（MPEG4、H.264、MP3、AAC、AMR、JPG、PNG、GIF）&lt;/li&gt;
&lt;li&gt;GSM通讯（依赖于硬件）&lt;/li&gt;
&lt;li&gt;蓝牙、EDGE、3G和WiFi（依赖于硬件）&lt;/li&gt;
&lt;li&gt;摄像头、GPS、罗盘和加速感应（依赖于硬件）&lt;/li&gt;
&lt;li&gt;丰富的开发环境，包括：设备模拟器，用于调试的工具，内存和性能分析，和Eclipse IDE插件&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Android架构&lt;/h1&gt;
&lt;p&gt;下图展示了Android操作系统的主要组件。
&lt;img alt="system architecture" src="/android-dev-guide/system-architecture.jpg"/&gt;&lt;/p&gt;
&lt;h1&gt;应用程序&lt;/h1&gt;
&lt;p&gt;Android发布时一般带有一套核心应用程序，包括email客户端，SMS程序，日历，地图，浏览器，联系人和其它。所有应用都是用Java编写的。&lt;/p&gt;
&lt;h1&gt;应用程序框架&lt;/h1&gt;
&lt;p&gt;通过提供一个开放的开发平台。Android给开发者提供了构建极其丰富和具有创新性的应用的能力。开发者可以自由的获取硬件的好处，访问位置信息，执行后台服务，设置警报，在状态条上增加通知等等。&lt;/p&gt;
&lt;p&gt;开发者可以像核心应用程序一样访问相同的应用程序框架提供的API。应用程序框架被设计为简单的可重用组件；任何应用程序都可以发布它自己的功能其它应用程序可以使用这些功能（比如框架提供的安全性约束）。同样的机制也允许用户替换组件。&lt;/p&gt;
&lt;p&gt;在所有应用程序下都是一套服务系统，它包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;丰富和具有扩展性的一套Views，它可以用于构造应用程序，包括：列表、表格、文本框、按钮和甚至是可嵌入的浏览器。&lt;/li&gt;
&lt;li&gt;Content Providers允许应用程序访问数据或者共享自己的数据。&lt;/li&gt;
&lt;li&gt;Resource Manager提供访问非代码性的资源比如：本地化字符串、图片、布局文件。&lt;/li&gt;
&lt;li&gt;Notification Manager允许所有应用程序在状态条上显示自己的通知信息。&lt;/li&gt;
&lt;li&gt;Activity Manager管理应用程序和生命周期并提供了一个通用的导航堆栈（navigation backstack）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;程序库&lt;/h1&gt;
&lt;p&gt;Android包括一套用于Android系统组件的C/C++程序库。它通过Android应用程序框架暴露给开发人员。一些核心库如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;System C library - 源于BSD系统实现的标准C系统库（libc）被调整为适用于嵌入式Linux设备优化。&lt;/li&gt;
&lt;li&gt;Media Libraries - 基于PacketVideo的OpenCORE；这些程序库支持播放和记录许多流行的音频和视频格式，如：静态图片文件、MPEG4、H.264、MP3、AAC、AMR、JPG和PNG。&lt;/li&gt;
&lt;li&gt;Surface Manager - 管理从不同的应用程序访问显示子系统和无缝集成2D和3D图形。&lt;/li&gt;
&lt;li&gt;LibWebCore - 一个现代的浏览器引擎来支持Android浏览器和可嵌入的web view。&lt;/li&gt;
&lt;li&gt;SGL - 底层的2D图形引擎。&lt;/li&gt;
&lt;li&gt;3D libraries - 基于OpenGL ES 1.0 APIs实现；这个库支持硬件3D加速（在可用时）或包含高度优化的3D软件光栅。&lt;/li&gt;
&lt;li&gt;Freetype - 位图和矢量字体渲染。&lt;/li&gt;
&lt;li&gt;SQLite - 为所有应用程序提供了一个功能强大的轻量级关系数据库引擎。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Android运行环境&lt;/h1&gt;
&lt;p&gt;Android包含了一套核心程序库在Java程序中绝大部分的功能都是可用的。&lt;/p&gt;
&lt;p&gt;所有Android应用程序运行在自己的进程中，使用自己的Dalvik虚拟机实例。Dalvik虚拟机被编写为可以有效的运行多个虚机。Dalvik虚拟机上的执行文件是Dalvik可执行文件格式（.dex）它被优化为最小的内存占用。这个虚拟机是基于寄存器的，可以运行Java语言编译的被&amp;ldquo;dx&amp;rdquo;工具转译为dex格式的class。&lt;/p&gt;
&lt;p&gt;Dalvik虚拟机依赖于Linux内核提供的底层功能，如：线程和底层的内存管理。&lt;/p&gt;
&lt;h1&gt;Linux内核&lt;/h1&gt;
&lt;p&gt;Android的核心系统服务依赖于Linux 2.6，如：安全、内存管理、进程管理、网络栈和驱动模型。内核也扮演了硬件和其它软件栈之间的抽像层。&lt;/p&gt;</content><category term="android"></category></entry><entry><title>OA Framework Page解析</title><link href="/oa-framework-pagejie-xi.html" rel="alternate"></link><published>2010-07-27T00:00:00+08:00</published><updated>2010-07-27T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-07-27:/oa-framework-pagejie-xi.html</id><summary type="html">&lt;h1&gt;Page基础&lt;/h1&gt;
&lt;p&gt;在浏览器看来，OA Framework页面与其它web页面一样，被渲染为HTML。&lt;/p&gt;
&lt;p&gt;在中间层中，页面是由内存中层级分布的Javabeans组成&amp;mdash;&amp;mdash;非常像传统的Java客户端UI。每个UI构件，比如按钮、表格、tab、商标图像等，被渲染为页面中对应的构件。&lt;/p&gt;
&lt;p&gt;浏览器向一个页面发出请求时，OA Framework读取页面定义的元数据创建web bean结构。每个bean与一个UI控制器关联，OA Framework调用你编写的代码初始化页面。页面处理完成后，OA Framework将web bean结构交给UIX框架处理以生成发送给浏览器的HTML。&lt;/p&gt;
&lt;p&gt;当浏览器发出一个表单提请求时，OA Framework重新创建bean及其层次结构（只在必要的时候才重新创建，通常这些bean是被缓存的，只在特定的情况下才重新创建），然后调用为page bean编写的事件处理代码。当页面处理完成后，页面HTML重新生成并发送给浏览器。&lt;/p&gt;
&lt;p&gt;OA Framework MVC架构：&lt;/p&gt;
&lt;p&gt;&lt;img alt="anatomy" src="/oaf_page/anatomy.gif"/&gt;&lt;/p&gt;
&lt;h1&gt;模型Model&lt;/h1&gt;
&lt;p&gt;模型包括下层的数据和应用业务逻辑。它也提花了现实世界对象和应用服务间的抽像层。&lt;/p&gt;
&lt;h2&gt;应用模块Application Modules&lt;/h2&gt;
&lt;p&gt;BC4j应用模块本质上是一个容器，它管理和提供对&amp;ldquo;相关&amp;ldquo;BC4J模型对象的访问。这里的&amp;ldquo;相关&amp;rdquo;指的是同一个任务中的参与者 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Page基础&lt;/h1&gt;
&lt;p&gt;在浏览器看来，OA Framework页面与其它web页面一样，被渲染为HTML。&lt;/p&gt;
&lt;p&gt;在中间层中，页面是由内存中层级分布的Javabeans组成&amp;mdash;&amp;mdash;非常像传统的Java客户端UI。每个UI构件，比如按钮、表格、tab、商标图像等，被渲染为页面中对应的构件。&lt;/p&gt;
&lt;p&gt;浏览器向一个页面发出请求时，OA Framework读取页面定义的元数据创建web bean结构。每个bean与一个UI控制器关联，OA Framework调用你编写的代码初始化页面。页面处理完成后，OA Framework将web bean结构交给UIX框架处理以生成发送给浏览器的HTML。&lt;/p&gt;
&lt;p&gt;当浏览器发出一个表单提请求时，OA Framework重新创建bean及其层次结构（只在必要的时候才重新创建，通常这些bean是被缓存的，只在特定的情况下才重新创建），然后调用为page bean编写的事件处理代码。当页面处理完成后，页面HTML重新生成并发送给浏览器。&lt;/p&gt;
&lt;p&gt;OA Framework MVC架构：&lt;/p&gt;
&lt;p&gt;&lt;img alt="anatomy" src="/oaf_page/anatomy.gif"/&gt;&lt;/p&gt;
&lt;h1&gt;模型Model&lt;/h1&gt;
&lt;p&gt;模型包括下层的数据和应用业务逻辑。它也提花了现实世界对象和应用服务间的抽像层。&lt;/p&gt;
&lt;h2&gt;应用模块Application Modules&lt;/h2&gt;
&lt;p&gt;BC4j应用模块本质上是一个容器，它管理和提供对&amp;ldquo;相关&amp;ldquo;BC4J模型对象的访问。这里的&amp;ldquo;相关&amp;rdquo;指的是同一个任务中的参与者。比如所有的BC4J对象在同一个任务中参与同一个事务&amp;mdash;&amp;mdash;即使对应的用户界面需要用户访问多个页面。&lt;/p&gt;
&lt;p&gt;应用模块：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ess_model_arch_am" src="/oaf_page/ess_model_arch_am.gif"/&gt;&lt;/p&gt;
&lt;p&gt;应用模块是oracle.apps.fnd.framework.server.OAApplicationModuleImpl类的子类。&lt;/p&gt;
&lt;p&gt;每个OAFramework 页都有一个根（root）应用模块，它与最顶层的页面区域（page region）关联。根应用模块提供事务环境和连接数据库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果多个页面参与同一个物理或虚拟事务，它们应该共享相同的根应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个页面功能不依赖于其它东西，它需要拥有自己的应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 一个根应用模块可能包含一个或多个嵌套的应用模块，可以嵌套任意多的层次。这种情况下，根应用模块可以访问它包含的子对象的数据和对象，所有子对象共享根应用模块的事务。你可以在创建需要重用的与数据库操作相关的UI区域时使用这个功能。&lt;/p&gt;
&lt;h2&gt;实体对象（Entity Objects）和关联对象（Association Objects）&lt;/h2&gt;
&lt;p&gt;BC4J实体对象包含了业务规则（校验、动作等）与数据库表中的一行关联。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 实体也可以基于视图、同义词、快照而定义。&lt;/p&gt;
&lt;p&gt;OA Framework支持Java和PL/SQL实体。&lt;/p&gt;
&lt;p&gt;实体对象：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ess_model_arch_eo" src="/oaf_page/ess_model_arch_eo.gif"/&gt;&lt;/p&gt;
&lt;p&gt;多数实体是oracle.aps.fnd.framework.server.OAEntityImpl的子类（PL/SQL继承于特殊版本的OAEntityImpl）。&lt;/p&gt;
&lt;p&gt;表和实体对象一一对象，所有实体应该包含与之关联的表的所有列。实体对象使用映射了它的属性和数据库列，并自动实现了查询、插入、更新、删除等操作。多数情况下，我们只需要添加校验逻辑。&lt;/p&gt;
&lt;p&gt;实体对象可以用于任何程序（不限于OA Framework）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关联对象Association Objects&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于定义实体间的关系。&lt;/p&gt;
&lt;h2&gt;视图对象（View Objects）和视图链接（View Links）&lt;/h2&gt;
&lt;p&gt;BC4J视图对象处理数据库查询。查询执行后，视图对象提供了访问它的结果集的功能。结果集包含了一个或多个视图行，视图行与数据库查询的行相对应。&lt;/p&gt;
&lt;p&gt;视图对象：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ess_model_arch_vo" src="/oaf_page/ess_model_arch_vo.gif"/&gt;&lt;/p&gt;
&lt;p&gt;所有的视图对象都是oracle.apps.fnd.framework.server.OAViewObjectImpl类的子类。&lt;/p&gt;
&lt;p&gt;视图对象可以配置为使用下面的策略查询数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它的属性映射到简单的SQL语句的列（通常用于小的只读的视图对象）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它的属性映射到实体对象的属性（用于插入、更新和删除实体）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些属性映射到实体对象，一些直接映射到SQL（用于增加实体临时数据，这些数据不能通过实体获得，比如计算值或用于UI显示需要）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在OA Framework应用中，将在下面情况下使用视图对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;呈现用于优化用户界面细节的数据。如果用户界面支持实体的插入、更新、删除，你将通过视图对象执行这些操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为poplists、lists of values和其它UI组件创建简单的查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为业务逻辑创建有效的&amp;ldquo;校验查询（validation queries）&amp;rdquo;。比如，在定单处理时使用一个校验视图对象获得最大可以购买的商品数量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以为视图对象编写代码用于实现复合查询或查询时的数据绑定（以便视图对象知道怎样&amp;ldquo;查询&amp;rdquo;自己）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视图链接View Links&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与实体对象类似，也可以为视图对象建立关联，称为视图链接（view links）。比如可以在定单头视图对象和定单内容间建立视图链接对象。这可以用于在运行时访问定单头时自动查询定单内容。&lt;/p&gt;
&lt;h2&gt;OADBTransaction&lt;/h2&gt;
&lt;p&gt;OADBTransaction：&lt;/p&gt;
&lt;p&gt;&lt;img alt="ess_model_arch_tran" src="/oaf_page/ess_model_arch_tran.gif"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 准备的来说这个图应该要包含实现类oracle.apps.fnd.framework.server.OADBTransactionImpl替代oracle.apps.fnd.framework.OADBTransaction接口。&lt;/p&gt;
&lt;p&gt;如图所示，OADBTransaction扮演的是模型中的中心角色，因为它与一个根应用模块关联，管理JDBC连接/数据库会话，直接拥有你创建的任何实体（根应用模块拥有的视图对象中的行指向实体对象）。可以使用OADBTransaction在模型代码中完成下面的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建一个语句执行PL/SQL函数和存储过程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问应用会话级环境信息（session-level Application context information），比如：用户名、id、当前责任（resposibility）等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问一个oracle.apps.fnd.framework.OANLSServices对象，如果你需要执行NLS操作，比如转换服务器时间到用户日期/时间等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过根应用模块访问OADBTransaction。&lt;/p&gt;
&lt;h1&gt;视图&lt;/h1&gt;
&lt;p&gt;视图格式化当前模型数据给用户。&lt;/p&gt;
&lt;h2&gt;定义页面&lt;/h2&gt;
&lt;p&gt;在Oracle Applications开发时，将使用XML页面定义文件。当产品发布后，OA Framework从数据库获取页面定义。&lt;/p&gt;
&lt;p&gt;使用JDeveloper定义的页面（pages）由区域（regions）和条目（items）组成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;条目是简单的构件，比如按钮、输入域、图像等，它不包含子构件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区域是容器对象它可以包含条目和其它区域。比如区域包含文件头（headers）、表格和特别的布局组件（layout components）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义的每个区域和条目都有style属性，它告诉OA Framework使用哪个web bean对象来描述它。比如，如果你定义区域的style属性为&amp;ldquo;table&amp;rdquo;，OA Framework将使用oracle.apps.fnd.framework.webui.beans.table.OATableBean。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有页面必须有一个单一的top-level region（通常称为&amp;ldquo;root region&amp;rdquo;）它的style为pageLayout。它将使用oracle.apps.fnd.framework.webui.beans.layout.OAPageLayoutBean。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;regions和items显示在JDeveloper page tree中的顺序告诉了Framework将这些对象添加在什么位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;属性集Attribute Sets&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个region或item通过使用attribute sets可以继承一组属性集合。attribute sets是一个被命名的属性的集合，可重用于任何UI对象，包括：regions，items和其它属性集。当使用attributes set创建UI时，你可以覆盖所继承的属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件重用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果需要在页面使用共同对象，可以简单的从它继承。&lt;/p&gt;
&lt;p&gt;比如，可以创建一个通用的region。新建region时，将新region的Extends属性设置为通用region的命名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 共享的通用region在引用它的page中是不可编辑的，属于它的选项目在JDeveloper中将显示为灰色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据源绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于需要与数据库交互的bean，你需要指定数据源，将它绑定到View Instance Name，并关联好View Attribute Name。这个绑定是至关重要的，因为OA Framework使用它获取数据，并将用户输入的数据写入下面的视图对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;View Instance Name指向当前上下文环境中包含应用模块中的视图对象（所有视图对象&amp;ldquo;生活&amp;ldquo;于一个应用模块中，在包含它的容器对象中有一个实例变量名）。比如，如果SuppliersVO视图对象，在页面的根应用模块中有一个实例变量&amp;ldquo;MySupVO&amp;rdquo;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;View Attribute Name指向视图对象中映射到数据库列的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;定义菜单&lt;/h2&gt;
&lt;h2&gt;定义页面流&lt;/h2&gt;
&lt;h2&gt;个性化页面&lt;/h2&gt;
&lt;h1&gt;控制器&lt;/h1&gt;
&lt;p&gt;控制器响应用户动作控制应用流转。&lt;/p&gt;
&lt;p&gt;控制器可以与视图中的region级的对象关联（任何实现oracle.apps.fnd.framework.webui.beans.OAWebBeanContainer的OA Framework web bean都可以与控制器关联）。&lt;/p&gt;
&lt;p&gt;控制器是oracle.apps.fnd.framework.webui.OAControllerImpl的子类。&lt;/p&gt;
&lt;p&gt;控制器代码的行为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;生成/初始化UI&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中途截取或处理用户事件，比如按钮按下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;请求处理&lt;/h2&gt;
&lt;p&gt;当浏览器向OA.jsp请求一个页面时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.OAPageBean（OA Framework主页面处理类）根据请求的页面名称检查需要哪个根应用模块，并从应用模块池（application module pool）中取出。这个应用模块将为页面从JDBC连接池中获取连接和事务上下文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户会话校验；如果无效，将显示登录页面（这里是简化的说法，具体细节在Developer's Guid中有说明）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果用户有效，OAPageBean根据请求参数处理HTTP POST或GET。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;处理GET请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当浏览器发起GET请求一个page时（或你手工forward时），OA Framework使用描述的UI定义构建web bean层级结构：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;OAPageBean调用页面的top-level pageLayout bean的processRequest()方法，然后进入web bean层级结构中继续递归调用来初始化web beans（包括任何相关的模型组件）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个web bean可以有自己的控制器，如果有就调用控制器的processRequest(OAPageContext pageContext, OAWebBean webBean)方法。这个方法可以用于构件或修改页面布局，设置web bean属性和执行任何手工的数据初始化工作（比如，打开页面时自动执行查询）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些复杂的web beans（比如：oracle.apps.fnd.framework.webui.beans.table.OATableBean和oracle.apps.fnd.framework.webui.beans.layout.OAPageLayoutBean）通过调用它们的prepareForRendering()（这个方法在JavaDoc中的说明）方法执行post-controller处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个web bean调用它的子对象的processRequest()方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.OAPageBean将web bean结构传递给UIX渲染并发送给浏览器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;处理POST请求&lt;/p&gt;
&lt;p&gt;当浏览器向服务器页面发出POST请求时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;OAPageBean检查web bean层级结构是否在内存中。如果没有它就像在GET请求中一样创建一个web bean层级结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAPageBean调用整个层级结构中的web bean的processFormData(OAPageContext pageContext, OAWebBean webBean)方法，并将form中的数据写入模型（它在pageLayout region上调用processFormData()，然后在它的子对象上递归的调用processFormData()方法）。将form数据写入模型时将自动调用属性和实体级别（attribute and entity-level validations）的校验，如果抛出了任何校验异常，处理将停止，错误信息将显示给用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在执行processFormData()期间没有异常抛出，OAPageBean将使用与上面相同的方法在层级结构中的所有web bean上调用processFormRequest(OAPageContext pageContext, OAWebBean webBean)方法。这里给了你的控制器响应用户动作的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有JSP forward或redirect发出，或在执行processFormRequest()方法时没有异常被抛出。则页面刷新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;OAPageContext&lt;/h2&gt;
&lt;p&gt;当OA Framework收到一个OA.jsp请求时，OAPageBean创建一个oracle.apps.fnd.framework.webui.OAPageContext，这个类仅在页面处理过程中存在。上面描述的三个方法（processRequest()，processFormData()，processFormRequest()）都有一个OAPageContext参数，任何将要编写的控制器代码都使用了这个至关重要的类。&lt;/p&gt;
&lt;p&gt;&lt;img alt="pagecontext_arch" src="/oaf_page/pagecontext_arch.gif"/&gt;&lt;/p&gt;
&lt;p&gt;如上图所描述的，OAPageContext有指向request和根应用模块的引用。根据这个关系，OAPageContext被传递到每个控制器的响应处理方法中，你将看到如何在下面的通用任务中使用OAPageContext：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问请求参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用getParameter(String name)方法读取请求参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;页面上的每个web bean（buttons，fields等等）传递给getParameter()的是你定义在页面上的唯一ID属性。比如，使用下面的代码可以得到用户是否按下了名为&amp;ldquo;GoButton&amp;rdquo;的按钮：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"GoButton"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// The user pressed the "Go" button, do something...&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;访问根应用模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OAPageContext缓存了根应用模块的引用，它可以访问视图对象和事务。如果需要访问应用模块，可以通过OAPageContext：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAApplicationModule&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRootApplicationModule&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;发出导航指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用方法告诉OA Framework执行JSP forward或客户端重定向。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"CreateButton"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// The user pressed the "Create Supplier" button, now perform a JSP forward to&lt;/span&gt;
    &lt;span class="c1"&gt;// the "Create Supplier" page.&lt;/span&gt;

    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setForwardURL&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OA.jsp?page=/oracle/apps/dem/employee/webui/EmpDetailsPG"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                               &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;                               &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;KEEP_MENU_CONTEXT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;                                                           &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;                                                           &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;                                                           &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Retain AM                                                      OAWebBeanConstants.ADD_BREAD_CRUMB_YES, // Show breadcrumbs                                                     OAWebBeanConstants.IGNORE_MESSAGES);&lt;/span&gt;

  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;访问应用上下文信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与模型中的OADBTransaction类似，OAPageContext可以访问servlet session级的Oracle Application上下文信息，如：用户名，ID，当前职责等。比如，下面的片段用于获取用户名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;userName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getUserName&lt;/span&gt;&lt;span class="o"&gt;();}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Web Bean架构&lt;/h1&gt;
&lt;p&gt;所有OA Framework web beans都与UIX framework中的bean对应。比如，OATableBean继承自oracle.cabo.ui.beans.table.TableBean（&amp;ldquo;cabo"是UIX framework早期的名字，包定义仍然使用了旧名）。&lt;/p&gt;
&lt;p&gt;每个OA Framework web bean都实现了一组接口，这些接口实现了OA Framework添加到基础的UIX beans上的行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.beans.OAWebBean定义了所有web beans的通用行为（比如，其中在这里定义的关键的行为有processRequest，processFormData，processFormRequest方法，一些beans自己实现了这些方法）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.OAWebBeanConstants用于视图和控制器的常量集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.beans.OAWebBeanData定义通用的个性化定义和数据源管理行为&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.beans.OAWebBeanContainer定义所有可以作为其它web beans容器的web beans的特性。比如，所有layout web beans都实现了这个接口。只有实现了这个接口的beans才可以与控制器关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAWebBean&lt;type&gt;定义了bean在OA Framework上下文环境中的内在特性。比如，OATableBean实现的oracle.apps.fnd.framework.webui.beans.OAWebBeanTable接口。&lt;/type&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;web bean例子（OATableBean）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="bean_arch" src="/oaf_page/bean_arch.gif"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内部Bean结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个web bean自己包含了下列的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;_indexedChildren子web beans&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;_namedChildren子web beans特殊行为的UIX标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;_attributes web bean的特性（属性描述），下表的图表描述&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;描述web bean使用Dictionary保存键值对属性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="bean_internals_attr" src="/oaf_page/bean_internals_attr.gif"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据绑定值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;与上面的图表描述的情况不同，OA Framework web bean的attributes实际上是用数据绑定值实现的，这意味着它是由下层的数据源提供的，在组件被渲染时才被获取。后面将看到如何定义用户自定义绑定值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在页面渲染时，UIX framework处理web bean层级对象产生页面的HTML代码。&lt;/p&gt;
&lt;p&gt;对于每个web bean属性，UIX调用它的getAttributeValue()方法。并传递给它一个渲染上下文（rendering context），rendering context是UIX决定绑定值的全部基础。对于给出的属性，比如，rendering context知道下层的视图对象实例，视图属性和当前的行。数据绑定使用rendering context通过查询它的数据源所提供的返回值传递给UIX以产正确的HTML。&lt;/p&gt;
&lt;h1&gt;OA Framework Javadoc手册&lt;/h1&gt;
&lt;p&gt;每个OA Framework包的描述：&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework&lt;/h2&gt;
&lt;p&gt;包含的类和接口可以安全的从模型（server）和用户界面控制器或视图（client）访问。比如，需要在页面中访问根应用模块，应该使用oracle.apps.fnd.framework.OAApplicationModule接口（不应该在客户端访问它的实现）。&lt;/p&gt;
&lt;p&gt;这个包也包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有OA Framework异常&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OANLSServices类用于执行国际化操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;oracle.apps.fnd.framework.server&lt;/h2&gt;
&lt;p&gt;包含了OA Framework Model-View-Controller中用于实现model的类和接口。&lt;/p&gt;
&lt;p&gt;这些类规定用于任何客户端用户界面（不仅仅是OA Framework HTML pages）[译注：根据后面的意思，这里似乎应该是不能用于！]，并且不允许被任何oracle.apps.fnd.framework.webui包和其子包中的类和接口引用，也不允许应用中的webui包和其子包引用。&lt;/p&gt;
&lt;p&gt;当建造OA Framework应用模型时，应该使用这个包中的类替代BC4J中继承的类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要从控制器或视图代码中调用这个包中的类。&lt;/p&gt;
&lt;h2&gt;oracle.app.fnd.framework.webui&lt;/h2&gt;
&lt;p&gt;包括了构造OA Framework HTML用户界面的核心类。&lt;/p&gt;
&lt;p&gt;一些这个包中最常用的类和接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OAController&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAPageContext&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何下面所描述的beans子包中的类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要从模型代码中调用这个包中的类。&lt;/p&gt;
&lt;h2&gt;oracle.app.fnd.framework.webui.beans&lt;/h2&gt;
&lt;p&gt;包含用于用户界面组件的web bean。你将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;这个包和其子包中的类与UIX组件对应，它们继承关系如下。当构造OA Framework应用页面时，应该使用OA Framework类，除非你要使用一个已经介绍给UIX的新的功能，但目前这还不被支持。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework类是在JDeveloper中描述的MDS页面中使用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;UIX Package&lt;/th&gt;
&lt;th align="left"&gt;OA Package&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cable.ui.beans&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cable.ui.beans.form&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.form&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cabo.ui.beans.include&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.include&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cabo.ui.beans.layout&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.layout&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cabo.ui.beans.message&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.message&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cabo.ui.beans.nav&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.nav&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;oracle.cabo.ui.beans.table&lt;/td&gt;
&lt;td align="left"&gt;oracle.apps.fnd.framework.webui.beans.table&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.beans.form&lt;/h2&gt;
&lt;p&gt;包含了HTML form组件相关的web bean类。包括了提交按钮和各种数据入口／特定的控件（checkbox,radio,group,shuttle,text input field等）。可以在编写用户界面控制器时使用这些类，需要用编程的方式处理web beans。&lt;/p&gt;
&lt;p&gt;与这个包中其它的web beans不同的是oracle.apps.fnd.framework.webui.beans.message包（message web beans可以显示错误，信息，带警告图标的说明信息）。当在JDeveloper中创建页面时，OA Framework为同一个包中的这些组件自动显示消息。应该只在下面的情况下使用这个包中的这个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类没有message bean供选择。（比如，这个包中唯一的类OASubmitButtonBean）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能使用message bean替换的时候。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.bean.include&lt;/h2&gt;
&lt;p&gt;包含了用于将外部资源（servlet,JSP,HTML）中包含到用户界面的web bean类。将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.beans.layout&lt;/h2&gt;
&lt;p&gt;包含了OA Framework程序中页面布局的web bean类，包括特殊的layout组件，比如，hide/show，content container，bulleted lists，headers，standardized templates等等。将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.beans.message&lt;/h2&gt;
&lt;p&gt;包含了HTMl form数据相关组件具有显示相关错误，警告信息或带信息图标的说明性消息的web bean类（比如，如果用户在文本框中输入了错误的值，下次渲染这个页面时，这个文本框前将显示一个表示出错的图标）。将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;这个包中的许多web bean也包含在oracle.apps.fnd.framework.webui.bean.form包中，没有显示额外的消息文本和图标文本的能力。当在JDeveloper中创建页面时，OA Framework自动将message bean添加这两个包中的组件。应该只在不能使用包含message bean的页面上使用不带消息显示能力的类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.bean.nav&lt;/h2&gt;
&lt;p&gt;包含了用户界面导航的组件（links,trees,menu elements,quick links,breadcrumbs等）。将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.beans.table&lt;/h2&gt;
&lt;p&gt;包含显示table和HGrid组件的web bean类。将在编写用户界面控制器时编程的方式处理这些web beans。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;
&lt;h2&gt;oracle.apps.fnd.framework.webui.laf&lt;/h2&gt;
&lt;p&gt;包含用于控制HTML渲染特性，包括页面观感和上下文细节（比如，内容能为打印效果而优化显示在浏览器中或用于e-mail）的工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 永远不要在模型代码中调用这些类。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>SOA Suite培训</title><link href="/soa-suitepei-xun.html" rel="alternate"></link><published>2010-07-13T00:00:00+08:00</published><updated>2010-07-13T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-07-13:/soa-suitepei-xun.html</id><summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;配置EBS启用SOA Suite&lt;/li&gt;
&lt;li&gt;Native interface开放为WebService接口&lt;/li&gt;
&lt;li&gt;通过ISG调用外部系统提供的WebService&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;EBS的配置&lt;/h1&gt;
&lt;p&gt;Native Service Enablement Of EBS&lt;/p&gt;
&lt;p&gt;参考Metalink Note:556540.1&lt;/p&gt;
&lt;h1&gt;ISG的设置&lt;/h1&gt;
&lt;h1&gt;Native Interface开放为WebService&lt;/h1&gt;
&lt;h2&gt;开放系统标准接口为WebService&lt;/h2&gt;
&lt;p&gt;通过&amp;ldquo;集成SOA网关&amp;rdquo;这个职责为标准接口授权、生成WSDL、部署或卸载WebService&lt;/p&gt;
&lt;h2&gt;开放自己开发的接口为WebService&lt;/h2&gt;
&lt;p&gt;通过Perl工具程序将自己的接口注册到Repository里&lt;/p&gt;
&lt;h2&gt;外部系统异步调用EBS发布的WebService&lt;/h2&gt;
&lt;h1&gt;ISG调用外部的WebService&lt;/h1&gt;
&lt;p&gt;不支持RPC格式的SOAP消息，只支持Document格式的。&lt;/p&gt;
&lt;h2&gt;Business Event驱动对外部系统WebService的调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Create/Use Invoker Event&lt;/li&gt;
&lt;li&gt;选Workflow Administrator WebApplications职责&lt;/li&gt;
&lt;li&gt;点击&amp;ldquo;Business Events&amp;rdquo;&lt;/li&gt;
&lt;li&gt;点击&amp;ldquo;Create Event&amp;rdquo;&lt;/li&gt;
&lt;li&gt;填写Name，Display Name和Description选择状态为&amp;ldquo;Enabled …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;配置EBS启用SOA Suite&lt;/li&gt;
&lt;li&gt;Native interface开放为WebService接口&lt;/li&gt;
&lt;li&gt;通过ISG调用外部系统提供的WebService&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;EBS的配置&lt;/h1&gt;
&lt;p&gt;Native Service Enablement Of EBS&lt;/p&gt;
&lt;p&gt;参考Metalink Note:556540.1&lt;/p&gt;
&lt;h1&gt;ISG的设置&lt;/h1&gt;
&lt;h1&gt;Native Interface开放为WebService&lt;/h1&gt;
&lt;h2&gt;开放系统标准接口为WebService&lt;/h2&gt;
&lt;p&gt;通过&amp;ldquo;集成SOA网关&amp;rdquo;这个职责为标准接口授权、生成WSDL、部署或卸载WebService&lt;/p&gt;
&lt;h2&gt;开放自己开发的接口为WebService&lt;/h2&gt;
&lt;p&gt;通过Perl工具程序将自己的接口注册到Repository里&lt;/p&gt;
&lt;h2&gt;外部系统异步调用EBS发布的WebService&lt;/h2&gt;
&lt;h1&gt;ISG调用外部的WebService&lt;/h1&gt;
&lt;p&gt;不支持RPC格式的SOAP消息，只支持Document格式的。&lt;/p&gt;
&lt;h2&gt;Business Event驱动对外部系统WebService的调用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Create/Use Invoker Event&lt;/li&gt;
&lt;li&gt;选Workflow Administrator WebApplications职责&lt;/li&gt;
&lt;li&gt;点击&amp;ldquo;Business Events&amp;rdquo;&lt;/li&gt;
&lt;li&gt;点击&amp;ldquo;Create Event&amp;rdquo;&lt;/li&gt;
&lt;li&gt;填写Name，Display Name和Description选择状态为&amp;ldquo;Enabled&amp;rdquo;&lt;/li&gt;
&lt;li&gt;输入Owner Name和Tag（通常都填FND/FND）&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击&amp;ldquo;Apply&amp;rdquo;保存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Native Service Invocation Process&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Search Invoker Business Event.&lt;/li&gt;
&lt;li&gt;Select to view its subscriptions&lt;/li&gt;
&lt;li&gt;Click "Create Subscription"&lt;/li&gt;
&lt;li&gt;Enter local Subscriber System,Phase(&amp;lt;100 for synchronous response).&lt;/li&gt;
&lt;li&gt;Select Rule Data as "Message".&lt;/li&gt;
&lt;li&gt;Select Action Type "Invoke Web Service".&lt;/li&gt;
&lt;li&gt;Click "Next".&lt;/li&gt;
&lt;li&gt;Follow wizard based WSDL parser UI:&lt;/li&gt;
&lt;li&gt;Enter WSDL URL and click "Next".&lt;/li&gt;
&lt;li&gt;Select Service and click "Next".&lt;/li&gt;
&lt;li&gt;Select Service Port and click "Next".&lt;/li&gt;
&lt;li&gt;Select Service Operation and click "Next".&lt;/li&gt;
&lt;li&gt;Use seeded Java Rule Function - oracle.apps.fnd.wf.bes.WebServiceInvokerSubscription or custom extended class.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Optionally enter WS Security parameters:WFBES_SOAP_USERNAME,WEBES_SOAP_PASSWORD_MOD,WEBES_SOAP_PASSWORD_KEY as &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create Receive Event&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;navigate to "Events" tab in Workflow &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自定义的Business Event驱动对外部系统的WebService的调用&lt;/h2&gt;
&lt;h2&gt;直接调用外部的WebService&lt;/h2&gt;
&lt;h2&gt;异步调用外部的WebService&lt;/h2&gt;
&lt;p&gt;由Create Subscription时的Phase决定，大于100时为异步调用&lt;/p&gt;
&lt;h1&gt;问题&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何开放自己开发的接口为WebService&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与其它系统集成时如何解决人员、权限、登录等方面的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有BPEL的情况下（不能通过接口表和多次WebService调用处理）如何处理大数据量的问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过接口表的方式，多次调用方法写入数据到接口表，再调用其它方法进行验证，然后再调用方法提交请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SOAP头的问题，如何在SOAP头设置相关的用户、职责等信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AQ自动触发对外部系统WebService的调用，还是需要轮询AQ&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;异步调用时需要运行工作流background engine 的请求&lt;/p&gt;
&lt;p&gt;测试WebService
http://www.ignyte.com/webservices/ignyte.whatsshowing.webservice/moviefunctions.asmx?wsdl
参数 88052 18&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category></entry><entry><title>会计拉面读书笔记</title><link href="/hui-ji-la-mian-du-shu-bi-ji.html" rel="alternate"></link><published>2010-03-12T00:00:00+08:00</published><updated>2010-03-12T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2010-03-12:/hui-ji-la-mian-du-shu-bi-ji.html</id><summary type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;损益平衡点（Break Even Point）：利润为零或收支相等时的销售额或者销售量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固定费用：每个月保持固定不变的费用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变动费用：随销量变化的费用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;收支相等：利润（收入-变动费用）累计起来，正好抵减固定费用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边际利润：(单价-单位变动费用)*销售数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超过损益平衡点之后，固定费用的包袱就一点都没了，利润于是呈现跳跃式上升的态势（因为超过损益平衡点的销售所产生的边际利润实际上就是利润）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;损益平衡点（Break Even Point）：利润为零或收支相等时的销售额或者销售量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固定费用：每个月保持固定不变的费用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变动费用：随销量变化的费用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;收支相等：利润（收入-变动费用）累计起来，正好抵减固定费用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;边际利润：(单价-单位变动费用)*销售数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超过损益平衡点之后，固定费用的包袱就一点都没了，利润于是呈现跳跃式上升的态势（因为超过损益平衡点的销售所产生的边际利润实际上就是利润）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Emacs Lisp参考手册</title><link href="/emacs-lispcan-kao-shou-ce.html" rel="alternate"></link><published>2009-12-31T00:00:00+08:00</published><updated>2009-12-31T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2009-12-31:/emacs-lispcan-kao-shou-ce.html</id><summary type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;介绍和约定&lt;/p&gt;
&lt;p&gt;这是2.9版的GNU Emacs Lisp参考手册，适应于GNU Emacs 22.1。&lt;/p&gt;
&lt;h2&gt;警告&lt;/h2&gt;
&lt;h2&gt;Lisp历史&lt;/h2&gt;
&lt;h2&gt;习惯约定&lt;/h2&gt;
&lt;p&gt;这节说明了手册中的符号约定。&lt;/p&gt;
&lt;h3 id="yi-xie-zhu-yu"&gt;一些术语&lt;/h3&gt;
&lt;p&gt;整个手册中，词Lisp阅读器（the Lisp reader）&amp;ldquo;和&amp;ldquo;Lisp打印机（the Lisp printer）&amp;rdquo;指那些Lisp例程包括将文本方式描述的Lisp对象转换为真实的Lisp对象，反之亦然。&amp;ldquo;你&amp;rdquo;，指阅读本手册的你，即&amp;ldquo;程序员&amp;rdquo;。&amp;ldquo;用户&amp;rdquo;指使用Lisp程序的人，包括你写的那些程序。&lt;/p&gt;
&lt;p&gt;Lisp代码被格式化为：(list 1 2 3)。函数中不合法的变量或参数将被显示为斜体： &lt;strong&gt;&lt;em&gt;first-number&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id="nilhe-t"&gt;nil和t&lt;/h3&gt;
&lt;p&gt;Lisp中符号nil有三种含义：它是一个名为&amp;lsquo;nil&amp;lsquo;的符号；它是逻辑值false；它是空的list&amp;mdash;&amp;mdash;有零个元素的list。当作为变量时 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;介绍&lt;/h1&gt;
&lt;p&gt;介绍和约定&lt;/p&gt;
&lt;p&gt;这是2.9版的GNU Emacs Lisp参考手册，适应于GNU Emacs 22.1。&lt;/p&gt;
&lt;h2&gt;警告&lt;/h2&gt;
&lt;h2&gt;Lisp历史&lt;/h2&gt;
&lt;h2&gt;习惯约定&lt;/h2&gt;
&lt;p&gt;这节说明了手册中的符号约定。&lt;/p&gt;
&lt;h3 id="yi-xie-zhu-yu"&gt;一些术语&lt;/h3&gt;
&lt;p&gt;整个手册中，词Lisp阅读器（the Lisp reader）&amp;ldquo;和&amp;ldquo;Lisp打印机（the Lisp printer）&amp;rdquo;指那些Lisp例程包括将文本方式描述的Lisp对象转换为真实的Lisp对象，反之亦然。&amp;ldquo;你&amp;rdquo;，指阅读本手册的你，即&amp;ldquo;程序员&amp;rdquo;。&amp;ldquo;用户&amp;rdquo;指使用Lisp程序的人，包括你写的那些程序。&lt;/p&gt;
&lt;p&gt;Lisp代码被格式化为：(list 1 2 3)。函数中不合法的变量或参数将被显示为斜体： &lt;strong&gt;&lt;em&gt;first-number&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id="nilhe-t"&gt;nil和t&lt;/h3&gt;
&lt;p&gt;Lisp中符号nil有三种含义：它是一个名为&amp;lsquo;nil&amp;lsquo;的符号；它是逻辑值false；它是空的list&amp;mdash;&amp;mdash;有零个元素的list。当作为变量时，nil一直表示nil值。&lt;/p&gt;
&lt;p&gt;对于Lisp阅读器来说&amp;lsquo;()&amp;rsquo;和&amp;lsquo;nil&amp;rsquo;是同等的：他们代表相同的对象，符号nil。这个符号的两种不同的写法只是对于用户阅读不同。对于Lisp阅读器来说读取&amp;lsquo;()&amp;rsquo;或&amp;lsquo;nil&amp;rsquo;之后是无法知道程序员编写的代码时的实际写法。&lt;/p&gt;
&lt;p&gt;在本手册中，当我们要强调是空的list时我们写作()，当写为nil时表示我们要强调它表示 &lt;strong&gt;false&lt;/strong&gt;。这也是Lisp程序中一个很好的约定。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;con&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;                   &lt;span class="c1"&gt;; 强调为空的list&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;foo-flag&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;             &lt;span class="c1"&gt;; 强调为false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在希望得到true时，任何非nil值都将被作为 &lt;strong&gt;true&lt;/strong&gt;。但是，用t是表示true的首选方式。当你需要用一个值描述true时，在没有其它较好选择时就使用t。符号t的值总是t。&lt;/p&gt;
&lt;p&gt;在Emacs Lisp中，nil和t是特殊的符号，它们的值总是他们自己。这也是为什么在程序中你不需要使用引号把它们作为常量的原因。试图改变他们的值时将导致setting-constant错误。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;booleanp&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果object是两个布尔值（t或nil）中的一个则返回非nil值。&lt;/p&gt;
&lt;h3 id="qiu-zhi-de-biao-shi-fang-fa"&gt;求值的表示方法&lt;/h3&gt;
&lt;p&gt;可求值的Lisp表达式被称为form。对一个form求值总会生成一个结果，它是一个lisp对象。本手册中的例子中，使用&amp;lsquo;=&amp;gt;&amp;rsquo;标识求值的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以把这读作&amp;ldquo;(car '(1 2))的值为1。&amp;rdquo;&lt;/p&gt;
&lt;p&gt;当form是一个宏调用时，它将被展开为一个新的form被Lisp求值。我们使用&amp;lsquo;==&amp;gt;&amp;rsquo;标识展开的结果。我们将有可能不显示展开的form的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;third&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="nv"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;==&amp;gt; (car (cdr (cdr '(a b c))))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有时为了帮助描述一个form与另一个form产生同样的值。将使用等价符号。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-sparse-keymap&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;==&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="ss"&gt;'keymap&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="da-yin-de-biao-shi-fang-fa"&gt;打印的表示方法&lt;/h3&gt;
&lt;p&gt;本手册中的许多例子在被求值时将打印文本。如果你在Lisp交互缓冲区（比如&amp;lsquo;&lt;em&gt;scratch&lt;/em&gt;&amp;rsquo;）中执行示例，打印的文本被插入到缓冲区中。如果你通过其它方法执行例子（比如使用函数eval-region求值），打印的文本将显示在回显区（echo area）。&lt;/p&gt;
&lt;p&gt;本手册中的例子使用&amp;lsquo;-|&amp;lsquo;标识打印的文本，而不关心文本被输出到哪里。对form求值的结果显示在单独的一行上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;prinl&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;princ&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;prinl&lt;/span&gt; &lt;span class="ss"&gt;'bar&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;-| foo&lt;/span&gt;
     &lt;span class="c1"&gt;;-| bar&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="cuo-wu-xin-xi"&gt;错误信息&lt;/h3&gt;
&lt;p&gt;有些例子将产生错误。通常错误信息显示在回显区域。我们将错误信息显示在以&amp;lsquo;error--&amp;gt;&amp;rsquo;开头的行上。注意&amp;lsquo;error--&amp;gt;&amp;rsquo;自身并不会显示在回显区。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(+ 23 'x)
error--&amp;gt; Wrong type argument: number-or-marker-p, x
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="huan-chong-qu-wen-ben-fu-zhu"&gt;缓冲区文本附注&lt;/h3&gt;
&lt;p&gt;有些例子可能会修改缓冲区的内容，本手册将使用&amp;ldquo;before&amp;rdquo;和&amp;ldquo;after&amp;rdquo;标识文本的版本。这些例子将缓冲区的内容显示在包含缓冲区名称的短划线之间。另外，将使用&amp;lsquo;-|-&amp;rsquo;标识point的位置。（这个符号当然也不是缓冲区中文本的一部分；它标明当前point的位置。）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     ---------- Buffer: foo ----------
     This is the -!-contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          =&amp;gt; nil
     ---------- Buffer: foo ----------
     This is the changed -!-contents of foo.
     ---------- Buffer: foo ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="miao-shu-de-ge-shi"&gt;描述的格式&lt;/h3&gt;
&lt;p&gt;函数、变量、宏、命令、用户属性和特殊的form的描述在手册中都有统一的格式。描述的第一行包括项的名称和它的参数（如果有）。项类型可以是函数，变量或其它内容&amp;mdash;&amp;mdash;显示在行的开头位置。项的描述显示在余下的行中，有时带有示例。&lt;/p&gt;
&lt;h4 id="yi-ge-jian-dan-de-han-shu-de-miao-shu"&gt;一个简单的函数的描述&lt;/h4&gt;
&lt;p&gt;在函数描述中，函数名称最先显示。在同一行上跟着参数名的列表。这些名称将用于在描述体中使用，代表参数的值。&lt;/p&gt;
&lt;p&gt;参数列表中的关键字&amp;amp;optional标明subsequent参数可以被忽略（被忽略的参数默认为nil）。在调用函数时不要写&amp;amp;optional。&lt;/p&gt;
&lt;p&gt;关键字&amp;amp;rest（它必须出现在单个变量的后面）标明后面可以带任意数量的参数。单一参数名后的&amp;amp;rest将被接收，它的值将作为其它参数传递给函数。在调用函数时不要写&amp;amp;rest。&lt;/p&gt;
&lt;p&gt;下面是一个虚拟的函数foo的描述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;foo&lt;/code&gt; integer1 &amp;amp;optional integer2 &amp;amp;rest integers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数foo将从integer2中减integer1，然后加上其它参数。如果integer2不存在，则将使用19作为默认值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 16&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 14&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更通俗的表达方式，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(foo w x y...)
==
(+ (- x w) y...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;任何参数名包含类型描述（例如，integer，integer1或buffer）表示它需要那种类型的值。复数形式（比如buffers）通常表示包含那一类型的list对象。参数名为object表示可以为任何类型。参数名有其它名称的（比如，new-file）将在函数的描述中论述。在有些情况下，多个具有类似功能的函数的通用参数将在开始的位置进行描述。&lt;/p&gt;
&lt;p&gt;参见Lambda表达式，详细了解optional和rest参数。&lt;/p&gt;
&lt;p&gt;命令，宏和特殊form的描述具有相同的格式，只是将&amp;lsquo;Function&amp;rsquo;分别替换为&amp;rsquo;Command&amp;lsquo;，&amp;lsquo;Macro&amp;rsquo;或&amp;lsquo;Special Form&amp;rsquo;。命令与函数相比只是可以交互式的被调用；宏处理参数的方式与函数不同（参数不会被求值），但可以以相同的方式描述。&lt;/p&gt;
&lt;p&gt;特殊form的描述使用了更复杂的标记方法来指定optional和repeated参数，因为它们可以以更复杂的方式将参数列表分解为独立的参数。&amp;lsquo;[optional-arg]&amp;lsquo;表示optional-arg是可选的，&amp;lsquo;repeated-args...&amp;rsquo;表示零个或多个参数。圆括号用于将多个参数分组到辅助的list结构。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Special Form: &lt;strong&gt;count-loop&lt;/strong&gt; (var [from to [inc]]) body...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个虚拟的特殊form实现了循环执行body form然后在每次迭代时将变量var自增。在第一次迭代时，变量的值为from的值；在后面的迭代中，它每次加1（或增加由inc指定的值）。如果var等于to则这个循环在执行body之前退出。下面是使用它的一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;printl&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;princ&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;ptinl&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;aref&lt;/span&gt; &lt;span class="nf"&gt;vector&lt;/span&gt; &lt;span class="nv"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;terpri&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果from和to被忽略，var将在循环开始时被设置为nil，如果在迭代开始时var是非nil值则循环退出。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-loop&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;done&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pending&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fixit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;done&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个特殊的form中，参数from和to是可选的，但必须同时存在或不存在。如果都存在，inc是可选的。这些变量被参数var分组到一个list中，为了将他们区别于body，它将包括form中的其它元素。&lt;/p&gt;
&lt;h4 id="yi-ge-jian-dan-de-bian-liang-de-miao-shu"&gt;一个简单的变量的描述&lt;/h4&gt;
&lt;p&gt;变量是可以保存值的对象的名字。尽管几乎所有变量都可以被用户设置，某些变量将明确用户可以修改它们；它们被称为用户选项（user options）。变通变量和用户选项的描述格式与函数是相同的只是它们没有参数。&lt;/p&gt;
&lt;p&gt;下面是一个虚拟的变量electric-future-map。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;electric-future-map&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;变量的值是用于Electric Command Future mode的keymap。这个map中的函数允许你编辑还没有想过执行的命令。&lt;/p&gt;
&lt;p&gt;用户选项的描述具有相同的格式，只是将&amp;lsquo;Variable&amp;lsquo;替换为&amp;rsquo;User Option&amp;lsquo;。&lt;/p&gt;
&lt;h2&gt;版本信息&lt;/h2&gt;
&lt;p&gt;下面的设施提供了当前使用的Emacs的版本信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command: &lt;code&gt;emacs-version&lt;/code&gt; &amp;amp;optional here&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数返回一个字符串描述当前运行的Emacs的版本信息。报告bug时将它包含进去非常有用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;emacs-version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="c1"&gt;;=&amp;gt; "GNU Emacs 20.3.5 (i486-pc-linux-gnulibc1, X toolkit) of Sat Feb 14 1998 on psilocin.gnu.org"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果here是非nil值，它将在缓冲区的point的前面插入文本，并返回nil。交互式调用时，函数将在回显区显示相同的信息，但需要通过前缀参数使用here为非nil值（译注：M-2 M-x emacs-version）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;emacs-build-time&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值标明Emacs是在当前站点何时构建的。它是一个包含三个整数的list，类似current-time的值（参见Time of Day）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;emacs-build-time&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (13623 62065 344633)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;emacs-version&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值是当前运行的Emacs的版本。它是一个类似&amp;ldquo;20.3.1&amp;rdquo;的字符串。字符串的最后一个数字并不真是Emacs release 版本的版本号的一部分；它将在你每次构建时自动加一。由四个数字组成的类似&amp;ldquo;20.3.9.1&amp;rdquo;的值，表明是一个unrelease的test版本。&lt;/p&gt;
&lt;p&gt;下面两个变量从Emacs 19.23版开始存在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;emacs-major-version&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Emacs的主版本号，是一个整数。对于Emacs 20.3，它的值为20。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;emacs-minor-version&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Emacs的次版本号，是一个整数。对于Emacs 20.3，它的值为3。&lt;/p&gt;
&lt;h2&gt;感谢&lt;/h2&gt;
&lt;h1&gt;Lisp数据类型&lt;/h1&gt;
&lt;p&gt;一个Lisp对象（object）是一块数据可以被Lisp程序使用和操作。对于我们来说，类型或者说数据类型是一组可能的对象。&lt;/p&gt;
&lt;p&gt;每个对象至少属于一个类型。相同的对象有类似的结构通常可以在相同的上下文使用。类型可以被覆盖，对象可以属于两个或更多类型。因此，我们可以询问某个对象是否属于某个特殊类型，但不是&amp;rdquo;那个&amp;ldquo;个类型的一个对象。&lt;/p&gt;
&lt;p&gt;一些基本对象类型是Emacs内置的。其它所有类型都是由这些类型构建起来的，这些基本对象类型被称为原生类型（primitive types）。每个对象有且只能属于一个原生类型。这些类型包括integer、float、cons、symbol、string、vector、hash-table、subr和byte-code函数，加上一些特殊类型，比如buffer，它与编辑相关。（参见Editing Types。）&lt;/p&gt;
&lt;p&gt;每个原生类型有相应的Lisp函数用于检查某个对象是否是那种类型的成员。&lt;/p&gt;
&lt;p&gt;注意Lisp不像其它语言，在Lisp中对象是类型是自描述的（self-typing）：原生类型的对象的对象类型被隐式包含在对象自身中。比如，如果对象是一个vector，则不能将它作为一个数字；Lisp知道它是一个vector而不是数字。&lt;/p&gt;
&lt;p&gt;在多数语言中，程序员必须申明每个变量的类型，编译器知道变量的类型但不会描述在数据自身中。这样的对象申明不存在于Emacs Lisp中。Lisp变量可以有任何类型的值，它记得你存储于它里面的任何值，类型和其它所有信息。（实际上，少数Emacs Lisp变量只能用于保存某些类型的值。参考Variables with Restricted Values。）&lt;/p&gt;
&lt;p&gt;在这章的目的是描述GNU Emacs Lisp中每个标准类型的打印表示方法和读取格式。使用这些类型的细节可以在后续章节找到。&lt;/p&gt;
&lt;h2&gt;打印表示方法和读取语法&lt;/h2&gt;
&lt;p&gt;对象的打印表示方法（printed representation）指由Lisp打印机（prinl函数）产生的那个对象的输出。每个数据类型有唯一的打印表示方法。对象的读取语法（read syntax）指可以被Lisp阅读器（read函数）读取的对象格式。这不需要是唯一的；很多对象类型可以有一个或多个语法。参考Read和Print。&lt;/p&gt;
&lt;p&gt;在多数情况下，一个对象的打印表示方法也是这个对象的读取语法。然而，某些类型没有读取语法，因为在Lisp程序中输入这些类型的对象作为常量没有意义。这些对象被打印为hash notation，由字符&amp;lsquo;#&amp;lt;&amp;rsquo;，一个描述字符串（通常是类型的名称跟在对象名称后面），和&amp;lsquo;&amp;gt;&amp;rsquo;组成。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;current-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;buffer objects.texi&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hash notation根本不能被读取，因此Lisp阅读器将在它遇到&amp;lsquo;#&amp;lt;&amp;rsquo;时报错invalid-read-syntax。在其它语言中，一个表达式是文本；它没有其它form。在Lisp中，一个表达式首先是一个Lisp对象第二才可被读取的文本格式的对象。通常这不需要强调他们的区别，但你必须在大脑中保持清析的概念，否则有时会非常迷惑。&lt;/p&gt;
&lt;p&gt;当你交互式的执行表达式时，Lisp解释器首先读取它的文本化描述，生成Lisp对象，然后对那个对象求值（参考Evaluation）。但，求值和读取是分开的活动。读取将返回读取的文本描述的Lisp对象；这个对象可能会被求值也可能不会。参考Input Functions，获取read的描述和读取对象的基本函数。&lt;/p&gt;
&lt;h2&gt;注释&lt;/h2&gt;
&lt;p&gt;注释写在程序中是为了让人们能读懂程序，对于程序本身没有作用。在Lisp中，不存在于字符串或字符常量中的分号（&amp;lsquo;;&amp;rsquo;）标明注释的开始。注释直到行尾结束。Lisp阅读器忽略注释；他们不会变成Lisp系统中的Lisp对象。&lt;/p&gt;
&lt;p&gt;&amp;lsquo;#@count&amp;lsquo;结构，用于忽略下面的count个字符，它对于程序生成的包含二进制数据的注释非常有用。&lt;/p&gt;
&lt;p&gt;参考Comment Tips，了解注释的格式约定。&lt;/p&gt;
&lt;h2&gt;编程类型&lt;/h2&gt;
&lt;p&gt;在Emacs Lisp中只有两类通用类型：与Lisp编程有关，另一些与编辑有关。前者存在于很多Lisp实现中。后者是Emacs Lisp特有的。&lt;/p&gt;
&lt;h3 id="zheng-xing_1"&gt;整型&lt;/h3&gt;
&lt;p&gt;Emacs Lisp整型值在多数机器上的范围为-268435456至268435455（29位；例如，-2&lt;strong&gt;28至2&lt;/strong&gt;28-1）。（某些机器可以提供更大的范围。）记得Emacs Lisp数学函数不检查溢出是很重要的。因此在多数机器上(1+ 268435455)为-268435456。&lt;/p&gt;
&lt;p&gt;整型的读取表达式为一串十进制的数字可带正负号和后面的小数点。由Lisp解释器打印出来的打印格式不会包含前面的&amp;lsquo;+&amp;rsquo;或最后的&amp;lsquo;.&amp;lsquo;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;                              &lt;span class="c1"&gt;; 整数-1。&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;                               &lt;span class="c1"&gt;; 整数1。&lt;/span&gt;
&lt;span class="mi"&gt;1.&lt;/span&gt;                              &lt;span class="c1"&gt;; 也是整数1。&lt;/span&gt;
&lt;span class="mi"&gt;+1&lt;/span&gt;                              &lt;span class="c1"&gt;; 也是整数1。&lt;/span&gt;
&lt;span class="mi"&gt;536870913&lt;/span&gt;                       &lt;span class="c1"&gt;; 在29-bit的实现上也是整数1。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考Numbers，获取更多信息。&lt;/p&gt;
&lt;h3 id="fu-dian-lei-xing"&gt;浮点类型&lt;/h3&gt;
&lt;p&gt;浮点数相当于计算机科学计数法；你可以把浮点数当作十进制分数的集合。浮点数的精度与具体的机器有关；Emacs使用C的双精度类型存储浮点值，在内部它被表示为二进制而不是十进制。&lt;/p&gt;
&lt;p&gt;浮点数的打印表示法可以是十进制小数，或指数形式，或两者都用。例如：&amp;lsquo;1500.0&amp;rsquo;，&amp;lsquo;15e2&amp;rsquo;，&amp;lsquo;25.0e2&amp;rsquo;，&amp;lsquo;1.5e3&amp;rsquo;，&amp;lsquo;.15e4&amp;rsquo;五种方法都表示值为1500的浮点数。这些表示法都是等价的。&lt;/p&gt;
&lt;p&gt;参考Numbers，获取更多信息。&lt;/p&gt;
&lt;h3 id="zi-fu-lei-xing"&gt;字符类型&lt;/h3&gt;
&lt;p&gt;Emacs Lisp中的字符不过是整型。换言之，字符是使用他们的代码来描述的。比如字符A被描述为整数65。&lt;/p&gt;
&lt;p&gt;单独的字符偶尔会用于程序中，但更常见的情况是与字符串一起工作，字符串是由有序的字符组成的。参见String Type。&lt;/p&gt;
&lt;p&gt;字符串，缓冲区和文件中了字符被限制在0至52487-19的范围。但不是所有在这个范围的字符都是有效的字符编码。0至127为ASCII码；其它的为非ASCII字符（参考Non-ASCII Characters）。用于描述键盘输入的字符范围更宽，以编码Control，Meta和Shift等修饰符。&lt;/p&gt;
&lt;p&gt;有一些特殊的函数可以生成字符的可阅读的文本化的描述。见Describing Characters。&lt;/p&gt;
&lt;h3 id="fu-hao-lei-xing"&gt;符号类型&lt;/h3&gt;
&lt;p&gt;GNU Emacs Lisp中的符号（symbol）是一个有名称的对象。符号名被作为符号的打印表示方法。经常用于Lisp中，（参见Creating symbols），符号的名称是唯一的－没有两个符号具有相同的名称。&lt;/p&gt;
&lt;p&gt;符号可以作为变量或函数名，或用于保存属性列表（property list）。或它只是作为区别于其它Ｌisp对象的标识，以便于它在一个数据结构中能被可靠的识别。在一个具体的上下文中，通常只有一种类型（符号作为变量名、函数名、属性列表、区别于其它对象的标识）有意义。但是可以将符号独立的用作所有的用途。&lt;/p&gt;
&lt;p&gt;符号名称以冒号（&amp;lsquo;:&amp;rsquo;）开头称为键盘符号（keyword symbol）。这些符号自动地作为常量，通常只被用于与未知的符号比较具有少量特殊的选择。&lt;/p&gt;
&lt;p&gt;符号名可以包括任何字符。多数符号由字母，数字和标点符号&amp;lsquo;-+=*/&amp;rsquo;组成。名称不需要特殊的标点符号；组成名称的字符应该足够长以使它看起来不像是一个数字。（如果不是这样，则要在开如的位置添加&amp;lsquo;\&amp;rsquo;强制解释器将它作为符号。）&amp;lsquo;_~!@$%^&amp;amp;:&amp;lt;&amp;gt;{}?&amp;rsquo;这些字符很少使用但是并不需要的标点符号。其它字符可以通过使用反斜线转义字符将其包含在符号名称中。对比用于字符串中，符号中的反斜线只会简单的引用后面的单个字符。比如，在字符串中&amp;rsquo;\t&amp;lsquo;表示一个tab字符；在符号中，&amp;rsquo;\t&amp;lsquo;只是表示字母&amp;rsquo;t&amp;lsquo;。要在符号名称中使用tab字符，必须真正的使用tab（以反斜线为前缀）。但这对于字符串是非常少见的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Common Lisp注意：&lt;/strong&gt; 在Common Lisp中，小写字母总是被&amp;ldquo;folded&amp;rdquo;为大写字母，除非显式的转义。在Emacs Lisp中，字母大小写字母是敏感的。&lt;/p&gt;
&lt;p&gt;下面是一些符号名称的例子。注意第五个例子中的&amp;lsquo;+&amp;rsquo;例子使用转义字符防止它被作为数字。这在第四个例子中是不需要的，因为其它部分使它不成为一个有效的数字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt;                             &lt;span class="c1"&gt;; 符号名称为&amp;rsquo;foo&amp;lsquo;&lt;/span&gt;
&lt;span class="nv"&gt;FOO&lt;/span&gt;                             &lt;span class="c1"&gt;; 符号名称为&amp;rsquo;FOO&amp;lsquo;，与&amp;rsquo;foo&amp;lsquo;不同&lt;/span&gt;
&lt;span class="nf"&gt;char-to-string&lt;/span&gt;                  &lt;span class="c1"&gt;; 符号名称为&amp;lsquo;char-to-string&amp;rsquo;&lt;/span&gt;
&lt;span class="nf"&gt;1+&lt;/span&gt;                              &lt;span class="c1"&gt;; 符号名称为&amp;rsquo;1+&amp;lsquo;&lt;/span&gt;
                                &lt;span class="c1"&gt;; （不是&amp;rsquo;+1&amp;lsquo;，那是一个整数）&lt;/span&gt;
&lt;span class="nv"&gt;\+1&lt;/span&gt;                             &lt;span class="c1"&gt;; 符号名称为&amp;rsquo;+1&amp;lsquo;&lt;/span&gt;
&lt;span class="nv"&gt;\(*\1\2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                        &lt;span class="c1"&gt;; 符号名称为&amp;rsquo;(*12)&amp;rsquo;（一个更差的名称）&lt;/span&gt;

&lt;span class="nv"&gt;+-*/_~!@$%^&amp;amp;=:&amp;lt;&amp;gt;{}&lt;/span&gt;              &lt;span class="c1"&gt;; 符号名称为&amp;lsquo;+-*/_~!@$%^&amp;amp;=:&amp;lt;&amp;gt;{}&amp;rsquo;&lt;/span&gt;
                                &lt;span class="c1"&gt;; 这些字符不需要转义&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常Lisp阅读器保留所有符号（参见Creating Symbols）。为防止被保留，你可以在符号名前面添加&amp;lsquo;#:&amp;rsquo;。&lt;/p&gt;
&lt;h3 id="xu-lie-lei-xing"&gt;序列类型&lt;/h3&gt;
&lt;p&gt;序列（sequence）是一个Lisp对象用于描述有序的元素集合。在Emacs Lisp中有两种类型的序列，list和array。因此，list或array类型的对象也被作为序列。&lt;/p&gt;
&lt;p&gt;数组可以再细分为string，vector，char-table和bool-vector。Vector可以保存任何类型的元素，但是string中的元素必须是字符，Bool-vector元素必须是t或nil。Char-table与vector类似除了他们可以被任何有效字符代码索引。String中的字符与buffer的字符类似可以有文本属性（text properties）（参见Text Properties），但vector不支持text properties，即使当它的元素是字符时也不支持。&lt;/p&gt;
&lt;p&gt;List，string和其它数组类型也不同，但他们有重要的相似点。比如，都有长度l，都有可以从０到l索引访问的元素。一些函数被称为sequence函数，可以接收任何类型的sequence。比如，可以向函数elt传递索引值从sequence中获得元素（译注：类似从数组中获取元素，索引类似于下标）。参见Sequences Arrays Vectors。&lt;/p&gt;
&lt;p&gt;通常不能对同一个sequence读取两次，因为序列都是建立后，重新读取。如果你用读取sequence的语法读取两次，将会获得两个内容相同的sequence。有一个例外的就是空list()，它总是表示nil对象。&lt;/p&gt;
&lt;h3 id="cons-cellhe-listlei-xing"&gt;Cons Cell和List类型&lt;/h3&gt;
&lt;p&gt;cons cell是一个对象由两个slot组成，称为CAR slot和CDR slot。每个slot可以保存或指向任何Lisp 对象。我们也可以说&amp;ldquo;cons cell的CAR是&amp;rdquo;whatever object its car slot currently holds, and likewise for the cdr.&lt;/p&gt;
&lt;p&gt;C程序员要注意：　在Lisp中，对于&amp;ldquo;holding&amp;rdquo;一个值和&amp;ldquo;pointing to&amp;rdquo;一个值是不区分的，因为Lisp中的指针是隐式使用的。&lt;/p&gt;
&lt;p&gt;list是一连串的cons cells，每个cons cell的CDR slot保存下一个cons cell或为空的list。空的list实际上是符号nil。参见Lists，了解工作于list的函数。因为多数cons cells被用于list的一部分，术语list结构（list structure）指向任何由con cells构成的结构。&lt;/p&gt;
&lt;p&gt;Cons cells对于Lisp是如此重要，因此们也需要了解&amp;ldquo;不是cons cell的对象&amp;rdquo;。这些对象被称为原子（atoms）。&lt;/p&gt;
&lt;p&gt;list的读取语法和打印描述方法是相同的，由左括，任意数量的元素和右括号组成。下面是list的一些例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="s"&gt;"A"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                       &lt;span class="c1"&gt;; 有三个元素的list&lt;/span&gt;
&lt;span class="p"&gt;()&lt;/span&gt;                              &lt;span class="c1"&gt;; 没有元素的list（空list）&lt;/span&gt;
&lt;span class="no"&gt;nil&lt;/span&gt;                             &lt;span class="c1"&gt;; 没有元素的list（空list）&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"A ()"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                        &lt;span class="c1"&gt;; 有一个元素的list，字符串"A()"&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;                          &lt;span class="c1"&gt;; list有两个元素：A和一个空的list&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                         &lt;span class="c1"&gt;; 等同于前一个例子&lt;/span&gt;
&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="nv"&gt;B&lt;/span&gt; &lt;span class="nv"&gt;C&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;                       &lt;span class="c1"&gt;; 有一个元素的list&lt;/span&gt;
                                &lt;span class="c1"&gt;; （它是一个包含三个元素的list）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;括号内的每个对象都会变成list中的一个元素。每个元素被构造为一个cons cell。cons cell的CAR slot保存元素本身，CDR slot保存list中下一个cons cell，它保存了list中的下一个元素。最后一个cons cell的CDR slot被设置为nil。&lt;/p&gt;
&lt;p&gt;CAR和CDR这两个名称源自于Lisp的历史。原始的Lisp实现运行在IBM 704计算机上它将words（译注：从下文看寄存器）分为两个部分，称为&amp;ldquo;address&amp;rdquo;部分和&amp;ldquo;decrement&amp;rdquo;部分；CAR指令是用于获取寄存器address部分的内容，CDR指令用于获取decrement的内容。对比来看， &amp;ldquo;cons cells&amp;rdquo;的命名来自于创建他们的函数cons，函数的命名来自于它的目的，即cells的构造器（construction）。&lt;/p&gt;
&lt;h4 id="listde-he-zhuang-tu"&gt;List的盒状图&lt;/h4&gt;
&lt;p&gt;list可以使用盒状图描绘，在盒状图中cons cells被显示为成对的盒，像多米诺骨牌。（Lisp阅读器不能读取这种图表；它与文本化的表示方法不同，文本化的方法即可以被人读懂也可以被机器阅读，盒状图只能被人类理解。）这张图描绘了有三个元素的list(rose violet buttercup)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; |   |   |--&amp;gt; nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --&amp;gt; rose     --&amp;gt; violet   --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这张图中，每个盒表示一个可以保存或指向任何Lisp对象的slot。每对盒子表示表示一个cons cell。每个箭头表示引用一个Lisp对象，可以是atom或其它cons cell。&lt;/p&gt;
&lt;p&gt;在这个例子中，第一个盒子，保存第一个cons cell的CAR部分，指向（refers to）或保存（holds）rose（一个符号）。第二个盒子，保存第一个cons cell的CDR部分，指向下一对盒子，即第二个cons cell。第二个cons cell的CAR是violet，它的CDR是第三个cons cell。第三个cons cell（最后一个）的CDR为nil。&lt;/p&gt;
&lt;p&gt;下面是同一个list的另一个图表，(rose violet buttercup)，在某种意义是另一个补充：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o--------&amp;gt;| violet |   o--------&amp;gt;| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没有元素的list是空list（empty list）；它等同于符号nil。换言之，nil既是符号也是一个list。&lt;/p&gt;
&lt;p&gt;下面是list (A ())，等同于(A nil)，描述成盒状图如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; nil
         --- ---      --- ---
          |            |
          |            |
           --&amp;gt; A        --&amp;gt; nil
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是一个更复杂的图例，展示了三个元素的list，((pine needles) oak maple)，第一个元素是一个有两个元素的list：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; |   |   |--&amp;gt; nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --&amp;gt; oak      --&amp;gt; maple
          |
          |     --- ---      --- ---
           --&amp;gt; |   |   |--&amp;gt; |   |   |--&amp;gt; nil
                --- ---      --- ---
                 |            |
                 |            |
                  --&amp;gt; pine     --&amp;gt; needles
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示成第二种盒状图如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   o   |   o-------&amp;gt;| oak   |   o-------&amp;gt;| maple |  nil |
     |   |   |      |     |       |      |     |       |      |
      -- | ---------       --------------       --------------
         |
         |
         |        --------------       ----------------
         |       | car   | cdr  |     | car     | cdr  |
          ------&amp;gt;| pine  |   o-------&amp;gt;| needles |  nil |
                 |       |      |     |         |      |
                  --------------       ----------------
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="dian-dui-biao-ji-fa-dotted-pair-notation"&gt;点对标记法（Dotted Pair Notation）&lt;/h4&gt;
&lt;p&gt;Dotted pair表示法是cons cells的一般语法，用于显式的描述CAR和CDR。在这种语法中，(a . b)表示cons cell的CAR是对象a它的CDR是对象b。Dotted pair表示法比list表示法更通用因为CDR可以不必要是list。但，如果list语法能工作的时候，这种方式更加笨重。在Dotted pair表示法中，list&amp;lsquo;(1 2 3)&amp;rsquo;可以被写作&amp;lsquo;(1 . (2 . (3 . nil)))&amp;rsquo;。对于以nil结尾的list，你可以任意的使用这两种表示方法，但list表式方法更加清析和方便。当打印list时，dotted paire表示法只用于cons cell的CDR不是list时。&lt;/p&gt;
&lt;p&gt;下面使用盒状图描述了dotted pair表示法。这个例子展示了(rose . violet)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---
        |   |   |--&amp;gt; violet
         --- ---
          |
          |
           --&amp;gt; rose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以组合使用dotted pair表达方式和list表达方式，以便于链接以非nil结束的CDR。你可以在list的最后一个元素后写一个点，后面跟最后的cons cell的CDR。例如，(rose violet . buttercup)等同于(rose . (violet . buttercup))。这个对象看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; buttercup
         --- ---      --- ---
          |            |
          |            |
           --&amp;gt; rose     --&amp;gt; violet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表达式(rose . violet . buttercup)是无效的因为它不能表达任何东西。它将buttercup放到cons cell的CDR而它的CDR已经用于violet了。&lt;/p&gt;
&lt;p&gt;list (rose violet)等同于(rose . (violet))，看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; nil
         --- ---      --- ---
          |            |
          |            |
           --&amp;gt; rose     --&amp;gt; violet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似地，包含三个元素的list(rose violet buttercup)等同于(rose . (violet . (buttercup)))。它的结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         --- ---      --- ---      --- ---
        |   |   |--&amp;gt; |   |   |--&amp;gt; |   |   |--&amp;gt; nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --&amp;gt; rose     --&amp;gt; violet   --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="guan-lian-listlei-xing-association-list-type"&gt;关联list类型（Association List Type）&lt;/h4&gt;
&lt;p&gt;association list或alist是一种特殊结构的list它的元素是cons cells。每个元素中，CAR被作为key，CDR作为关联的值（associated value）。（某些情况下，关联值被存在CDR的CAR中）Association list通常用作栈，因为它很容易从list的前面添加或移除关联对象。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;alist-of-colors&lt;/span&gt;
           &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;rose&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;red&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lily&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;white&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buttercup&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nv"&gt;yellow&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将变量alist-of-colors设置了包含三个元素的alist。在第一个元素中，rose是key，red是值。&lt;/p&gt;
&lt;p&gt;参见Association Lists，了解更多关于alist及作用于alist的函数。参见Hash Tables，了解另一种lookup table，它在处理大量keys的时候更加快。&lt;/p&gt;
&lt;h3 id="shu-zu-lei-xing-array-type_1"&gt;数组类型（Array Type）&lt;/h3&gt;
&lt;p&gt;array由任意数量的slots以保存或引用其它Lisp对象，存储在一块连续的内存中。访问数组中的任何元素所花的时间大致是相同的。相反，访问list中的一个元素所花的时间与他们存储在list中的位置成比例。（访问list结束位置的元素所花的时间比访问list开始位置的元素所花的时间更长。）&lt;/p&gt;
&lt;p&gt;Emacs定义了四种类型的array：strings，vectors，bool-vectors和char-tables。&lt;/p&gt;
&lt;p&gt;string是一个字符的数组，vector是任意类型对象的数组。bool-vector只可以保存t或nil。这些类型的数组的长度可以达到整型的最大值。Char-tables是稀疏的数组可以使用任意有效的字符代码作为索引；他可以保存任意的对象。&lt;/p&gt;
&lt;p&gt;数组的第一个元素的索引为0，第二个元素索引为1，以些类推。这称为zero-origin索引。例如，数组有四个元素则有索引0，1，2和3。最大可能的索引值比数组长度小1。一旦数组被创建，它的长度就是固定的。&lt;/p&gt;
&lt;p&gt;所有Emacs Lisp数组都是一维的。（多数其它语言支持多维数组，但他们并不是必需的；可以通过嵌套的一维数组来达到相同的效果。）每种类型的数组有其自己的读取语法；参见下面的章节了解细节。&lt;/p&gt;
&lt;p&gt;数组类型是sequence类型的子类型，包括string，vector，bool-vector和char-table类型。&lt;/p&gt;
&lt;h3 id="zi-fu-chuan-lei-xing"&gt;字符串类型&lt;/h3&gt;
&lt;p&gt;string是字符的数组。在Emacs中字符串有很多用途，例如，作为Lisp符号名，作为显示给用户的信息，作为从缓冲区中提取的文本。Lisp中的字符串是不可变的：对字符串求值返回相同的字符串。&lt;/p&gt;
&lt;p&gt;参见Strings and Characters，了解操作字符串的函数。&lt;/p&gt;
&lt;h4 id="zi-fu-chuan-yu-fa"&gt;字符串语法&lt;/h4&gt;
&lt;p&gt;字符串的读取语法是双引号，任意数量的字符，另一个双引号，例如"like this"。为了在字符串中包含双引号，可以在双引号前添加反斜线；因而，"\""是一个字符串包含了单个双引号字符。同样，也可以使用两个双斜线表示斜线符号，如"this \ is a single embedded backslash"。&lt;/p&gt;
&lt;p&gt;换行符不是字符串的特殊读取语法；如果你需要在双引号间添加换行符，它将变成字符串中的一个字符。但如果换行符前有转义字符&amp;lsquo;\&amp;rsquo;则换行符不会变成字符串的一部分；例如，Lisp阅读器在读取字符串时将忽被转义的换行符。转义符后面的空格&amp;lsquo;\ &amp;rsquo;也将被忽略。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          =&amp;gt; "It is useful to include newlines
     in documentation strings,
     but the newline is ignored if escaped."
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="zi-fu-chuan-zhong-de-fei-asciizi-fu"&gt;字符串中的非ASCII字符&lt;/h4&gt;
&lt;p&gt;可以在字符串常量书写时添加非ASCII的国际化字符。在Emacs字符串（和缓冲区中）有两种非ASCII文本描述方法：单字节（unibyte）和多字节（multibyte）。如果字符串常量是从一个多字节的源码中读取的，比如多字节的缓冲区或字符串，或以多字节方式访问的文件，这时字符被以多字节字符读取，并且将生成多字节的字符串。如果字符串常量是从多字节的源码中读取的，则字符将被以多字节的方式读取并且生成多字节的字符串。&lt;/p&gt;
&lt;p&gt;你也可以以多字节的非ASCII字符的代码来表示字符：使用十六进制前缀，&amp;lsquo;\xnnnnnnn&amp;rsquo;，可以带有多个数字。（多字节非ASCII字符编码都会大于256。）任何无效的十六朝向数字将结束这个结构。如果字符串中的下一个字符可以被解释为十六进制数字，则以&amp;lsquo;\ &amp;rsquo;（转义字符和空格）来结束十六进制转义&amp;mdash;&amp;mdash;比如，&amp;lsquo;\x8e0&amp;rsquo;表示一个字符，带重音符号的&amp;lsquo;a&amp;rsquo;。字符串常量中的&amp;lsquo;\ &amp;rsquo;与斜线-换行符类似；它不会添加任何字符到字符串，但它会终结前面的十六进制转义。&lt;/p&gt;
&lt;p&gt;你可以字符的编码来描述多字节的非ASCII字符，它必须在128（八进制的0200）到255（八进制的0377）之间。如果你以八进制书写所有那些字符的代码并且字符串不包含其它字符强制字符串为多字节，则将产生一个单字节的字符串。但是，在字符串中使用十六进制黑底（即使是使用在ASCII字符上）将强制字符串为多字节。&lt;/p&gt;
&lt;p&gt;你也可以在字符串中使用字符的Unicode数字编号，使用&amp;lsquo;\u&amp;rsquo;和&amp;lsquo;\U&amp;rsquo;（参见Character Type）。&lt;/p&gt;
&lt;p&gt;参见Text Representations，了解这两种文本描述方式的更多信息。&lt;/p&gt;
&lt;h4 id="zi-fu-chuan-zhong-de-fei-da-yin-zi-fu"&gt;字符串中的非打印字符&lt;/h4&gt;
&lt;p&gt;你可以在字符串常量中使用反斜线的转义字符序列（但不要以问号开始字符常量）。比如，你可以写一个字符串包括非打印字符tab和C-a，在他们之间添加逗号和空格："\t, C-a"。参见Character Type，了解字符读取语法的描述。&lt;/p&gt;
&lt;p&gt;但是，并不是所有使用转义字符的字符都是有效的字符串字符。只有控制字符，ASCII控制字符可以保存在字符串中。字符串不会区别ASCII控制字符的大小写。&lt;/p&gt;
&lt;p&gt;确切的说，字符串不能保存meta字符；但当字符串用作按键序列（key sequence）时，有一个特殊的约定提供了一个方法可以在字符串中描述meta版的ASCII字符。如果你使用&amp;lsquo;\M-&amp;rsquo;语法标明字符串常量中的meta字符，这将设置字符串中的字符的2**7bit。如果字符串用于define-key或lookup-key，这个数字代码将被转译为相当于meta字符。参见Character Type。&lt;/p&gt;
&lt;p&gt;字符串不能保存修饰字符hyper，super和alt。&lt;/p&gt;
&lt;h4 id="zi-fu-chuan-zhong-de-wen-ben-shu-xing-text-properties"&gt;字符串中的文本属性（Text Properties）&lt;/h4&gt;
&lt;p&gt;字符串可以保存它包含的字符的文本属性。这使程序在string和buffer中复制文本和文本属性时不需要特殊的工作。参见Text Properties，以了解什么是文本属性。带文本属性的字符串使用特殊的读取和打印语法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;"characters"&lt;/span&gt; &lt;span class="nv"&gt;property-data...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当属性数据由0个或多个元素组成时，可以用三个参数来分组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;beg end plist
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;元素beg和end是整数，一起指定字符串中文本的范围；plist是属性列表。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;"foo bar"&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;face&lt;/span&gt; &lt;span class="nv"&gt;bold&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;face&lt;/span&gt; &lt;span class="nv"&gt;italic&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;描述了一个字符串，它的文本内容为&amp;lsquo;foo bar&amp;rsquo;，它的前三个字符有一个face属性，属性的值为bold，后三个字符的face属性值为italic。（第四个字符没有文本属性，因此它的属性列表为nil。实际上不需要论及以nil作为属性列表的范围，因为任何不在范围中的字符默认都没有属性。）&lt;/p&gt;
&lt;h3 id="vectorlei-xing_1"&gt;Vector类型&lt;/h3&gt;
&lt;p&gt;vector是一个元素可以为任何类型的一维数组。花相同的时间可以访问任何vector中的任何元素。（在List中，访问时间与元素离list开始位置的距离成正比。）&lt;/p&gt;
&lt;p&gt;vector的打印描述方法由一个左方括号，元素和右方括号组成。这也是它的读取语法。与数字和字符串类似，vector对于求值来说是常量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="s"&gt;"two"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;three&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;               &lt;span class="c1"&gt;; 有三个元素的vector&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; [1 "two " (three)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参见Vectors，了解工作于vector的函数。&lt;/p&gt;
&lt;h3 id="char-tablelei-xing"&gt;Char-Table类型&lt;/h3&gt;
&lt;p&gt;char-table是一个元素可以是任何类型的一维数组，通过字符代码进行索引。Char-table有某些特殊的功能使它们对于很多与设置字符代码信息相关的工作时非常有用&amp;mdash;&amp;mdash;比如，char-table可以从父对象继承，默认值，和少量用于特目的的额外的slot。char-table也可以为整个字符集合指定单个值。&lt;/p&gt;
&lt;p&gt;char-table的打印描述方法与vector类似，只是在开始位置添加了额外的&amp;lsquo;#^&amp;rsquo;。&lt;/p&gt;
&lt;p&gt;参见Char-Tables，了解操作char-tables的特殊函数。使用char-tables的包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Case tables&lt;/li&gt;
&lt;li&gt;Character category tables&lt;/li&gt;
&lt;li&gt;Display tables&lt;/li&gt;
&lt;li&gt;Syntax tables&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bool-vectorlei-xing"&gt;Bool-Vector类型&lt;/h3&gt;
&lt;p&gt;bool-vector是一个一维数组，它的元素必须是t或nil。&lt;/p&gt;
&lt;p&gt;bool-vector的打印描述方法像一个字符串，但它以&amp;lsquo;#&amp;amp;&amp;rsquo;开头后面跟长度。这个字符串常量后面的bool-vector内容实际上看像一个bitmap&amp;mdash;&amp;mdash;这个字符串中的每个字符包含8bits，它指定了bool-vector后面的8个元素（1表示t，0表示nil）。字符的其它的有效位对应于bool-vector底部。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-bool-vector&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;amp;3"^G"&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-bool-vector&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;amp;3"^@"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些结果很有意义，因为&amp;lsquo;C-g&amp;rsquo;的二进制代码为111，&amp;lsquo;C-@&amp;rsquo;的字符代码为0。&lt;/p&gt;
&lt;p&gt;如果长度不是8的倍数，则打印描述将显示额外的元素，但这些额外的内容不会产生差异。比如，在下面的例子中，两个bool-vector是相等的，因为只有前三个bit被使用了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;&amp;amp;3&lt;/span&gt;&lt;span class="s"&gt;"\377"&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;&amp;amp;3&lt;/span&gt;&lt;span class="s"&gt;"\007"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ha-xi-biao-lei-xing-hash-table-type"&gt;哈希表类型（Hash Table Type）&lt;/h3&gt;
&lt;p&gt;哈希表是一种非常快的lookup table，有点像alist，alist将key映射到对应的值，但哈希表更快。哈希表没有读取语法，打印的时候使用哈希表示法。参见Hash Tables，了解操作哈希表的函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-hash-table&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;hash-table 'eql nil 0/65 0x83af980&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="han-shu-lei-xing-function-type"&gt;函数类型（Function Type）&lt;/h3&gt;
&lt;p&gt;Lisp函数是可执行的代码，与其它编程语言中的函数类似。在Lisp中，与某些语言不同的是函数也是Lisp对象。一个不编译的Lisp函数是一个lambda表达式：它也是一个list，它的第一个元素是符号lambda（参见Lambda Expressions）。&lt;/p&gt;
&lt;p&gt;多数编程语言不允许函数没有名称。在Lisp中函数没有内部名称。Lambda表达式可以在没有名称的情况下被函数调用；为强调这一点，我们也称它为匿名函数（ananymous function参见Anonymous Function）。命名的Lisp函数也只是一个符号它的function cell有一个有效的函数（参见Defining Function）。&lt;/p&gt;
&lt;p&gt;多数情况下，函数将在Lisp程序的Lisp表达式中出现它的名称时被调用。但你可以在运行时构造或得到一个函数对象，并使用原生函数（primitive function）funcall和apply调用它。参见Calling Functions。&lt;/p&gt;
&lt;h3 id="hong-lei-xing-macro-type"&gt;宏类型（Macro Type）&lt;/h3&gt;
&lt;p&gt;Lisp宏是用户定义的扩展Lisp语言的结构。将作为对象更像函数，但具有不同的参数传递语义。Lisp宏具有form list，它的第一个元素是符号macro它的CDR是一个Lisp函数对象，包括lambda符号。&lt;/p&gt;
&lt;p&gt;Lisp宏对象通常使用内置函数defmacro来定义，but any list that begins with macro is a macro as far as Emacs is concerned。参见Macros，它说明了如何编写宏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt;Lisp宏和键盘宏（参见Keyboard Macros）是完全不同的事情。当我们使用不带限定词的单词&amp;ldquo;macro&amp;rdquo;时，表示是Lisp宏，而不是键盘宏。&lt;/p&gt;
&lt;h3 id="yuan-sheng-han-shu-lei-xing-primitive-function-type"&gt;原生函数类型（Primitive Function Type）&lt;/h3&gt;
&lt;p&gt;原生函数（primitive function）是可以从Lisp调用的函数但它是用C语言编写的。原生函数也称为subrs或built-in functions。（subr源自于subroutine）多数原生函数在他们被调用时对他们的所有参数求值。不对它的参数求值的原生函数被称为 special form（参见Special Forms）。&lt;/p&gt;
&lt;p&gt;对于调用者来说并不关心它调用的函数是否为原生的。但如果你使用Lisp代码重新定义原生函数会产生麻烦因为原生函数可以直接被C代码调用。在Lisp代码中调用重定义的函数将使用新的定义，但如果从C代码中调用将仍然使用内置的定义。因此， &lt;strong&gt;我们不推荐重新定义原生函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;术语function指Emacs中的所有函数，不论是用Lisp或C编写的。参见Function Type了解使用Lisp编写函数。&lt;/p&gt;
&lt;p&gt;Primitive functions have no read syntax and print in hash notation with the name of the subroutine.&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt; &lt;span class="ss"&gt;'car&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;; 访问符号的function cell&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;subr car&amp;gt;&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;subrp&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-function&lt;/span&gt; &lt;span class="ss"&gt;'car&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;; 是否为一个原生函数？&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; t                       ; 是的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="byte-codehan-shu-lei-xing"&gt;Byte-Code函数类型&lt;/h3&gt;
&lt;p&gt;byte compiler生成byte-code函数对象。在内部，byte-code函数对象更象vector；但是，当它出现为一个被调用的函数时求值器将特殊地处理这种数据类型。参见Bypte Compilation，了解关于byte compiler的相关信息。&lt;/p&gt;
&lt;p&gt;byte-code函数对象的打印和读取格式类似于vector，在&amp;lsquo;[&amp;rsquo;前添加了&amp;lsquo;#&amp;rsquo;。&lt;/p&gt;
&lt;h3 id="autoloadlei-xing"&gt;Autoload类型&lt;/h3&gt;
&lt;p&gt;autoload对象是一个list它的第一个元素是符号autoload。它像符号的函数定义一样被存储，它作为真实定义的占位符。autoload对象表明真实的函数定义可以在Lisp代码的文件中找到，可以在需要时加载。它包括文件的名称，和一些关于实际定义的相关信息。&lt;/p&gt;
&lt;p&gt;当文件被加载后，符号将有一个新的函数定义而不再是一个autoload对象。这时新的定义可以被调用就像它一开始就存在于那里一样。从用户的观点来看，函数调用工作起来和预期的一样，可以使用被加载的文件中定义的函数。&lt;/p&gt;
&lt;p&gt;autoload对象通常使用autoload函数创建，它将这个对象存储于符号的function cell区域。参见Autoload，了解更多细节。&lt;/p&gt;
&lt;h2&gt;编辑类型（Editing Types）&lt;/h2&gt;
&lt;p&gt;前一节讲述的类型用于通用编程目的，它们中的大多数也用于大多数的Lisp方言中。Emacs Lisp提供了几个特殊的类型用于连接编辑处理。&lt;/p&gt;
&lt;h3 id="huan-chong-qu-lei-xing"&gt;缓冲区类型&lt;/h3&gt;
&lt;p&gt;buffer是一个对象用于保存可编辑的文本（参见Buffers）。多数缓冲区用于保存磁盘文件的内容（参见Files）以便于被编辑，但另一些用于其它目的。有时，在一个窗口中（参见Windows），一些缓冲区只用于显示给用户查看。但缓冲区不必要一定显示在窗口中。&lt;/p&gt;
&lt;p&gt;缓冲区的内容更像一个字符串，但缓冲区在Emacs Lisp中不能用作字符串，它们的操作也是不同的。例发，你可以在一个缓冲区中插入文本更改缓冲区的内容，但是&amp;ldquo;插入&amp;rdquo;文本到字符串中需要连接子字符串（concatenating substring），其结果是一个全新的新字符串对象。&lt;/p&gt;
&lt;p&gt;每个缓冲区都有一个指定的位置称为point（参见Positions）。在任何时候，有一个缓冲区是当前缓冲区。多数编辑命令操作当前缓冲区中邻近point的内容。许多标准Emacs函数操作或测试当前缓冲区中的字符；这个手册中有一整章用于描述这些函数（参见Text）。&lt;/p&gt;
&lt;p&gt;有几个其它的数据结构与每个缓冲区关联&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地语法表（local syntax）（参见Syntax Tables）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地按键映射（local keymap）（参见Keymaps）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓冲区局部绑定的变量的list（参见Buffer-Local Variables）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;overlays（参见Overlays）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓冲区的文本属性（参见Text Properties）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;局部按键映射和变量列表包含了覆盖全局按键绑定的值或新值的入口。这些用于在不同的缓冲区自定义程序的行为，而不会改变程序本身。&lt;/p&gt;
&lt;p&gt;缓冲区可能是indirect的，这与另一个缓冲区共享文本，但用它的不同的方式呈现内容。参见Indirect Buffers。&lt;/p&gt;
&lt;p&gt;缓冲区没有读取语法。打印时将显示缓冲区的名称。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;current-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;buffer objects.texi&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="markerlei-xing"&gt;Marker类型&lt;/h3&gt;
&lt;p&gt;marker指示了具体缓冲区的位置。markers有个组件：一个用于缓冲区，另一个用于位置。修改缓冲区的文本将自动重新定位位置的值以确保marker总是指向缓冲区中的两个字符之间的位置。&lt;/p&gt;
&lt;p&gt;markers没有读取语法。打印为hash表示法时，将显示当前字符的位置和缓冲区的名称。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;marker at 10779 in objects.texi&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参见Markers，了解如何测试，创建，复制和移动markers。&lt;/p&gt;
&lt;h3 id="windowlei-xing"&gt;Window类型&lt;/h3&gt;
&lt;p&gt;window表示终端屏幕的一部分，Emacs用它显示一个缓冲区。每个window有一个相关的缓冲区，它的内容显示在窗口中。相反，一个缓冲区可以显示在一个窗口中，或不显示在窗口中，或显示在多个窗口中。&lt;/p&gt;
&lt;p&gt;尽管可以同时存在很多窗口，同一时候只有一个窗口是当前选中窗口（selected window）。这是当前光标停留的窗口，在这个窗口中Emacs等侍命令输入。选中的窗口通常显示当前缓冲区（current buffer），但这并不是必需的情况。&lt;/p&gt;
&lt;p&gt;窗口在屏幕上被组织到frames中；每个窗口属于一个并且只能属于一个frame。参见Frame Type。&lt;/p&gt;
&lt;p&gt;窗口没有读取语法。打印为hash表示法时，将显示窗口号和显示的缓冲区的名称。窗口号用于唯一标识窗口，因为显示在窗口中的缓冲区可能会改变。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;selected-window&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;window 1 on objects.texi&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参见Windows，了解工作于窗口的函数。&lt;/p&gt;
&lt;h3 id="framelei-xing"&gt;Frame类型&lt;/h3&gt;
&lt;p&gt;frame是一个屏幕区域包含一个或多个Emacs窗口；我们也使用术语&amp;ldquo;frame&amp;rdquo;指向Lisp对象，Emacs使用它指向屏幕区域。&lt;/p&gt;
&lt;p&gt;Frames没有读取语法。它们打印为哈希标记法，frame标题加它在核心中的的地址（用于唯一标识frame）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;selected-frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; #&amp;lt;frame emacs@psilocin.gnu.org 0xdac80&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参见Frames，了解工作于frames的函数。&lt;/p&gt;
&lt;h3 id="chuang-kou-pei-zhi-lei-xing-window-configuration-type"&gt;窗口配置类型（Window Configuration Type）&lt;/h3&gt;
&lt;p&gt;window configuration存储frame中的窗口的位置，尺寸，内容相关的信息，因此你可以重新组织窗口的位置。&lt;/p&gt;
&lt;p&gt;Window configurations没有读取语法；它的打印语法格式如&amp;ldquo;#&lt;window-configuration&gt;&amp;rdquo;。参见Window Configurations，了解与window configurations相关的函数。&lt;/window-configuration&gt;&lt;/p&gt;
&lt;h3 id="frame-configurationlei-xing"&gt;Frame Configuration类型&lt;/h3&gt;
&lt;p&gt;Frame configuration存储了所有frame中的窗口的位置，大小和内容等信息。它实际上是一个list，它的CAR是frame-configuration它的CDR是一个alist。每个alist元素描述一个frame，它作为那个元素的CAR出现。&lt;/p&gt;
&lt;p&gt;参见Frame Configurations，了解与frame configurations相关的函数。&lt;/p&gt;
&lt;h3 id="jin-cheng-lei-xing"&gt;进程类型&lt;/h3&gt;
&lt;p&gt;单词&amp;ldquo;进程&amp;rdquo;通常表示运行的程序。Emacs自己也是那样一个运行的进程。在Emacs Lisp中，进程是一个Lisp对象，表示由Emacs进程创建的子进程。shell，GDB，ftp和编译器等程序作为Emacs子进程运行，扩展了Emacs的能力。&lt;/p&gt;
&lt;p&gt;Emacs子进程从Emacs接收文本化输入并返回文本化的输出到Emacs中以便处理。Emacs也可以发送信号到子进程。&lt;/p&gt;
&lt;p&gt;进程对象没有读取语法。它使用哈希表示法打印，显示进的名称：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;process-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; (#&amp;lt;process shell&amp;gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参见[[#Processes][Processes]]，了解关于进程创建，删除，返回信息，发送输入或信号和接收输出到进程的函数。&lt;/p&gt;
&lt;h3 id="streamlei-xing"&gt;Stream类型&lt;/h3&gt;
&lt;p&gt;stream是一个对象流可以提供字符作为输入或输出。很多不同的类型可以使用这种方式，比如：marks，buffers，strings和functions。通常，输入流（字符源）可以从键盘、缓冲区或文件获得，输出流可以发送到缓冲区，例如&lt;em&gt;Help&lt;/em&gt;缓冲区或回显区。&lt;/p&gt;
&lt;p&gt;nil对象，用于流有其它的含义。它表示变量standard-input或standard-output。对象t作为流指定使用minibuffer作为输入（参见MiniBuffers）或输出到回显区（参见The Echo Area）。&lt;/p&gt;
&lt;p&gt;参见Read and Print，了解与流相关的函数，包括解析和打印函数。&lt;/p&gt;
&lt;h3 id="keymaplei-xing"&gt;Keymap类型&lt;/h3&gt;
&lt;p&gt;keymap将按键映射到用户命令。这个映射控制了用户命令如何被输入执行。按键映射实际上是一个list，它的CAR是keymap符号。&lt;/p&gt;
&lt;p&gt;参见[[#Keymaps][Keymaps]]，了解创建keymaps，处理前缀参数，局部和全局映射，修改按键组合。&lt;/p&gt;
&lt;h3 id="overlaylei-xing"&gt;Overlay类型&lt;/h3&gt;
&lt;p&gt;overlay指定了将应用到缓冲区的属性。每个overlay将应用到缓冲区的指定范围，包括了一个属性列表（一个包含将要修改的属性和值的list）。overlay属性用于将当前缓冲区临时设置为不同的显示风格。Overlay没有读取语法，在打印为哈希表达方式时，将显示缓冲区的名称和位置范围。&lt;/p&gt;
&lt;p&gt;参见[[#Overlays][Overlays]]，了解如何创建和使用overlays。&lt;/p&gt;
&lt;h2&gt;环状对象的读取语法（Read Syntax for Circular Objects）&lt;/h2&gt;
&lt;p&gt;为在一个复杂的Lisp对象中描述共享或通知结构时，你可以使用读取结构&amp;lsquo;#n=&amp;rsquo;和&amp;lsquo;#n#&amp;rsquo;。&lt;/p&gt;
&lt;p&gt;在一个对象前使用#n=标明它是一个延时的引用；在后面，你可以在另一个地方使用#n#来引用同一个对象。在这里，n是个整数。比如，下面的例子产生了一个list，在这里第一个元素在第三个元素处重现了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#1=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="o"&gt;#1#&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这不同于普通的表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个表达式生成的list中第一个和第三个元素看起来相同，但他们不是同一个Lisp对象。下面显示了他们的不同：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#1=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="o"&gt;#1#&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;b&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以使用相同的语法产生一个环状结构，它表现了一个元素处理它自己内部。这里有一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="o"&gt;#1=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="o"&gt;#1#&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样生成的list的第二个元素是list自身。这里展示了它是如何工作的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="o"&gt;'#1=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="o"&gt;#1#&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cadr&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果将变量print-circle设置成了非nil值Lisp打印器可以按这种语法在Lisp对象中生成环状和共享结构。参见[[#Output_Variables][Output Variables]]。&lt;/p&gt;
&lt;h2&gt;类型判定（Type Predicates）&lt;/h2&gt;
&lt;p&gt;Emacs Lisp解释器对于传递给被调用的函数的参数并不会对参数执行类型检查。它也做不到这一点，因为Lisp中的函数参数并没有申明数据类型，这与其它编程语言不同。对此可以使用检查参数属于哪种类型的函数。&lt;/p&gt;
&lt;p&gt;所有内置函数都会检查他们的实参是否适当，如果参数类型错误将生成wrong-type-arguemnt错误。例如，下面展示了如果传递不能处理的参数给+将产生错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ss"&gt;'a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="nv"&gt;error--&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;Wrong&lt;/span&gt; &lt;span class="nv"&gt;type&lt;/span&gt; &lt;span class="nv"&gt;argument:&lt;/span&gt; &lt;span class="nv"&gt;number-or-marker-p,&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你希望程序可以用不同的方式处理不同的类型，则必须显式的进行类型检查。通常检查对象的类型的方法是调用类型判定（type predicate）函数。Emacs对于每个类型都有类型判定函数，对于一些组合类型也有类型判定函数。&lt;/p&gt;
&lt;p&gt;类型判定函数接收一个参数；如果参数属于相应的类型则返回t，否则返回nil。按Lisp对于类型判定函数的的习惯，多数类型判定函数名称心&amp;lsquo;p&amp;rsquo;结束。&lt;/p&gt;
&lt;p&gt;下面的例子使用了listp检查是list，使用symbolp检查symbol。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;add-on&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;symbolp&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="c1"&gt;;; If X is a symbol, put it on LIST.&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
             &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;listp&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="c1"&gt;;; If X is a list, add its elements to LIST.&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
              &lt;span class="c1"&gt;;; We handle only symbols and lists.&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ne"&gt;error&lt;/span&gt; &lt;span class="s"&gt;"Invalid argument %s in add-on"&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下表列举了预定义的类型判定函数，按字母顺序排列。&lt;/p&gt;
&lt;p&gt;atom&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;参见[[#atom][atom]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;arrayp&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;参见[[#arrayp][arrayp]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bool-vector-p&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;参见[[#bool-vector-p][bool-vector-p]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bufferp
    参见[[#bufferp][bufferp]]&lt;/p&gt;
&lt;p&gt;byte-code-function-p
    参见[[#byte-code-function-p][byte-code-function-p]]&lt;/p&gt;
&lt;p&gt;case-table-p
    参见[[#case-table-p][case-table-p]]&lt;/p&gt;
&lt;p&gt;char-or-string-p
    参见[[#char-or-string-p][char-or-string-p]]&lt;/p&gt;
&lt;p&gt;char-table-p
    参见 char-table-p.&lt;/p&gt;
&lt;p&gt;commandp
    参见 commandp.&lt;/p&gt;
&lt;p&gt;consp
    参见 consp.&lt;/p&gt;
&lt;p&gt;display-table-p
    参见 display-table-p.&lt;/p&gt;
&lt;p&gt;floatp
    参见 floatp.&lt;/p&gt;
&lt;p&gt;frame-configuration-p
    参见 frame-configuration-p.&lt;/p&gt;
&lt;p&gt;frame-live-p
    参见 frame-live-p.&lt;/p&gt;
&lt;p&gt;framep
    参见 framep.&lt;/p&gt;
&lt;p&gt;functionp
    参见 functionp.&lt;/p&gt;
&lt;p&gt;hash-table-p
    参见 hash-table-p.&lt;/p&gt;
&lt;p&gt;integer-or-marker-p
    参见 integer-or-marker-p.&lt;/p&gt;
&lt;p&gt;integerp
    参见 integerp.&lt;/p&gt;
&lt;p&gt;keymapp
    参见 keymapp.&lt;/p&gt;
&lt;p&gt;keywordp
    参见 Constant Variables.&lt;/p&gt;
&lt;p&gt;listp
    参见 listp.&lt;/p&gt;
&lt;p&gt;markerp
    参见 markerp.&lt;/p&gt;
&lt;p&gt;wholenump
    参见 wholenump.&lt;/p&gt;
&lt;p&gt;nlistp
    参见 nlistp.&lt;/p&gt;
&lt;p&gt;numberp
    参见 numberp.&lt;/p&gt;
&lt;p&gt;number-or-marker-p
    参见 number-or-marker-p.&lt;/p&gt;
&lt;p&gt;overlayp
    参见 overlayp.&lt;/p&gt;
&lt;p&gt;processp
    参见 processp.&lt;/p&gt;
&lt;p&gt;sequencep
    参见 sequencep.&lt;/p&gt;
&lt;p&gt;stringp
    参见 stringp.&lt;/p&gt;
&lt;p&gt;subrp
    参见 subrp.&lt;/p&gt;
&lt;p&gt;symbolp
    参见 symbolp.&lt;/p&gt;
&lt;p&gt;syntax-table-p
    参见 syntax-table-p.&lt;/p&gt;
&lt;p&gt;user-variable-p
    参见 user-variable-p.&lt;/p&gt;
&lt;p&gt;vectorp
    参见 vectorp.&lt;/p&gt;
&lt;p&gt;window-configuration-p
    参见 window-configuration-p.&lt;/p&gt;
&lt;p&gt;window-live-p
    参见 window-live-p.&lt;/p&gt;
&lt;p&gt;windowp
    参见 windowp.&lt;/p&gt;
&lt;p&gt;booleanp
    参见 booleanp.&lt;/p&gt;
&lt;p&gt;string-or-null-p
    参见 string-or-null-p.&lt;/p&gt;
&lt;p&gt;最通用的检查对象类型的方法是调用type-of函数。再次强调每个对象只属于且仅能属于一个原生类型；type-of可以告诉你它属于哪种类型（参见[[#Lisp_Data_Types][Lisp Data Types]]）。但是type-of不了解非原生类型的信息。在多数情况下，更方便的是使用类型判定函数type-of。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;type-off&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数返回object的原生类型的名称的符号。返回值可能是下面的一个符号：symbol，integer，float，string，cons，vector，char-table，bool-vectorhash-table，subr，compiled-function，marker，overlay，window，buffer，frame，或window-configuration。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type-of&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; integer&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type-of&lt;/span&gt; &lt;span class="ss"&gt;'nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; symbol&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type-of&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;    &lt;span class="c1"&gt;; () is nil.&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; symbol&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;type-of&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; cons&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相等判定（Equality Predicates）&lt;/h2&gt;
&lt;p&gt;这里我们讲述两个用于测试两个对象的相等性的函数。其它函数测试特定类型的对象的相等性，比如，string。对于这些判定，可以参见相应的章节描述。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;eq&lt;/code&gt; object1 object2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果object1和object2是相同的对象，则返回t，否则返回nil。&lt;/p&gt;
&lt;p&gt;如果object1和object2是整数并有相同的值eq将返回t。因为符号名通常是唯一的，如果参数是符号并有相同的名字，则它们相等。对于其它类型（比如，lists，vectors，strings），两个参数有相同的同内容或元素不必要每个都相等：它们是同样的对象时相等，这意味着改变一个的内容将影响反映到另一个上产生同样的变化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="mi"&gt;456&lt;/span&gt; &lt;span class="mi"&gt;456&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; (1 (2 (3)))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;make-symbol函数返国 个uninterned符号，这有别于你编写在Lisp表达式的符号。这两种不同的符号有相同的名称但不相等（eq）。参见[[Creating_Symbols][Creating Symbols]]。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-symbol&lt;/span&gt; &lt;span class="s"&gt;"foo"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;eqal&lt;/code&gt; object1 object2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果object1和object2有相等的内容则返回t，否则返回nil。eq检查它的参数是否为相同的对象，equal检查它的参数内部的元素或内容是否一样。因此，如果两个对象eq则他们equal，反之则不一定。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt; &lt;span class="ss"&gt;'foo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="mi"&gt;456&lt;/span&gt; &lt;span class="mi"&gt;456&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; t&lt;/span&gt;

          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-marker&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字符串比较时是大小写敏感的，但不会考虑文本属性（）text properties），它只会比较字符串中的字符。因为技术原因，单字节字符串和多字节字符串比较时，如果他们包含相同的字符代码序列并且所有这些代码都处于0至127（ASCII）之间或160至255（八bit图元），则两个字符串equal。（参见[[#Text_Representations][Text Representations]]）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="s"&gt;"asdf"&lt;/span&gt; &lt;span class="s"&gt;"ASDF"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个不同的buffer总不会equal，即使他们的文本内容是相同和。&lt;/p&gt;
&lt;p&gt;相等性的测试是通过递归实现的：例如，两个cons cells分别为x和y，在下面的两个表达式都返回t时(equal x y)返回t。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为这是一个递归方法，circular list将会至进入无限递归（导致产生错误）。&lt;/p&gt;
&lt;h1&gt;数字（Numbers）&lt;/h1&gt;
&lt;p&gt;GNU Emacs支持两种数字类型：整形（integer）和浮点（floating point)类型。Integer值如－3，0，7，13和511。他们的值是精确的。Floating point数字是带有小数部分的数字，比如－4.5，0.0或2.71828。他们也可以表示为科学计数法：1.5e2等于150；在这个例子中，&amp;lsquo;e2&amp;rsquo;表示10的2次方，乘1.5。Floating point值是不精确的；他们有一个固定的有限的精度。&lt;/p&gt;
&lt;h2&gt;整数基础（Integer Basics）&lt;/h2&gt;
&lt;p&gt;Integer的范围依赖于具体的机器类型。最小范围是-268435456至268435455（29位；-2&lt;strong&gt;28至2&lt;/strong&gt;28-1），但有些机器可以提供更宽的范围。这章中的许多例子都假设整数为29bits。Lisp阅读器将整数当作数字序列读取，前面可以带有符号后面可以带有小数点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      &lt;span class="mi"&gt;1&lt;/span&gt;               &lt;span class="c1"&gt;; The integer 1.&lt;/span&gt;
      &lt;span class="mi"&gt;1.&lt;/span&gt;              &lt;span class="c1"&gt;; The integer 1.&lt;/span&gt;
     &lt;span class="mi"&gt;+1&lt;/span&gt;               &lt;span class="c1"&gt;; Also the integer 1.&lt;/span&gt;
     &lt;span class="mi"&gt;-1&lt;/span&gt;               &lt;span class="c1"&gt;; The integer ?1.&lt;/span&gt;
      &lt;span class="mi"&gt;536870913&lt;/span&gt;       &lt;span class="c1"&gt;; Also the integer 1, due to overflow.&lt;/span&gt;
      &lt;span class="mi"&gt;0&lt;/span&gt;               &lt;span class="c1"&gt;; The integer 0.&lt;/span&gt;
     &lt;span class="mi"&gt;-0&lt;/span&gt;               &lt;span class="c1"&gt;; The integer 0.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;十进制以外的其它整数表示方法使用&amp;lsquo;#&amp;rsquo;后跟一个字母指定进制：&amp;lsquo;b&amp;rsquo;表示二进制，&amp;lsquo;o&amp;rsquo;表示八进制，&amp;lsquo;x&amp;rsquo;表示十六进制，或&amp;lsquo;radixr&amp;rsquo;以指明进制。指定进制的字母的大小写无关。因此，&amp;lsquo;#binteger&amp;rsquo;将以二进制读取整数，&amp;lsquo;#radixrinteger&amp;rsquo;将以指定的进制读取整数。进制指定的范围为2至36。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="mb"&gt;#b101100&lt;/span&gt; &lt;span class="c1"&gt;;=&amp;gt; 44&lt;/span&gt;
     &lt;span class="mo"&gt;#o54&lt;/span&gt; &lt;span class="c1"&gt;;=&amp;gt; 44&lt;/span&gt;
     &lt;span class="mh"&gt;#x2c&lt;/span&gt; &lt;span class="c1"&gt;;=&amp;gt; 44&lt;/span&gt;
     &lt;span class="m"&gt;#24r1k&lt;/span&gt; &lt;span class="c1"&gt;;=&amp;gt; 44&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;了解整数处理相关的函数，特别是位操作（参见[[#Bitwise_Operations][Bitwise Operations]]），它对于了解数字的二进制处理很有帮助。&lt;/p&gt;
&lt;p&gt;在29bit的二进制中，数字5看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     0 0000  0000 0000  0000 0000  0000 0101
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（我们在以4bits为一组插入了一个空格，8bits一组插入了两个空格，以便阅读。）&lt;/p&gt;
&lt;p&gt;整数-1看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     1 1111  1111 1111  1111 1111  1111 1111
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-1被描述为29个1。（This is called two's complement notation.）&lt;/p&gt;
&lt;p&gt;在这种实现方式中，最大的29bit的二进制整数值为268,435,455。它的二进制形式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     0 1111  1111 1111  1111 1111  1111 1111
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于算术函数不会检查整数是否溢出，当你将1和268,435,455相加后将得到负整数-268,435,456：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;268435455&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; -268435456&lt;/span&gt;
          &lt;span class="c1"&gt;;=&amp;gt; 1 0000  0000 0000  0000 0000  0000 0000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这章中介绍的许多函数在接收number的地方都可以接收marker。（参见[[#Markers][Markers]]。）因为这些函数的实参可以是numbers或markers，我们通常将这些参数称为number-or-marker。当参数值是marker时，将使用它的位置信息而它的buffer信息将被忽略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;most-positive-fixnum&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值是Emscs Lisp可以处理的最大的整数值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;most-negative-fixnum&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值是Emacs Lisp可以处理的最小的整数值。它是一个负数。&lt;/p&gt;
&lt;h2&gt;浮点数基础（Floating Point Basics）&lt;/h2&gt;
&lt;p&gt;Floating point用于描述非整型的数字。Floating point的精度范围与具体机器相关；它的范围与你使用的机器的C语言double类型的精度范围相同。&lt;/p&gt;
&lt;p&gt;Floating point的读取语法需要一个小数点（后面至少有一个小数），一个整数部分，或者两者都有。例如，&amp;lsquo;1500.0&amp;rsquo;、&amp;lsquo;15e2&amp;rsquo;、&amp;lsquo;15.0e2&amp;rsquo;、&amp;lsquo;1.5e3&amp;rsquo;和&amp;lsquo;.15e4&amp;rsquo;这5种写法都是表示1500。它们都是相等的。你也可以使用减号写floating point的负数，&amp;lsquo;-1.0&amp;rsquo;。&lt;/p&gt;
&lt;p&gt;多数现代的计算机都支持IEEE floating point标准，它提供正负无穷大的floating point值。它也提供了一个值类型NaN或称为&amp;ldquo;not-a-number&amp;rdquo;；算术函数函数在不能正确响应时返回这个类型的值。例如，(/ 0.0 0.0)将返回NaN。在实际应用中，Emacs Lisp中不同的NaN值之间的区别并没有实际意义，没有规则表明在某个特殊情况下需要使用哪个NaN，因此Emacs Lisp不会去区分它们（但它在打印时不会报告出标记）。下面是特殊的floating point值的读取语法：&lt;/p&gt;
&lt;p&gt;正无穷大&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;1.0e+INF&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;负无穷大&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;`&lt;/span&gt;&lt;span class="nv"&gt;-1.0e+INF&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Not-a-number&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;`0.0e+NaN' 或 `-0.0e+NaN'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了测试一个floating point值是否为NaN，可以将它与自身使用=比较。如果是NaN则返回nil，其它floating point值将返回t。&lt;/p&gt;
&lt;p&gt;在IEEE的floating point中-0.0与普通的0是有区别的，但是Emacs Lisp中equal和=都把他们当作相等的值。&lt;/p&gt;
&lt;p&gt;你可以使用logb提取二进制数的浮点数值（或取整数的对数）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;logb&lt;/code&gt; number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数返回number的二进制数。更精确的讲，返回值是number的以2为底的对数四舍五入的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;logb&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; 3&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;logb&lt;/span&gt; &lt;span class="mf"&gt;10.0e20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="c1"&gt;;=&amp;gt; 69&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;数字的类型判定（Type Predicates for Numbers）&lt;/h2&gt;
&lt;p&gt;这节中的函数用于测试数字，或指定数字的类型。函数intergerp和floatp可以接收任何类型的Lisp对象作为参数（否则它们将没有多大作用），但zerop判定需要一个数字作为参数。参见[[#Predicates_on_Markers][Predicates on Markers]]中的integer-or-marker-p和number-or-marker-p。&lt;/p&gt;
&lt;p&gt;－ Function: &lt;code&gt;floatp&lt;/code&gt; object&lt;/p&gt;
&lt;p&gt;这个判定测试它的参数是否为一个floating point数，如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;p&gt;floatp在Emacs 18版或更早的版本中不存在。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;integrep&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个判定测试它的参数是束为一个integer，如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Funtion: &lt;code&gt;numberp&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个判定测试它是参数是否为数字（integer或floating point），如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;wholenump&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;wholenump判定（它的名称来自于短语&amp;ldquo;whole-number-p&amp;rdquo;）测试它的参数是否为一个非负的整数，如果是则返回t，否则返回nil。0被作为非负。&lt;/p&gt;
&lt;p&gt;natnump是wholenump被废弃的同义词。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function &lt;code&gt;zerop&lt;/code&gt; number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个判定测试它的参数是否为0，如果是则返回t，否则返回nil。参数必须是一个数字。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(zerop x) 等同于 (= x 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Comparison-of-Numbers&lt;/h1&gt;
&lt;h2&gt;数字的比较（Comparision of Numbers）&lt;/h2&gt;
&lt;p&gt;测试数字的数值相等性，通常应该使用=，而不是eq。具有相同的数值的floating point数字对象可能是截然不同。如果使用eq比较他们，则你在测试两个值是否为相同的对象。相反，=只比较对象的数值。&lt;/p&gt;
&lt;p&gt;目前，在Emacs Lisp中每个integer值有一个唯一的Lisp对象。因此，在处理integer时eq等同于=。某些情况下使用eq比较一个未知的值和一个integer比较方便，因为如果这个未知值不是数字时eq不会产生错误&amp;mdash;&amp;mdash;它可以接收任何类型的参数。相反，如果参数不是numbers或markers，则=号将产生错误。但是，如果可以则使用=号是一个好主意，即使是在比较integers时，以防我们在将来的Emacs版本中修改integers的表示方法。&lt;/p&gt;
&lt;p&gt;有时使用equal比较两个number也比较有用；如果两个number有相同的数据类型（都是integer或都是floating point）它将两个number当作equal。相反，=可以将integer和floating point当作相等。参见[[#Equality_Predicates][EqualityPredicates]]。&lt;/p&gt;
&lt;p&gt;另一个小问题：因为floating point的数学运算是不精确的，检查两个floating point的相等性不是个好主意。通常较好的方法是比较他们的相似性。有一个函数可以完成这个比较：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;fuzz-factor&lt;/span&gt; &lt;span class="mf"&gt;1.0e-6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;approx-equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;abs&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;max&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;abs&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;abs&lt;/span&gt; &lt;span class="nv"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
              &lt;span class="nv"&gt;fuzz-factor&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Common Lisp注意：&lt;/strong&gt;在Common Lisp中比较number总是需要=因为Common Lisp实现了multi-word integers，两个不同的integer对象可以有相同的数值。Emacs Lisp对于给定的值只有一个integer对象，因为它的integer值的范围是有限的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;=&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查它的参数的数字是否相等，如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;eql&lt;/code&gt; value1 value2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;的行为类似eq，除了在两个参数都是number时。它比较number的类型的数值，因此(eql 1.0 1)返回nil，但(eql 1.0 1.0)和(eql 1 1)都返回t。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;/=&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查它的参数的数字是否相等（numerically equal），如果不是则返回t，如果是则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;&amp;lt;&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查它的第一个参数是否严格地（strictly）小于第二个参数。如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;&amp;lt;=&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查它的第一个参数是否小于或等于它的第二个参数。如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;&amp;gt;&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查它的第一个参数是否大于第二个参数。如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;&amp;gt;=&lt;/code&gt; number-or-marker1 number-or-marker2&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试第一个参数是否大于或等于第二个参数。如果是则返回t，否则返回nil。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;max&lt;/code&gt; number-or-marker &amp;amp;rest numbers-or-markers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回参数列表中的最大值。如果参数中的任何一个值为float型，则返回值也为float型，即使这个最大的参数是以整型传入的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;min&lt;/code&gt; numbers-or-markers &amp;amp;rest numbers-or-markers&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回参数列表中的最小值。如果参数中的任何一个值为float型，则返回值也为float型，即使这个最小的参数是以整型传入的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;abs&lt;/code&gt; number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回参数的绝对值。&lt;/p&gt;
&lt;h1&gt;Numeric-Conversions&lt;/h1&gt;
&lt;h2&gt;数值转换（Numeric Conversions）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;float&lt;/code&gt; number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将number转换为浮点类型。如果number本身就是浮点型的则返回它自身。&lt;/p&gt;
&lt;p&gt;有四个函数用于将浮点类型转变为整数；他们的区别在于进位处理上。它们都接收number型参数和可选的divisor参数。这两个参数都可以是整数或浮点数。divisor也可以是nil。如果divisor为nil或被忽略，则这些函数将number参数转化为整型，如果number原来是整型则返回原来的整数。如果divisor是非nil值，则将number除以divisor将并将结果转换为整数。如果divisor为0则返回arith-error。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;truncate&lt;/code&gt; number &amp;amp;optional divisor&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Processes&lt;/h1&gt;
&lt;h1&gt;进程&lt;/h1&gt;
&lt;p&gt;执行子进程并与其通讯。&lt;/p&gt;
&lt;p&gt;在操作系统术语中，进程是程序可以执行的的一块区域。Emacs是作为一个进程进行的。Emacs Lisp程序可以调用其它进程。这些被称为Emacs进程的子进程（subprocesses或processes），Emacs进程是它们的父进程。&lt;/p&gt;
&lt;p&gt;Emacs的子进程可以是同步或异步的，这取决于怎样子进程如何被创建。当创建同步子进程时，Lisp程序在继续执行之前将等侍子进程结束。当创建异步子进程时，它将与Lisp程序并行的运行。这些子进程类型在Emacs内部被描述为Lisp对象，它也被称为&amp;ldquo;进程（process）&amp;rdquo;。Lisp程序可以使用这个对象与子进程通讯或控制它。比如，你可以向它发送信号，获取状态信息，接收进程的输出，或向它发送输入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;processp&lt;/code&gt; object&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个函数返回t如果object是一个进程，否则返回nil。&lt;/p&gt;
&lt;h2&gt;子进程的创建&lt;/h2&gt;
&lt;p&gt;启动子进程的函数。&lt;/p&gt;
&lt;p&gt;有三个函数创建新的子进程来运行程序。start-process，创建一个异步进程并返回一个process对象。call-process和call-process-region，创建一个同步进程并且它不会返回一个process对象。&lt;/p&gt;
&lt;p&gt;同步和异步进程将在后面的章节解释。由于这三个函数的调用方式是类似的，它们的公共参数在这里描述。&lt;/p&gt;
&lt;p&gt;在所有的情况下，函数的program参数指定要被运行的程序。如果文件未找到或不能被执行将显示错误。如果文件名是相对路径，变量exec-path包含了将搜索的目录的列表。Emacs在它启动时初始化exec-path，它的值基于环境变量PATH。标准文件名结构&amp;lsquo;~&amp;lsquo;，&amp;lsquo;.&amp;lsquo;和&amp;lsquo;..&amp;lsquo;，在exec-path中被正确的解释，但环境变量代入（比如，&amp;lsquo;$HOME&amp;lsquo;）将不被识别；使用substitute-in-file-name来处理它们。这个list中的nil指向default-directory。&lt;/p&gt;
&lt;p&gt;执行程序时将尝试在名称后添加指定的后缀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;exec-suffixes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量是一个将添加到指定程序名后的后缀名的列表。这个list应该包含&amp;rdquo;&amp;ldquo;，如果你需要使用完整的执行文件名时。这个变量的默认值是与平台相关的。&lt;/p&gt;
&lt;p&gt;注意：包含参数的程序应该只使用程序的名称；不可以包含命令行参数。应该使用 args 来提供参数。&lt;/p&gt;
&lt;p&gt;每个用于创建子进程的函数都有一个 buffer-or-name 参数用于指定程序的标准输出。它可以是一个缓冲区或缓冲区名称；如果它是一个缓冲区名称，则将在缓冲区不存在时创建这个缓冲区。它也可以是 nil，在没有过虑处理函数时这表示忽略输出。通常，应该避免将多个进程的输出发送到同一个缓冲区因为它们的输出将被随机的混合在一起。&lt;/p&gt;
&lt;p&gt;所有这三个创建子进程的函数都有一个 &amp;amp;rest 参数，args 。args 必须都是都是字符串，它们被提供给程序作为独立的命令行参数。这个字符串中的通配符和其它shell中的字符将没有特殊意义，因为字符串将被直接传递给程序。&lt;/p&gt;
&lt;p&gt;子进程将获取 default-directory 的值作为它的当前目录。&lt;/p&gt;
&lt;p&gt;子进程从 Emacs 中继承环境变量，但你指定 process-environment 来覆盖这个值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;exec-directory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值是一个字符串，包含 GNU Emacs 所包含的程序的目录名称。例如 movemail ；Rmail 使用它从收件箱中获取新邮件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User Option: &lt;code&gt;exec-path&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量的值是一个目录的 list ，它用于搜索作为子进程运行的程序。每个元素可以是一个目录名或 nil ，nil 表示缺省目录（变量 default-directory 的值）。exec-path 将在 program 参数不是绝对路径时被用于 call-process 和 start-process 。&lt;/p&gt;
&lt;h2&gt;Shell 参数&lt;/h2&gt;
&lt;p&gt;Lisp 程序有时需要运行 shell 并给它一个包含用户指定的文件名称的命令。这个程序应该能处理任何有效的文件名。但 shell 将对特殊字符作特殊的处理，如果这些字符包含在文件名中，将会导致 shell 迷惑。为了处理这些字符，可以使用 shell-quote-argument 函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function: &lt;code&gt;shell-quote-argument&lt;/code&gt; argument&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Variables&lt;/h1&gt;
&lt;h1&gt;变量&lt;/h1&gt;
&lt;p&gt;Lisp中符号名为变量名，符号的value cell存储的是变量的值。同一个符号既可以作为变量名又可以作为函数名。参见[[#Symbol Components][Symbol Components]]&lt;/p&gt;
&lt;h1&gt;Global Variable&lt;/h1&gt;
&lt;h2&gt;全局变量：变量值在任何地方都存在。&lt;/h2&gt;
&lt;p&gt;通常创建的变量都是全局变量，在整个Lisp系统中都有效。&lt;/p&gt;
&lt;p&gt;通过setq来指定符号的值。&lt;/p&gt;
&lt;h1&gt;Major和Minor Modes&lt;/h1&gt;
&lt;h2&gt;Font Lock Mode&lt;/h2&gt;
&lt;p&gt;Font Lock mode是用于根据缓冲区的语法规则自动设置某些部分的face属性的一项功能。它如何来解析缓冲区依赖于major mode；多数major mode都为自己定义了基于语法规则的face。&lt;/p&gt;
&lt;p&gt;Font Lock mode查找文本并高亮有两个方法：根据语法表通过语法解析或通过搜索（通常是正则表达式）。基于语法的方式先进行；它找出注释和字符串常量并高亮它们。然后再进行基于搜索的操作。&lt;/p&gt;
&lt;h3 id="font-lock-basics"&gt;Font Lock Basics&lt;/h3&gt;
&lt;p&gt;有多个变量可以控制Font Lock mode对文本进行高亮显示。但major modes不应该直接设置其它变量。它应该设置buffer-local变量font-lock-defaults。当Font Lock mode被开启时，将使用这个变量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variable: &lt;code&gt;font-lock-defaults&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个变量由major mode设置为buffer-local变量，用于指定在那种mode下如何显示文本。当设置它时它将自动变为buffer-local变量。如果它的值为nil，Font Lock mode不会高亮，你可以使用&amp;lsquo;Edit&amp;rsquo;下的&amp;lsquo;Text Properties&amp;rsquo;中的&amp;lsquo;Faces&amp;rsquo;菜单显式的设置缓冲区中文本的外观。&lt;/p&gt;
&lt;p&gt;如果它为非nil值，它的值应该类似下面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;(keywords [keywords-only [case-fold
           [syntax-alist [syntax-begin other-vars...]]]])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个元素，keywords间接指定font-lock-keywords的值，它导致基于查询的字体设置。它可以是符号，变量或函数（值是一个用于font-lock-keywords的list）。&lt;/p&gt;</content><category term="emacs"></category></entry><entry><title>Better Builds With Maven 学习笔记</title><link href="/better-builds-with-maven-xue-xi-bi-ji.html" rel="alternate"></link><published>2009-09-21T00:00:00+08:00</published><updated>2009-09-21T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2009-09-21:/better-builds-with-maven-xue-xi-bi-ji.html</id><summary type="html">&lt;h1&gt;开始&lt;/h1&gt;
&lt;h2&gt;准备使用Maven&lt;/h2&gt;
&lt;p&gt;Maven默认读取&lt;user_home&gt;/.m2/settings.xml，通过proxy段的配置设置代理信息。通过mirror段设置镜像服务器。这两个配置在M2_HOME/conf/settings.xml中都有范例。将M2_HOME/bin添加到环境变量。运行&lt;/user_home&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn -version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看使用的Maven版本信息。&lt;/p&gt;
&lt;h3 id="zhao-dao-de-xiang-guan-zi-liao"&gt;找到的相关资料&lt;/h3&gt;
&lt;p&gt;配置环境变量M2_HOME为Maven2的安装目录，这样即使是在使用maven-ant-tasks时也读取M2_HOME/conf/settings.xml。&lt;/p&gt;
&lt;p&gt;在mirrors段添加镜像配置，当前比较快的国内镜像是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;mirror&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;redv.com&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://mirrors.redv.com/maven2&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;mirrorOf&amp;gt;&lt;/span&gt;central&lt;span class="nt"&gt;&amp;lt;/mirrorOf&amp;gt;&lt;/span&gt;
      &lt;span class="c"&gt;&amp;lt;!-- Shanghai, China --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/mirror&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建第一个Maven工程&lt;/h2&gt;
&lt;p&gt;使用Maven的&lt;code&gt;Archetype&lt;/code&gt;机制创建第一个工程。Archetype被定义为原始的模式或模型，从它可以生成同一类型的东西 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;开始&lt;/h1&gt;
&lt;h2&gt;准备使用Maven&lt;/h2&gt;
&lt;p&gt;Maven默认读取&lt;user_home&gt;/.m2/settings.xml，通过proxy段的配置设置代理信息。通过mirror段设置镜像服务器。这两个配置在M2_HOME/conf/settings.xml中都有范例。将M2_HOME/bin添加到环境变量。运行&lt;/user_home&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn -version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看使用的Maven版本信息。&lt;/p&gt;
&lt;h3 id="zhao-dao-de-xiang-guan-zi-liao"&gt;找到的相关资料&lt;/h3&gt;
&lt;p&gt;配置环境变量M2_HOME为Maven2的安装目录，这样即使是在使用maven-ant-tasks时也读取M2_HOME/conf/settings.xml。&lt;/p&gt;
&lt;p&gt;在mirrors段添加镜像配置，当前比较快的国内镜像是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;mirror&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;redv.com&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://mirrors.redv.com/maven2&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;mirrorOf&amp;gt;&lt;/span&gt;central&lt;span class="nt"&gt;&amp;lt;/mirrorOf&amp;gt;&lt;/span&gt;
      &lt;span class="c"&gt;&amp;lt;!-- Shanghai, China --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/mirror&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建第一个Maven工程&lt;/h2&gt;
&lt;p&gt;使用Maven的&lt;code&gt;Archetype&lt;/code&gt;机制创建第一个工程。Archetype被定义为原始的模式或模型，从它可以生成同一类型的东西。在Maven中，Archetype是工程的模板，它与用户输入的一些信息组合起来生成一个全功能的Maven工程。&lt;/p&gt;
&lt;p&gt;创建工程&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn archetype:create -DgroupId=com.mycompany.app -DartifactId=my-app
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将创建一个my-app目录，目录中包含了一个pom.xml文件，它的内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&lt;/span&gt; &lt;span class="na"&gt;xmlns=&lt;/span&gt;&lt;span class="s"&gt;"http://maven.apache.org/POM/4.0.0"&lt;/span&gt; &lt;span class="na"&gt;xmlns:xsi=&lt;/span&gt;&lt;span class="s"&gt;"http://www.w3.org/2001/XMLSchema-instance"&lt;/span&gt;
  &lt;span class="na"&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class="s"&gt;"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.mycompany.app&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mvn-app&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;mvn-app&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.8.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;src目录包含了构建、测试、创建文档、部署工程所需的输入信息。&lt;/p&gt;
&lt;h2&gt;编译应用程序源码&lt;/h2&gt;
&lt;p&gt;进入&lt;my-app&gt;目录，执行：&lt;/my-app&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn compile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将编译源码。Maven遵循&amp;ldquo;约定优于配置&amp;rdquo;的原则，这是Maven的第一个原则。默认情况下，源码放在src/main/java中。这个默认值并不会出现在POM文件中，实际上，它是从父级（根级）POM继承过来的。编译后的classes保存目录也是同样的方式处理的，默认它放在target/classes目录下。&lt;/p&gt;
&lt;p&gt;是什么编译了应用程序源码？这是Maven的第二个原则&amp;ldquo;重用构建逻辑&amp;rdquo;。默认配置中配置了标准编译插件，它用于编译应用程序源码。同样的编译逻辑可以重用于其它的工程中。&lt;/p&gt;
&lt;p&gt;上面了解了Maven如何找到应用程序源码，Maven怎样来编译应用源码，怎样调用编译插件。接下来的问题是，Maven如何能获取编译器插件？在Maven的标准安装中，找不到编译插件，因为它不是与Maven发布版一起发布的。Maven将在需要插件时自动下载插件。&lt;/p&gt;
&lt;p&gt;当第一次执行编译命令（或其它任何命令），Mave将下载这个命令需要的插件及其依赖的其它插件。下次再执行同样的命令时，Maven将不再下载它，命令执行将快很多。&lt;/p&gt;
&lt;h2&gt;编译测试源码执行单元测试&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将进行单元测试。这时Maven将下载更多需要的插件。在执行单元测试前，Maven将编译主代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn test-compile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译测试代码。但是当执行mvn test时总是会先执行compile和test-compile。&lt;/p&gt;
&lt;h2&gt;打包并安装到本地仓库&lt;/h2&gt;
&lt;p&gt;生成jar包执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn package
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看工程的POM文件可以看到packaging元素被设置为jar。Maven通过这个设置了解到需要生成一个JAR文件。&lt;/p&gt;
&lt;p&gt;安装到本地仓库&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以通过修改settings.xml的localRepository设置仓库的位置。&lt;/p&gt;
&lt;p&gt;注意：Surefire插件（它执行test）将按特定的命名约定查看测试代码。默认情况下，下面的测试将被包含：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;**/*Test.java
**/Test*.java
**/*TestCase.java
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的将不被包含：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;**Abstract*Test.java
**/Abstract*TestCase.java
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Maven的重用构建逻辑使得即使是使用默认的POM文件也可以执行大量基础构建操作，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn site
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以为工程生成一个简单网站。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn clean
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将清除target目录下旧的构建数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn idea:idea
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以产生一个IDEA工程。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn eclipse:eclipse
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成一个eclipse工程。&lt;/p&gt;
&lt;h2&gt;处理Classpath资源&lt;/h2&gt;
&lt;p&gt;src/main/resources是Maven推荐的保存资源文件的目录。可以将需要打包到JAR文件的资源放到这个目录。Maven使用的规则是所有放在src/main/resources目录下的文件和目录都将打包到JAR中。&lt;/p&gt;
&lt;p&gt;默认生成的JAR文件中包含了META-INF目录。在这个目录下可以找到MANIFEST.MF和pom.xml和pom.properties。你可以创建自己的mainfest文件，如果不创建Maven将自动生成一个。也可以包含自己的资源文件，例如在src/main/resources目录下添加一个application.properties文件，重新打包则资源文件也将也现在JAR包中。&lt;/p&gt;
&lt;p&gt;pom.xml和pom.properties文件被打包到JAR以便由Maven的每个artifact生成的JAR包都是自描述的，并且允许你包含自己的应用中的原数据。最简单的应用可能就是用于获取应用的版本号。操作POM文件需要使用Maven的工具，但是propertiest文件却可以使用标准Java API。&lt;/p&gt;
&lt;h3 id="chu-li-ce-shi-yong-classpathde-zi-yuan"&gt;处理测试用Classpath的资源&lt;/h3&gt;
&lt;p&gt;添加资源到单元测试classpath，可以将资源添加到src/test/resources目录。在单元测试中，使用下面的代码片段在测试阶段访问资源：
&lt;src lang="java"&gt;
// Retrieve resource
InputStream is = getClass().getResourceAsStream( "/test.properties" );
// Do something with the resource
&lt;/src&gt;&lt;/p&gt;
&lt;p&gt;可以使用下面的配置覆盖maven-jar-plugin的默认配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-jar-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;archive&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;manifestFile&amp;gt;&lt;/span&gt;META-INF/MANIFEST.MF&lt;span class="nt"&gt;&amp;lt;/manifestFile&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/archive&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="guo-lu-classpathzi-yuan"&gt;过滤Classpath资源&lt;/h3&gt;
&lt;p&gt;有时资源文件中包含的一些值在构建时才能提供。Maven中可以使用资源过滤，动态的将资源属性值设置到资源文件中。将资源文件中的属性值设置为${&lt;property name=""&gt;}，这个属性可以是pom.xml或用户的settings.xml中定义的属性，或定义在外部properties文件，或都是系统属性。&lt;/property&gt;&lt;/p&gt;
&lt;p&gt;需要将pom.xml中将需要进行过滤处理的资源目录的filtering属性设置为true。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.mycompany.app&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;my-app&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Maven Quick Start Archetype&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.8.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;resources&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filtering&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/filtering&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/resources&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用资源过滤的举例：创建src/main/resources/META-INF/application.properties，内容设置为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# application.properties
application.name=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
application.version=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn process-resources
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;target/classes目录下的application.properties文件内容将变为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# application.properties
application.name=Maven Quick Start Archetype
application.version=1.0-SNAPSHOT
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要引用外部propertiest文件中的属性值，需要在pom.xml中添加对外部文件的引用。例如，创建一个外部资源文件src/main/filters/filter.properties：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# filter.properties
my.filter.value=hello!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将对它的引用添加到pom.xml中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;filters&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;filter&amp;gt;&lt;/span&gt;src/main/filters/filter.properties&lt;span class="nt"&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/filters&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;resources&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;filtering&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/filtering&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/resources&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在application.propertiest文件中引用对应的属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# application.properties
application.name=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
application.version=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
message=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行mvn process-resources命令时会将message替换为外部文件中my.filter.value属性对应的值。&lt;/p&gt;
&lt;p&gt;也可以在pom文件的properties段定义这些属性值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.mycompany.app&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;my-app&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Maven Quick Start Archetype&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.8.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;resources&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filtering&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/filtering&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/resources&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;my.filter.value&amp;gt;&lt;/span&gt;hello&lt;span class="nt"&gt;&amp;lt;/my.filter.value&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;资源过滤也可以获取系统属性，也可以是编译到Java中的（java.version或user.home），或使用Java -D参数在命令行指定的属性。例如将application.propertiest文件设置为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# application.properties
java.version=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
command.line.prop=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prop&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后执行下面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn process-resources "-Dcommand.line.prop=hello again"
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="fang-zhi-guo-lu-er-jin-zhi-zi-yuan"&gt;防止过滤二进制资源&lt;/h3&gt;
&lt;p&gt;某些情况下我们不希望属性过滤处理某些资源文件。比如图像文件。&lt;/p&gt;
&lt;p&gt;比如src/main/resources/images不希望被过滤，这时应该排除这些资源。pom.xml设置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;resources&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filtering&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/filtering&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;excludes&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;exclude&amp;gt;&lt;/span&gt;images/**&lt;span class="nt"&gt;&amp;lt;/exclude&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/excludes&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/resources&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;includes&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;include&amp;gt;&lt;/span&gt;images/**&lt;span class="nt"&gt;&amp;lt;/include&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/includes&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/resources&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;使用Maven插件&lt;/h2&gt;
&lt;p&gt;配置Maven插件的参数。&lt;/p&gt;
&lt;p&gt;例如，指定Java编译器只允许编译JDK 5.0的源码。可以在POM中添加设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;source&amp;gt;&lt;/span&gt;1.5&lt;span class="nt"&gt;&amp;lt;/source&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;target&amp;gt;&lt;/span&gt;1.5&lt;span class="nt"&gt;&amp;lt;/target&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Maven 2的插件和工程的依赖很相似，在某种程度上它们确实如此。如果在本地找不到插件，则将自动下载插件，这更是与依赖关系的处理相同。插件与依赖同相样有groupId和version元素，但多数情况下这些元素不需要。&lt;/p&gt;
&lt;p&gt;如果不指定groupId，则Maven将搜索org.apache.maven.plugins或org.codehause.mojo这两个groupId。你也可以在POM或settings.xml中指定goupId。&lt;/p&gt;
&lt;p&gt;如果不指定版本Maven将尝试获取指定插件的最新版本。&lt;/p&gt;
&lt;p&gt;通过mvn help:describe命令可以找到插件可选配置项。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn help:describe -DgroupId=org.apache.maven.plugins \
 -DartifactId=maven-compiler-plugin -Dfull=true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以在 http://maven.apache.org/plugins/ 使用Maven Plugin Reference找到相关插件的配置信息。&lt;/p&gt;
&lt;h1&gt;使用Maven创建应用&lt;/h1&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;将要创建的应用名叫Proficio，拉丁语的"help"。&lt;/p&gt;
&lt;h2&gt;设置应用程序的目录结构&lt;/h2&gt;
&lt;p&gt;在设置Proficio的目录结构时，注意Maven强调的实践标准化和构建模块化构建是很重要的。&lt;/p&gt;
&lt;p&gt;这种实践自然将产生分离的可重用的开发工程。决定如何最优化的分解应用的原则叫做&amp;ldquo;分离关注点（Separation of Concerns）&amp;rdquo;原则，即SoC原则。&lt;/p&gt;
&lt;p&gt;SoC有助于识别、封装、操作于有相关特殊概念、目标、任务或目的的软件片段。关注点是组织和分解软件的动力，更多的易于管理和理解的部分，每个都用于说明一个或多个特定关注点。&lt;/p&gt;
&lt;p&gt;如上所述，Proficio样例工程将被设置为多个Maven模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Proficio API：Proficio的应用编程接口，它包含了一套接口。这些接口是主要组件（例如store）的API。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proficio CLI：提供Proficio的命令行接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proficio Core：API的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proficio Model：Proficio应用的数据模型，它包含了将被整个Proficio工程所使用的所有的类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Proficio Stores：这个模块处理包含所有的存储模块。Proficio有一个简单的memory-based和XStream-based存储。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Proficio的顶层POM中，可以看到所有子模块元素。一个模块指向另一个Maven工程，实际上它是指向另一个POM。Proficio的顶层POM文件如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;pom&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Maven Proficio&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;modules&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;proficio-model&lt;span class="nt"&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;proficio-api&lt;span class="nt"&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;proficio-core&lt;span class="nt"&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;proficio-stores&lt;span class="nt"&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;proficio-cli&lt;span class="nt"&gt;&amp;lt;/module&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/modules&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的版本号1.0-SNAPSHOT。对于一个有多模块的应用，通常将所有模块一起发布，所有模块使用一个公共的版本号。这是推荐的一种方式。&lt;/p&gt;
&lt;p&gt;注意上面的packaging元素，这里它被设置为pom。对于包含模块的POM文件，packaging必须设置为pom：这告诉Maven你准备创建一个模块集。&lt;/p&gt;
&lt;p&gt;Proficio应用的模块打包类型：
模块 || 打包类型
proficio-api | jar
proficio-cli | jar
proficio-core | jar
proficio-module | jar
proficio-stores | pom&lt;/p&gt;
&lt;p&gt;proficio-stores模块有两个子模块。&lt;/p&gt;
&lt;h2&gt;使用工程继承&lt;/h2&gt;
&lt;p&gt;Maven最重要的功能之一就是工程继承。使用工程继承允许你在一个地方规定组织机构信息，规定部署信息，或规定通用的依赖。由Proficio工程产生的每个工程的POM文件，每个的顶部都有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[...]&lt;/span&gt;
&lt;span class="na"&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;
  &lt;span class="na"&gt;&amp;lt;groupId&amp;gt;com.devzuz.mvnbook.proficio&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="na"&gt;&amp;lt;artifactId&amp;gt;proficio&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="na"&gt;&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class="na"&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个片段允许你从指定的顶层的POM继承。顶层POM中指定了依赖JUnit 3.8.1。在这种情况下子工程中不再申明这个依赖也可以使用这个包。&lt;/p&gt;
&lt;p&gt;为了了解在继承处理时发生的东西可以执行mvn help:effective-pom命令。这个命令将显示出最终的POM。在proficio的子工程中执行这个命令时可以看到依赖中出现了JUnit 3.8.1。&lt;/p&gt;
&lt;h2&gt;管理依赖关系&lt;/h2&gt;
&lt;p&gt;Maven可以让不同的工程共享程序包。&lt;/p&gt;
&lt;p&gt;可以在顶层的POM中描述所有子工程共享的依赖。&lt;/p&gt;
&lt;p&gt;例如Proficio的顶层POM：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-model&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-api&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-store-memory&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-store-xstream&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-core&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-container-default&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-9&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意${project.version}指定了版本，它与应用的版本对应。&lt;/p&gt;
&lt;p&gt;在dependencyManagement一节，有多个Proficio依赖并且还依赖于Plexus IoC container。dependencyManagment元素与顶层POM的dependencies有重要区别。&lt;/p&gt;
&lt;p&gt;dependencyManagement元素中包括的dependencies元素仅用于说明引用的版本号，对并不影响工程的依赖关系图，然而顶层的dependencies元素将影响依赖关系图。查看proficio-api模块的POM将只看到引用而没有指定版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-model&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个依赖的版本号是从Proficio的顶层POM文件的dependencyManagement继承过来的。dependencyManagement指定了引用proficio-model的版本号为1.0-SNAPSHOT（被设置为${project.version}）这个版本号将注入到上面的依赖中。dependencyManagement中说明的dependencies只用于当某个依赖没有版本号的情况。&lt;/p&gt;
&lt;h2&gt;使用快照&lt;/h2&gt;
&lt;p&gt;当开发的应用具有多个模块时，通常每个模块的版本都在变更。API可能正在经历变迁或你的实现正在发生改变，或者在进行重构。你在构建时需要非常容易的实时获取最新版本，这是Maven的快照（snapshot）的概念。快照是Maven的一个artifact。查看Proficio的顶层POM可以看到指定了快照版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-model&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-api&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-container-default&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-9&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;指定快照版本作为依赖时Maven将会查找新版本而不像手工指定版本时那样操作。快照依赖假定总是在变更，因此Maven将尝试更新它们。默认情况下Maven将以天为单位查找新版本，但你可以使用命令行参数-U来强制它查找新版本。当指定非快照的依赖时Maven将下载依赖并且不会进行重试。
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;解决依赖冲突和使用版本号范围&lt;/h2&gt;
&lt;p&gt;在Maven 2.0中通过引入依赖传递，使得可以在简单的POM文件中只指定你直接需要的依赖，并且Maven可以计算出完整的依赖关系图。但是，随着图的增涨，不可避免的将产生一个或多个artifacts需要依赖的不同版本。这种情况下，Maven必须选择使用哪个版本。&lt;/p&gt;
&lt;p&gt;Maven通常选择这个关系树中顶层的&amp;ldquo;最接近的版本（nearest）&amp;rdquo;，Maven选择版本号跨度最小的版本。如果在POM中指定了版本，则将被使用而不管其它的原因。但这种方式也有下面的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;选择的版本可能没有某个依赖的组件所需要的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在相同的级别先择了多个不同的版本，则结果将是不明确的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;手工解决冲突，可以从依赖树中移除不正确的版本，或者可以用正确的版本来覆盖掉树中的版本。移除不正确的版本需要在运行Maven时指定-X标识来找出不正确的版本。例如，如果在proficio-core模块运行mvn -X test将输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;proficio-core&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;0-SNAPSHOT&lt;/span&gt;
  &lt;span class="nt"&gt;junit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;1&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;test&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="nt"&gt;plexus-container-default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;0-alpha-9&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nt"&gt;plexus-utils&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;4&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nt"&gt;classworlds&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;1-alpha-2&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nt"&gt;junit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;8&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;1&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;not&lt;/span&gt; &lt;span class="nt"&gt;setting&lt;/span&gt; &lt;span class="nt"&gt;scope&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;local&lt;/span&gt; &lt;span class="nt"&gt;scope&lt;/span&gt; &lt;span class="nt"&gt;test&lt;/span&gt; &lt;span class="nt"&gt;wins&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="nt"&gt;proficio-api&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;0-SNAPSHOT&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nt"&gt;proficio-model&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;0-SNAPSHOT&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="nt"&gt;plexus-utils&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nd"&gt;1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;1&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;selected&lt;/span&gt; &lt;span class="nt"&gt;for&lt;/span&gt; &lt;span class="nt"&gt;compile&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样可以找出当前操作所使用的详细版本信息，一旦找出了不正确的版本，你可以将它从依赖关系图中移除。例如，这个例子中，plexus-utils出现了两次，Proficio需要1.1版。为确保这个依赖，可以修改plexus-container-default的依赖，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-container-default&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-9&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;exclusions&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;exclusion&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-utils&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/exclusion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/exclusions&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这保证了Maven将忽略1.04版的plexus-utils，而使用1.1版。&lt;/p&gt;
&lt;p&gt;另一种方法确保在依赖中使用特定版本，是将它直接包含在POM中，例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-utils&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;runtime&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这种方式是不被推荐的除非你是在制作一个绑定了自己的依赖的artifact，并且它自身不会作为一个依赖（例如，是一个WAR文件）。原因是这种做法歪曲了真实的依赖关系图，在工程自身作为依赖被重用时将导致问题。&lt;/p&gt;
&lt;p&gt;在这里指定了runtime作用范围。这是因为，在这种情况下，依赖只是用于打包而不是编译。实际上，如果依赖是在编译时需要，它应该总是出现在当前POM的依赖中&amp;mdash;&amp;mdash;而不管另一个依赖是否使用了它。&lt;/p&gt;
&lt;p&gt;上面的这些解决都只是理想化的，但它可以提高你自己的依赖的质量，避免你在构建自己的产品时的风险。这一点在构建一个应用程序框架时是非常重要的，因为它将广泛的被其它人使用。为达到这个目标，可以使用版本范围来替代这种方式。&lt;/p&gt;
&lt;p&gt;当上面的plexus-utils的版本被设置为1.1时，标明首选依赖的是1.1版，但其它版本可能也能够接受。Maven并不知道哪个版本可以工作，因此当与其它依赖冲突时，Maven确保所有的版本使用前面描述的&amp;ldquo;最近依赖（nearest dependency）&amp;rdquo;技术来决定使用哪个版本。&lt;/p&gt;
&lt;p&gt;但是，你可能需要一个plexus-utils 1.1版中的功能。这时，依赖应该指定为下面的形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.plexus&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;plexus-utils&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;[1.1,)&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表示在版本冲突时仍将使用nearest dependency技术，但是版本号必须符合给定的范围。如果版本不匹配，则下一个最接近的版本将被测试，如此继续。最后，如果没有匹配的版本，或本来就没有冲突，则使用指定的版本[1.1,)。这表示将从仓库中获取最小的版本号大于或等于1.1的版本。&lt;/p&gt;
&lt;p&gt;版本范围范例表：&lt;/p&gt;
&lt;p&gt;范围 || 含义
(,1.0] | 小于或等于1.0
[1.2,1.3] | 处于1.2和1.3之间（含1.3）
[1.0,2.0) | 大于或等于1.0，但小于2.0
[1.5,) | 大于或等于1.5
(,1.1),(1.1,) | 除1.1外的任何版本&lt;/p&gt;
&lt;p&gt;通过指定使用的版本范围，使得构建时依赖管理机制更加可靠并且减少异常的情况。但应该避免过度的详细。例如，如果两个版本范围依赖图不交叉，那么构建将失败。&lt;/p&gt;
&lt;p&gt;为了解版本范围是如何工作的，需要了解版本是怎样进行比较的。下面展示了Maven是如何分割版本号的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1.0.1-20060211.131141-1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从左至右依次为：&lt;/p&gt;
&lt;p&gt;1为主版本号&lt;/p&gt;
&lt;p&gt;0为次版本号&lt;/p&gt;
&lt;p&gt;1为Bug修正号&lt;/p&gt;
&lt;p&gt;20060211.131141为限定版本号&lt;/p&gt;
&lt;p&gt;1为构建号&lt;/p&gt;
&lt;p&gt;在目前的版本方案中，快照版本是一种特殊的情况，在这种情况下限定号和构建号可以同时存在。在正式版本中，可以只提供限定号或只提供构建号。有意设置的限定号标识出了一个较优先的版本（例如：alpha-1，beta-1，rc1）。对于快照版本，限定号必须是文本&amp;ldquo;snapshot&amp;rdquo;或时间戳。构建号是一个自增号在发布时标明是补丁构建。&lt;/p&gt;
&lt;p&gt;版本中的元素依次决定哪个版本较新&amp;mdash;&amp;mdash;首先是主版本号，如果主版本号相等，则比较次版本号，接下来是Bug修正号，限定号，最后比较构建号。带限定号的版本比不带限定号的版本要旧；比如1.2-beta比1.2旧。包含了构建号的版本比不带构建号的版本新；比如1.2-beta-1比1.2-beta新。某些情况下，版本可能会不匹配这个语法。在这些情况下，两个版本号将作为字符串进行比较。&lt;/p&gt;
&lt;p&gt;当使用快照版本测试编译发布版本或自己测试发布测试版本时应该将它们部署到快照仓库，这将在第七章讨论。这保证了在版本范围中的beta版本才会使用，除非工程显式的申明了使用快照版本。&lt;/p&gt;
&lt;p&gt;最后要注意的是当使用版本范围时版本更新是如何被决定的。这个机制与前面介绍的快照版本更新机制是相同的，即每天从版本库中更新一次版本。但是，这可以通过配置每个仓库来设置更新的频率，或在命令行使用-U参数强制Maven执行更新。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;releases&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;updatePolicy&amp;gt;&lt;/span&gt;interval:60&lt;span class="nt"&gt;&amp;lt;/updatePolicy&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/releases&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;利用构建生命周期&lt;/h2&gt;
&lt;p&gt;第二章中将Maven描述为一个正确调整插件执行方式或顺序的应用框架，这实际上就是Maven的默认构建生命周期。Maven默认的构建生命周期对于大多数工程来说不需要增加任何内容就可以满足了&amp;mdash;&amp;mdash;当然，有时工程需要增加不同的内容到Maven的默认构生命周期来满足构建的需求。&lt;/p&gt;
&lt;p&gt;例如，Proficio需要从model生成Java源码。Maven通过允许申明插件来满足这个需求，将它绑定到Maven默认生命周期的一个标准阶段&amp;mdash;&amp;mdash;generate-sources阶段。&lt;/p&gt;
&lt;p&gt;Maven的插件是为特定任务而创建的，这意味着插件将被绑定到默认的生命周期的一个特定阶段。在Proficio中，Modello插件被用于生成Proficio的数据模型的Java源码。查看proficio-model的POM可以看到plugins元素配置了Modello插件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.proficio&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;proficio-model&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Model&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.codehaus.modello&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;modello-maven-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-5&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;java&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;packageWithVersion&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/packageWithVersion&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;model&amp;gt;&lt;/span&gt;src/main/mdo/proficio.mdo&lt;span class="nt"&gt;&amp;lt;/model&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这与第二章中maven-compiler-plugin的申明非常相似，但这里可以看到额外的execution元素。Maven中的插件可以有多个goal，因此你需要指定你希望运行插件的哪个goal，这可以通过在execution中的goal元素来指定。&lt;/p&gt;
&lt;h2&gt;使用Profiles&lt;/h2&gt;
&lt;p&gt;Profile是Maven提供的用于创建构建生命周期中的不同环境变量、不同的平台、不同JVM、不同的测试数据库、或引用不同的本地文件系统的方法。通常你可以在POM中封装，以保证构建的可移植性，但有时你需要考虑变化的交叉系统的情况，这也是Maven中引入profile的原因。&lt;/p&gt;
&lt;p&gt;Profile使用POM中的一个子集元素来指定，可以用多种方式来启用。Profile在构建时修改POM，意味着它将用于给不同的目标环境中的参数集（比如，在开发环境、测试环境、产品环境下应用服务器根路径）不同参数值。&lt;/p&gt;
&lt;p&gt;Profile也可以很容易的实现团队中不同成员生成不同的构建结果。也可以通过profile阻止构建的移植性。Profile可以定义在下面三个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Maven的配置文件（通常是&lt;user_home&gt;/.m2/settings.xml）&lt;/user_home&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与POM同一目录下的名为profiles.xml的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POM文件中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优先级依次为POM文件、profiles.xml、settings.xml。这也是Maven中的基本原则。&lt;/p&gt;
&lt;p&gt;settings.xml中设置profile会影响所有的构建，因此它适合&amp;ldquo;全局&amp;rdquo;的profiles。profiles.xml允许设置单个工程的构建而不用修改POM。基于POM的profiles是首选方式，因为这样更具有移植性（它们将在布署时发布到仓库，对于源于仓库的子构建或依赖来说也同样有效）。&lt;/p&gt;
&lt;p&gt;因为移植性的原因，那些不会发布到仓库中的文件不允许修改任何基础构建。因此，profiles.xml和settings.xml只允许定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;仓库repositories&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插件仓库pluginRepositories&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性properties&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其它的信息必须在POM的profile中指定或在POM自身指定。例如，如果settings.xml中有一个profile它可以注入一个依赖，你的工程运行需要settings注入的依赖，一旦这个工程部部署到仓库中它将不能解决它的依赖。因为其中一个依赖设置在settings.xml的profile中了。&lt;/p&gt;
&lt;p&gt;注意：respositories、pluginRepositories和properties也可以在POM内部的profiles指定。因此，在POM外部指定的profiles只允许使用POM内部指定的profiles选项的一个小的子集。&lt;/p&gt;
&lt;p&gt;可以在POM中定义的profile：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;repositories&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pluginRepositories&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dependencies&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;plugins&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;properties(not actually available in the main POM, but used behind the scenes)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;modules&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reporting&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dependencyManagement&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;distributionManagement&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构建元素的子集，由下面组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;defaultGoal&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;resources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;testResources&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;finalName&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有多种方法启用profiles：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在命令行上使用-P选项。这个选项接收以逗号名分隔的profile的id列表。当指定这个选项时，这些指定在参数中的profiles将被激活。例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn -Pprofile1,profile2 install
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Profiles可以在Maven settings文件通过activeProfiles段中激活。这段接收activeProfile元素的列表，每个都包括了一个profile-id。注意你必须在settings.xml文件中定义了这些profiles。例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;settings&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;profiles&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;profile1&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      [...]
    &lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/profiles&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;activeProfiles&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;activeProfile&amp;gt;&lt;/span&gt;profile1&lt;span class="nt"&gt;&amp;lt;/activeProfile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/activeProfiles&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/settings&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Profiles可以在检测到构建环境时自动触发。这些在profile的activation段设置。目前这种检测仅限于匹配JDK版本号的前缀、当前系统属性或系统属性的值。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;profile1&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;activation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;jdk&amp;gt;&lt;/span&gt;1.4&lt;span class="nt"&gt;&amp;lt;/jdk&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/activation&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个激器将在JDK的版本以1.4开始时被触发。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;profile1&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;activation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;debug&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/activation&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的profile将在系统属性debug被指定时被触发。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;profile1&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;activation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;environment&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/activation&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的这个例子将在系统属性environment属性设置为true时激活。&lt;/p&gt;
&lt;p&gt;在熟悉profiles后，可以使用它组装不同的Proficio系统：一个配置方案是memory-base存储，另一个是XStream-based存储。这些将在proficio-cli模块中使用。proficio-cli模块的profile定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
 [...]
 &lt;span class="c"&gt;&amp;lt;!-- Profiles for the two assemblies to create for deployment --&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;profiles&amp;gt;&lt;/span&gt;
  &lt;span class="c"&gt;&amp;lt;!-- Profile which creates an assembly using the memory based store --&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;memory&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-assembly-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;descriptors&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;descriptor&amp;gt;&lt;/span&gt;src/main/assembly/assembly-store-memory.xml&lt;span class="nt"&gt;&amp;lt;/descriptor&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;/descriptors&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;activation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;memory&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/activation&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
  &lt;span class="c"&gt;&amp;lt;!-- Profile which creates an assembly using the xstream based store --&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;xstream&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-assembly-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;descriptors&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;descriptor&amp;gt;&lt;/span&gt;src/main/assembly/assembly-store-xstream.xml&lt;span class="nt"&gt;&amp;lt;/descriptor&amp;gt;&lt;/span&gt;
       &lt;span class="nt"&gt;&amp;lt;/descriptors&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;activation&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;xstream&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/activation&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/profiles&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到两个profiles：一个id为memory另一个id为xstream。在每个profile中你可以配置插件。也可以看到profile通过一个系统属性进行激活。这个例子依赖于前面已经执行过的一些构建步骤，因此应该先在工程的顶级目录执行mvn install确保需要的组件被安装到本地仓库。&lt;/p&gt;
&lt;p&gt;如果想基于memory-based存储进行构建，可以执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn -Dmemory clean assembly:assembly
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想基于XStream-based存储进行，可以执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn -Dxstream clean assembly:assembly
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种方式构建的结果都保存在target目录中，如果对输出使用jar tvf命令，可以看到memory-base方式构建时只包含了proficio-store-memory-1.0-SNAPSHOT.jar，当使用XStream-based方式时，只包含了proficio-store-xstream-1.0-SNAPSHOT.jar。&lt;/p&gt;
&lt;h2&gt;部署应用&lt;/h2&gt;
&lt;p&gt;当前Maven支持多种部署方式包括文件系统部署、SSH2部署、SFTP部署、FTP部署和外部SSH部署。为了进行部署，需要正确的配置POM中的distributionManagement元素，通常是在顶级POM中，因为子POM可以继承这些信息。&lt;/p&gt;
&lt;h3 id="wen-jian-xi-tong-bu-shu"&gt;文件系统部署&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;proficio-repository&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Repository&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;file://&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;basedir&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/target/deploy&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="ssh2bu-shu"&gt;SSH2部署&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;proficio-repository&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Repository&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;scp://sshserver.yourcompany.com/deploy&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="sftpbu-shu"&gt;SFTP部署&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;proficio-repository&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Repository&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;sftp://ftpserver.yourcompany.com/deploy&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="wai-bu-sshbu-shu"&gt;外部SSH部署&lt;/h3&gt;
&lt;p&gt;前面三个部署方式是包含在Maven内部的，因此只需要distributionMangement元素，但使用外部SSH命令部署则还要使用一个构建扩展。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;proficio-repository&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Repository&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;scpexe://sshserver.yourcompany.com/deploy&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;extensions&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;extension&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.wagon&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;wagon-ssh-external&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-6&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/extension&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/extensions&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个构建扩展指定使用Wagon外部SSH提供都，它将你的文件移动到远程服务器上。Wagon是Maven中通用的用于传送的机制。&lt;/p&gt;
&lt;h3 id="ftpbu-shu"&gt;FTP部署&lt;/h3&gt;
&lt;p&gt;FTP部署也必须指定一个构建扩展。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;distributionManagement&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;proficio-repository&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio Repository&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;ftp://ftpserver.yourcompany.com/deploy&lt;span class="nt"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/distributionManagement&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;extensions&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;extension&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.wagon&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;wagon-ftp&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-alpha-6&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/extension&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/extensions&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦配置完POM后，可以执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn deploy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进行部署。&lt;/p&gt;
&lt;h2&gt;为应用程序创建Web站点&lt;/h2&gt;
&lt;p&gt;前面已经完成了Proficio的构建、测试、部署，现在可以为这个应用创建一个标准的Web站点。对于Procio这样的应，推荐在顶级目录创建用于生成站点的资源目录。&lt;/p&gt;
&lt;p&gt;所有用于生成站点的文件保存在src/site目录。src/site目录中也有子目录保存支持文档。Maven支持大量同的文件格式。&lt;/p&gt;
&lt;p&gt;当前支持得最好的格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;XDOC格式，它是一个被Apache广泛使用的简单的XML格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;APT（Almost Plain Text）,与wiki格式类似的格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FML格式，FAQ格式。一个简单的XML格式管理FAQ。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DocBook Simple格式，它是一个比完整的DocBook格式简单一些的格式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Maven也有限的支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Twiki格式，这是一种流行的Wiki格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confluence格式，这是另一种流行的Wiki格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DocBook格式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在后面的章节将了解支持较好的那些格式，但你应该熟悉下面的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;配置banner的外观。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置站点的皮肤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置发布数据的格式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置banner下显示的链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置放入生成的页面的&lt;head&gt;&lt;/head&gt;元素中的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置显示在导航栏中的菜单项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置项目报表的外观。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看Proficio应用的src/site可以看到站点的描述：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Proficio"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;bannerLeft&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;href&amp;gt;&lt;/span&gt;http://maven.apache.org/&lt;span class="nt"&gt;&amp;lt;/href&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/bannerLeft&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;bannerRight&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Proficio&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;src&amp;gt;&lt;/span&gt;http://maven.apache.org/images/apache-maven project.png&lt;span class="nt"&gt;&amp;lt;/src&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/bannerRight&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;skin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.skins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-default-skin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/skin&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;publishDate&lt;/span&gt; &lt;span class="na"&gt;format=&lt;/span&gt;&lt;span class="s"&gt;"dd MMM yyyy"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;links&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;item&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Apache"&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://www.apache.org/"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;item&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Maven"&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://maven.apache.org/"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;item&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Continuum"&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://maven.apache.org/continuum"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/links&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&amp;lt;meta&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"faq"&lt;/span&gt; &lt;span class="na"&gt;content=&lt;/span&gt;&lt;span class="s"&gt;"proficio"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;menu&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Quick Links"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;item&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"Features"&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"/maven-features.html"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/menu&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;menu&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"About Proficio"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;item&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"What is Proficio?"&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"/what-is-maven.html"/&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/menu&amp;gt;&lt;/span&gt;
    &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;reports&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个相当标准的Web站点描述，每个元素的说明如下：&lt;/p&gt;
&lt;p&gt;站点描述元素 || 说明
bannerLeft and bannerRight | 这些元素包括名称、href和可选的src元素，可以用于图像。
skin | 这个元素看起来像是依赖的描述（使用了相同的机制来获取皮肤）控制站点使用的皮肤。
publishDate | 发布日期的格式，使用的Java类中的SimpleDateFormat。
body/links | 控制banner下的链接引用只需要name和href。
body/head | head元素允许你插入任何信息到生成的页面。可以加metadata、script（如Google Analytics）。&lt;/p&gt;
&lt;p&gt;Maven中最流行的功能之一就是花较少的功夫就可以生成标准的报表。只要简单的在站点描述中包含${reports}引用，默认情况下是包含的，工程信息报表将自动生成的被添加上来。标准的工程信息报表包含下面的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;依赖关系报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;邮件列表报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持续集成报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源码仓库报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发行版本跟踪报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工程团队报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;版权&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管标准报表很有用，通常你需要自定义工程的报表。报表的创建和显示控制是在POM的build/reports元素中。你可以选择生成报表的信息，只要列举出需要包含在站点中的报表即可。这个插件的配置方式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;reporting&amp;gt;&lt;/span&gt;
    [...]
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-project-info-reports-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;reportSets&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;reportSet&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;reports&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;dependencies&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;project-team&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;mailing-list&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;cim&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
              &lt;span class="c"&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class="c"&gt;              Issue tracking report will be omitted&lt;/span&gt;
&lt;span class="c"&gt;              &amp;lt;report&amp;gt;issue-tracking&amp;lt;/report&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;              --&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;license&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;report&amp;gt;&lt;/span&gt;scm&lt;span class="nt"&gt;&amp;lt;/report&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/reports&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/reportSet&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/reportSets&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
    [...]
  &lt;span class="nt"&gt;&amp;lt;/reporting&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn site
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成站点。&lt;/p&gt;
&lt;p&gt;生成的站点放在target目录下。如果有其它的资源，如图片、PDF等可以存放在src/site/resources。当站点被生成时src/site/resources将被复制到站点的顶级目录。&lt;/p&gt;
&lt;h1&gt;构建J2EE应用程序&lt;/h1&gt;
&lt;h1&gt;开发Maven插件&lt;/h1&gt;
&lt;p&gt;如第二章所述，Maven实际上是一个平台，它在构建生命周期中执行插件来执行构建一个项目时需要进行的任务。Maven核心API处理与POM定义相关操作，解决工程的依赖关系，组织和运行插件。实际执行任务或工作是由一套与工程的构建生命周期相关联的插件集来完成的。这使得Maven的插件框架极其重要，不光是在构建工程的过种中，在对工程的功能进行扩展，如集成外部工具和系统时也同样重要。&lt;/p&gt;
&lt;p&gt;多数工程中Maven提供的插件足够满足多数构建过程的需要。即使要执行一些特殊的任务，也可能已经存在了这样的插件。可以在Apache Maven project和CodeHaus Mojo project或其它第三方网站找到与Maven集成的插件。如果找不到合适的插件，可能就需要编写客户化插件将这些任务集成到构建生命周期中。&lt;/p&gt;
&lt;h2&gt;回顾插件技术&lt;/h2&gt;
&lt;p&gt;Mojo是Maven应用的基本工作单元。它执行原子性的构建任务，用于描述构建过程中的单个步骤。一些mojo结合起来完成相关的任务，它们被打包到plugin中。&lt;/p&gt;
&lt;p&gt;与Java中的包一样，plugin提供了分组的机制，将在构建生命周期中提供类似功能的多个mojo进行分组。比如，maven-compiler-plugin包含两个mojo：compile和testCompile。在这里，它们的任务都是编译代码。对这些mojo进行打包向用户提供了一致的访问机制，允许共享POM中添加的单个段的配置。另外，它也使mojo之间共享代码更方便。&lt;/p&gt;
&lt;p&gt;Mojo描述了构建过程中的单个任务。工程的构建过程包含了一套mojo的集合，它们按定义好的特定顺序执行。这个顺序被称为&amp;ldquo;构建生命周期&amp;rdquo;，它被定义为一套任务分类的集合，称为&amp;ldquo;构建阶段&amp;rdquo;。当Maven执行构建时，它按生命周期顺序执行每个阶段相关的mojo。&lt;/p&gt;
&lt;p&gt;mojo与构建阶段的关系被称为&amp;ldquo;构建building&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;Maven实际上定义了三个不同的构建周期，这章讨论默认的构建生命周期，它用于主要的构建活动（其它两个处理清理工作目录和生成Web站点）。&lt;/p&gt;
&lt;p&gt;多数mojo被分为不同的分类，对应于构建生命周期的阶段。因此，mojo自然的与一个阶段绑定，这决定了在这个周期中的某个任务该在何时执行。由于阶段绑定提供了mojo在生命周期中的分组机制，通过连续的各个阶段可以决定前一个价码应该做什么。因此，为确保与其它插件的兼容，为你的插件提供恰当的阶段绑定是很重要的。&lt;/p&gt;
&lt;p&gt;mojo通常指定了一个默认的阶段绑定，它们可以被绑定到构建过程的任何阶段。甚至，一个mojo可以通过配置工程POM文件的executions段被绑定到同一构建生命周期的多个位置。每个excution可以为它申明的mojo集合指定一个单独的构建阶段。但是，在mojo执行前，它可能需要某些活动先被执行完成，因此应该在重新绑定mojo之前检查文档以了解它。&lt;/p&gt;
&lt;p&gt;某些情况下，mojo可以被设计为独立于构建生命周期之外。比如mojo可能从版本库中检出代码，或为一个新的工程创建目录结构。这些mojo通常是被直接调用的，它们不会与构建生命周期的某个阶段绑定，因为他们不能被自动划分到典型的构建过程中。讨论这些mojo与Maven构建过程本身有些跑题了，因为它们通常是由POM的维护者执行的任务，或通过集成外部开发工具来完成。&lt;/p&gt;
&lt;h2&gt;开始插件开发&lt;/h2&gt;
&lt;p&gt;为了了解Maven插件开发技术，你需要较好的了解插件是如何构建的以及它们如何与他们的环境进行交互。作为插件开发都，你必须了解构建生命周期阶段的绑定和参数的注入。了解这个框架使你了解每个mojo都需要的Maven构建状态信息，并决定将mojo绑定到哪个构建阶段。&lt;/p&gt;
&lt;h3 id="cha-jian-kuang-jia"&gt;插件框架&lt;/h3&gt;
&lt;p&gt;Maven提为插件供了强大的框架，包括较好的生命周期定义，依赖关系管理，参数解析和注入。通过生命周期，Maven也较好的定义了生成工程发布包等等。将mojo绑定到构建生命周期使得mojo可以知道哪些处理阶段已经完成了。使用Maven的参数注入，使mojo可以获取构建的状态。参数注入和生命周期绑定是所有mojo开发的基础。&lt;/p&gt;
&lt;h4 id="can-yu-gou-jian-sheng-ming-zhou-qi"&gt;参与构建生命周期&lt;/h4&gt;
&lt;p&gt;大多数插件完全由mojo组成并根据它们的功能被绑定到构建生命周期的各个阶段。例如，某个工程的源码需要被编译并被打包到一个jar文件中以便发布。在这个构建过程中，Maven将为生成&amp;lsquo;jar&amp;rsquo;包执行一个默认的生命周期。&amp;lsquo;jar&amp;rsquo;包过程的定义被绑定到下面的生命周期阶段：&lt;/p&gt;
&lt;p&gt;生命周期阶段 || mojo || 插件
process-resources | resources | maven-resources-plugin
compile | compile | maven-compiler-plugin
process-test-resources | testResources | maven-resources-plugin
test-compile | testCompile | maven-compiler-plugin
test | test | maven-surefire-plugin
package | jar | maven-jar-plugin
install | install | maven-install-plugin
deploy | deploy | maven-deploy-plugin&lt;/p&gt;
&lt;p&gt;当命令Maven执行生命周期中的打包阶段时，上面至少有两个mojo将被执行。首先，maven-compile-plugin中的compile mojo将源代码编译到output目录。然后，maven-jar-plugin中的jar mojo将收集到的class文件打包到jar文件中。&lt;/p&gt;
&lt;p&gt;在这个例子的构建过程中仅仅只有这些mojo将被执行。因为这个假想的工程没有&amp;ldquo;非代码&amp;rdquo;资源，因此maven-resources-plugin中没有mojo会被执行。每个与资源相关的mojo将发现没有非代码资源的这个问题，它们将不会修改构建过程。这不是Maven框架的功能，而是mojo设计中的一个需要。好的mojo设计能决定什么时候不执行，它通常与执行时做出的修改一样重要。&lt;/p&gt;
&lt;p&gt;如果Maven工程中也包含了单元测试源码，则另外两个mojo将被触发处理单元测试。maven-compiler-plugin中的testCompile mojo编译测试代码，然后maven-surefire-plugin中的test mojo将执行这些编译过的测试。这些mojo总是被定义在生命周期中，但现在它们什么也不做。&lt;/p&gt;
&lt;p&gt;根据具体的工程，许多插件可以增加到默认的生命周期定义中来，提供各种各样的功能，例如部署到资源仓库、校验工程的内容、生成工程的Web站点，等等。Maven的插件框架确保几乎所有的东西都可以被集成到构建生命周期。这种扩展性也是使得Maven如此强大的部分原因。&lt;/p&gt;
&lt;h4 id="fang-wen-gou-jian-xin-xi"&gt;访问构建信息&lt;/h4&gt;
&lt;p&gt;为了使mojo能有效的执行，它需要获取当前构建的状态信息。这些信息来自于两方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;工程信息&amp;mdash;&amp;mdash;来自于工程的POM，或来自于前面的mojo执行时通过编程的方式所做的修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环境信息&amp;mdash;&amp;mdash;这些更加静态，包括用户、机器、Maven设置、系统属性、执行Maven时指定的系统属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了访问当前构建的状态，Maven允许mojo使用表达式设置参数值。在运行时，与参数关联的表达式将在当前的构建状态中被解析，并将结果注入mojo。通过正确的使用参数表达式，mojo可以保持它的依赖的最小化，从而避免了遍历整个构建状态对象图。&lt;/p&gt;
&lt;p&gt;例如，一个给源码打补丁的mojo需要找到工程的源码和补丁文件。这个可以使用下面的表达式mojo从当前的构建信息中获取源码目录列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compileSourceRoots&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假设补丁文件的保存目录是作为mojo的配置在POM中设置的，这个表达式可以使用类似下面的表达式获取这个信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;patchDirectory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="cha-jian-miao-shu"&gt;插件描述&lt;/h4&gt;
&lt;p&gt;Maven的插件描述是一个嵌入到插件的jar包中的描述文件，存放在/META-INF/maven/plugin.xml。描述文件XML格式的，它告诉Maven在这个插件包中包含的mojo集。包含的信息有：mojo实现类（或它在插件jar包中的路径）的信息，各个mojo应该被绑定到生命周期的哪个阶段，mojo申明的参数集和其它信息。&lt;/p&gt;
&lt;p&gt;在这个描述中，每个申明的mojo参数信息中都描述了多种用于获取参数值的表达式，描述了它是否可编辑，是否是mojo执行所必需的，以及参数值被注入到mojo实例的机制。&lt;/p&gt;
&lt;p&gt;插件描述非常强大足够满足各种pojo的需要。但这种弹性是要付出代价的。为了获得这种弹性，它使用了复杂的语法。手工编写插件描述需要插件开发者了解Maven插件框架的底层细节&amp;mdash;&amp;mdash;那些开发者不使用的细节，除非在配置描述时。这也是Maven插件开发工具出现的原因。通过从插件开发抽象许多细节，Maven的插件开发工具只暴露那些与插件实现语言相关的规范。（Maven's development tools expose only relevant specifications in a format convenient for a given plugin's implementation language）&lt;/p&gt;
&lt;h3 id="cha-jian-kai-fa-gong-ju_1"&gt;插件开发工具&lt;/h3&gt;
&lt;p&gt;为了创建插件描述，Maven提供了插件工具从多种不同格式中分析mojo的元数据。元数据被直接嵌入到源码中，它的格式与mojo的实现语言关。简言之，Maven的插件开发工具解除了手工维护mojo元数据的负担。插件开发工具分为下面两个分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;插件解析框架&amp;mdash;&amp;mdash;它知道如何从Maven支持的语言中解析出格式化的元数据。这个框架生成插件的文档和插件的描述；它包括一个应用框架的库，这些库提供了一套程序库（通常是每种mojo支持的语言都有一个）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;maven-plugin-plugin&amp;mdash;&amp;mdash;它使用插件解析框架，从mojo实现中解析出元数据，加上从插件自己的配置文件（插件工程POM）中获取的其它插件级元数据；maven-plugin-plugin简单的将插件作为前面所述的resource-generating step对标准的jar生命周期进行增强。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，用户编写mojo的元数据的格式依赖于用于实现该mojo的语言。使用Java时，最简单的方式是提供javadoc注释来标明mojo的属性和参数。例如，maven-clean-plugin中的clean mojo提供了下面的类级的javadoc注入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * @goal clean&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
public&lt;span class="w"&gt; &lt;/span&gt;class&lt;span class="w"&gt; &lt;/span&gt;CleanMojo&lt;span class="w"&gt; &lt;/span&gt;extends&lt;span class="w"&gt; &lt;/span&gt;AbstractMojo&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个注释告诉插件开发工具mojo的名称，以便它可以在生命周期中被引用，比如在POM配置文件中，或直接调用（比如从命令行）。clean mojo也定义了下面的内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/**
 * Be verbose in the debug log-level?
 *
 * @parameter expression="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;clean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;verbose&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" default-value="false"
 */
private boolean verbose;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个注释标明了这个字段是一个mojo参数。这个参数注释也指定了两个属性，表达式和默认值。首先指定参数的默认值应该被设置为false。第二个指定这个参数可以在命令行进行配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-Dclean.verbose=false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，也可以在POM中配置这个参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;verbose&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/verbose&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面可以看到参数名没有的显式的通过注释来指定；当使用@parameter注释时这是隐式指定的。&lt;/p&gt;
&lt;p&gt;我们可以直接申明字段而不是使用javadoc注释来初始化这个默认值，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;private boolean verbose = false;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但如果你需要注入的默认值包含了一个参数表达式时的情况。例如，下面是maven-resources-plugin中的resources mojo使用字段注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/**
 * Directory containing the classes.
 *
 * @parameter default-value="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;outputDirectory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"
 */
private File classesDirectory;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种情况下，不可能用需要的值来初始化这个java.io.File类型的字段，它指向当前工程的输出目录。当这个mojo被实例化后，这个值是从POM中获取并被注入的。由于插件工具也可以基于这些注释生成文档，因此通过元数据指定默认值是一个较好的方法，而不是在Java字段中初始化字段。&lt;/p&gt;
&lt;p&gt;上面这些注释是适应于用Java编写的mojo。如果你用其它语言mojo，比如Ant，这时指定元数据的定义将不同。但它们的原理是一样的。&lt;/p&gt;
&lt;h4 id="xuan-ze-mojode-shi-xian-yu-yan"&gt;选择mojo的实现语言&lt;/h4&gt;
&lt;h3 id="shi-yong-ben-zhang-fan-li-de-ti-shi_1"&gt;使用本章范例的提示&lt;/h3&gt;
&lt;p&gt;保持例子的简单。以便于理解。&lt;/p&gt;
&lt;p&gt;新建一个名为buildinfo的工程，它使用这个插件。&lt;/p&gt;
&lt;h2&gt;开发第一个Mojo&lt;/h2&gt;
&lt;p&gt;本章的开发目标是围绕一个称为Guniea Pig的简单工程。开发的成果将能获取构建信息并将被部署Maven开发仓库。&lt;/p&gt;
&lt;h3 id="buildinfode-yi-ge-li-zi-shi-yong-yi-ge-javabian-xie-de-mojohuo-qu-xin-xi"&gt;BuildInfo的一个例子：使用一个Java编写的Mojo获取信息&lt;/h3&gt;
&lt;p&gt;试想POM包含了这样一个profile，它将在系统属性os.name的值为Linux时被触发。当被触发时，这个profile将添加一个Linux下特定的新的依赖到工程中，有这个依赖的情况下在Linux下才能构建成功。当这个profile没有被触发时，一个默认的依赖将被注入，这个依赖是windows下的一个库。而这个依赖只在测试时需要而不会传递到依赖于本工程的其它工程。&lt;/p&gt;
&lt;p&gt;由于这个值非常重要。如果测试的依赖包含于这样一个profile中，当这个profile被触发时它能决定构建的成功或失败。因此，应该在构建信息文件中包含这个系统属性的说明以便他人能理解环境对这个构建的影响。&lt;/p&gt;
&lt;h4 id="xian-jue-tiao-jian-gou-jian-sheng-cheng-buildinfosheng-cheng-qi-gong-cheng"&gt;先决条件：构建生成buildinfo生成器工程&lt;/h4&gt;
&lt;p&gt;在编写buildinfo插件之前，你必须先将buildinfo生成器库安装到Maven本地仓库中。Buildinfo插件是对这个生成器的简单封装，它提供了一个很薄的适配层以便从Maven构建中运行生成器。这种方式也给出了一个重要的实践提示；通过将生成器从Maven构建代码中分离，你可以编写任何类型的适配器或前端代码，在不同的场景下使用用可重用的工具。&lt;/p&gt;
&lt;p&gt;构建buildinfo生成器类，执行下面的步骤：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd buildinfo
mvn install
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="shi-yong-archetypecha-jian-sheng-cheng-cha-jian-gong-cheng-de-ji-chu-dai-ma"&gt;使用archetype插件生成插件工程的基础代码&lt;/h4&gt;
&lt;p&gt;现在buildinfo生成器的类库已经被安装到Maven仓库，有助于我们使用Maven的archetype插件从标准插件工程模板中创建一个简单的基础工程从而转到插件编写过程。一旦插件工程结构就绪，编写pojo就简单了。为了生成基础的buildinfo插件，只要执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn archetype:create -DgroupId=com.devzuz.mvnbook.plugins \
-DartifactId=maven-buildinfo-plugin \
-DarchetypeArtifactId=maven-archetype-mojo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当运行这个命令时将看到警告信息&amp;ldquo;${project.build.directory} is not a valid reference&amp;rdquo;这是用于生成插件代码的Velocity模板产生的，不影响工程的正常使用。&lt;/p&gt;
&lt;p&gt;上面的命令在maven-buildinfo-plugin下创建了一个标准结构的工程。这个目录下包含了一个基础的POM和一个示例pojo。为完成这个插件，你对POM进行修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改name元素为Maven BuildInfo Plugin。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移除url元素，因为这个插件现在没有与Web站点关联。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以后还需要修改POM，比如修改mojo的依赖关系。&lt;/p&gt;
&lt;p&gt;由于你需要创建自己的mojo，因此应该删除示例mojo。示例保存在：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;src\main\java\com\devzuz\mvnbook\plugins\MyMojo.java
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="mojo"&gt;mojo&lt;/h4&gt;
&lt;p&gt;一个简单的Java编写的mojo：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/**
 * Write the environment information for the current build execution
 * to an XML file.
 * @goal extract
 * @phase package
 * @requiresDependencyResolution test
 *
 */
public class WriteBuildInfoMojo extends AbstractMojo {
    /**
     * Determines which system properties are added to the buildinfo file.
     * @parameter
     */
 private String systemProperties;
    /**
     * The location to write the buildinfo file. Used to attach the buildinfo
     * to the project jar for installation and deployment.
     * @parameter expression="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;buildinfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;outputFile&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" default- \
value="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;directory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;artifactId&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;- \
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;-buildinfo.xml"
     * @required
     */
    private File outputFile;
    public void execute() throws MojoExecutionException {
        BuildInfo buildInfo = new BuildInfo();
        addSystemProperties( buildInfo );
        try {
            BuildInfoUtils.writeXml( buildInfo, outputFile );
        } catch ( IOException e ) {
            throw new MojoExecutionException( "Error writing buildinfo \
XML file. Reason: " + e.getMessage(), e );
        }
    }
    private void addSystemProperties( BuildInfo buildInfo ) {
        Properties sysprops = System.getProperties();
        if ( systemProperties != null ) {
            String[] keys = systemProperties.split( "," );
            for ( int i = 0; i &lt;span class="nt"&gt;&amp;lt; keys.length&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt; &lt;span class="err"&gt;i++&lt;/span&gt; &lt;span class="err"&gt;)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
                &lt;span class="err"&gt;String&lt;/span&gt; &lt;span class="na"&gt;key =&lt;/span&gt; &lt;span class="err"&gt;keys[i].trim();&lt;/span&gt;
                &lt;span class="err"&gt;String&lt;/span&gt; &lt;span class="na"&gt;value =&lt;/span&gt; &lt;span class="err"&gt;sysprops.getProperty(&lt;/span&gt; &lt;span class="err"&gt;key,&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;
&lt;span class="err"&gt;BuildInfoConstants.MISSING_INFO_PLACEHOLDER&lt;/span&gt; &lt;span class="err"&gt;);&lt;/span&gt;
                &lt;span class="err"&gt;buildInfo.addSystemProperty(&lt;/span&gt; &lt;span class="err"&gt;key,&lt;/span&gt; &lt;span class="err"&gt;value&lt;/span&gt; &lt;span class="err"&gt;);&lt;/span&gt;
            &lt;span class="err"&gt;}&lt;/span&gt;
        &lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个mojo的代码部分比较简单，值得关注的是javadoc注释。在类级的javadoc注释中，有两个特殊的注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * @goal extract&lt;/span&gt;
&lt;span class="cm"&gt; * @phase package&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个注释@goal，告诉插件工具将这个类当作mojo。当调用这个mojo时，你将使用这个名称。第二个注释告诉Maven这个mojo应该在构建生命周期的哪个阶段被执行。在这里，你从环境中收集信息并将它同工程产品一起发布到maven仓库中。因此，应该在package阶段执行这个mojo，以便它被添加到工程产品中。通常，打包阶段也是获取信息并添加到构建结果中的最佳阶段。&lt;/p&gt;
&lt;p&gt;类级注释的下面是字段级的javadoc注释，它用于指定mojo的参数。每个都指向一个特定参数，以便可以独立的设置。systemProperties参数变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/**
 * @parameter expression="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;buildinfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;systemProperties&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"
 */
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一种最为简单的指定参数的情况。使用@parameter注释，没有属性，将允许在POM中插件配置中指定这个mojo字段。你可能想要允许用户指定哪些系统属性应该被包含到构建信息文件中，使用expression属性，你可以指定参数从命令行引用的名称。在这种情况下，expression属性可以被设置为系统属性的列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;localhost $ mvn buildinfo:extract \
-Dbuildinfo.systemProperties=java.version,user.dir
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行这个命令的模块应该使用buildinfo前缀。在这里，guinea-pig模块应该使用buildinfo这个goal前缀来绑定到maven-buildinfo-plugin，以便在guinea-pig目录下执行上面的命令。&lt;/p&gt;
&lt;p&gt;最后，outputFile参数出现在一个更加复杂的参数注释例子中。由于你对这个参数有更加复杂的要求，这个复杂性是合理的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/**
* The location to write the buildinfo file. Used to attach the buildinfo
* for installation and deployment.
*
* @parameter expression="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;buildinfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;outputFile&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" default- \
value="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;directory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;artifactId&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;- \
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;-buildinfo.xml"
*
* @required
*/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，mojo不运行除非它知道将构建信息写到哪个文件。为确保这个参数有一个值，mojo使用了@required注释。如果在配置mojo时这个参数没有值，这个构建将产生错误。另外，你可能需要让mojo从工程中计算出这个值作为这个参数的默认值。在这里注释中使用几个表达式来指定默认输出路径。&lt;/p&gt;
&lt;h4 id="cha-jian-de-pom"&gt;插件的POM&lt;/h4&gt;
&lt;p&gt;Mojo编写完后，你可以构建一个简单POM文件以便你构建这个插件，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class="nt"&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-buildinfo-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;maven-plugin&lt;span class="nt"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;

  &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-plugin-api&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.0&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.shared&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;buildinfo&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
[...]
  &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个POM申明了工程的标识和它的两个依赖。&lt;/p&gt;
&lt;p&gt;注意依赖中的buildinfo，它提供了解析和格式化构建信息文件的工具。依赖中也指定了maven-plugin，这表示这个插件将遵循构建生命周期映射。&lt;/p&gt;
&lt;h4 id="bang-ding-dao-gou-jian-sheng-ming-zhou-qi"&gt;绑定到构建生命周期&lt;/h4&gt;
&lt;p&gt;现在已经有了方法来获取构建时的环境信息，你需要确保每个构建都能得到这个信息。最简单的保证方法就是将extract mojo绑定到构建生命周期，让它在每次构建时都被触发。这包括了修改标准的jar生命周期。可以通过向Guinea Pig的POM中配置新的插件，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-buildinfo-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;extract&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;systemProperties&amp;gt;&lt;/span&gt;os.name,java.version&lt;span class="nt"&gt;&amp;lt;/systemProperties&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;extract&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    [...]
  &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的绑定将在构建生命周期的package阶段执行maven-buildinfo-plugin的extract mojo，并获取系统的os.name属性。&lt;/p&gt;
&lt;h4 id="shu-chu"&gt;输出&lt;/h4&gt;
&lt;p&gt;现在你有了一个mojo和一个POM，你可以构建这个插件并试用！首先，使用下面的命令构建buildinfo插件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd C:\book-projects\maven-buildinfo-plugin
mvn clean install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，通过将buildinfo插件绑定到Guinea Pig工程来测试插件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd C:\book-projects\guinea-pig
mvn package
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当执行Guinea Pig的构建时，你可以看到类似下面的输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[...]&lt;/span&gt;
&lt;span class="k"&gt;[INFO] [buildinfo:extract {execution: extract}]&lt;/span&gt;
&lt;span class="k"&gt;[INFO]&lt;/span&gt;
&lt;span class="k"&gt;[INFO]&lt;/span&gt;
&lt;span class="na"&gt;[INFO] ------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="na"&gt;[INFO] Reactor Summary:&lt;/span&gt;
&lt;span class="na"&gt;[INFO] ------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="k"&gt;[INFO] Guinea Pig Sample Application ......................... SUCCESS [6.468s]&lt;/span&gt;
&lt;span class="k"&gt;[INFO] Guinea Pig API ........................................ SUCCESS [2.359s]&lt;/span&gt;
&lt;span class="k"&gt;[INFO] Guinea Pig Core ....................................... SUCCESS [0.469s]&lt;/span&gt;
&lt;span class="na"&gt;[INFO] ------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="na"&gt;[INFO] BUILD SUCCESSFUL&lt;/span&gt;
&lt;span class="na"&gt;[INFO] ------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="k"&gt;[...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在target目录下，应该有一个新的文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;guinea-pig-1.0-SNAPSHOT-buildinfo.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个文件中，可以看到类似下面的信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;buildinfo&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;systemProperties&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;java.version&amp;gt;&lt;/span&gt;1.5.0_06&lt;span class="nt"&gt;&amp;lt;/java.version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;os.name&amp;gt;&lt;/span&gt;Windows XP&lt;span class="nt"&gt;&amp;lt;/os.name&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/systemProperties&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;sourceRoots&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;sourceRoot&amp;gt;&lt;/span&gt;src\main\java&lt;span class="nt"&gt;&amp;lt;/sourceRoot&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/sourceRoots&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;resourceRoots&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;resourceRoot&amp;gt;&lt;/span&gt;src\main\resources&lt;span class="nt"&gt;&amp;lt;/resourceRoot&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/resourceRoots&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/buildinfo&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然OS的名称和java的版本可能会不同。&lt;/p&gt;
&lt;h3 id="buildinfode-li-zi-shi-yong-ant-mojotong-zhi-qi-ta-kai-fa-zhe_1"&gt;BuildInfo的例子：使用Ant Mojo通知其它开发者&lt;/h3&gt;
&lt;p&gt;现在一些重要信息已经被获取，你需要在这个工程的产品被部署时与团队中的其它人分享这些信息。在Maven的世界中要记住&amp;ldquo;部署deployement&amp;rdquo;表示将工程产品注入到Maven仓库系统。现在，需要发送一个通知邮件到工程开发的邮件列表，以便其它团队成员来访问。&lt;/p&gt;
&lt;p&gt;当然，这样的任务可以使用基于Java的mojo通过JavaMail API来处理。但这需要写大量的代码和测试，更简单的办法是使用Ant。&lt;/p&gt;
&lt;p&gt;在编写完发送通知邮件的Ant target后，你只需要编写一个mojo来将这个target封装到Maven构建过程中。&lt;/p&gt;
&lt;h4 id="ant-target"&gt;Ant target&lt;/h4&gt;
&lt;p&gt;新的mojo保存在notify.build.xml中，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;target&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;"notify-target"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;mail&lt;/span&gt; &lt;span class="na"&gt;from=&lt;/span&gt;&lt;span class="s"&gt;"maven@localhost"&lt;/span&gt; &lt;span class="na"&gt;replyto=&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;listAddr&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;
      &lt;span class="na"&gt;subject=&lt;/span&gt;&lt;span class="s"&gt;"Build Info for Deployment of &lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;
       &lt;span class="na"&gt;mailhost=&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;mailHost&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt; &lt;span class="na"&gt;mailport=&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;mailPort&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;
       &lt;span class="na"&gt;messagefile=&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;buildinfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;outputFile&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

      &lt;span class="nt"&gt;&amp;lt;to&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;listAddr&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/to&amp;gt;&lt;/span&gt;

    &lt;span class="nt"&gt;&amp;lt;/mail&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/target&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="mojo-metadatawen-jian"&gt;Mojo Metadata文件&lt;/h4&gt;
&lt;p&gt;不同于之前的例子，Ant mojo的metadata是保存在单独的文件中的，它使用命名约定与构建脚本关联。在这个例子中，构建脚本被命名为notify.build.xml。对应的metadata文件名为notify.mojos.xml，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;pluginMetadata&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;mojos&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;mojo&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;call&amp;gt;&lt;/span&gt;notify-target&lt;span class="nt"&gt;&amp;lt;/call&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;notify&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;phase&amp;gt;&lt;/span&gt;deploy&lt;span class="nt"&gt;&amp;lt;/phase&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;description&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;![CDATA[&lt;/span&gt;
&lt;span class="cp"&gt;        Email environment information from the current build to the&lt;/span&gt;
&lt;span class="cp"&gt;        development mailing list when the artifact is deployed.&lt;/span&gt;
&lt;span class="cp"&gt;      ]]&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/description&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;parameters&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;parameter&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;buildinfo.outputFile&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;defaultValue&amp;gt;&lt;/span&gt;
              &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;directory&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;artifactId&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;- \
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;-buildinfo.xml
            &lt;span class="nt"&gt;&amp;lt;/defaultValue&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;required&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;readonly&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/readonly&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/parameter&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;parameter&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;listAddr&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;required&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/parameter&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;parameter&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;project.name&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;defaultValue&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/defaultValue&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;required&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;readonly&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/readonly&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/parameter&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;parameter&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;mailHost&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;expression&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;mailHost&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/expression&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;defaultValue&amp;gt;&lt;/span&gt;localhost&lt;span class="nt"&gt;&amp;lt;/defaultValue&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;required&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/parameter&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;parameter&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;mailPort&lt;span class="nt"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;expression&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;mailPort&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/expression&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;defaultValue&amp;gt;&lt;/span&gt;25&lt;span class="nt"&gt;&amp;lt;/defaultValue&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;required&amp;gt;&lt;/span&gt;false&lt;span class="nt"&gt;&amp;lt;/required&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/parameter&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/parameters&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/mojo&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/mojos&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/pluginMetadata&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初看起来，文件内容与Java编写的mojo包含的metadata是不同的；但细看就可以发现有许多相似的地方。&lt;/p&gt;
&lt;p&gt;首先，由于现在你对于用来描述mojo的metadata类型已经有一个较好的概念，总体结构应该比较熟悉。与Java的例子中一样，mojo级的metadata描述绑定的阶段和mojo的名称等细节。&lt;/p&gt;
&lt;p&gt;metadata指定mojo的参数列表，每个都有自己的信息，如名字、表达式、默认值和其它信息。表达式的语法用于从构建状态解析信息，参数标识如required仍然存在，但是是通过XML表达的。&lt;/p&gt;
&lt;p&gt;当这个mojo被执行时，Maven仍然将解析并注入这些参数到mojo中；不同之处在于用来注入的方式。在Java中，参数注入通过直接注入到字段或通过JavaBean风格的setXXX()方法进行。在基于Ant的mojo中，参数注入是作为属性被Ant工程实例引用的。&lt;/p&gt;
&lt;p&gt;Ant参数注入应遵循下面的原则：如果参数类型是java.lang.String（默认），则它的值是作为属性被注入的；其它的值将作为工程的属性引用被注入。在这个例子中，所有mojo参数类型都为java.lang.String。如果某个参数是其它类型的，你需要在&lt;name&gt;元素中添加&lt;type&gt;元素来描述参数的类型。&lt;/type&gt;&lt;/name&gt;&lt;/p&gt;
&lt;p&gt;最后，注意这个mojo被绑定到生命周期的deploy阶段。这是这个mojo中一个重要的地方，因为你准备在这时发送邮件到开发邮件列表。如果绑定在其它阶段，它将产生大量垃圾邮件。而放在deploy阶段，则只在新的工程产品被部署到远程仓库中时才会发送邮件。&lt;/p&gt;
&lt;h4 id="wei-ant-mojosxiu-gai-cha-jian-pom"&gt;为Ant Mojos修改插件POM&lt;/h4&gt;
&lt;p&gt;由于Maven 2.0不支持基于Ant的mojo（将在2.0.2中支持Ant），需要一些特殊的配置来让maven-plugin-plugin识别Ant mojos。幸运的是，Maven允许POM-specific注入插件级的依赖，以便插件使用框架提供的功能。（in order to accommodate plugins that take a framework approach to providing their functionality. ）&lt;/p&gt;
&lt;p&gt;maven-plugin-plugin是一个完善的例子，它通过使用maven-plugin-tools-api库中的MojoDescriptorExtractor接口。这个库定义了一套从原生格式（Java或其它语言编写的pojo）解析并生成mojo描述信息的接口集，这些描述信息包括了插件描述文件。maven-plugin-plugin的Java和BeanShell版中提供了上述接口的实现库。&lt;/p&gt;
&lt;p&gt;这允许开发者不需要额外的配置就可以在基于Java或BeanShell的mojo中生成描述信息。为了开发基于Ant的mojo，你需要使用maven-plugin-plugin来支持Ant mojo。&lt;/p&gt;
&lt;p&gt;为达到这个目的，你需要在POM配置中将maven-plugin-tools-ant库添加到maven-plguin-plugin的依赖中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;project&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-plugin-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-plugin-tools-ant&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.0.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，由于插件现在包括了一个基于Ant的mojo，它需要一些新的依赖，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.maven&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-script-ant&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.0.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;ant&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;ant&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.6.5&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
  [...]
&lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个新依赖是用于封装Ant构建脚本的mojo API，它们对于在Maven构建过程中将Ant脚本作为mojo总是需要的。第二个新的依赖，是对Ant库的依赖。&lt;/p&gt;
&lt;h4 id="jiang-notify-mojobang-ding-dao-sheng-ming-zhou-qi"&gt;将Notify Mojo绑定到生命周期&lt;/h4&gt;
&lt;p&gt;Ant mojo插件的描述生成完后，它与Maven中其它类型的mojo一样。甚至配置都是一样的。在Guinea PIG POM中添加Ant mojo：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
  [...]
  &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.devzuz.mvnbook.plugins&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-buildinfo-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;extract&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
          [...]
        &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;notify&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;notify&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;listAddr&amp;gt;&lt;/span&gt;dev@guineapig.codehaus.org&lt;span class="nt"&gt;&amp;lt;/listAddr&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    [...]
  &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;execution&gt;&amp;mdash;&amp;mdash;它将extract mojo绑定到构建中。notify mojo放在另一个&lt;execution&gt;中。这是因为一个execution只能包含构建生命周期中的一个阶段，并且这两个mojo不应该在同一个构建阶段执行。&lt;/execution&gt;&lt;/execution&gt;&lt;/p&gt;
&lt;p&gt;为了告诉notify mojo将邮件发送到里，还应该在configuration一节中配置listAddr参数值。&lt;/p&gt;
&lt;p&gt;现在执行下面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn deploy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构建过程将执行构建步骤并部署jar&amp;mdash;&amp;mdash;，它也将在打包阶段获取环境信息，并在部署阶段发送邮件到Guinea Pig开发者邮件列表。&lt;/p&gt;
&lt;p&gt;注意：应该配置distributionManagement和scm以便能成功的执行mvn deploy。&lt;/p&gt;
&lt;h2&gt;高级Mojo开发&lt;/h2&gt;
&lt;p&gt;前面的例子展示了如何申明简单的mojo参数，如何使用名称和绑定阶段来注释mojo。下面的例子将包含更多与mojo开发相关的高级主题。下面的章节互相没有依赖，对于开发基本的mojo来说并不是必须的。但如果你想知道如何开发插件来管理依赖、工程源码和资源、产品附件，那么准备开始吧！&lt;/p&gt;
&lt;h1&gt;评估工程的健康度&lt;/h1&gt;
&lt;h1&gt;使用Maven进行团队协作&lt;/h1&gt;
&lt;h1&gt;迁移到Maven&lt;/h1&gt;</content><category term="maven"></category></entry><entry><title>Maven2 Tips</title><link href="/maven2-tips.html" rel="alternate"></link><published>2009-09-21T00:00:00+08:00</published><updated>2009-09-21T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2009-09-21:/maven2-tips.html</id><summary type="html">&lt;h1&gt;mvn命令行&lt;/h1&gt;
&lt;h2&gt;执行Java程序&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn exec:java -Dexec.mainClass=org.jamsa.scalademo.FunctionValue
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;运行单个单元测试&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn test -Dtest=AppTest
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;安装包和源码包&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn install:install-file -Dfile=target/jsonplugin-0.34.jar -Dsources=target/jsonplugin-0.34-sources.jar -DartifactId=jsonplugin -DgroupId=com.googlecode -Dversion=0.34 -Dclassifier=sources -Dpackaging=jar
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成lift应用&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn.bat archetype:generate -U -DarchetypeGroupId=net …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;mvn命令行&lt;/h1&gt;
&lt;h2&gt;执行Java程序&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn exec:java -Dexec.mainClass=org.jamsa.scalademo.FunctionValue
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;运行单个单元测试&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn test -Dtest=AppTest
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;安装包和源码包&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn install:install-file -Dfile=target/jsonplugin-0.34.jar -Dsources=target/jsonplugin-0.34-sources.jar -DartifactId=jsonplugin -DgroupId=com.googlecode -Dversion=0.34 -Dclassifier=sources -Dpackaging=jar
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;生成lift应用&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mvn.bat archetype:generate -U -DarchetypeGroupId=net.liftweb -DarchetypeArtifactId=lift-archetype-blank -DremoteRepositories=http://scala-tools.org/repo-releases -DgroupId=demo.helloworld -DartifactId=helloworld -Dversion=1.0-SNAPSHOT
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;pom.xml配置&lt;/h1&gt;
&lt;h2&gt;dependency的scope&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;junit&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;3.8.1&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!-- 使ide能找到c标签库的tld文件 --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;taglibs&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;standard&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;provided&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的test表示在测试时才需要该依赖。而provided则表示发布后的环境中将提供这个包。&lt;/p&gt;
&lt;h2&gt;scala插件配置&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;      &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.scala-tools&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-scala-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;compile&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;testCompile&lt;span class="nt"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;scalaVersion&amp;gt;&lt;/span&gt;${scala.version}&lt;span class="nt"&gt;&amp;lt;/scalaVersion&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;args&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;arg&amp;gt;&lt;/span&gt;-target:jvm-1.5&lt;span class="nt"&gt;&amp;lt;/arg&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;arg&amp;gt;&lt;/span&gt;-encoding&lt;span class="nt"&gt;&amp;lt;/arg&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;arg&amp;gt;&lt;/span&gt;GBK&lt;span class="nt"&gt;&amp;lt;/arg&amp;gt;&lt;/span&gt;
          &lt;span class="nt"&gt;&amp;lt;/args&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过args可指定-encoding参数，可以避免出现scalac识别源码字符集错误的问题。&lt;/p&gt;
&lt;h2&gt;指定所使用的依赖的编译版本&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.json&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;json&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;20090211&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;classifier&amp;gt;&lt;/span&gt;jdk1.5&lt;span class="nt"&gt;&amp;lt;/classifier&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;jetty插件的配置&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.mortbay.jetty&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-jetty-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;stopPort&amp;gt;&lt;/span&gt;9966&lt;span class="nt"&gt;&amp;lt;/stopPort&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;stopKey&amp;gt;&lt;/span&gt;foo&lt;span class="nt"&gt;&amp;lt;/stopKey&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;webAppConfig&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;contextPath&amp;gt;&lt;/span&gt;/budget&lt;span class="nt"&gt;&amp;lt;/contextPath&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;defaultsDescriptor&amp;gt;&lt;/span&gt;src/main/resources/webdefault.xml
                &lt;span class="nt"&gt;&amp;lt;/defaultsDescriptor&amp;gt;&lt;/span&gt;
                &lt;span class="c"&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class="c"&gt;                    &amp;lt;overrideDescriptor&amp;gt;src/main/resources/override-web.xml&amp;lt;/overrideDescriptor&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;                --&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/webAppConfig&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有一个样例 &lt;a href="webdefault.xml"&gt;webdefault.xml&lt;/a&gt; 。webdefault.xml可以解决执行jetty:run时静态文件不能修改的问题。&lt;/p&gt;
&lt;h2&gt;一个简单的Profile&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;&amp;lt;profiles&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;oc4j&lt;span class="nt"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;xerces&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;xercesImpl&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.6.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;javax.servlet&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;jstl&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;taglibs&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;standard&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1.2&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-war-plugin&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;webResources&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;
                                    &lt;span class="nt"&gt;&amp;lt;directory&amp;gt;&lt;/span&gt;src/main/oc4j&lt;span class="nt"&gt;&amp;lt;/directory&amp;gt;&lt;/span&gt;
                                &lt;span class="nt"&gt;&amp;lt;/resource&amp;gt;&lt;/span&gt;
                            &lt;span class="nt"&gt;&amp;lt;/webResources&amp;gt;&lt;/span&gt;
                        &lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/profiles&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="maven"></category></entry><entry><title>JBoss Seam 学习笔记</title><link href="/jboss-seam-xue-xi-bi-ji.html" rel="alternate"></link><published>2009-01-15T00:00:00+08:00</published><updated>2009-01-15T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2009-01-15:/jboss-seam-xue-xi-bi-ji.html</id><summary type="html">&lt;h1&gt;JBoss Seam介绍&lt;/h1&gt;
&lt;p&gt;Seam是一个for Java EE5的应用框架。它是从下面的规则得到灵感的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集成JSF和EJB3.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集成AJAX。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Seam支持两个开源的JSF AJAX解决方案：ICEFaces和Ajax4JSF。这些解决方案让你可以在应用中添加AJAX支持而不需要编写JS代码。&lt;/p&gt;
&lt;p&gt;Seam也支持内置EJB3组件的的JavaScript远程调用。AJAX客户端可以很容易的调用服务端组件和JMS主题，而不需要中间动作层。&lt;/p&gt;
&lt;p&gt;这两种办法都工作得比较好，如果不是有Seam内置的并发和状态管理，它确保了许多并发和异步的AJAX请求被安全高效的在服务端被处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集成业务流程作为一流的构件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集成了jBPM，并允许定义会话层。JSF为这个会话层提供了强大的事件模型。Seam通过暴露jBPM的业务流程相关的事件，使用同样的事件处理机制，为所有Seam的组件模型提供了统一的事件模型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种&amp;ldquo;填充&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申明性状态管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作区管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到处都是带注释的POJO&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;易测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Seam可以工作于任何支持EJB3的应用服务器中。通过使用Jboss嵌入式EJB3容器，甚至可以在Servlet容器中使用Seam，比如Tomcat或任何J2EE应用服务器。&lt;/p&gt;
&lt;p&gt;在现在并不是所有的人都准备迁移到EJB3。因此，在这期间可以把Seam作为一种框架来使用，使用JSF作展现，Hibernate作持久层，JavaBean处理应用逻辑。当准备迁移到EJB3.0时，迁移将比较直接。&lt;/p&gt;
&lt;h1&gt;Chapter 1. Seam教程 …&lt;/h1&gt;</summary><content type="html">&lt;h1&gt;JBoss Seam介绍&lt;/h1&gt;
&lt;p&gt;Seam是一个for Java EE5的应用框架。它是从下面的规则得到灵感的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集成JSF和EJB3.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集成AJAX。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Seam支持两个开源的JSF AJAX解决方案：ICEFaces和Ajax4JSF。这些解决方案让你可以在应用中添加AJAX支持而不需要编写JS代码。&lt;/p&gt;
&lt;p&gt;Seam也支持内置EJB3组件的的JavaScript远程调用。AJAX客户端可以很容易的调用服务端组件和JMS主题，而不需要中间动作层。&lt;/p&gt;
&lt;p&gt;这两种办法都工作得比较好，如果不是有Seam内置的并发和状态管理，它确保了许多并发和异步的AJAX请求被安全高效的在服务端被处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集成业务流程作为一流的构件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集成了jBPM，并允许定义会话层。JSF为这个会话层提供了强大的事件模型。Seam通过暴露jBPM的业务流程相关的事件，使用同样的事件处理机制，为所有Seam的组件模型提供了统一的事件模型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种&amp;ldquo;填充&amp;rdquo;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申明性状态管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作区管理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到处都是带注释的POJO&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;易测试&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Seam可以工作于任何支持EJB3的应用服务器中。通过使用Jboss嵌入式EJB3容器，甚至可以在Servlet容器中使用Seam，比如Tomcat或任何J2EE应用服务器。&lt;/p&gt;
&lt;p&gt;在现在并不是所有的人都准备迁移到EJB3。因此，在这期间可以把Seam作为一种框架来使用，使用JSF作展现，Hibernate作持久层，JavaBean处理应用逻辑。当准备迁移到EJB3.0时，迁移将比较直接。&lt;/p&gt;
&lt;h1&gt;Chapter 1. Seam教程&lt;/h1&gt;
&lt;h1&gt;Chapter 2. 使用seam-gen开始Seam&lt;/h1&gt;
&lt;h2&gt;2.1 开始之前&lt;/h2&gt;
&lt;p&gt;确保你有JDK 5或JDK 6，JBoss AS 4.0.5和Ant 1.6。&lt;/p&gt;
&lt;p&gt;JBoss有完善的热部署和重新部署WAR和EAR的功能。但不幸的是，由于JVM的Bug，重新部署一个EAR&amp;mdash;&amp;mdash;通常是在开发阶段&amp;mdash;&amp;mdash;最终将导致JVM Perm Gen溢出。因此，我们推荐在开发阶段调整JVM参数。推荐的参数为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-Xms512m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=512
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你没有足够的内存，推荐使用下面的参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-Xms256m -Xmx512m -XX:PermSize=128m -XX:MaxPermSize=256
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你从命令行运行JBoss，则可以修改bin/conf下的配置来配置JVM参数。&lt;/p&gt;
&lt;h2&gt;2.2 设置一个新的Eclipse工程&lt;/h2&gt;
&lt;p&gt;首先我们需要配置一个seam-gen环境：JBoss AS安装路径、Eclipse工作空间、数据库连接：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cd jboss-seam-home
seam setup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据提示输入相关的信息。其中重要的选项是选择EAR和WAR部署。EAR工程支持EJB 3.0需要Java EE 5。WAR工程不支持EJB 3.0，但可以部署到J2EE环境中。WAR包简单易懂。如果安装了支持EJB 3.0的JBoss，选择ear。否则，选择war。&lt;/p&gt;
&lt;p&gt;如果数据模型已经存在，请确保告诉了seam-gen数据库表已经存在于数据库。&lt;/p&gt;
&lt;p&gt;设置保存在seam-gen/build.properties，但你可以再次运行seam set来修改。&lt;/p&gt;
&lt;p&gt;进入Eclipse工作空间，执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;seam new-project
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它将复制Seam需要的jar文件，需要的JDBC驱动包到新的Eclipse工程中，并生成所有需要的资源和配置文件，facelets模板文件和样式，Eclipse元数据和Ant脚本。这个Eclipse工程将自动部署到JBoss中一个展开的目录中。在Eclipse中点击New -&amp;gt; Project... -&amp;gt; General -&amp;gt; Project -&amp;gt; Next，不要选择Java Project。&lt;/p&gt;
&lt;p&gt;如果Eclipse中默认的JDK不是Java SE 5或Java SE 6，你需要设置工程的默认编译器。&lt;/p&gt;
&lt;p&gt;你也可以在Eclipse外部，使用seam explode。&lt;/p&gt;
&lt;p&gt;转到&lt;code&gt;http://localhost:8080/helloworld&lt;/code&gt;查看欢迎页面。这是一个facelet页面，vew/home/xhtml，使用的模板为&lt;code&gt;view/layout/template.xhtml&lt;/code&gt;可以修改这个页面或模板，修改将立即生效。&lt;/p&gt;
&lt;p&gt;不要害怕生成的工程目录中的XML配置文档。它们中多数是标准的Java EE原料，这些原料只要创建一次就不再需要查看，在所有Seam工程中它们有90%是相同的。&lt;/p&gt;
&lt;p&gt;生成的工程包括三个数据库和持久化配置。jboss-beans.xml，persistence-test.xml和import-test.sql文件用于基于HSQLDB做TestNG单元测试。测试用的数据库数据存储在import-test.sql中,它们在运行测试前被导出到数据库。project-dev-ds.xml，persistence-dev.xml和import-dev.sql用于部署到开发数据库。这个数据库配置是否自动导出到数据库取决于你使用seam-gen是否告诉它你工作于已经存在的数据库上。myproject-prod-ds.xml，persistence-prod.xml和import-prod.sql文件用于部署到产品数据库。这个数据库配置不会自动导出和部署。&lt;/p&gt;
&lt;h2&gt;2.3 创建一个新的action&lt;/h2&gt;
&lt;p&gt;如果你使用传递的action风格的web应用框架，你可以使用下面的方法创建一个无状态的action方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;seam new-action
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Seam将提示一些信息，并生成新的facelet页面和Seam组件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;C:\Projects\jboss-seam&amp;gt;seam new-action ping
Buildfile: C:\Projects\jboss-seam\seam-gen\build.xml

validate-workspace:

validate-project:

action-input:
    [input] Enter the Seam component name
ping
    [input] Enter the local interface name [Ping]

    [input] Enter the bean class name [PingBean]

    [input] Enter the action method name [ping]

    [input] Enter the page name [ping]


setup-filters:

new-action:
     [echo] Creating a new stateless session bean component with an action method
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello\test
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello\test
     [copy] Copying 1 file to C:\Projects\hello\view
     [echo] Type 'seam restart' and go to http://localhost:8080/helloworld/ping.seam

BUILD SUCCESSFUL
Total time: 13 seconds
C:\Projects\jboss-seam&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我们添加了新的Seam组件，我们需要重新部署。你可以使用seam restart，或运行build.xml中的restart任务。另一种方法是编辑&lt;code&gt;resources/META-INF/application&lt;/code&gt;文件来重启。不需要每次都重启JBoss。&lt;/p&gt;
&lt;p&gt;现在转到&lt;code&gt;http://localhost:8080/helloworld/ping.seam&lt;/code&gt;然后点击按钮。你将看到执行了src中的action中的代码。可以在ping()方法中设置断点，然后再次点击。&lt;/p&gt;
&lt;p&gt;最后，在测试包中找到PingTest.xml文件并使用Eclipse的TestNG插件来执行集中测试。也可以使用seam tesst或build.xml中的test任务。&lt;/p&gt;
&lt;h2&gt;2.4 创建一个带action的form&lt;/h2&gt;
&lt;p&gt;创建form的步骤：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;seam new-form
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;C:\Projects\jboss-seam&amp;gt;seam new-form
Buildfile: C:\Projects\jboss-seam\seam-gen\build.xml

validate-workspace:

validate-project:

action-input:
    [input] Enter the Seam component name
hello
    [input] Enter the local interface name [Hello]

    [input] Enter the bean class name [HelloBean]

    [input] Enter the action method name [hello]

    [input] Enter the page name [hello]


setup-filters:

new-form:
     [echo] Creating a new stateful session bean component with an action method
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello\test
     [copy] Copying 1 file to C:\Projects\hello\view
     [copy] Copying 1 file to C:\Projects\hello\src\com\hello\test
     [echo] Type 'seam restart' and go to http://localhost:8080/hello/hello.seam

BUILD SUCCESSFUL
Total time: 5 seconds
C:\Projects\jboss-seam&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启应用，转到&lt;code&gt;http://localhost:8080/helloworld/hello.seam&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;2.5 从已存的数据库生成一个应用&lt;/h2&gt;
&lt;p&gt;在数据库中手工创建一些表.输入:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;seam generate-entities
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启应用,转到&lt;code&gt;http://localhost:8080/helloworld&lt;/code&gt;。你可以浏览数据库，编辑已经存在的对象，创建新对象。如果你查看生成的代码，你将对它的简单感到吃惊！Seam被设置为易于访问数据，即不想使用seam-gen的用户。&lt;/p&gt;
&lt;h2&gt;2.6 使用EAR部署应用&lt;/h2&gt;
&lt;p&gt;最后，我们需要能将应用打包成标准的Java EE 5 的包。首先，我们需要运行&lt;code&gt;seam unexplode&lt;/code&gt;移除wxploded目录。输入&lt;code&gt;seam deploy&lt;/code&gt;命令部署EAR，或运行生成的工程中的&lt;code&gt;deploy&lt;/code&gt;任务。也可以使用&lt;code&gt;seam undeploy&lt;/code&gt;取消部署。&lt;/p&gt;
&lt;p&gt;默认情况下，将使用&lt;code&gt;dev&lt;/code&gt;配置来部署应用。EAR将包含persistence-dev.xml和import-dev.sql和myproject-dev-ds.xml。可以使用&lt;code&gt;prod&lt;/code&gt;配置文件来部署，输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;seam -Dprofile=prod deploy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以定义自己的应用部署配置文件。只需要添加适当的文件&amp;mdash;&amp;mdash;比如，persistence-staging.xml、import-staging.sql和myproject-staging-ds.xml并使用&lt;code&gt;-Dprofile=staging&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;2.7 Seam和增量热部署&lt;/h2&gt;
&lt;p&gt;当使用解压后的目录（exploded directory）部署Seam应用时，你将在开发时获得增量热部署的支持。也可以在components.xml中启动debug模式来启动Seam和Facelets的调试模式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;core:init debug="true"/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，下面的文件可以重新部署而不需要重启web应用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; 任何facelets页面
 任何pages.xml文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但如果你修改了Java代码，我们仍然需要重启应用。（在Jboss中可以通过修改EAR部署中的顶级部署描述application.xml，或WAR部署中的web.xml的时间戳。）&lt;/p&gt;
&lt;p&gt;但如果你想快速进行编辑/编译/测试周期，Seam支持JavaBean组件的增量部署。为使用这个功能，你必须将JavaBean组件部署到WEB-INF/dev目录，以便被特殊的Seam classloader加载，而不是被WAR或EAR的classloader加载。&lt;/p&gt;
&lt;p&gt;你需要知道有下面的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;组件必须是JavaBean组件，不能是EJB3 Bean（我们正在修正这个限制）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实例不能被热部署&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过components.xml部署的组件不可以被热部署&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;热部署的组件对于WEB-INF/dev之外的class loader是不可见的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Seam debug模式必须被启用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你使用seam-gen生成了一个WAR工程，增量热部署对于src/action源码目录下的类都是可用的。但是，seam-gen不支持EAR工程的热部署。&lt;/p&gt;
&lt;h1&gt;3 上下文组件模型&lt;/h1&gt;
&lt;p&gt;Seam中两个核心的概念是上下文（context）的概念和组件（component）概念。组件是有状态对象，使用EJB，组件的实例与一个上下文关联，在上下文中被命名，Seam允许组件树被动态装配和重新装配。&lt;/p&gt;
&lt;h2&gt;3.1 Seam上下文&lt;/h2&gt;
&lt;p&gt;Seam上下文是被框架创建和销毁的。应用不显示的使用Java API控制上下文的界限。上下文通常是隐式的。有些情况下，上下文界限通过注释来设置。&lt;/p&gt;
&lt;p&gt;基本的Seam上下文是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有状态上下文（Stateless context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件（或请求）上下文（Event(or request) context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面上下文（Page context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对话上下文（Conversation context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会话上下文（Session context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;业务流程上下文（Business process context）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用上下文（Application context）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你能从servlet和相关规范中识别出其中一些上下文。但其中两个可能是新的概念：对话上下文和业务流上下文。在web应用中状态管理比较脆弱和易于出的一个原因在于三个内置上下文（request，session和application）从业务逻辑的观点来看没有特别的含义。一个用户登录session，比如，任意构建的实际应用工作流。因此，多数Seam组件处于对话上下文或业务流程上下文中，因为它们对于应用是有含义的。&lt;/p&gt;
&lt;h3 id="311-you-zhuang-tai-shang-xia-wen"&gt;3.1.1 有状态上下文&lt;/h3&gt;
&lt;p&gt;真正有状态的组件（有状态session bean）总是存在于有状态上下文中。有状态组件并不是很有趣，可以证明不是很面向对象。但它仍然是很重要的且经常使用。&lt;/p&gt;
&lt;h3 id="312-shi-jian-shang-xia-wen"&gt;3.1.2 事件上下文&lt;/h3&gt;
&lt;p&gt;事件上下文是&amp;ldquo;窄&amp;rdquo;的有状态上下文，它是对web request上下文的封装。但是事件上下文与JSF请求的生命周期相关是事件上下文最重要的一个例子，它是你最常用的。与事件上下文关联的组件将在请求结束时被销毁，但它们的状态在请求周期中是有效的。&lt;/p&gt;
&lt;p&gt;当你通过RMI或Seam Remoting调用Seam组件，事件环境的创建和销毁仅在调用的期间。&lt;/p&gt;
&lt;h3 id="313-ye-mian-shang-xia-wen"&gt;3.1.3 页面上下文&lt;/h3&gt;
&lt;p&gt;页面组件允许你关联状态到一个被渲染的页面实例。你可以在你的事件监听中初始化状态，或当实际渲染页面时，然后可以从任何发源于这个页面的事件中访问它。这对于类似可选项列表这类的功能非常有用，这种情况下列表可能通过修改服务端修改数据而改变。状态实际上被序列化到客户端，因此这个机构对于多窗口操作和后退按钮来说非常健壮。&lt;/p&gt;
&lt;h3 id="314-dui-hua-shang-xia-wen"&gt;3.1.4 对话上下文&lt;/h3&gt;
&lt;p&gt;对话上下文是Seam中的一个中心概念。一个对话上下文对于用户来说是一组功能的集合。它可能处于多个用户交互，多个请求和多次数据库事务之间。但对于用户，一个对话只解决一个单一的问题。比如，&amp;ldquo;旅馆登记&amp;rdquo;，&amp;ldquo;批准合同&amp;rdquo;，&amp;ldquo;创建定单&amp;ldquo;都是对话。你可以把一个对话当作一个单一的&amp;rdquo;用例&amp;ldquo;，但这不是很准确。&lt;/p&gt;
&lt;p&gt;一个对话保持了关于&amp;ldquo;用户在这个窗口中正在做什么&amp;rdquo;的状态。在一个时间点上一个单一用户可以使用多个窗口拥有有多个对话。对话上下文允许我们确保多个不同的对话间不产生冲突。&lt;/p&gt;
&lt;p&gt;你可能需要花一些时间了解对话在应用中的作用。但一旦你使用它，你将喜欢上这个概念。&lt;/p&gt;
&lt;p&gt;一些对话只是简单的一个请求。对话跨多个请求可以使用Seam提供的注释来划分。&lt;/p&gt;
&lt;p&gt;一些对话也是任务。一个任务是一个长时间的业务处理，当它成功时可能触发业务流程状态的变迁。Seam为任务的划分提供了一套特殊的注释。&lt;/p&gt;
&lt;p&gt;对话可以嵌套，这是一个高级功能。&lt;/p&gt;
&lt;p&gt;通常，对话状态由Seam保持在请求之间的servlet session中。Seam实现可配置的对话超时，自动清除无效的对话，这确保单个用户的session状态不会过度增长。&lt;/p&gt;
&lt;p&gt;在同一个进程中Seam串行处理同一个长时间运行的对话上下文。&lt;/p&gt;
&lt;p&gt;Seam也可以配置为在客户端浏览器中保持对话状态。&lt;/p&gt;
&lt;h3 id="315-sessionshang-xia-wen"&gt;3.1.5 Session上下文&lt;/h3&gt;
&lt;p&gt;Session上下文保持登录用户session相关的状态。某些情况下这对于在多个对话间共享状态很有用，我们通常不赞成在session上下文中保持除登录用户全局信息外的其它组件。&lt;/p&gt;
&lt;p&gt;在JSR-168 portal环境，session上下文代表portlet session。&lt;/p&gt;
&lt;h3 id="316-ye-wu-liu-shang-xia-wen"&gt;3.1.6 业务流上下文&lt;/h3&gt;
&lt;h1&gt;Chapter 3. 上下文组件模型&lt;/h1&gt;
&lt;p&gt;（未完成）&lt;/p&gt;
&lt;h1&gt;环境配置&lt;/h1&gt;
&lt;p&gt;直接运行setup.bat按提示操作。&lt;/p&gt;
&lt;p&gt;要注意的一些问题：
 1. seam必须要在相匹配的JBoss版本上才能运行。我的机器上安装的JBoss为4.2.0GA，开始的时候试了一下运行jboss-seam-2.0.0.CR2，maven提示安装jboss-seam-gen这个包，手工下载了这个包，然后在jboss-seam-2.0.0.CR2/build/maven2/bin下的mvn命令来安装这个包。（注：在2.0.0.CR3中已经没有这个问题了）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;jboss-seam-1.x版本在JBoss-4.2.0GA上运行出错。jboss-seam-1.x需要JBoss-4.0.5x。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署jboss-seam-2.0.0.CR2/examples下的例子时需要先修改jboss-seam-2.0.0.CR2/build.properties添加一行指定jboss的路径，jboss.home=d:\jboss-4.2.0.GA。注意：即使在seam.bat setup时指定了正确的JBoss的路径，这里也必须要设置，这好像是jboss-seam-2.0.0.CR2的一个BUG。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;创建一个简单的例子&lt;/h1&gt;
&lt;h2&gt;seam create-project&lt;/h2&gt;
&lt;p&gt;创建一个项目&lt;/p&gt;
&lt;h2&gt;seam create-action&lt;/h2&gt;
&lt;p&gt;创建一个action类&lt;/p&gt;
&lt;h2&gt;seam create-form&lt;/h2&gt;
&lt;p&gt;创建一个表单&lt;/p&gt;
&lt;h2&gt;seam generate-entities&lt;/h2&gt;
&lt;p&gt;基于数据库生成CRUD代码（没有D）。
测试这个例子时不应该使用hsqldb，除非写了import.sql文件。在hsqldb启动后创建了表，否则在创建实体重启后会找不到表。&lt;/p&gt;
&lt;h1&gt;components.xml文件&lt;/h1&gt;
&lt;h2&gt;分页&lt;/h2&gt;
&lt;p&gt;可以通过在components.xml中注入每页最多显式的记录数，也可以修改XxxList类的getMaxResults的返回值。&lt;/p&gt;</content><category term="seam"></category><category term="jsf"></category></entry><entry><title>Emacs Org Mode及GTD</title><link href="/emacs-org-modeji-gtd.html" rel="alternate"></link><published>2009-01-09T00:00:00+08:00</published><updated>2009-01-09T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2009-01-09:/emacs-org-modeji-gtd.html</id><summary type="html">&lt;h1&gt;Org Mode常用快捷键&lt;/h1&gt;
&lt;h2&gt;文档操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TAB 折叠或打开子项&lt;/li&gt;
&lt;li&gt;S-TAB 折叠整个文档&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;节点操作相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;M-左右 左右移动节点&lt;/li&gt;
&lt;li&gt;M-S-左右 整体左右移动节点及子节点&lt;/li&gt;
&lt;li&gt;M-上下 上移或下移条目&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;记录操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;S-上下 调整条目的优先级&lt;/li&gt;
&lt;li&gt;C-c C-t 切换条目状态&lt;/li&gt;
&lt;li&gt;C-c C-s 设置计划时间&lt;/li&gt;
&lt;li&gt;C-s C-d 设置最后完成期限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;查找操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C-c / 按关键查找&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;日程相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C-c a a 日程表，再输入d、w或m分别表示按日、周或月查看&lt;/li&gt;
&lt;li&gt;C-c a t TODO列表&lt;/li&gt;
&lt;li&gt;C-c a m 按tag查找&lt;/li&gt;
&lt;li&gt;C-c a M 按tag查找，但只针对TODO项 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;Org Mode常用快捷键&lt;/h1&gt;
&lt;h2&gt;文档操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TAB 折叠或打开子项&lt;/li&gt;
&lt;li&gt;S-TAB 折叠整个文档&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;节点操作相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;M-左右 左右移动节点&lt;/li&gt;
&lt;li&gt;M-S-左右 整体左右移动节点及子节点&lt;/li&gt;
&lt;li&gt;M-上下 上移或下移条目&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;记录操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;S-上下 调整条目的优先级&lt;/li&gt;
&lt;li&gt;C-c C-t 切换条目状态&lt;/li&gt;
&lt;li&gt;C-c C-s 设置计划时间&lt;/li&gt;
&lt;li&gt;C-s C-d 设置最后完成期限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;查找操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C-c / 按关键查找&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;日程相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C-c a a 日程表，再输入d、w或m分别表示按日、周或月查看&lt;/li&gt;
&lt;li&gt;C-c a t TODO列表&lt;/li&gt;
&lt;li&gt;C-c a m 按tag查找&lt;/li&gt;
&lt;li&gt;C-c a M 按tag查找，但只针对TODO项&lt;/li&gt;
&lt;li&gt;C-a a C 按自定义方式查找&lt;/li&gt;
&lt;/ul&gt;</content><category term="emacs"></category><category term="org"></category></entry><entry><title>OA Framework应用构建之——实现控制器</title><link href="/build_control.html" rel="alternate"></link><published>2008-08-06T00:00:00+08:00</published><updated>2008-08-06T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-08-06:/build_control.html</id><summary type="html">&lt;h1&gt;设计一个OA Controller&lt;/h1&gt;
&lt;p&gt;如&lt;a href="/oa-framework-pagejie-xi.html"&gt;OA Framework Page解析&lt;/a&gt;中所描述的，OA Controller定义了web beans的行为。具体来说，编写控制器代码的目的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在运行时处理／初始化UI（包含那些通过编程方式添加的layout）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拦截或响应按钮按下之类的用户事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制器不应该包含任何业务逻辑；这应该属于模型类。&lt;/p&gt;
&lt;h2&gt;必备知识&lt;/h2&gt;
&lt;p&gt;通常来说，在提出如何设计控制器之前，应该思考一下是否需要创建控制器。&lt;/p&gt;
&lt;p&gt;作为一条规则，应该只在绝对必要的情况下才编写控制器。如果可以通过设计的方式创建页面，就不要通过编程的方式实现region和item。编程方式创建的web beans不能被个性化，重用或继承。而且，一些硬编码的layouts可能会丢失BLAF UI样式。&lt;/p&gt;
&lt;p&gt;在&lt;a href="/build_view.html"&gt;实现视图&lt;/a&gt;中说过，所有位于共同组件中的顶级regions必须与一个控制器关联。&lt;/p&gt;
&lt;h2&gt;粒度&lt;/h2&gt;
&lt;p&gt;OA Controllers可以与任何region关联（任何实现oracle.apps.fnd.framework.webui.beans.OAWebBeanContainer接口的web beans）；不能将控制器与items关联。&lt;/p&gt;
&lt;p&gt;许多OA Framework新手都想知道控制器应该是 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;设计一个OA Controller&lt;/h1&gt;
&lt;p&gt;如&lt;a href="/oa-framework-pagejie-xi.html"&gt;OA Framework Page解析&lt;/a&gt;中所描述的，OA Controller定义了web beans的行为。具体来说，编写控制器代码的目的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在运行时处理／初始化UI（包含那些通过编程方式添加的layout）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拦截或响应按钮按下之类的用户事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制器不应该包含任何业务逻辑；这应该属于模型类。&lt;/p&gt;
&lt;h2&gt;必备知识&lt;/h2&gt;
&lt;p&gt;通常来说，在提出如何设计控制器之前，应该思考一下是否需要创建控制器。&lt;/p&gt;
&lt;p&gt;作为一条规则，应该只在绝对必要的情况下才编写控制器。如果可以通过设计的方式创建页面，就不要通过编程的方式实现region和item。编程方式创建的web beans不能被个性化，重用或继承。而且，一些硬编码的layouts可能会丢失BLAF UI样式。&lt;/p&gt;
&lt;p&gt;在&lt;a href="/build_view.html"&gt;实现视图&lt;/a&gt;中说过，所有位于共同组件中的顶级regions必须与一个控制器关联。&lt;/p&gt;
&lt;h2&gt;粒度&lt;/h2&gt;
&lt;p&gt;OA Controllers可以与任何region关联（任何实现oracle.apps.fnd.framework.webui.beans.OAWebBeanContainer接口的web beans）；不能将控制器与items关联。&lt;/p&gt;
&lt;p&gt;许多OA Framework新手都想知道控制器应该是&amp;rdquo;多大&amp;ldquo;。应该一个页面一个，或一个功能region一个（比如&amp;ldquo;Search&amp;rdquo; region），或一个复合web bean（比如一个table）一个，或者？答案是要看情况。&lt;/p&gt;
&lt;p&gt;最初，在一个非常简单的页面，你可能不需要任何控制器（如果没有工作要作就不需要创建控制器）。如果需要编写代码，你需要根据下面的条件决定创建什么样的控制器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利于封装，一个web bean实现了它自己的行为&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组件重用，如果组件被设置为重用，它必须是自包含，自已自足。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码实用性，尽管页面包含了8个regions时可以很容易的添加8个控制器（每个包含少量的代码），这种&amp;ldquo;纯&amp;rdquo;OO的观念可以导致代码维护困难，可能导致产品代码文件膨胀。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一些方法可以帮助决定如何处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;永远不要从child bean中设置parent/grandparent web bean的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为相关联的region定义控制器来设置region和它的子孙region的属性。如果需要主控制器管理多个子／孙web bean，控制器应该与适当的父／祖父bean相关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于复杂的beans（比如OATableBean）应该将控制器关联到bean自身，或关联到一个简单的容器bean中（如果它实现功能逻辑单元）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，应该为页面创建少于满足上面规则和考虑数量的控制器。对于非常简单的页面，通常是为pageLayout区域关联单个的控制器。对于更复杂的页面，应该为各个功能组件（比如，查询页面中典型的&amp;ldquo;Search&amp;rdquo;区域控制器和&amp;ldquo;Results&amp;rdquo;区域控制器）创建少量不同的控制器。共享区域应该拥有自己的适当的控制器。&lt;/p&gt;
&lt;h2&gt;模型性／重用&lt;/h2&gt;
&lt;p&gt;在同一组相关联的页面中，你有时将找到可以重用代码的机会。下面是创建模块性更强的控制器代码的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在控制器中添加私自己的私有方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个公用的控制器类（它是oracle.apps.fnd.framework.webui.OAControllerImpl），然后为有需要的页面／区域继承这个类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建辅助的实用工具类，控制器中可以根据需要代理。这些类不需要实现任何OA Framework类或接口，应该被包含在与它们所辅助的控制器类所在的包中。注意，静态方法适合于在这些类中使用，当使用静态方法时，应该考虑下面的问题：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能影响子类中的静态方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;封装相关常量和静态方法。（There are packaging implications related to the use of constants and static methods ）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;线程安全&lt;/h2&gt;
&lt;p&gt;OA Framework被设计为支持多线程web bean访问（尽管还没有实现）。大部分对于你的代码来说是透明的，只有少量规则必须在控制器代码中遵守：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果在控制器或辅助类中使用静态方法，则永远不要包含状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总是将页面的OAPageContext传递给任何web bean存储器（如果需要可以带OAPageContext）。比如，使用setText(OAPageContext pageContext, String text)代替setText(String text)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;状态管理&lt;/h2&gt;
&lt;p&gt;不要在控制器中或你实例化的辅助类中添加非易失性成员变量。OA Framework不会钝化成员变量，因此一旦虚拟机失效被支持后将不能恢复这些值。可以添加static final成员变量。&lt;/p&gt;
&lt;h2&gt;编码规则&lt;/h2&gt;
&lt;h1&gt;创建一个控制器&lt;/h1&gt;
&lt;p&gt;为一个区域创建控制器：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在JDeveloper Structure页面中选择区域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右键选择Set New Controller...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在New Controller对话框中，输入包和类名。选择OK创建与选择区域关联的控制器。注意Inspector中的Controller Class属性值是类的全名，如：oracle.apps.fnd.framework.toolbox.tutorial.webui.HomeSearchCO。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JDeveloper将创建控制器模板。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*===========================================================================+&lt;/span&gt;
&lt;span class="cm"&gt; | Copyright (c) 2001, 2003 Oracle Corporation, Redwood Shores, CA, USA      |&lt;/span&gt;
&lt;span class="cm"&gt; | All rights reserved.                                                      |&lt;/span&gt;
&lt;span class="cm"&gt; +===========================================================================+&lt;/span&gt;
&lt;span class="cm"&gt; | HISTORY                                                                   |&lt;/span&gt;
&lt;span class="cm"&gt; +===========================================================================*/&lt;/span&gt;
&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.toolbox.tutorial.webui&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.common.VersionInfo&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.webui.OAControllerImpl&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.webui.OAPageContext&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.webui.beans.OAWebBean&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;  * Controller for ...&lt;/span&gt;
&lt;span class="cm"&gt;  */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OrderSummaryCO&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;OAControllerImpl&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;RCS_ID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"$Header$"&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;RCS_ID_RECORDED&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
   &lt;span class="n"&gt;VersionInfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;recordClassVersion&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RCS_ID&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"%packagename%"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

 &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Layout and page setup logic for a region.&lt;/span&gt;
&lt;span class="cm"&gt;   * @param pageContext the current OA page context&lt;/span&gt;
&lt;span class="cm"&gt;   * @param webBean the web bean corresponding to the region&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;

 &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;   * Procedure to handle form submissions for form elements in&lt;/span&gt;
&lt;span class="cm"&gt;   * a region.&lt;/span&gt;
&lt;span class="cm"&gt;   * @param pageContext the current OA page context&lt;/span&gt;
&lt;span class="cm"&gt;   * @param webBean the web bean corresponding to the region&lt;/span&gt;
&lt;span class="cm"&gt;   */&lt;/span&gt;
   &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 缺省的模板内容不包含processFormData(OAPageContext pageContext, OAWebBean webBean)方法，这个方法在POST处理的第一个阶段被调用。如果需要（非常少见），可以将它加到控制器中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 也可以通过编程的方式将控制器与区域关联。查看OAWebBeanContainer中的setControllerClass(String javaClass)方法。&lt;/p&gt;
&lt;h1&gt;处理HTTP GET&lt;/h1&gt;
&lt;p&gt;在GET处理过程中，每个控制器的processRequest(OAPageContext pageContext, OAWebBean webBean)方法被按照它们被实例化时的层级结构而依次被调用。处理从pageLayout bean开始，然后递归处理整个层级结构。初始化页面&amp;mdash;&amp;mdash;或影响层级结构中的web bean（通过设置属性，创建web bean等等）&amp;mdash;&amp;mdash;属于processRequest()方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 传递到processRequest()方法中的oracle.apps.fnd.framework.webui.OAWebBean参数是与当前控制器关联的区域。&lt;/p&gt;
&lt;p&gt;下面是一个典型的processRequet的代码。它描绘的是根据从&amp;ldquo;search&amp;rdquo;页面传递过来的参数，初始化用于查看的&amp;ldquo;detail&amp;rdquo;页面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Layout and page setup logic for region.&lt;/span&gt;
&lt;span class="cm"&gt; * @param pageContext the current OA page context&lt;/span&gt;
&lt;span class="cm"&gt; * @param webBean the web bean corresponding to the region&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// Always call this before adding your own code.&lt;/span&gt;
   &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// Get the purchase order number from the request.&lt;/span&gt;
   &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"headerId"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// We need to set the page header text to include the PO order number for reference.&lt;/span&gt;
   &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"PO_NUMBER"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;};&lt;/span&gt;

   &lt;span class="c1"&gt;// Always use a translated value from Message Dictionary when setting strings in&lt;/span&gt;
   &lt;span class="c1"&gt;// your controllers.&lt;/span&gt;
   &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;pageHeaderText&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_T_PO_HEADER_TEXT"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// Set the po-specific page title (which also appears in the breadcrumbs. Since this&lt;/span&gt;
   &lt;span class="c1"&gt;// controller is associated with the page layout region, simply cast the webBean&lt;/span&gt;
   &lt;span class="c1"&gt;// parameter to the right type and set the title.&lt;/span&gt;

   &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;OAPageLayoutBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;setTitle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageHeaderText&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// Now we want to initialize the query for our single purchase order with all of its&lt;/span&gt;
   &lt;span class="c1"&gt;// details.&lt;/span&gt;
   &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt; &lt;span class="o"&gt;};&lt;/span&gt;
   &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"initDetails"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end processRequest()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在调用super.processRequest(pageContxt, webBean)后，范例中的代码从request参数中获取名为&amp;ldquo;headerId（从Search页面传递过来的参数）&amp;rdquo;。这个值被显示在页面标题和breadcrumbs上，并且它被传递给模型以便查询。&lt;/p&gt;
&lt;p&gt;使用页面的title值定义页面标题和breadcrumbs：&lt;/p&gt;
&lt;p&gt;&lt;img alt="page_title" src="/oaf_build_control/page_title.gif"/&gt;&lt;/p&gt;
&lt;p&gt;由于显示于页面中的值必须被翻译，我们在Oracle应用消息字典（Oracle Application Message Dictionary）中创建了一个名为FWK_TBX_T_PO_HEADER_TEXT的消息，消息内容为&amp;ldquo;Purchase Order: &amp;amp;PO_NUMBER&amp;rdquo;。这个代码定义了以令牌PO_NUMBER作为Purchase Order Number的占位符，然后从oracle.apps.fnd.framework.webui.OAPageContext（它将操作委派给AOL/J）中提取翻译后的版本。然后将翻译后的字符串作为页面标题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 不要在用户界面中使用硬编码的文本值。所有以编程方式显示的文本值必须来源于消息字典（Message Dictionary）。也可以在设计时在web bean中使用这种方式（所有显示的bean属性都是被翻译的），或者也可以从多国语言表中查询出值来显示。&lt;/p&gt;
&lt;p&gt;最后，这个只读的&amp;rdquo;details&amp;ldquo;页面自动按给定的编号进行查询而不管它是否会被渲染。它通过将编号传递给页面根应用模块的initDetails()方法。然后应用模块将参数传递给适当的视图对象，在那里将参数与WHERE子句绑定并执行查询。&lt;/p&gt;
&lt;h2&gt;修改Bean属性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 作为规则来说，更好的修改web bean属性的方法是使用局部页面渲染（partial page rendering （PPR））和SPEL，在Dynamic User Interface中有描述。在不能通过PPR和SPEL的环境下，也必须在processRequest()方法中修改web bean层级结构（这节被包含在GET处理一章中，也是由于只能在processRequest()方法中才允许修改web bean层级结构）。&lt;/p&gt;
&lt;p&gt;如果需要以编程方式在响应表单提交的事件中修改层级结构，必须forward到同一个页面的processRequest()方法（见下面POST事件处理）。作出这个限制的原因有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;确保web bean层级结构能在需要的时候被正确的重建。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beans被适当的初始化。主要是Rendered属性，或影响复杂组件渲染的prepareForRendering()方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bean层级结构被放在同一个方法中维护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;修改web bean的属性时，只需要简单的根据它的名称（在JDeveloper中赋给它的ID）查找到正确的bean，然后按下面的方法调用适当的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 当获得web bean时，在调用它的任何方法前都需要检查对象是否为空。即使你认为bean被包含于web bean层级结构中，但也有可能在用户使用个性化定制时半它隐藏了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Always call this before adding your own code.&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;OATableBean&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OATableBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findIndexedChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OrdersTable"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OBJECT_NAME"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"OrdersTable"&lt;/span&gt;&lt;span class="o"&gt;)};&lt;/span&gt;
     &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_OBJECT_NOT_FOUND"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// Set the purchase-order specific "control bar" select text:&lt;/span&gt;
  &lt;span class="c1"&gt;// "Select Purchase Order(s) and..."&lt;/span&gt;

  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;selectPOText&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_T_SELECT_PO"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setTableSelectionText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;selectPOText&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用findIndexedChildRecursive(String name)方法可以在整个web bean层级结构中查找到第一个与名称匹配的被索引的子对象。如果如果要修改的web bean是一个被命名的UIX子对象（或，如果你不确定它是否&amp;ldquo;被命名（named）&amp;ldquo;或&amp;rdquo;被索引（indexed）&amp;ldquo;），则使用findChildRecursive(String name)方法。&lt;/p&gt;
&lt;p&gt;如果需要修改控制器区域的属性，只需要将processRequest()的OAWebBean参数转换为正确的类型并调用需要的方法。&lt;/p&gt;
&lt;h2&gt;编程的方式创建Bean&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 本节包含于GET处理部分，因为只允许在processRequest()方法中修改web bean层级结构。&lt;/p&gt;
&lt;p&gt;如果需要在响应表单提交事件中添加web bean到层级结构中，必须forward到同一个页面的processRequest()代码中执行。&lt;/p&gt;
&lt;p&gt;作为规则，如果你可以通过设计的方式产生web bean就不应该通过编程的方式产生web beans。另外，如果你的页面与局部页面渲染相关，则也不能在运行时修改web bean层级结构。&lt;/p&gt;
&lt;p&gt;对于那些极少见的必须手工实例化web bean的情况，则使用OAControllerImpl类中的createWebBean()工厂方法。不要直接使用web bean的构造器，不必担心要直接创建oracle.apps.fnd.framework.webui.OAWebBeanFactory，因为控制器的createWebBean()方法代理了OAWebBeanFactory。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 对于这些手工创建的beans，使用工厂方法时可以指定bean的&amp;ldquo;name&amp;rdquo;（JDeveloper中的ID属性）。避免使用deprecated的方法，它允许你在创建web bean时不指定name。web bean的名称（name）在同一个页面中必须是一个唯一标识。另外，bean的名称可能被OA Framework用于BC4J对象实例名（比如应用模块实例），因此不应该包含Java命名中规定的无效字符。&lt;/p&gt;
&lt;p&gt;比如，下面的代码描述了如何创建两个web bean并将它们添加到父区域中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OATableLayoutBean&lt;/span&gt; &lt;span class="n"&gt;tableLayout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OATableLayoutBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;findIndexedChildRecursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"tableLayout"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Create a row layout and give it the unique ID "topRow"&lt;/span&gt;
&lt;span class="n"&gt;OARowLayoutBean&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OARowLayoutBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;createWebBean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                     &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ROW_LAYOUT_BEAN&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                     &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// no need to specify a data type&lt;/span&gt;
                                                     &lt;span class="s"&gt;"topRow"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Create a row layout and give it the unique ID "bottomRow"&lt;/span&gt;
&lt;span class="n"&gt;OARowLayoutBean&lt;/span&gt; &lt;span class="n"&gt;anotherRow&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OARowLayoutBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;createWebBean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                            &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ROW_LAYOUT_BEAN&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                            &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// no need to specify a data type&lt;/span&gt;
                                                            &lt;span class="s"&gt;"bottomRow"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Always check to see if a web bean exists.&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tableLayout&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

   &lt;span class="c1"&gt;// Add the two row layout beans to the table so the "topRow" renders above&lt;/span&gt;
   &lt;span class="c1"&gt;// the "bottomRow"&lt;/span&gt;
   &lt;span class="n"&gt;tableLayout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addIndexedChild&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;tableLayout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addIndexedChild&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;anotherRow&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以通过编程的方式将设计时定制的web bean关联到父区域中。比如，在下面的代码中，名为&amp;ldquo;HomeSearchRN&amp;rdquo;的stackLayout区域是在JDeveloper中定义的，但它必须通过编程的方式创建side navigation component。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;OASideNavBean&lt;/span&gt; &lt;span class="n"&gt;sideNav&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OASideNavBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;createWebBean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                     &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;SIDE_NAV_BEAN&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                                     &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// no need to specify a data type&lt;/span&gt;
                                                     &lt;span class="s"&gt;"sideNav"&lt;/span&gt; &lt;span class="c1"&gt;// always specify name);&lt;/span&gt;

&lt;span class="n"&gt;OAStackLayoutBean&lt;/span&gt; &lt;span class="n"&gt;search&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
   &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAStackLayoutBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;createWebBean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                    &lt;span class="s"&gt;"/oracle/apps/fnd/framework/toolbox/tutorial/webui/HomeSearchRN"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                    &lt;span class="s"&gt;"HomeSearchRN"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// always specify name&lt;/span&gt;
                                     &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// region created in Oracle JDeveloper OA Extension&lt;/span&gt;

&lt;span class="n"&gt;sideNav&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addIndexedChild&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;search&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;约束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OA Framework并不能很容易的支持通过编程的方式添加、删除、替换任何&amp;ldquo;默认（default）&amp;rdquo;区域中的子对象（比如OA Extension中的defaultSingleColumn区域是oracle.apps.fnd.framework.webui.beans.layout.OADefaultSingleColumnBean的实例）。这些区域应该通过设计的方式定义。如果绝对必须替换或删除&amp;ldquo;默认（default）&amp;rdquo;区域（不能添加item），则要遵循下面的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;调用webBean.findIndexedChildRecursive()获得要被移除或替换的子web bean。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过调用子web bean的childWebBean.getAttribute(OAWebBeanConstants.PARENT)方法获取子web bean的父对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OAWebBeanConstants.PARENT属性被用作OA Framework内部开发使用（如果查看OAWebBeanConstants的Javadoc将看到警告信息）。只可以对缺省区域使用这个入口。另外，缺省区域已经不被推荐使用（deprecated），因此不应该在新的开发中使用这这些。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行从父bean中替换或移除自己的操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;处理HTTP POST（表单提交）&lt;/h1&gt;
&lt;p&gt;在HTTP POST处理过程中，OA Framework首先检查页面的web bean层级结构是否位于它的缓存中。如果没有（资源被限制或者用户使用了浏览器的后退按钮），则OA Framework必须在处理前重新创建web bean层级结构。这意味着processRequest()中的代码被重新执行，就好像浏览器发出了一个HTTP GET请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 可能发生的重建web bean层级结构将导致产生了大量编码上的考虑，这些在Chapter 6: Supporting the Brower Back Button和OA Framework View和Controller编码规范中有完整的描述。&lt;/p&gt;
&lt;p&gt;POST的主要处理过程发生在整个web bean层级结构中的两个分开的途径中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，OA Framework将在整个web bean层级结构中递归调用web bean的processFormData()方法将form的数据写入模型。任何需要在这个处理阶段执行的代码应该添加到控制器的processFormData(OAPageContext pageContext, OAWebBean webBean)方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假设第一阶段的处理过程中没有发生异常，OA Framework处理第二阶段，在每个web bean上调用processFormRequest(OAPageContext pageContext, OAWebBean webBean)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;processFormData()&lt;/h2&gt;
&lt;p&gt;多数情况（并非所有情况）下没有理由要覆盖这个方法。实际上，使用这种方法只会在极端的情况下，而不像是在OA Framework应用中：如果区域的数据源不是一个视图对象，因此没有为各个web bean定义视图实例和属性，这时你可以在区域的processFormData()方法中编码将子web bean的数据写入适当的数据源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework在item级实现了processFormData()，但你只能在region级别覆盖它，因此如果你实现了这个方法则必须处理region中的所有item。如果是有选择性的修改，则要记得先要调用super.processFormData(OAPageContext pageContext, OAWebBean webBean)。&lt;/p&gt;
&lt;h2&gt;processFormRequest()&lt;/h2&gt;
&lt;p&gt;任何处理用户表单提交的动作属于processFormRequest()方法。&lt;/p&gt;
&lt;p&gt;下面是一个典型的processFormRequest()的代码。它描述了好何决定是哪个组件的区域表单提交（在这里是&amp;ldquo;Go&amp;ldquo;按钮），如果开始在模型中查询，如何执行一个JSP Forward回到同一个页面以便在processRequest()方法中修改web bean的属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// Always call this before adding your code&lt;/span&gt;
   &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// Pressing the Go button causes the search to be executed.&lt;/span&gt;
   &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Go"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"SearchOrder"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Created"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyOrders"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

     &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

     &lt;span class="c1"&gt;// All parameters passed using invokeMethod() must be serializable.&lt;/span&gt;

     &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt; &lt;span class="o"&gt;};&lt;/span&gt;
     &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"search"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

     &lt;span class="c1"&gt;// Now forward back to this page so we can implement UI changes as a&lt;/span&gt;
     &lt;span class="c1"&gt;// consequence of the query in processRequest(). NEVER make UI changes in&lt;/span&gt;
     &lt;span class="c1"&gt;// processFormRequest().&lt;/span&gt;

     &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setForwardURLToCurrentPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// no parameters to pass&lt;/span&gt;
                                            &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// retain the AM&lt;/span&gt;
                                            &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ADD_BREAD_CRUMB_NO&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                            &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;IGNORE_MESSAGES&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end processFormRequest();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子展示了如何使用setForwardUrl()方法传递请求参数，包括了如休替换一个已经存在的参数值（在这里，&amp;ldquo;X&amp;rdquo;将成为目标页面被&amp;ldquo;忽略（ignore）&amp;ldquo;的值）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.sun.java.util.collections.HashMap&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.bali.share.util.IntegerUtils&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// Always call this before adding your code&lt;/span&gt;
   &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;poEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poEvent"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="n"&gt;HashMap&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// Replace the current poEvent request parameter value with "X"&lt;/span&gt;
   &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poEvent"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"X"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="c1"&gt;// IntegerUtils is a handy utility&lt;/span&gt;
   &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poStep"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;IntegerUtils&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInteger&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;

   &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setForwardURL&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OA.jsp?page=/oracle/apps/dem/employee/webui/EmpDetailsPG"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// target page&lt;/span&gt;
                             &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// not necessary with KEEP_MENU_CONTEXT&lt;/span&gt;
                             &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;KEEP_MENU_CONTEXT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// no change to menu context&lt;/span&gt;
                             &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// No need to specify since we're keeping menu context&lt;/span&gt;
                             &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// request parameters&lt;/span&gt;
                             &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// retain the root application module&lt;/span&gt;
                             &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ADD_BREAD_CRUMB_YES&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// display breadcrumbs&lt;/span&gt;
                             &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ERROR&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// do not forward w/ errors&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如果视图对象被作为被显示的web bean的数据源，则不要移除视图对象和它的行，以及嵌套包含的应用模块。如果你需要在定向到页面之前移除这些对象，则将不会显示视图对象中数据（出于性能优化的原因），在作出移除的调用后，确保使用oracle.apps.fnd.framework.webui.OAPageContext.forwardImmediatelyOAPageContext.setforwardURL方法定向到新页面。这保证了forward动作将立即发生，当前页面中forward调用后其它的web bean将不会处理；否则，移除视图对象或行实例将导致后续处理产生不良影响。&lt;/p&gt;
&lt;h2&gt;使用不同的技术POST到OA Framework页面&lt;/h2&gt;
&lt;p&gt;如果你使用不同的技术（比如JTT页面）POST到OA Framework页面，OA Framework只会执行目录页面的processRequest段。它不执行processFormData和processFormRequest段。&lt;/p&gt;
&lt;h1&gt;与模型交互&lt;/h1&gt;
&lt;p&gt;简单来说，应该只从OA Controller中直接访问应用模块。换言之，在控制器中唯一有效的模型导入代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.OAApplicationModule&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不应该访问视图对象直接执行查询、迭代行集或与下层的实体交互。比如，下面的代码（尽管技术上是可行的）是不符合OA Framework Controller Coding Starndards的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.OAViewObject&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;...&lt;/span&gt;

   &lt;span class="c1"&gt;// Get the root application module&lt;/span&gt;
   &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRootApplicationModule&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

   &lt;span class="c1"&gt;// Find the view object you want to query&lt;/span&gt;
   &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAViewObject&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;instanceName&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

   &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要执行视图对象查询，应该按下面在&amp;ldquo;Search&amp;rdquo;区域中按下&amp;ldquo;Go&amp;rdquo;按钮的事件处理的例子的方式。&lt;/p&gt;
&lt;p&gt;首先，添加方法到应用模块中（这个例子中，它是页面的根应用模块）它接收查询，然后将它委派给视图对象执行查询（查看&lt;a href="/build_model.html"&gt;实现模型&lt;/a&gt;获取关于查询的信息）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;search&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PoSummarySimpleExpVOImpl&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPoSummarySimpleExpVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// Always check for the null condition if the VO cannot be found/created&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OBJECT_NAME"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"PoSummarySimpleExpVO"&lt;/span&gt;&lt;span class="o"&gt;)};&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_OBJECT_NOT_FOUND"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initQuery&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;orderNumber&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end search()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，添加如下的按钮处理代码到控制器中，它调用应用模块中对应的方法。&lt;/p&gt;
&lt;p&gt;注意，总是应该在processFormRequest()的代码中检查事件源；不要假设浏览器发送的POST请求是由于你的item被选中了（即使是一个只有一个按钮的简单页面）。在后台，OA Framework经常提交页面的表单，而这可能是不是你所期望的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

  &lt;span class="c1"&gt;// Check to see if the "Go" button was pressed...&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"gButton"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Get the search criteria&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"SearchOrder"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Created"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyOrders"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// All parameters passed using invokeMethod() must be serializable.&lt;/span&gt;
    &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;orderNumber&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;showMyOrders&lt;/span&gt; &lt;span class="o"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"search"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 不要在服务端BC4J组件中调用invokeMethod()，任何你传递的参数必须是Serializable类型的。上例中展示的的invokeMethod()方法需要的参数都是字符串。如果需要传递其它对象类型，可以使用带一个类型数组参数版本的invokeMethod()。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Class&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;parameterTypes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Hashtable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt; &lt;span class="o"&gt;...};&lt;/span&gt;
&lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"search"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameterTypes&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似地，由于视图对象是实体对象的导管&amp;mdash;&amp;mdash;不应该在控制器中直接与视图对象交互&amp;mdash;&amp;mdash;也应该通过应用模块来处理实体操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如&lt;a href="/build_model.html"&gt;实现模型&lt;/a&gt;中描述的，添加到应用模块中的方法命名应该与UI&amp;ldquo;事件（events）&amp;ldquo;对应。比如，如果用户按了&amp;ldquo;Create&amp;rdquo;按钮，应用模块方法应该命名为&amp;ldquo;create&amp;rdquo;等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建的实例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"create"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;删除的实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个例子展示了调用共享区域中的嵌套应用模块中的delete方法而不是调用页面根应用模块中的方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"DeleteYesButton"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// User has confirmed that she wants to delete this purchase order.&lt;/span&gt;
   &lt;span class="c1"&gt;// Invoke a method on the AM to set the current row in the VO and&lt;/span&gt;
   &lt;span class="c1"&gt;// call remove() on this row.&lt;/span&gt;

   &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;poHeaderId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poHeaderId"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="n"&gt;poHeaderId&lt;/span&gt; &lt;span class="o"&gt;};&lt;/span&gt;

   &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"delete"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

 &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;自定义动作实例（&amp;ldquo;Approve&amp;rdquo;）&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Approve"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"approve"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;提交操作实例&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// Simply telling the transaction to commit will cause all the Entity Object validation&lt;/span&gt;
   &lt;span class="c1"&gt;// to fire.&lt;/span&gt;
   &lt;span class="c1"&gt;//&lt;/span&gt;
   &lt;span class="c1"&gt;// Note: there's no reason for a developer to perform a rollback. This is handled by&lt;/span&gt;
   &lt;span class="c1"&gt;// the OA Framework if errors are encountered during the processFormData phase.&lt;/span&gt;

   &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"apply"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;禁用校验&lt;/h1&gt;
&lt;p&gt;有多个机会可以屏蔽在处理OA Framework HTTP POST过程中的校验。比如，实现表格中的&amp;rdquo;Add Another Row&amp;ldquo;中，在用户添加新行的操作时，可能不需要因为未填写完整的行数据而显示错误信息。同样，你可能在一个多步骤的页面流中想要将校验延时到最后一个预览提交页面，或者通过tabs导航到同一个下层对象的不同视图上时。&lt;/p&gt;
&lt;h2&gt;禁用服务端校验&lt;/h2&gt;
&lt;p&gt;为了阻止从模型校验逻辑中抛出异常，在页面中与下面列表对应的bean上调用setServerUnvalidated(true)方法（记住在processRequest()方法中添加修改web bean的代码）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OASubmitButtonBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OATableBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAAdvancedTableBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OASubTabLayoutBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OANavigationBarBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OADefaultHideShowBean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OAHideShowHeaderBean&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 也可以在设计时设置组件的Disable Server Side Validation属性为True，也可以为那些配置为提交表单的链接或图标设置禁用校验。查看下面的Javascript URL一节获得更多信息。&lt;/p&gt;
&lt;p&gt;当用户执行一个由这些bean导致的表单提交时，OA Framework按上面描述的方式执行所有的HTTP POST处理&amp;mdash;&amp;mdash;包括执行属性级别的校验逻辑（实体级别的校验没有被执行）。如果在处理processFormData()过程中抛出了oracle.apps.fnd.framework.OARowValException或oracle.apps.fnd.framework.OAAttrValException异常（功它们被deprecated的子类），OA Framework只是简单的忽略这些异常，并继续执行就像没有遇到异常一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework不会忽略processFormData()中的严重异常（比如NullPointerException）。这些会按正常的方式显示出来，并且不会继续处理processFormRequest()。而且processFormRequest()中由你或者由BC4J抛出的异常都会被正常的显示出来。&lt;/p&gt;
&lt;h2&gt;禁用客户端校验&lt;/h2&gt;
&lt;p&gt;当一个带的客户输入的数据的表单提交时，UIX执行一些基础的onSubmit JavaScript校验（它校验必填字段，数据类型和格式），如果校验通过就提交表单。为了屏蔽校验，也需要在上节&amp;ldquo;禁用服务端校验&amp;rdquo;中的bean列表中的bean上调用setUnvalidated(true)方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 也可以在设计时设置组件的Disable Server Side Validation属性为True，也可以为那些配置为提交表单的链接或图标设置禁用校验。查看下面的Javascript URL一节获得更多信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 对于tables和HGrid组件，必须通过设置table和HGrid区域自己的属性启用／禁用客户端校验，因为你不能直接访问OANavigationBarBean的用作数据集导航的子web bean。注意，现在不能禁用这些组件的服务端校验。&lt;/p&gt;
&lt;h1&gt;错误处理&lt;/h1&gt;
&lt;p&gt;OA Framework自动显示模型层抛出的任何错误信息；不需要在控制器中做什么就能处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查看Error Handling获取更多关于在控制器中抛出异常和在页面顶端显示错误、警告、确认信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看Chapter 4: Dialog Pages获取关于显示模型错误、警告、确认和信息的对话框页面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;JavaScript&lt;/h1&gt;
&lt;p&gt;UIX和OA Framework正在快速的添加新的功能以提供更好的用户体验（区域页面渲染、自动的表格统计等等）。当这些功能发布后，你将受益于这些功能，但是，在这之前你不应该自己实现这些功能。&lt;/p&gt;
&lt;p&gt;简单来说，Javascript在OA Framework开发团队外是被禁止的。&lt;/p&gt;
&lt;h2&gt;JavaScript URL&lt;/h2&gt;
&lt;p&gt;以前，如果需要配置链接或图像来提交页面表单（由于你需要在导航到新页面前处理事件），可以将它设置在UIX submitForm Javascript函数中。&lt;/p&gt;
&lt;p&gt;现在，应该配置fireAction事件来代替使用Javascript URL。查看Declarative Submit Form文档获取其它信息。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>OA Framework状态管理</title><link href="/oa-frameworkzhuang-tai-guan-li.html" rel="alternate"></link><published>2008-07-25T00:00:00+08:00</published><updated>2008-07-25T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-25:/oa-frameworkzhuang-tai-guan-li.html</id><summary type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;这个文档用于描述OA Framework状态管理架构，包括缓存应用系统用户数据和从页面间值传递的机制。&lt;/p&gt;
&lt;h1&gt;结构预览&lt;/h1&gt;
&lt;p&gt;主要状态管理组：&lt;/p&gt;
&lt;p&gt;&lt;img alt="state_architecture" src="/oaf_state/state_architecture.gif"/&gt;&lt;/p&gt;
&lt;h1&gt;根应用模块（数据库会话和事务状态）&lt;/h1&gt;
&lt;p&gt;如&lt;a href="/page.html"&gt;OA Framework 页面解析&lt;/a&gt;一文中描述的，每个OA Framework页面与一个根应用模块关联，根应用模块提供事务环境和JDBC数据库连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework中，一个数据库会话与一个JDBC连接关联。&lt;/p&gt;
&lt;p&gt;根应用模块是任何OA Framework模块的中枢，因为核心应用数据（存储在BC4J视图，实体对象，等等）和页面web bean层级结构自动缓存于根应用模块的oracle.apps.fnd.framework.OADBTransaction对象中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 使用浏览器后退按钮将导致应用模块状态丢失。可以查看Supporting the Browser Back Button一文。&lt;/p&gt;
&lt;p&gt;任何存储于事务中的数据可以被任何共享同一个根应用模块实例的页面访问（在页面间导航时使用下面描述的方式保留应用模块）。OA Framework提供了方法用于从事务中存储、获取和移除值。可以在控制器（client）和模型（server）代码中访问单一的事务对象，这些工具在oracle …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;这个文档用于描述OA Framework状态管理架构，包括缓存应用系统用户数据和从页面间值传递的机制。&lt;/p&gt;
&lt;h1&gt;结构预览&lt;/h1&gt;
&lt;p&gt;主要状态管理组：&lt;/p&gt;
&lt;p&gt;&lt;img alt="state_architecture" src="/oaf_state/state_architecture.gif"/&gt;&lt;/p&gt;
&lt;h1&gt;根应用模块（数据库会话和事务状态）&lt;/h1&gt;
&lt;p&gt;如&lt;a href="/page.html"&gt;OA Framework 页面解析&lt;/a&gt;一文中描述的，每个OA Framework页面与一个根应用模块关联，根应用模块提供事务环境和JDBC数据库连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework中，一个数据库会话与一个JDBC连接关联。&lt;/p&gt;
&lt;p&gt;根应用模块是任何OA Framework模块的中枢，因为核心应用数据（存储在BC4J视图，实体对象，等等）和页面web bean层级结构自动缓存于根应用模块的oracle.apps.fnd.framework.OADBTransaction对象中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 使用浏览器后退按钮将导致应用模块状态丢失。可以查看Supporting the Browser Back Button一文。&lt;/p&gt;
&lt;p&gt;任何存储于事务中的数据可以被任何共享同一个根应用模块实例的页面访问（在页面间导航时使用下面描述的方式保留应用模块）。OA Framework提供了方法用于从事务中存储、获取和移除值。可以在控制器（client）和模型（server）代码中访问单一的事务对象，这些工具在oracle.apps.fnd.framework.webui.OAPageContext(controller中)和OADBTransaction(model中)类可以访问。&lt;/p&gt;
&lt;h2&gt;根应用模块保留&lt;/h2&gt;
&lt;p&gt;缺省情况下，当用户从一个页面导航到另一个页面（比如使用GET请求或JSP forward）时，OA Framework渲染新的页面，与前一个页面关联的应用模块实例被&amp;ldquo;释放&amp;rdquo;，一个新的实例请求被发送到应用模块池。&lt;/p&gt;
&lt;p&gt;导航到新的页面时，缺省情况下的原页面的根应用模块将被释放：&lt;/p&gt;
&lt;p&gt;&lt;img alt="root_am_default" src="/oaf_state/root_am_default.gif"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework在表单提交（POST）期间不会释放应用模块，除非你显式的在控制器中释放应用模块。比如，如果用户对表格中的数据排序或在表格数据中导航&amp;mdash;&amp;mdash;两个动作隐式的提交了页面表单&amp;mdash;&amp;mdash;页面的根应用模块实例被自动保留。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在页面间保留应用模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在多个页面处理同一个任务时相关的页面需要参与同一个虚拟事务。这时，不同页面需要关联到同一个根应用模块实例。&lt;/p&gt;
&lt;p&gt;相关页面共同同一个根应用模块（和事务）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="root_am_retain" src="/oaf_state/root_am_retain.gif"/&gt;&lt;/p&gt;
&lt;p&gt;为达到这个目的，必须执行下面的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;申明各个页面关联同一个类型的根应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置应用模块的保留标记。通过指定URL参数retainAM=y设置模块保留标记。对于GET请求。当新的页面被渲染时（注意，OA Framework对于POST请求将一直保留应用模块而不管retainAM参数的值）。如果设置为&amp;ldquo;Y&amp;rdquo;，前一个页面的应用模块实例将被保留。如果设置为&amp;ldquo;N&amp;rdquo;（或不指定，缺省为&amp;ldquo;N&amp;ldquo;），OA Framework将释放所有应用模块&amp;mdash;&amp;mdash;包括到达这点前任何可能显式申明为保留的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也可以在调用JSP forward OAPageContext中的方法时设置这个参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 不能简单的让不同页面关联相同的根应用模块。如果忘记设置retainAM标记，每个页面仍将使用不同的应用模块实例和事务，即使这些页面关联的是同一个类型的应用模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 技术上来说，这依赖于应用模块池的状态。Page B可能获取到与Page A使用的同一个物理应用模块。但是，对象的状态将完全被重置，就像被新创建的一样。从这个观点来看，可以看作一个&amp;ldquo;新的实例&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;两个页面引用相同类型的应用模块，但没有设置Retain AM标记：&lt;/p&gt;
&lt;p&gt;&lt;img alt="root_am_noretainproblem" src="/oaf_state/root_am_noretainproblem.gif"/&gt;&lt;/p&gt;
&lt;p&gt;同样，将retainAM标记设置为&amp;ldquo;Y&amp;ldquo;&amp;mdash;&amp;mdash;但没有将页面的根应用模块设置为相同的类型。这将产生不同的应用模块实例（每个页面一个），各自有自己的事务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有条件的保留和释放应用模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有些情况下，你需要通过一个条件来决定是否保留或释放应用模块。这时，你可以让应用模块实现oracle.apps.fnd.framework.webui.OAReleaseListener接口，详细描述见Javadoc。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; Oracle Application开发人员应该在使用这个接口时通知OA Framework开发团队。不正确的使用这个接口将导致内存泄漏。OA Framework团队正在跟踪这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;显式的释放应用模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以显式的通过代码在OA Framework处理之前释放根应用模块。可以在页面控制器中调用OAPageContext.releaseRootApplicationModule()方法，OA Framework将在页面渲染完成后尽快释放这个页面的根应用模块，而不是等到下次应用模块请求时。&lt;/p&gt;
&lt;h2&gt;根应用模块保留的使用场景&lt;/h2&gt;
&lt;p&gt;下列情况下推荐保留／释放应用模块。&lt;/p&gt;
&lt;p&gt;情况 || 推荐操作
无关的分离的任务 | 当导航到两个不相关的页面时不保留应用模块。比如一连串的不相关的管理任务，它们是独立运行的（即使这们与同一个菜单项目关联），保留应用模块是不必要的。
多页面流 | 当在相关的页面间导航时，这些页面合作完成同一个完整的任务处于单个事务中时，保留应用模块
相关页面（虚拟事务） | 当在关联同一个业务对象（即使页面为用户设置了不同的提交点）的不同任务间的相关页面间导航时，如果UI关联得比较紧密则保留应用模块。比如，一个模块可以查询、查看、更新、删除、打印写单则应该使应用模块保留
多页面流中使用分支事务 | 有一个多页面流使用了分支事务，比如，在创建定单时创建供应商时，在主流程中保留应用模块，而在创建供应商的页面使用OAPageContext.releaseRootApplicationModule方法释放模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在介绍OA Framework的钝化和JDBC池化/回收之前，鼓励开发人员经常的释放应用模块，因为保留JDBC连接是一个昂贵的开销。在了解钝化功能后这不再是个问题。&lt;/p&gt;
&lt;h1&gt;Servlet Session&lt;/h1&gt;
&lt;p&gt;可以在servlet session中缓存小型的，可序列化的对象（OA Framework限定为字符串，数字和日期类型）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 使用session缓存那些需要在多个页面设置或访问的简单值，这些页面可以有不同的根应用模块。（事务缓存不在这个范围内）。由于session变量失效时间较长，且没有好的事件可以释放内存，因此应该把session作为最后一种缓存选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 隐藏域通常不被推荐使用。因此，OA Framework当前的菜单实现（一些菜单发送GET请求而不是POST请求），并不总是能在用户点击菜单时添加额外的值，根应用绑定是交叉的。&lt;/p&gt;
&lt;p&gt;可以使用OAPageContext put&lt;em&gt;()，get&lt;/em&gt;()和remove*()方法访问session变量值。&lt;/p&gt;
&lt;h1&gt;Oracle 应用用户Session&lt;/h1&gt;
&lt;p&gt;当用户登录到OA Framework application时，OA Framework将创建一个AOL/J oracle.apps.fnd.comn.WebAppsContext对象和一个基于session的浏览器cookie以跟踪Oracle Application context信息的key。Oracle Application context中的信息包括当前的责任，组织机构id和用户的各种属性，比如：用户名，用户id，雇员id等等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cookie包含了一个加密的key用于标识存储于Application数据库中的一个session行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每次请求时WebAppsContext获取这个key的值，并使用它查询当前session状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Oracle Application用户session与一个servlet session关联，但是它有自己的生命周期和超时特性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常，Oracle Application用户session的生存时间比servlet session更长。servlet session超时快一些。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个Oracle Application用户session可能关联到多个servlet session中。比如，当用户在创建开支报表时，打电话的过程中servlet session超时了，然后在Oracle Application用户session超时前恢复工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果Oracle Application用户session超时了，只要用户没有关闭浏览器窗口（因此基于浏览器session的coolie并没有丢失）并且没有人删除ICX_SESSION表中相应的session行，用户可以在提示登录后重新登录并恢复她之前停止时的事务点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你需要访问任何存储于Oracle Application user session的信息，可以从OAPageContext(在控制器代码中)或OADBTransaction（在模型代码中）获得。&lt;/p&gt;
&lt;h2&gt;应用状态（Application Context State）&lt;/h2&gt;
&lt;p&gt;当不同访问OAPageContext（Java服务层代码或PL/SQL）时，可以使用Application context存储一些状态信息。使用WebAppsContext.setSessionAttribute(java.lang.String pName,java.lang.String pValue)方法。&lt;/p&gt;
&lt;h1&gt;页面环境（Page Context）&lt;/h1&gt;
&lt;p&gt;每次请求接收一个页面时，OA Framework创建一个OAPageContext并持续到新页面处理完成。明确，OAPageBean的主要能力是在页面后面处理创建OAPageContext。&lt;/p&gt;
&lt;h2&gt;请求和页面边界&lt;/h2&gt;
&lt;p&gt;web应用的工作单元是一个请求／响应对：浏览器提交一个请求，servlet处理请求并返回一个响应。发送一个响应表示单个请求的结束，或者说一个已经完成的请求和一个新请求之间的&amp;ldquo;边界&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;同样，当OAPageBean完成一个页面处理时，这就是当前页面和新页面的&amp;ldquo;边界&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;因此，在下面的简单场景中当用户从Page X转到Page A然后再转到Page B，这里有两个请求边界：第一个是Page X和Page A之间，第二个位于Page A和Page B之间。这里也有两个页面边界位于Page X和Page A，Page A和Page B之间。&lt;/p&gt;
&lt;p&gt;请求和页面边界相同：&lt;/p&gt;
&lt;p&gt;&lt;img alt="boundary_case1" src="/oaf_state/boundary_case1.gif"/&gt;&lt;/p&gt;
&lt;p&gt;有些情况下，请求和页面边界是不相同的。比如下面的JSP Forward情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户如上面的图中所示的，从Page X导航到Page A。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当在Page A上时，用户选择了一个控件，Page A的代码在决定在响应中显示哪个页面前进行计算。浏览器发出请求到Page A，OA Framework进行处理，并为页面创建了一个OAPageContext。一旦Page A的处理完成后，第一个页面的边界到达了，已经如下面的图所示的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Page A的代码中，开发人员执行用户选择的控件并发出JSP Forward到Page B。而不是在这时提供了一个HTTP响应，因为我们不想显示Page A，OA Framework首先处理Page B，并为这个页面创建一个新的OAPageContext对象。一旦Page B的处理完成，第二个页面边界到达。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于Page B现在必须显示给用户了，一个HTTP响应被发送给浏览器。这时响应边界到达了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在JSP Forward情况下，请求界面和页面界面不同：&lt;/p&gt;
&lt;p&gt;&lt;img alt="boundary_case2" src="/oaf_state/boundary_case2.gif"/&gt;&lt;/p&gt;
&lt;p&gt;明确这个区别是很重要的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求参数生存于请求生命周期中，它可以跨越多个页面边界。想像下面的情况：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户选择了Page X中的一个链接导航到Page A。Page A的URL包含了参数foo=bar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Page A请求JSP Forward到Page B。现在，尽管已经在新页面中了，但请求仍然包含了foo=bar。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你不希望请求参数在执行JSP Forward后仍然存在，你必须的替换它。比如，在调用OAPageContext.setForward*()之前，简单的重新设置foo=X。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 不能从请求中移除参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 比较好的处理方式是将参数值设置为一个不需要的值，这样代码可以忽略它。而不要简单的将值设置为""。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于page context和request不是一一对应的，一些人可以会对从OAPageContext中访问请求参数觉得迷惑。只要记住每个页面是一个独立的实体，从它的观点来看，OAPageContext表现了request。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当了钝化的细节后，将更清楚明白页面和请求边界的区别，甚至是受钝化的影响也不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;请求Request&lt;/h1&gt;
&lt;p&gt;对每个HTTP request都将创建一个请求对象。这个对象包含下面的应用状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;任何URL参数，不论是POST或GET请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果浏览器发出一个POST请求：任何form字段值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果浏览空对空发出POST请求：web bean和事件名称与用户选择的动作或控件组件关联。比如：如果用户选择了&amp;ldquo;GO&amp;rdquo;按钮执行一个查询，请求将包含以这个按钮命名的web bean，以便你能获取到是这个按钮被按下了而做出响应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用OAPageContext getParameter*()方法获取任何请求值。不能直接与request对象交互。&lt;/p&gt;
&lt;p&gt;设置request变量值（首选的两个页面间通讯的方法）时，你可以使用下面介绍的方法。参考视图实现和控制器实现的相关信息。&lt;/p&gt;
&lt;h2&gt;使用隐藏域&lt;/h2&gt;
&lt;p&gt;可以在JDeveloper中设置域的style属性为formValue。运行时，是使用oracle.apps.fnd.framework.webui.beans.form.OAFormValueBean来实现的。&lt;/p&gt;
&lt;h2&gt;在JSP Forward或客户端重定向时指定值&lt;/h2&gt;
&lt;p&gt;当显式的forward到新页面时，使用OAPageContext setForward*()方法或调用OAPageContext.sendRedirect()请求客户端重定时，可以随意设置请求的参数值。&lt;/p&gt;
&lt;h2&gt;调用OAPageContext.putParameter()指定参数值&lt;/h2&gt;
&lt;p&gt;OAPageContext包含了一个putParameter()方法，它可以在页面是过程中传递值到web bean结构中。通过调用putParameter()指定的值技术上来说并不是加到request中的，而是存储于特殊的页面缓存中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 可以把这个方法与servlet 2.1 API中的HttpServletRequest.setAttribute()方法等同起来。&lt;/p&gt;
&lt;h2&gt;申明URL参数&lt;/h2&gt;
&lt;p&gt;可以在JDeveloper中开发时指定URL参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; URL长度是受限的；对于添加大量URL参数要谨慎注意它的长度。由于URL对于用户是可见的，要注意加密敏感的数据。&lt;/p&gt;
&lt;h1&gt;状态持久化模型（'钝化Passivation'）&lt;/h1&gt;
&lt;p&gt;OA Framework应用主要是事务导向的。许多事务跨越了多个页面，这些页面的事务需要某种机制保持到用户完成相关的任务。&lt;/p&gt;
&lt;p&gt;HTTP协议天生就是无状态的；它不保留任何应用状态信息或保证状态的持久化。甚至，即使是在JVM实例提供的servlet session失败或servlet session超时后，应用状态也将丢失，挂起的事务也不能恢复。&lt;/p&gt;
&lt;p&gt;OA Framework具有透明的保存和恢复客户端状态的能力&amp;mdash;&amp;mdash;即使servlet session超时（未来的版本将提供JVM失效的支持）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将应用状态保存到辅助介质上的过程叫作钝化（passivation）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从辅助介质上恢复状态的过程叫作激活（activation）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OA Framework当前提供了下面的状态管理功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可伸缩的应用当资源占用比较高的情况下，需要为新的服务线程创建新的资源，OA Framework将保存挂起的线程的状态并回收它们的资源以供其它用户使用。当挂起的用户线程被唤醒后，保存的应用状态被恢复。简单来说，内在被重新分配给JDBC连接，应用模块，用户session而不会影响用户的使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Servlet session超时恢复servlet session允许超时，而不需要强制用户启动一个新的事务。（将来，这个功能将扩展为支持中间层失效）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;应用模块池&lt;/h1&gt;
&lt;p&gt;为提高性能和可伸缩性，OA Framework池化（缓存和重用）应用模块。重用比重新创建更有效。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个JVM有一个应用模块池管理器，它包含并管理各个应用模块池。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个应用模块池包含多个同一应用模块的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用模块池中的实例被设计为可以置为可用或不可用（现在被称为"checked out"）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有根应用模块被池化；嵌套的应用模块不会被池化为根应用模块的子应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用模块池：&lt;/p&gt;
&lt;p&gt;&lt;img alt="am_pool" src="/oaf_state/am_pool.gif"/&gt;&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>Programming in Emacs Lisp笔记</title><link href="/programming-in-emacs-lispbi-ji.html" rel="alternate"></link><published>2008-07-16T00:00:00+08:00</published><updated>2008-07-16T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-16:/programming-in-emacs-lispbi-ji.html</id><summary type="html">&lt;h1&gt;序&lt;/h1&gt;
&lt;h1&gt;表处理&lt;/h1&gt;
&lt;h2&gt;Lisp列表&lt;/h2&gt;
&lt;h3 id="shu-zi-lie-biao-zhong-de-lie-biao"&gt;数字，列表中的列表&lt;/h3&gt;
&lt;p&gt;列表里也可以包含数字：(+ 2 2)。&lt;/p&gt;
&lt;p&gt;Lisp里的数据和程序都是相同的方式实现的，他们都是在括号中由单词、数字或者其它列表组成的用空白分隔的列表。因为程序看起来像数据，所以一个程序可以当作数据传递给另一个程序，这是lisp一强非常强大的功能。&lt;/p&gt;
&lt;h3 id="lispyuan-zi"&gt;Lisp原子&lt;/h3&gt;
&lt;p&gt;Lisp列表中的单词叫原子（意为原子在Lisp列表中不可再分割成更小的单位）。与原子不同，list可以分隔成更小的单位（car cdr &amp;amp; cons）。&lt;/p&gt;
&lt;p&gt;空的列表：()，被称作空列表。与其它的数据类型不同，空列表被同时看作原子和列表。&lt;/p&gt;
&lt;p&gt;与自然界的原子一样,Lisp中的原子这个名称来出现得太早（意指与自然界的原子一样，原子还可以再分割）。Lisp中部分原子，比如数组就可以进行分割。但是这种机制与列表的分隔是不同的。如果依据对列表的分隔方式来说，列表中原子就是不可分隔的了。&lt;/p&gt;
&lt;h3 id="lie-biao-zhong-de-kong-bai"&gt;列表中的空白&lt;/h3&gt;
&lt;p&gt;额外的空白被用来提高代码的可读性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;
   &lt;span class="nv"&gt;looks&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;looks&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是相同的。&lt;/p&gt;
&lt;h3 id="lie-biao-pai-ban"&gt;列表排版 …&lt;/h3&gt;</summary><content type="html">&lt;h1&gt;序&lt;/h1&gt;
&lt;h1&gt;表处理&lt;/h1&gt;
&lt;h2&gt;Lisp列表&lt;/h2&gt;
&lt;h3 id="shu-zi-lie-biao-zhong-de-lie-biao"&gt;数字，列表中的列表&lt;/h3&gt;
&lt;p&gt;列表里也可以包含数字：(+ 2 2)。&lt;/p&gt;
&lt;p&gt;Lisp里的数据和程序都是相同的方式实现的，他们都是在括号中由单词、数字或者其它列表组成的用空白分隔的列表。因为程序看起来像数据，所以一个程序可以当作数据传递给另一个程序，这是lisp一强非常强大的功能。&lt;/p&gt;
&lt;h3 id="lispyuan-zi"&gt;Lisp原子&lt;/h3&gt;
&lt;p&gt;Lisp列表中的单词叫原子（意为原子在Lisp列表中不可再分割成更小的单位）。与原子不同，list可以分隔成更小的单位（car cdr &amp;amp; cons）。&lt;/p&gt;
&lt;p&gt;空的列表：()，被称作空列表。与其它的数据类型不同，空列表被同时看作原子和列表。&lt;/p&gt;
&lt;p&gt;与自然界的原子一样,Lisp中的原子这个名称来出现得太早（意指与自然界的原子一样，原子还可以再分割）。Lisp中部分原子，比如数组就可以进行分割。但是这种机制与列表的分隔是不同的。如果依据对列表的分隔方式来说，列表中原子就是不可分隔的了。&lt;/p&gt;
&lt;h3 id="lie-biao-zhong-de-kong-bai"&gt;列表中的空白&lt;/h3&gt;
&lt;p&gt;额外的空白被用来提高代码的可读性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;
   &lt;span class="nv"&gt;looks&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;this&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;looks&lt;/span&gt; &lt;span class="nv"&gt;like&lt;/span&gt; &lt;span class="nv"&gt;this&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是相同的。&lt;/p&gt;
&lt;h3 id="lie-biao-pai-ban"&gt;列表排版&lt;/h3&gt;
&lt;p&gt;在Emacs Lisp mode下，有多种方法来对Lisp语句进行排版。比如，按&lt;tab&gt;键将自动缩进当前光标所在行到正确的位置。M-C-\可以格式化当前所选区域中的代码。&lt;/tab&gt;&lt;/p&gt;
&lt;h2&gt;运行一个程序&lt;/h2&gt;
&lt;p&gt;执行Lisp程序时，将执行下列三者之一：
 1. 什么都不做，返回列表本身
 2. 返回错误信息
 3. 把列表中的第一个符号当作命令执行一些操作&lt;/p&gt;
&lt;p&gt;放在列表前的单引号被称作引用（quote）；当用它来处理列表时，它告诉Lisp不要对列表进行处理。但如果列表前没有单引号，则列表前的第一个元素是特殊的，它被当作命令被执行（Lisp中这些命令被称作函数）。列表(+ 2 2)显示也与加引号的列表的不同，Lisp知道需要用+来处理列表中的其它元素：把后面的数字相加。&lt;/p&gt;
&lt;h2&gt;生成错误信息&lt;/h2&gt;
&lt;p&gt;错误信息是由内置的GNU Emacs debugger生成的。进入debugger后，可以用按键q退出debugger。&lt;/p&gt;
&lt;h2&gt;符号名称和函数定义&lt;/h2&gt;
&lt;p&gt;Lisp中同一指令可以被绑定到多个名称。&lt;/p&gt;
&lt;p&gt;另一方面,在同一时刻一个符号只允许绑定到一个函数定义上。&lt;/p&gt;
&lt;p&gt;由于Emacs Lisp的庞大，它有一套按照不同函数功能分类的符号命名规则。如：所有处理Texinfo的函数都心textinfo-开头，而处理邮件的函数以rmail-开头。&lt;/p&gt;
&lt;h2&gt;Lisp解释器&lt;/h2&gt;
&lt;p&gt;Lisp的工作方式：首先，它查看列表前是否有单引号，如果有则解释器给出这个列表。如果没有引号，解释器检查列表中的第一个元素是否有对应的函数定义，如果找到则解释器调用函数定义的指令。否则，解释器将打印出错误信息。&lt;/p&gt;
&lt;h3 id="fu-za-yi-dian-de-nei-rong"&gt;复杂一点的内容&lt;/h3&gt;
&lt;p&gt;Lisp解释器可以对没有单引号且不被括号包围的符号。Lisp解释器将检测符号是否为一个变量。&lt;/p&gt;
&lt;p&gt;一些函数不是普通的方法。被用来处理一些特殊的工作，比如定义一个函数。&lt;/p&gt;
&lt;p&gt;Lisp求值时，将先对列表内部嵌入的列表进行求值，从内向外。&lt;/p&gt;
&lt;p&gt;Lisp解释器工作时从左向右，从一个语句到另一个语句（从上至下）。&lt;/p&gt;
&lt;h3 id="bian-yi-byte-compiling"&gt;编译（Byte Compiling）&lt;/h3&gt;
&lt;p&gt;Lisp解释器可以解释两种类型的代码：人可以读的代码和另一种被你为byte compiled code的代码。编译过的代码执行更快。&lt;/p&gt;
&lt;p&gt;可以用byte-compile-file编译代码。被编译好的字节码文件扩展名为.elc。&lt;/p&gt;
&lt;h2&gt;求值&lt;/h2&gt;
&lt;p&gt;当Lisp解释器工作于一个语句上时，这个活动的过程被称为求值（evaluation）。求值完成后解释器将返回函数定义的执行结果，或者在函数出错时给出错误信息。&lt;/p&gt;
&lt;h3 id="dui-nei-bu-lie-biao-qiu-zhi"&gt;对内部列表求值&lt;/h3&gt;
&lt;p&gt;可以把光标停留在内部列表右括号的后面，按C-x C-e执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把光标放在括号后面，或者把光标放在代码下面的空行的行首，都可以得到8。如果用C-x C-e对一个数字求值将得到数字自身，这也是数字与符号的不同。&lt;/p&gt;
&lt;h2&gt;变量&lt;/h2&gt;
&lt;p&gt;Emacs Lisp中符号可以有一个值绑定到它或者一个函数定义绑定到它。两者不同在于，函数定义是指令的集合。值是可以修改的数字或者其它。符号的值可以是任意的Lisp表达式，比如符号、数字、列表、字符串等。有值的符号通常被称作变量。&lt;/p&gt;
&lt;p&gt;符号可以同时有一个函数定义和值。两个是分开的。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;test_f&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="s"&gt;"test2"&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"bbb"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;test_f&lt;/span&gt; &lt;span class="s"&gt;"124"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;test_f&lt;/span&gt;          &lt;span class="nv"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;变量值&lt;/span&gt;&lt;span class="s"&gt;"124"&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;test_f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="nv"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;函数调用显示&lt;/span&gt;&lt;span class="s"&gt;"bbb"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="fill-columnyi-ge-bian-liang-de-li-zi"&gt;fill-column一个变量的例子&lt;/h3&gt;
&lt;p&gt;变量fill-column，每个Emacs缓冲区，这个符号通常被设置成72或70,但也可能有不同的值。可以用C-x C-e对fill-column这个符号求值。&lt;/p&gt;
&lt;p&gt;符号可以有值绑定到上面，我们可以绑定变量到值、数字、字符串、列表甚至是函数定义。&lt;/p&gt;
&lt;h3 id="han-shu-fu-hao-wei-ding-yi-shi-de-cuo-wu-xin-xi"&gt;函数符号未定义时的错误信息&lt;/h3&gt;
&lt;p&gt;当我们对fill-column求值时将得到变量的值时并没有在符号外面添加括号。这是因为我们不打算将符号当作函数的名称。&lt;/p&gt;
&lt;p&gt;如果fill-column是列表中的第一个元素或者唯一的元素，Lisp解释器将查找绑定到符号上的函数定义。但fill-column不是一个函数定义。当我们对&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fill-column&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;求值时将产生错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数fill-column未定义。&lt;/p&gt;
&lt;p&gt;按q退出调试器。&lt;/p&gt;
&lt;h3 id="fu-hao-mei-you-zhi-shi-de-cuo-wu-xin-xi"&gt;符号没有值时的错误信息&lt;/h3&gt;
&lt;p&gt;例如对&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中的+号求值（光标停留在+的后面，按C-x C-e）时将产生错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个错误信息与上节函数未定义时的不同。表示变量+未定义。&lt;/p&gt;
&lt;h2&gt;参数&lt;/h2&gt;
&lt;h3 id="can-shu-lei-xing"&gt;参数类型&lt;/h3&gt;
&lt;p&gt;传递给函数的数据类型依赖于函数需要使用何种信息。比如+函数需要数字类型的参数。concat需要字符串类型的参数。substring是一个特殊一点的函数（称作原子粉碎机），它能把从原子类型中解析出一部分数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="s"&gt;"The quick brown fox jumped."&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bian-liang-zhi-huo-zhe-lie-biao-dang-zuo-can-shu"&gt;变量值或者列表当作参数&lt;/h3&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;fill-column&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="s"&gt;"The "&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;number-to-string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;fill-column&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="s"&gt;" red foxes."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="can-shu-shu-liang"&gt;参数数量&lt;/h3&gt;
&lt;p&gt;一些函数可以带多个参数，例如：+、*。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;; =&amp;gt; 0&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;; =&amp;gt; 1&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;; =&amp;gt; 3&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;; =&amp;gt; 3&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; =&amp;gt; 12&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; ==&amp;gt; 60&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shi-yong-cuo-wu-lei-xing-de-can-shu"&gt;使用错误类型的参数&lt;/h3&gt;
&lt;p&gt;当传递了错误的参数类型时Lisp解释器将产生错误信息。例如对&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="ss"&gt;'hello&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;求值的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error:
         (wrong-type-argument number-or-marker-p hello)
  +(2 hello)
  eval((+ 2 (quote hello)))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;错误信息的第一部分直截告诉我们参数类型错误(wrong-type-argument。第二个部分看起来有些迷惑number-or-marker-p，这部分告诉了我们+函数所需要的参数类型。&lt;/p&gt;
&lt;p&gt;符号number-or-marker-p说明Lisp解释器检查提供给函数的信息（参数的值）是否是数字或marker（C-@或C-&lt;spc&gt;设置的位置，mark可以被当作数字进行处理－mark在缓冲区中的字符位置）。Emacs Lisp中+可以将数字和作为数字的marker位置相加。&lt;/spc&gt;&lt;/p&gt;
&lt;p&gt;number-of-marker-p中的p是早期Lisp程序中的用法。p是'predicate'的简写。是早期Lisp研究者所使用的术语，predicate指明了函数用于决定一些属性是true还是false。因此p告诉我们number-or-marker-p是一个根据参数是否为数字或者marker而返回true或者false的函数。另一个以p结尾的Lisp符号包括zerop，这是一个检查参数值是否为0的函数，listp则是一个检测参数是否为一个列表（list）的函数。&lt;/p&gt;
&lt;p&gt;最后，错误信息的其它部分将显示出符号hello。这是传递给+的参数值。&lt;/p&gt;
&lt;h3 id="messagehan-shu"&gt;message函数&lt;/h3&gt;
&lt;p&gt;message函数显示信息到回显区。占位符%s表示字符串，%d为整数。例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"This message appears in the echo area!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"The name of this buffer is: %s."&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"The value of fill-column is %d."&lt;/span&gt; &lt;span class="nv"&gt;fill-column&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"There are %d %s in the office!"&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;fill-column&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"pink elephants"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"He saw %d %s"&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;fill-column&lt;/span&gt; &lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="s"&gt;"red "&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt;
                  &lt;span class="s"&gt;"The quick brown foxes jumped."&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="s"&gt;" leaping."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;设置变量值&lt;/h2&gt;
&lt;p&gt;有几种方法给变量赋值。set或setq函数，let函数。&lt;/p&gt;
&lt;h3 id="shi-yong-set"&gt;使用set&lt;/h3&gt;
&lt;p&gt;要把符号flowers的值设置为列表'(rose violet daisy buttercup)，可以执行下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;'flowers&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;rose&lt;/span&gt; &lt;span class="nv"&gt;violet&lt;/span&gt; &lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;列表(rose violet daisy buttercup)将显示在回显区。这是set函数的返回值。另一方面符号flowers被绑定到列表；这样符号flower可以看作一个变量，它具有那个列表值。&lt;/p&gt;
&lt;p&gt;在对set语句求值后，就可以对符号flowers求值，它将返回set设置的值。
当对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;flowers&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;求值时，回显区将显示(ros violet daisy buttercup)。&lt;/p&gt;
&lt;p&gt;这时如果对'flowers求值，将在回显区看到符号自身flowers。&lt;/p&gt;
&lt;p&gt;当使用set时，需要在两个参数前加单引号，除非你想对它们进行求值。如果没有加单引号，则解释器将先对参数进行求值，例如对flowers求值，如果flowers之前未赋过值，则将报错，如果对flowers的求值返回了值，则后面的变量值将赋给对flowers求值所返回的值上。这种情况非常少见。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;'flowers&lt;/span&gt; &lt;span class="ss"&gt;'aaa&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;flowers&lt;/span&gt; &lt;span class="s"&gt;"123"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="nv"&gt;aaa&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="nv"&gt;-&amp;gt;显示&lt;/span&gt;&lt;span class="s"&gt;"123"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shi-yong-setq"&gt;使用setq&lt;/h3&gt;
&lt;p&gt;setq与set类似，但setq将自动给第一个参数前加单引号。另一方面，setq允许在一条语句中同时设置多个不同的变量值。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;carnivores&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt; &lt;span class="nv"&gt;leopard&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt; &lt;span class="ss"&gt;'carnivores&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt; &lt;span class="nv"&gt;leopard&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相同。&lt;/p&gt;
&lt;p&gt;setq可以给多个变量赋值，例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;trees&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;herbivores&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;antelope&lt;/span&gt; &lt;span class="nv"&gt;zebra&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尽管我们一直在用赋值（'assign'），但有另一种方式思考set和setq；即set和setq使一个符号指向（point）一个列表。&lt;/p&gt;
&lt;h3 id="ji-shu-qi"&gt;计数器&lt;/h3&gt;
&lt;p&gt;这是一个在计数器中使用setq的例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;; 初始化&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;    &lt;span class="c1"&gt;; 增加&lt;/span&gt;
&lt;span class="nv"&gt;counter&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Lisp程序由表达式组成，表达式可以是列表或者原子。&lt;/li&gt;
&lt;li&gt;列表由零个或者多个原子或内部列表组成，各元素由空白分隔，被括号包括。列表可以为空。&lt;/li&gt;
&lt;li&gt;原子是多个字符符号，比如：forward-paragraph，单字符比如+，双引号间的字符串，数字。&lt;/li&gt;
&lt;li&gt;对自身求值的数字。&lt;/li&gt;
&lt;li&gt;双引号间的字符串也将对自身求值。&lt;/li&gt;
&lt;li&gt;当对符号自身求值时，将返回它指向的值。&lt;/li&gt;
&lt;li&gt;当对列表求值时，Lisp解释器查看列表中的第一个符号所绑定的函数定义。然后按定义的指令执行。&lt;/li&gt;
&lt;li&gt;单引号，'，告诉Lisp解释器应该把后面的表达式按原样返回，不对它进行求值。&lt;/li&gt;
&lt;li&gt;参数是传递给函数的信息。函数是列表中的第一个元素，其它元素被求值并作为参数传递给函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;实践&lt;/h1&gt;
&lt;h2&gt;执行代码&lt;/h2&gt;
&lt;p&gt;通过C-x C-e执行代码&lt;/p&gt;
&lt;h2&gt;缓冲区名称&lt;/h2&gt;
&lt;p&gt;buffer-name和buffer-file-name这两个函数用于区分文件和缓冲区。&lt;/p&gt;
&lt;p&gt;如果是在&lt;em&gt;scratch&lt;/em&gt;缓冲区中，可以用C-u C-x C-e运行代码，这样运行结果会显示在表达式的后面。&lt;/p&gt;
&lt;h2&gt;获取缓冲区&lt;/h2&gt;
&lt;p&gt;buffer-name可以获取缓冲区名称，current-buffer可以返回缓冲区本身。&lt;/p&gt;
&lt;p&gt;other-buffer可以获得上一次访问过的缓冲区。&lt;/p&gt;
&lt;h2&gt;切换缓冲区&lt;/h2&gt;
&lt;p&gt;switch-to-buffer可以切换当前缓冲区。产生与按C-x b类似的效果。
下面的代码将切换当前缓冲区到上次访问过的缓冲区：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;switch-to-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;other-buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一个函数set-buffer也是用于切换缓冲区的，但与switch-to-buffer不同在于它只改变程序处理的缓冲区，并不改变当前屏幕显示的缓冲区。&lt;/p&gt;
&lt;h2&gt;缓冲区大小和光标位置&lt;/h2&gt;
&lt;p&gt;几个简单的函数用于缓冲区大小和检测光标位置：buffer-size,point,point-min,point-max。&lt;/p&gt;
&lt;h1&gt;编写函数&lt;/h1&gt;
&lt;h2&gt;关于基本函数(Primitive Function)&lt;/h2&gt;
&lt;p&gt;除了少数C编写的基本函数外，所有的函数都是由其它函数语句定义的。当编写自己函数时，C所编写的函数与Emacs Lisp编写的函数看起来是一样的。&lt;/p&gt;
&lt;p&gt;除非你想去考究，否则不需要知道知道一个函数是用Emacs Lisp编写的还是C编写的。&lt;/p&gt;
&lt;h2&gt;defun&lt;/h2&gt;
&lt;p&gt;在一个函数的定义中，在defun关键字后面有5个部分：
 1. 函数符号的名称
 2. 传递给函数的参数列表,如果没有参数则传递给函数的是一个空列表,()
 3. 描述函数的文档字符串。（可选）
 4. 当用户按M-x func_name以交互方式运行函数时的提示信息;或按键组合。（可选）
 5. 函数体&lt;/p&gt;
&lt;p&gt;模板&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;function-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;arguments...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="s"&gt;"optional-documentation..."&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="nv"&gt;argument-passing-info&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; optional&lt;/span&gt;
    &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个实例（非交互）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Multiply NUMBER by seven."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数参数列表中的变量名对每个函数是私有的，不同函数的参数名可以相同。&lt;/p&gt;
&lt;p&gt;参数列表后面是描述函数功能的文档字符串。也就是按C-h f name_of_function时所看到的信息。&lt;/p&gt;
&lt;p&gt;在调用的时候使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尽管传递给函数的参数外面没有加括号。但函数能计算出来。&lt;/p&gt;
&lt;p&gt;当对这个表达式求值时将出错。这是因为我们只编写了函数定义，但并未告诉机器在Emacs中安装(install/load)这个函数定义。&lt;/p&gt;
&lt;h2&gt;安装函数定义&lt;/h2&gt;
&lt;p&gt;将光标停留上节所写的函数定义的最后一个括号后面，按C-x C-e。这时回显区将显示multiply-by-seven(这表示函数定义被计算，计算的返回值是所定义的函数的名字)。这时函数就已经安装好，可以在像使用Emacs中其它函数一样使用了。&lt;/p&gt;
&lt;h3 id="an-zhuang-hou-de-xiao-guo"&gt;安装后的效果&lt;/h3&gt;
&lt;p&gt;可以在&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;的最后一个括号后按C-x C-e，回显区将显示计算结果21。
还可以查看函数帮助文档。按C-h f(describe-function) function_name，multiply-by-seven。y&lt;/p&gt;
&lt;h3 id="xiu-gai-han-shu-ding-yi"&gt;修改函数定义&lt;/h3&gt;
&lt;p&gt;可以直接修改函数的定义，然后重新把光标停留在在函数定义的最后一个括号后面按C-x C-e。&lt;/p&gt;
&lt;h2&gt;制作交互式函数&lt;/h2&gt;
&lt;p&gt;用户可以通过按键或者M-x 函数名来调用。&lt;/p&gt;
&lt;h3 id="jiao-hu-shi-han-shu-multiply-by-sevenyu-lan"&gt;交互式函数multiply-by-seven预览&lt;/h3&gt;
&lt;p&gt;交互式版本的multiply-by-seven：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Multiply NUMBER by seven."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"The result is %d"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装上面的函数后，可以使用C-u number参数，然后输入M-x multiply-by-seven然后回车。回显区将显示计算结果。&lt;/p&gt;
&lt;p&gt;调用这个函数的两种方法：
 1. 输入前缀参数，然后输入M-x和函数名，比如C-u 3 M-x forward-sentence
 2. 输入任意按键绑定例如：C-u 3 M-e&lt;/p&gt;
&lt;p&gt;输入C-u不带数字，则参数默认为4。&lt;/p&gt;
&lt;h3 id="jiao-hu-shi-han-shu-multiply-by-seven"&gt;交互式函数multiply-by-seven&lt;/h3&gt;
&lt;p&gt;在上节所写的函数中,表达式(interactive "p")中的"p"告诉Emacs把前缀参数(C-u后带的参数)作为函数参数(number)传递给函数。&lt;/p&gt;
&lt;p&gt;message是一个Emacs Lisp函数，用于显示信息给用户。&lt;/p&gt;
&lt;h2&gt;不同的interactive选项&lt;/h2&gt;
&lt;p&gt;emacs有超过20过的选项可以传递给interactive。具体可以查阅elisp手册。&lt;/p&gt;
&lt;p&gt;例如，字符r，Emacs将把当前选中区域作为两个参数传递给函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B告诉Emacs提示用户输入缓冲区名称，并把该缓冲区作为参数传递给函数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BAppend to buffer:"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当函数需要2个或更多参数时，可以在interactive中添加新的部分。每个部分用\n分隔。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;name-of-function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BAppend to buffer: \nr"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;body-of-function...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果一个函数不需要参数，可以直接使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;永久的安装函数&lt;/h2&gt;
&lt;p&gt;安装函数的几种方法：
 1. 把代码放在.emacs文件中。
 2. 把代码放在其它文件中，使用load函数装载文件。
 3. 如果所有用户都要使用可以把代码放在site-init.el文件中&lt;/p&gt;
&lt;h2&gt;let&lt;/h2&gt;
&lt;p&gt;let表达式是在多数函数中都要用到的一个Lisp表。&lt;/p&gt;
&lt;p&gt;let用于修改或者绑定值到符号上。&lt;/p&gt;
&lt;h3 id="let-ke-yi-fang-zhi-hun-luan"&gt;let 可以防止混乱&lt;/h3&gt;
&lt;p&gt;let创建的是本地变量，作用范围止于let表达式范围内，不影响let外部的变量。let可以一次创建多个变量，并给每个变量赋值，初始值也可以是nil。在let执行完后，将返回最后一个语句的值。&lt;/p&gt;
&lt;h3 id="letbiao-da-shi-de-zu-cheng"&gt;let表达式的组成&lt;/h3&gt;
&lt;p&gt;let表达式分为3个部分，第一部分是符号"let"。第二个部分被称为变量列表（varlist），每个元素都一个符号或者包含二个元素的列表，每个列表中的一个元素是一个符号。第三部分是let的体（body）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;variable&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;variable&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="letbiao-da-shi-ju-li"&gt;let表达式举例&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zebra&lt;/span&gt; &lt;span class="ss"&gt;'stripes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;tiger&lt;/span&gt; &lt;span class="ss"&gt;'fierce&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"One kind of animal has %s and another is %s."&lt;/span&gt;
           &lt;span class="nv"&gt;zebra&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="letyu-ju-zhong-de-wei-chu-shi-hua-bian-liang"&gt;let语句中的未初始化变量&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;birch&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;pine&lt;/span&gt;
      &lt;span class="nv"&gt;fir&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="ss"&gt;'some&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
   &lt;span class="s"&gt;"Here are %d variables with %s, %s, and %s value."&lt;/span&gt;
   &lt;span class="nv"&gt;birch&lt;/span&gt; &lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的pine、fir的值都是nil。&lt;/p&gt;
&lt;h2&gt;if语句&lt;/h2&gt;
&lt;p&gt;if的基本理念就是，如果if测试为真则表达式被执行。&lt;/p&gt;
&lt;h3 id="if-xi-jie"&gt;if 细节&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;true-or-false-test&lt;/span&gt;
    &lt;span class="nv"&gt;action-to-carry-out-if-test-is-true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;type-of-animal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;characteristic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print message in echo area depending on CHARACTERISTIC.&lt;/span&gt;
&lt;span class="s"&gt;If the CHARACTERISTIC is the symbol &lt;/span&gt;&lt;span class="ss"&gt;`fierce'&lt;/span&gt;&lt;span class="s"&gt;,&lt;/span&gt;
&lt;span class="s"&gt;then warn of a tiger."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="nv"&gt;characteristic&lt;/span&gt; &lt;span class="ss"&gt;'fierce&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"It's a tiger!"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;type-of-animal&lt;/span&gt; &lt;span class="ss"&gt;'fierce&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;type-of-animal&lt;/span&gt; &lt;span class="ss"&gt;'zebra&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(type-of-animal 'fierce)将在回显区显示"It's a tiger!"，第二行将返回nil。&lt;/p&gt;
&lt;h2&gt;if-then-else语句&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;true-or-false-test&lt;/span&gt;
    &lt;span class="nv"&gt;action-to-carry-out-if-the-test-returns-true&lt;/span&gt;
  &lt;span class="nv"&gt;action-to-carry-out-if-the-test-returns-false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;type-of-animal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;characteristic&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; Second version.&lt;/span&gt;
  &lt;span class="s"&gt;"Print message in echo area depending on CHARACTERISTIC.&lt;/span&gt;
&lt;span class="s"&gt;If the CHARACTERISTIC is the symbol &lt;/span&gt;&lt;span class="ss"&gt;`fierce'&lt;/span&gt;&lt;span class="s"&gt;,&lt;/span&gt;
&lt;span class="s"&gt;then warn of a tiger;&lt;/span&gt;
&lt;span class="s"&gt;else say it's not fierce."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="nv"&gt;characteristic&lt;/span&gt; &lt;span class="ss"&gt;'fierce&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"It's a tiger!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"It's not fierce!"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Emacs Lisp中的真值与假值&lt;/h2&gt;
&lt;p&gt;符号nil作为假值，nil外的其它值都为真。&lt;/p&gt;
&lt;h3 id="dui-nilde-jie-shi"&gt;对nil的解释&lt;/h3&gt;
&lt;p&gt;在Emacs Lisp中对符号nil有两种解释。一种代表空的列表，另一种为真假判断中的假值。nil可以被写作：()、nil。对Lisp解释器来说两种写法是相同的。推荐用nil表示false，()表示空的列表。&lt;/p&gt;
&lt;p&gt;在Emacs lisp里，任何非nil非空列表的值都被当作真。&lt;/p&gt;
&lt;h2&gt;save-excursion&lt;/h2&gt;
&lt;p&gt;save-excursion函数保存当前的point和mark，然后执行函数体，然后恢复point和mark的位置。它的主要目的是为了保存用户在调用函数前所设置的point和mark。&lt;/p&gt;
&lt;h3 id="pointhe-mark"&gt;point和mark&lt;/h3&gt;
&lt;p&gt;Point指当前光标之前的一个位置。在Emacs Lisp中，point是一个整数。缓冲区中第一个字符的point数字是1，函数point返回当前光标位置。&lt;/p&gt;
&lt;p&gt;Mark是缓冲区中的另一个位置。其值是通过C-&lt;spc&gt;（set-mark-command）设置的。通过C-x C-x（exchange-point-and-mark）可以在point和mark间跳转。如果设置了另一个mark，前一个mark被保存到mark ring里去。可以通过C-u C-&lt;spc&gt;将光标跳转到被保存的mark。&lt;/spc&gt;&lt;/spc&gt;&lt;/p&gt;
&lt;p&gt;缓冲区中point和mark之间的区域叫作region。大量命令用于region上，例：center-region，count-lines-region，kill-region和print-region。&lt;/p&gt;
&lt;p&gt;Emacs里函数工作时经常移动point尽管用户感觉不到这一点。例如：count-lines-region。为防止用户的point被移动到非预期的位置（相对于执行函数之前），save-excursion常用于保存point的位置，使用save-excursion是一个好的习惯。&lt;/p&gt;
&lt;p&gt;不论代码运行是否成功（非正常结束），save-execursion总是恢复point和mark的位置。&lt;/p&gt;
&lt;p&gt;另外，save-excursion也将记录当前所在的缓冲区，并恢复它。这意味着可以在代码中修改当前缓冲区，结果后save-excursion将切换回原来的缓冲区。&lt;/p&gt;
&lt;h3 id="save-excursionyu-ju-mo-ban"&gt;save-excursion语句模板&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更详细一些的模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="nv"&gt;first-expression-in-body&lt;/span&gt;
  &lt;span class="nv"&gt;second-expression-in-body&lt;/span&gt;
  &lt;span class="nv"&gt;third-expression-in-body&lt;/span&gt;
   &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="nv"&gt;last-expression-in-body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Emacs Lisp代码中，save-excursion语句通常放在let语句中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;varlist&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;p&gt;部分函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eval-last-sexp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对当前poing前的表达式求值。通常被绑定到C-x C-e上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;defun&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义函数。这个表(form)有5个部分：名称、参数定义、文档字符串、可选的交互式描述，函数体定义。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;back-to-indentation&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Move point to first visible character on line."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;skip-chars-forward&lt;/span&gt; &lt;span class="s"&gt;" \t"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;interactive&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;告诉解释器函数可以交互。跟在字符串后的特殊的表（form）可以作为参数传递给函数。多个部分之间用\n分隔。常用的字符代码如下：
b | 一个buffer的名称
f | 一个文件名
p | 数字前缀（按C-u时输入的数字，默认为4）
r | 传递poing和mark两个数字参数，小的数字在前。这是唯一一个传递两个参数的字符代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;let&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;申明并初始化作用于let函数体的局部变量，变量值可以为nil。在let内部，Lisp解释器对外部的同名变量不可见。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;bar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
   &lt;span class="s"&gt;"This buffer is %s and has %d characters."&lt;/span&gt;
   &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="nv"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;save-excursion&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录当前point、mark和当前所在缓冲区，在函数体执行完后恢复这些值。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"We are %d characters into this buffer."&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;if&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对第一个参数求值；如果返回的为true，则对第二个参数求值；否则如果第三个参数存在，则对第三个参数求值。if被称作条件语句。Emacs Lisp也有其它的条件语句，但if是最常用的。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-equal&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;number-to-string&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;emacs-version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"This is version 21 Emacs"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"This is not version 21 Emacs"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;equal&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eq&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查两个对象是否相同。equal检测是否&amp;rdquo;相同（same）&amp;ldquo;，如果两个对象有相似的结构和内容就返回true。eq则需要两个参数指向同一个对象才返回true。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;lt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;lt;=&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;=&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的比较函数的参数都必须是数字或者mark（C-&lt;spc&gt;产生的）。&lt;/spc&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;string&amp;lt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string-lessp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string=&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;string-equal&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;string-lessp函数检测第一个参数是否小于第二个参数。string&amp;lt;是它的简写。传递给string-lessp的参数必须是字符串或者符号（symbols）。空字符串""小于任何其它字符串。&lt;/p&gt;
&lt;p&gt;string-equal用于检查字符串的一致性。string=是它的简写。没有针对字符串&amp;gt;、&amp;gt;=或&lt;code&gt;&amp;lt;=&lt;/code&gt;的函数定义。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;message&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在回显区显示消息。第一个参数是一个字符串，它可以包含%s，%d或%c这些占位符。%s必须对应于字符串或符号。%d对应于整数。%c必须是一个ascii编码数字。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setq&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;setq函数设置第一个变量的值为第二个变量。第一个变量自动被加上单引号。setq可以同时对多个变量赋值。set只能给带两个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;buffer-name&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不需要参数，返回缓冲区的名字。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;buffer-file-name&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不需要参数，返回缓冲区所对应的文件名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;current-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回当前活动的缓冲区；它可以不是当前屏幕上显示的缓冲区（编程时使用）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;other-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回最近访问过的访问区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;switch-to-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;选择一个缓冲区显示到当前用户窗口。磁盘被绑定到C-x b。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;set-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在程序运行时切换Emacs的焦点到某个缓冲区。并不会改变当前窗口中显示的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;buffer-size&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回当前缓冲区的字符数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;point&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回当前光标所在位置，返回值是从缓冲区开始处到光标位置的字符数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;point-min&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回当前缓冲区的开始位置。默认为1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;point-max&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回当前缓冲区的结束位置。&lt;/p&gt;
&lt;h1&gt;部分与缓冲区有关的函数&lt;/h1&gt;
&lt;h2&gt;查找更多信息&lt;/h2&gt;
&lt;p&gt;可以通过C-h f查看函数的说明，C-h v查看变量的说明，这些说明就是Emacs Lisp代码中的文档字符串。&lt;/p&gt;
&lt;p&gt;在20或更高版本以后，可以用describe-function（C-h f）将告诉你函数定义的位置。在文件名上按回车（这个操作是help-follow函数调用）将打开函数定义。&lt;/p&gt;
&lt;p&gt;etags：在代码中如果想要查看函数源文件，可以使用find-tags函数跳转到源文件上去。find-tags可以处理多种语法，不限于Lisp和C，也可以工作于非编程语言如Texinfo文档。在Texinfo文档里调用find-tags将跳转到对应的文件节点。&lt;/p&gt;
&lt;p&gt;find-tags函数依赖于标签表'tags tables'，它记录了函数、变量和其它信息的位置。&lt;/p&gt;
&lt;p&gt;使用M-.调用find-tags函数，然后在提示符后要查找的函数名，比如mark-whole-buffer。Emacs将转到显示该函数源码缓冲区。&lt;/p&gt;
&lt;p&gt;符号表'tags table'通常是一个名为TAGS的文件。Emacs源码的TAGS存储在/usr/local/share/emacs目录中。但可以通过M-x visit-tags-table命令指定一个符号表。&lt;/p&gt;
&lt;p&gt;通过etags命令可以创建符号表。使用M-x cd命令或C-x d（dired）切换到要建立符号表的目录，然后运行编译命令执行&lt;code&gt;etags *.el&lt;/code&gt;命令。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;M-x&lt;/span&gt; &lt;span class="nv"&gt;compile&lt;/span&gt; &lt;span class="nv"&gt;RET&lt;/span&gt; &lt;span class="nv"&gt;etags&lt;/span&gt; &lt;span class="nv"&gt;*.el&lt;/span&gt; &lt;span class="nv"&gt;RET&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件中的代码通常称为库。通过C-h p可以查看Emacs Lisp的标准库。&lt;/p&gt;
&lt;h2&gt;简化版的beginning-of-buffer函数定义&lt;/h2&gt;
&lt;p&gt;beginning-of-buffer命令将把光标移动到缓冲区起始位置，并把mark设置在前一个位置。通常被绑定到M-&amp;lt;上。&lt;/p&gt;
&lt;p&gt;简化版本的函数具有与标准库版本类似的功能，但不包含完整的功能。&lt;/p&gt;
&lt;p&gt;设想一下该函数的定义应包括：包含能让用户交互的表达式，比如按M-x beginning-of-buffer或按键C-&amp;lt;；必须包含能在原位置设置mark的代码；必须包含让光标移动到缓冲区起始位置的代码。&lt;/p&gt;
&lt;p&gt;简化版本的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;simplified-beginning-of-buffer&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Move point to the beginning of the buffer;&lt;/span&gt;
&lt;span class="s"&gt;leave mark at previous position."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与其它函数一样，这个函数也包含了defun需要的五个部分：
 1. 函数名，这里使用的：simplified-beginning-of-buffer。
 2. 参数列表：这里是一个空列表()。
 3. 文档字符串。
 4. 交互表达式。
 5. 函数体。&lt;/p&gt;
&lt;p&gt;这个函数定义中，参数列表为空，意味着函数不需要任何参数。（查看完整函数定义时，我们可以看到它可能传递了可选的参数）。&lt;/p&gt;
&lt;p&gt;interactive语句告诉Emacs函数允许交互。这个例子中interactive没有参数，因此调用simplified-beginning-of-buffer时也不需要参数。&lt;/p&gt;
&lt;p&gt;函数体由两行代码组成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(push-mark)执行时将在当前光标所在位置设置mark，之前的mark被保存到mark ring上。&lt;/p&gt;
&lt;p&gt;(goto-char (point-min))将光标转移到缓冲区起始位置。&lt;/p&gt;
&lt;p&gt;在阅读这些代码遇到陌生的函数时，比如goto-char，可以使用describe-function命令，按C-h f然后输入函数名。describe-function将在一个&lt;em&gt;Help&lt;/em&gt;窗口打印出函数的帮助文档。&lt;/p&gt;
&lt;p&gt;调用describe-function时，如果光标停留在函数名上，describe-function默认将把光标所在位置的函数名作为参数。&lt;/p&gt;
&lt;p&gt;end-of-buffer的函数定义与beginning-of-buffer类似，只是用(goto-char (point-max))替换(goto-char (point-min))。&lt;/p&gt;
&lt;h2&gt;mark-whole-buffer的定义&lt;/h2&gt;
&lt;p&gt;mark-whole-buffer函数标把整个缓冲区标记为区域。把point设置在缓冲区开始位置，mark设置在缓冲区结束位置。通常被绑定到C-x h上。&lt;/p&gt;
&lt;h3 id="mark-whole-bufferyu-lan"&gt;mark-whole-buffer预览&lt;/h3&gt;
&lt;p&gt;在Emacs 20中，完整的函数代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;mark-whole-buffer&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Put point at beginning and mark at end of buffer."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与函数定义模板类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;name-of-function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;argument-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;interactive-expression...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="mark-whole-bufferde-han-shu-ti"&gt;mark-whole-buffer的函数体&lt;/h3&gt;
&lt;p&gt;mark-whole-buffer的函数体仅有3行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行(push-mark (point))与simplified-beginning-of-bufer函数相同，那里写的是(push-mark。两种写法都是告诉解释器在当前光标所在位置设置mark。&lt;/p&gt;
&lt;p&gt;下一行(push-mark (point-max))在缓冲区结尾设置mark。设置这个mark后，前一行设置的mark将进入mark ring。这意味着你可以通过按两次C-u C-&lt;spc&gt;重新回到那个位置。&lt;/spc&gt;&lt;/p&gt;
&lt;p&gt;在Emacs 21里，(push-mark (point-max))看起来更复杂：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数增加了两上参数，第二个参数为nil。这告诉函数，在设置mark后，需要显示消息：'Mark set'。第三个参数t，它告诉push-mark如果当Transient Mark mode是开启状态，则应该将mark设置为活动状态。Transient Mark mode将高亮显示当前活动的区域，它默认是关闭的。&lt;/p&gt;
&lt;p&gt;最后一行(goto-char (point-min))与beginning-of-buffer完全一样。这个语句将光标移动到缓冲区开始位置。运行的结果：point被设置到缓冲区开始位置，mark被设置为缓冲区结束位置。整个缓冲区被标记为区域（region）。&lt;/p&gt;
&lt;h2&gt;append-to-buffer的定义&lt;/h2&gt;
&lt;p&gt;append-to-buffer函数从当前缓冲区中拷贝选中区域到指定的缓冲区中。&lt;/p&gt;
&lt;h3 id="append-to-bufferhan-shu-yu-lan"&gt;append-to-buffer函数预览&lt;/h3&gt;
&lt;p&gt;append-to-buffer命令使用insert-buffer-substring函数来拷贝区域。insert-buffer-substring函数将缓冲区的一部分作为字符串（substring）插入到另一个缓冲区。完整的函数代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;append-to-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Append to specified buffer the text of the region.&lt;/span&gt;
&lt;span class="s"&gt;It is inserted into that buffer before its point.&lt;/span&gt;

&lt;span class="s"&gt;When calling from a program, give three arguments:&lt;/span&gt;
&lt;span class="s"&gt;a buffer or the name of one, and two character numbers&lt;/span&gt;
&lt;span class="s"&gt;specifying the portion of the current buffer to be copied."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BAppend to buffer: \nr"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;current-buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer-create&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="append-to-bufferhan-shu-zhong-de-jiao-hu-biao-da-shi"&gt;append-to-buffer函数中的交互表达式&lt;/h3&gt;
&lt;p&gt;append-to-buffer函数需要与用户交互，因此函数使用了interactive表达式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BAppend to buffer: \nr"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句有一个双引号包含的字符串，该字符串被\n分隔为两部分。&lt;/p&gt;
&lt;p&gt;第一部分BAppend to bufefer：这里的B告诉Emacs传递一个缓冲区给函数。Emacs将在回显区用B后面的字符串（Append to buffer:）提示用户输入缓冲区名称。然后Emacs将该缓冲区到参数buffer上。&lt;/p&gt;
&lt;p&gt;\n分隔了交互表达式中的字符串。\n后的r告诉Emacs将point和mark的值分别绑定到参数buffer后面的两个参数上。&lt;/p&gt;
&lt;h3 id="append-to-bufferde-han-shu-ti"&gt;append-to-buffer的函数体&lt;/h3&gt;
&lt;p&gt;函数体是以let开头的。定义了局部变量，在函数中let将(current-buffer)的返回值绑定到oldbuf上。这个变量用于跟踪当前工作的缓冲区。&lt;/p&gt;
&lt;p&gt;单独来看let语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;append-to-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BAppend to buffer: \nr"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;variable&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;let语句包含三个元素：
 1. 符号let。
 2. 变量列表，列表中的元素是只含有两个元素的列表。
 3. let语句体。&lt;/p&gt;
&lt;h3 id="append-to-bufferzhong-de-save-excursion"&gt;append-to-buffer中的save-excursion&lt;/h3&gt;
&lt;p&gt;let语句的body部分是一个save-excursion语句。它用于在执行完代码后恢复point，mark和buffer的值。&lt;/p&gt;
&lt;p&gt;使用save-excursion函数处理过程与下面的模板类似：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="nv"&gt;first-expression-in-body&lt;/span&gt;
  &lt;span class="nv"&gt;second-expression-in-body&lt;/span&gt;
   &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="nv"&gt;last-expression-in-body&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在函数定义中，save-excursion只包含了两个语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer-create&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;save-excursion依次执行这两条语句，save-excursion函数执行的最后一条语句被作为该次函数调用的返回值。&lt;/p&gt;
&lt;p&gt;save-excursion的body部分的第一条语句set-buffer函数用于改变当前缓冲区到append-to-buffer函数调用时第一个参数所指定的缓冲区。（set-buffer变不改当前屏幕显示的内容，只在Lisp程序内部改变当前处理的缓冲区）。第二条语句执行了函数的主要工作。&lt;/p&gt;
&lt;p&gt;(get-buffer-create buffer)语句根据名称获取缓冲区，如果缓冲区不存在，就创建一个同名的缓冲区。这意味着可以用append-to-buffer将文本放到一个之前不存在的缓冲区上。&lt;/p&gt;
&lt;p&gt;get-buffer-create也使set-buffer可以从错误中恢复：set-buffer需要一个缓冲区才能工作；如果传递给它的缓冲区不存在，Emacs将报错。get-buffer-create将在缓冲区不存在时创建一个，因此set-buffer将总能获取到一个缓冲区。&lt;/p&gt;
&lt;p&gt;最后一行append-to-buffer执行追加文本的工作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;insert-buffer-substring函数从指定的缓冲区中拷贝字符串到当前缓冲区。在这里，传递给inset-buffer-substring的参数值是由let绑定的，并被命名为oldbuf，它是开始执行append-to-buffer时的当前缓冲区（执行命令时屏幕上显示的缓冲区）。&lt;/p&gt;
&lt;p&gt;在insert-buffer-substring执行完后，save-excursion将恢复原缓冲区，append-to-buffer工作完成。&lt;/p&gt;
&lt;p&gt;append-to-buffer的函数体工作骨架：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;bind-oldbuf-to-value-of-current-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;                       &lt;span class="c1"&gt;; Keep track of buffer.&lt;/span&gt;
    &lt;span class="nv"&gt;change-buffer&lt;/span&gt;
    &lt;span class="nv"&gt;insert-substring-from-oldbuf-into-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="nv"&gt;change-back-to-original-buffer-when-finished&lt;/span&gt;
&lt;span class="nv"&gt;let-the-local-meaning-of-oldbuf-disappear-when-finished&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结append-to-buffer的工作方式：它保存当前缓冲区到变量oldbuf。获取或者新建一个缓冲区并让Emacs切换到那个缓冲区（非屏幕上显示的缓冲区）。使用oldbuf变量从旧缓冲区中获取文本区域插入到新缓冲区；然后使用save-excursion函数回到最初的缓冲区。&lt;/p&gt;
&lt;p&gt;查看append-to-buffer代码，探究了复杂的函数。它展示了如何使用let和save-excursion，如何从另一个缓冲区回到原来的缓冲区。许多函数定义中以这种方式使用了let、save-excursion和set-buffer。&lt;/p&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;describe-function&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;describe-variable&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打印函数或变量文档字符串。通常被绑定到C-h f和C-h v。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;find-tag&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找包含函数或变量的源码，并在缓冲区打开，并定位到对应的位置。通常绑定到M-.上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;save-excursion&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;保存当前的point和mark，在传递给save-excursion的参数执行完后恢复这两个值。它也会记录下当前的缓冲区并重新回到这个缓冲区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push-mark&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在某个位置设置mark并将之前的mark保存到mark ring里面去。mark是缓冲区中的一个位置，不管缓冲区中的文本添加或者删除，它都将保持它的相对位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;goto-char&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置point到参数指定的位置，参数可以是数字、mark或者返回位置数据的表达式，例如：(point-min).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;insert-buffer-substring&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从传递给它的第一个参数（缓冲区）对应的缓冲区拷贝区域中的文本到当前缓冲区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mark-whole-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;把整个缓冲区标记为一个区域。通常绑定到C-x h上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;get-buffer-create&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;get-buffer&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按名称查找缓冲区，如果缓冲区不存在就创建一个。get-buffer函数在查找不到缓冲区后将返回nil。&lt;/p&gt;
&lt;h1&gt;一些更复杂的函数&lt;/h1&gt;
&lt;h2&gt;copy-to-buffer的函数定义&lt;/h2&gt;
&lt;p&gt;这个函数拷贝文本到缓冲区，但它不是追加到第二个缓冲区，而是替换第二个缓冲区之前的文本。copy-to-buffer函数与append-to-buffer代码很类似，但它使用了erase-buffer和二个save-excursion。&lt;/p&gt;
&lt;p&gt;该函数的函数体如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"BCopy to buffer: \nr"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;current-buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer-create&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;erase-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;oldbuf&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码与append-to-buffer类似：不同处在于，改变buffer后append-to-buffer添加文本到缓冲区；而copy-to-buffer函数先删除缓冲区的内容。在删除之前的缓冲区的内容后，第二次使用了save-excursion，并且插入了新的文本。&lt;/p&gt;
&lt;p&gt;为什么需要执行save-excursion两次？&lt;/p&gt;
&lt;p&gt;单独提取copy-to-buffer函数体如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;bind-oldbuf-to-value-of-current-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;         &lt;span class="c1"&gt;; First use of save-excursion.&lt;/span&gt;
    &lt;span class="nv"&gt;change-buffer&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;erase-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;     &lt;span class="c1"&gt;; Second use of save-excursion.&lt;/span&gt;
        &lt;span class="nv"&gt;insert-substring-from-oldbuf-into-buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个save-excursion让Emacs返回被复制文本的缓冲区。很清楚，这与append-to-buffer函数中的使用是一致的。为什么要使用第二个save-excursion呢？原因在于insert-buffer-substring总是将point设置在被插入的区块（region）的结束位置。第二个save-excursion将使用Emacs将point设置在被插入区块的开始位置。多数情况下，用户喜欢看到point停留在被插入文本的开始位置。（copy-to-buffer函数将返回用户最初所在的缓冲区，当用户切换到拷贝的目标缓冲区时，point停留在缓冲区开始的位置）。&lt;/p&gt;
&lt;h2&gt;insert-buffer的函数定义&lt;/h2&gt;
&lt;p&gt;与append-to-buffer和copy-to-buffer相反，这个命令拷贝另一个缓冲区到当前缓冲区。&lt;/p&gt;
&lt;h2&gt;insert-buffer的代码&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;insert-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Insert after point the contents of BUFFER.&lt;/span&gt;
&lt;span class="s"&gt;Puts mark after the inserted text.&lt;/span&gt;
&lt;span class="s"&gt;BUFFER may be a buffer or a buffer name."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"*bInsert buffer: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;bufferp&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;newmark&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;newmark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt; &lt;span class="nv"&gt;newmark&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="insert-bufferzhong-de-jiao-hu"&gt;insert-buffer中的交互&lt;/h3&gt;
&lt;p&gt;insert-buffer中的interactive有两个部分，*号和bInsert buffer:&lt;/p&gt;
&lt;h4 id="zhi-du-huan-chong-qu"&gt;只读缓冲区&lt;/h4&gt;
&lt;p&gt;星号用于只读缓冲区。如果insert-buffer是在一个只读缓冲区上被调用，提示信息将在回显区显示提示不允许插入到当前的缓冲区。星号不需要使用\n与下一个参数分隔。&lt;/p&gt;
&lt;h4 id="jiao-hu-biao-da-shi-b"&gt;交互表达式b&lt;/h4&gt;
&lt;p&gt;交互表达式的第二个参数是小写b开头的（append-to-buffer中是大写的B）。小写b告诉Lisp解释器，insert-buffer需要一个已存在的缓冲区或者已存在的缓冲区名称作为参数。（大写的B可以使用一个不存在的缓冲区）Emacs将提示输入缓冲区名称，并提供了默认的缓冲区，输入时可以使用自动完成功能。如果缓冲区不存在，将给出"No match"的提示。&lt;/p&gt;
&lt;h3 id="insert-bufferhan-shu-ti_1"&gt;insert-buffer函数体&lt;/h3&gt;
&lt;p&gt;insert-buffer函数有两个主要部分：or语句和let语句。or语句用于确保参数buffer参数不仅仅只是被绑定到缓冲区的名字上。let语句包含复制其它缓冲区到当前缓冲区的代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;insert-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"*bInsert buffer: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;varlist&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;body-of-let...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要明白or如何确保参数buffer不只是被绑定到缓冲区名称上，先要清楚or函数。&lt;/p&gt;
&lt;h3 id="zai-insert-bufferyong-ifti-dai-or"&gt;在insert-buffer用if替代or&lt;/h3&gt;
&lt;p&gt;主要工作在于确保buffer变量值是一个缓冲区，而不是缓冲区的名字。如果变量值是名字，则需要获取对对应的缓冲区。&lt;/p&gt;
&lt;p&gt;通过if来实现：如果没有获取到buffer就获取它。&lt;/p&gt;
&lt;p&gt;这里使用了bufferp函数，这个函数检查参数是否为一个缓冲区（或者缓冲区的名字），我们可以如下编码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;bufferp&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;              &lt;span class="c1"&gt;; if-part&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;  &lt;span class="c1"&gt;; then-part&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面说过bufferp中的字符p是一个约定的函数描述，它意味着函数用于决定某些属性为true或false。这里bufferp就是用于检查参数是否为一个缓冲区。&lt;/p&gt;
&lt;p&gt;not函数用于取逻辑值的反值。&lt;/p&gt;
&lt;p&gt;当buffer参数不是一个缓冲区但它是一个缓冲区名称时，true-or-false-test返回true。这时(set q buffer (get-buffer buffer))被执行。语句使用get-buffer函数获取缓冲区名称所对应的缓冲区。setq将buffer绑定到缓冲区上。&lt;/p&gt;
&lt;h3 id="han-shu-ti-zhong-de-or"&gt;函数体中的or&lt;/h3&gt;
&lt;p&gt;insert-buffer函数中使用or语句的目的在于确保buffer被绑定到缓冲区。上一节用if实现了这个功能。但在insert-buffer函数中实际使用的却是or函数。&lt;/p&gt;
&lt;p&gt;or函数可以接收任何意数量的参数。它依次对每个参数求值并返回第一个结果不为nil的值。or并不会对第一个返回值不为nil的参数的后面的参数求值。&lt;/p&gt;
&lt;p&gt;or语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;bufferp&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;get-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该语句中or的第一个参数为(bufferp buffer)。如果buffer参数是一个缓冲区则返回true（一个非nil值）。在or语句中，这种情况下or将返回true，并且不执行后面的语句。&lt;/p&gt;
&lt;p&gt;如果(bufferp buffer)返回值为nil，即buffer是一个缓冲区的名字，Lisp解释器将执行or语句的下一个元素：(setq buffer (get-buffer buffer))。这个语句将返回一个非nil值，这个值为绑定到buffer变量上的缓冲区而不是缓冲区的名字。&lt;/p&gt;
&lt;p&gt;使用or的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;holding-on-to-guest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;find-and-take-arm-of-guest&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="insert-bufferzhong-de-letyu-ju"&gt;insert-buffer中的let语句&lt;/h3&gt;
&lt;p&gt;确保了buffer变量绑定到缓冲区后，insert-buffer函数中接下来是一个let语句。它设置了3个局部变量start、end和newmark并初始化为nil。这些变量是let语句中的临时变量。&lt;/p&gt;
&lt;p&gt;let语句体包含了两个save-excursion语句。内部的那个save-excursion如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(set-buffer buffer)将将当前缓冲区设置为将要复制文本的缓冲区。在那个缓冲区中将start和end分别设置为缓冲区开始位置和结束位置。这里可以看到setq可以在一个语句中设置多个变量。第一个参数值设置为第二个参数，第三个参数值为第四个参数。&lt;/p&gt;
&lt;p&gt;外部的那个save-excursion表达式结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;inner-save-excursion-expression&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;go-to-new-buffer-and-set-start-and-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert-buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;newmark&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;insert-buffer-substring函数从原缓冲区中把start和end所定义的区域中的文本拷贝到buffer中。第二个缓冲区所有内容都处于start和end之间，因此整个缓冲区都将被拷贝到当前编辑的缓冲区中。这时，point位于被插入的文本的结束位置，被保存到newmark变量中。&lt;/p&gt;
&lt;p&gt;在执行外部的save-excursion语句后，point和mark将回到原来的位置。&lt;/p&gt;
&lt;p&gt;然而，合适的mark位置应该被设置在被插入的文本块的结束位置，而point应当被设置在这个文本块的开始位置。newmark记录了被插入文本的结束位置。let语句的最后一行(push-mark newmark)语句将mark设置到了那个位置。（前一个mark仍然可以访问，它被保存在mark ring里面，可以用C-u C-&lt;spc&gt;回到那个位置）。同时，point被设置到被插入文本的开始位置，这也是函数调用前point所在的位置。&lt;/spc&gt;&lt;/p&gt;
&lt;h2&gt;完整的beginning-of-buffer函数的定义&lt;/h2&gt;
&lt;p&gt;前面讨论过"简化版的beginning-of-buffer函数定义"。在那个版本中，调用的时候没有传递参数。Emacs中的beginning-of-buffer将光标移到缓冲区开始位置，并将mark设置在之前光标所在位置。调用的时候可以传递1-10之间的数字给这个命令，函数将把参数当作移动的百分比：整个缓冲区当作10份，C-u 7 M-&amp;lt;将跳转到整个缓冲区70%的位置。M-&amp;lt;将中跳转到缓冲区的开始位置。如果传递的参数大于10，则将移动到缓冲区的结束位置。&lt;/p&gt;
&lt;p&gt;beginning-of-buffer的参数是可选的，可以不带参数调用。&lt;/p&gt;
&lt;h3 id="ke-xuan-can-shu"&gt;可选参数&lt;/h3&gt;
&lt;p&gt;在调用需要参数的函数时，如果没有设置参数Lisp解释器将报错：Wrong number of arguments。&lt;/p&gt;
&lt;p&gt;但Lisp提供了可选参数的功能：用&amp;amp;optional（&amp;amp;是这个关键字的一部分）关键字告诉解释器参数是可选的，如果参数跟在&amp;amp;optional的后面，则在调用函数时可以不传递这个参数&lt;/p&gt;
&lt;p&gt;beginning-of-buffer函数定义的第一行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;beginning-of-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个函数看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;beginning-of-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"P"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;push-mark&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;if-there-is-an-argument&lt;/span&gt;
        &lt;span class="nv"&gt;figure-out-where-to-go&lt;/span&gt;
      &lt;span class="nv"&gt;else-go-to&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个函数与simplified-beginning-of-buffer函数类似，除了interactive语句用了"P"参数和goto-char函数跟了一个用于在传递了参数时计算光标位置if-then-else语句。&lt;/p&gt;
&lt;p&gt;"P" interactive语句告诉Emacs传递一个前缀参数，这个参数来自于按&lt;meta/&gt;键前输入的数字。或者输入C-u时输入的数字。(如果不输入数字，C-u缺省为4）&lt;/p&gt;
&lt;p&gt;if语句部分比较简单：如果参数arg的值不为nil，即调用beginning-of-buffer时有带参数，则true-or-false-test返回true，if语句的then部分将被执行。如果beginning-of-buffer调用时没有带参数则if语句将被执行。else部分(goto-char (point-min))被执行。&lt;/p&gt;
&lt;h3 id="dai-can-shu-zhi-xing-beginning-of-buffer"&gt;带参数执行beginning-of-buffer&lt;/h3&gt;
&lt;p&gt;当带参数执行时，用于计算传递给goto-char的参数值的语句被执行。这个语句初看起来比较复杂。它内部包含了一个if语句和更多的数学计算。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;;; Avoid overflow for large buffer sizes!&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="jie-kai-beginning-of-buffer"&gt;解开beginning-of-buffer&lt;/h4&gt;
&lt;p&gt;解开上面的条件语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buffer-is-large&lt;/span&gt;
    &lt;span class="nv"&gt;divide-buffer-size-by-10-and-multiply-by-arg&lt;/span&gt;
  &lt;span class="nv"&gt;else-use-alternate-calculation&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;if语句检查缓冲区的大小。这样做主要是由于在由的Emacs 18版本中计算出来的数字不允许大于8百万，Emacs怕缓冲区太大，后面的计算结果超过上限而溢出。在Emacs 21中使用大数字，但这个代码没被改动。&lt;/p&gt;
&lt;h4 id="huan-chong-qu-hen-da-shi-de-qing-kuang"&gt;缓冲区很大时的情况&lt;/h4&gt;
&lt;p&gt;在beginning-of-buffer中，内部的if语句为了检查缓冲区是否大于1000个字符使用了&amp;gt;函数和buffer-size函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果超过了if语句的then部分将执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语句使用*函数将两个参数相乘。&lt;/p&gt;
&lt;p&gt;第一个参数(prefix-number-value arg)。当使用"P"作为interactive时，传递给函数的参数值是一个"raw prefix argument"，不是一个数字（是一个包含了一个数字的列表）。为了执行数字运行，需要通过prefix-number-value来做转换。&lt;/p&gt;
&lt;p&gt;第二个参数是(/ (buffer-size) 10)。这个语句将数值与十相除。这计算出了缓冲区中1/10有多少个字符。&lt;/p&gt;
&lt;p&gt;在整个相乘的语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;numeric-value-of-prefix-arg&lt;/span&gt;
   &lt;span class="nv"&gt;number-of-characters-in-one-tenth-of-the-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果传递的参数是7，计算出的位置就是缓冲区70%的位置。&lt;/p&gt;
&lt;p&gt;缓冲区很大的时候，goto-char语句的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="huan-chong-qu-jiao-xiao-shi-de-qing-kuang"&gt;缓冲区较小时的情况&lt;/h4&gt;
&lt;p&gt;如果缓冲区包含的字符数量小于10000，计算上有些不同。也许你会认为这没有必要，因为第一个计算方式（大于10000时的情况）也能工作。然而在小型缓冲区中，第一种方法不能将光标放在需要位置；第二种方法则工作得好一些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;格式化后看得更清楚一些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;/&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;prefix-numeric-value&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
   &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看最内部的括号(prefix-numberic-value arg)，它将raw argument转换为数字。然后将数字与缓冲区大小相乘。
&amp;lt;src lang="emacs-lisp"
(* (buffer-size) (prefix-numeric-value arg)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;这个操作将得到一个大于缓冲区几倍的数字。然后用这个数字加上10最后再除以10得到一个大于百分比位置的值。

这个结果被传递给goto-char将光标移到那个点。

### beginning-of-buffer的完整代码
```emacs-lisp
(defun beginning-of-buffer (&amp;amp;optional arg)
  "Move point to the beginning of the buffer;
leave mark at previous position.
With arg N, put point N/10 of the way
from the true beginning.
Don't use this in Lisp programs!
\(goto-char (point-min)) is faster
and does not set the mark."
  (interactive "P")
  (push-mark)
  (goto-char
   (if arg
       (if (&amp;gt; (buffer-size) 10000)
           ;; Avoid overflow for large buffer sizes!
           (* (prefix-numeric-value arg)
              (/ (buffer-size) 10))
         (/ (+ 10 (* (buffer-size)
                     (prefix-numeric-value arg)))
            10))
     (point-min)))
  (if arg (forward-line 1)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中的文档字符串中使用了一个语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;\(goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语句第一个括号前的\告诉Lisp解释器应该打印这个表达式而不是对它求值。&lt;/p&gt;
&lt;p&gt;beginning-of-buffer的最后一行代码：如果执行命令时带了参数，则移动point到下一行的起始位置。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这行代码将光标移动到了计算位置的下一行的起始位置。(这行代码并非必要的，只是为了看起来更好）&lt;/p&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;or&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依次执行各个参数直到遇到一个返回值不为nil的值。如果没有返回值为nil的参数，则返回nil，否则返回第一个返回值不为nil的值。简单来说就是：返回参数中第一个为true的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;and&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依次执行各个参数，直到遇到返回值为nil时，返回nil；如果没有nil则返回最后一个参数的值。简单来说就是：如果所有参数都为true就返回true；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;amp;optional&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个关键字用于标明函数定义中的参数是可选的参数。意味着调用函数时可以不传递这个参数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prefix-numeric-value&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将从(interactive "P")获取到的"raw prefix argument'转换为数字。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;forward-line&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将point移到下一行的行首，如果参数大于1，则向下移动多行。如果不能移动那么多行，则forward-line尽量移动到能到达的位置，并返回没有进行操作的多余次数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;erase-buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;删除当前整个缓冲区中的内容。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bufferp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果参数是一个缓冲区，则返回t，否则返回nil。&lt;/p&gt;
&lt;h1&gt;Narrowing and Widening&lt;/h1&gt;
&lt;p&gt;Narrowing是Emacs的一项功能，它使你可以将焦点集中在缓冲区的某个部分上，而不用担心意外的修改了其它部分。Narrowing通常被禁用，因为它可能会使新手觉得迷惑。&lt;/p&gt;
&lt;h2&gt;Narrowing的优点&lt;/h2&gt;
&lt;p&gt;使用narrowing时，缓冲区的其它部分不可见，看起来就像其它部分不存在一样。利用这点你可以只在缓冲区中的某个部分进行查找或替换操作，而不会影响缓冲区的其它部分。narrow-to-region被绑定到C-x n n。&lt;/p&gt;
&lt;p&gt;narrowing将使缓冲区的其它部分不可见，如果用户在无意中执行了narrowing命令时他们有可能会认为其它部分被删除了。而且，在这里用undo命令也不（C-x u）也不能关闭narrowing。这时可以使用widen（C-x n w）命令让其它部分重新显示出来。&lt;/p&gt;
&lt;p&gt;Narrowing对于Lisp解释器或者用户都是很有用的。Emacs Lisp函数通常被设计为工作于缓冲区的一部分，或者工作于被narrow处理的整个缓冲区。比如：what-line函数（这个函数存在narrow时将显示两两个行号narrowing情况时的行数和非narrowing时的行数），从缓冲区中移除narrowing，工作完成后恢复narrowing。另一个函数count-lines，它被what-line调用，它使用narrowing将工作范围限定在需要处理的区域，在处理完成后再恢复。&lt;/p&gt;
&lt;h2&gt;特殊的save-restriction表(form)&lt;/h2&gt;
&lt;p&gt;在Emacs Lisp中，可以使用save-restriction保持对所有narrowing操作的跟踪。当Lisp解释器遇到save-restriction时，它执行save-restriction语句的body部分，然后撤消在body部分代码执行中的所有narrowing相关的操作。比如：缓冲区当前是narrowed状态，save-restriction中的代码删除了narrowing，save-restriction返回时将回到narrorwed的状态。在what-line命令中，所有的narrowing缓冲区都可能被save-restriction后面的widen命令撤消。所有原始的narrowing将在函数完成后被恢复。&lt;/p&gt;
&lt;p&gt;使用save-restriction语句的简单模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-restriction&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;save-restriction函数的body部分是一个或多个将被依序执行的语句。&lt;/p&gt;
&lt;p&gt;注意：同时使用save-excursion和save-restriction时，应该将save-excursion放在外部。如果放反了顺序，就有可能使Emacs在调用save-excursion后无法记录当前的narrowing信息。因此，这两个函数同时使用应该写成下面的结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-restriction&lt;/span&gt;
    &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这两个函数不紧挨在一起，也必须按顺序使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-restriction&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;widen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;what-line&lt;/h2&gt;
&lt;p&gt;what-line命令告诉你当前光标所在行的行号。这个命令个使用了save-restriction和save-excursion函数的例子。函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;what-line&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Print the current line number (in the buffer) of point."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-restriction&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;widen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Line %d"&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-lines&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数有一个文档字符串和交互语句。接下来的两行使用了save-restriction和widen。&lt;/p&gt;
&lt;p&gt;save-restriction将在其body部分的代码执行完后恢复narrowing。&lt;/p&gt;
&lt;p&gt;save-restriction下面的widen撤消调用what-line时缓冲区中的所有narrowing（这些narrowing就save-restriction所记录的那些）。widen使得可以从缓冲区的开始位置计数。否则，它将只能对可访问区域进行计数。在save-restriction执行完成后将恢复原来的narrowing。&lt;/p&gt;
&lt;p&gt;widen后面是save-excursion语句，它将保存当前光标位置（mark point等），在执行完成后恢复。在save-excursion的body部分使用了beginning-of-line函数移动poing。&lt;/p&gt;
&lt;p&gt;注意：这里的widen语句在save-restriction和save-excursion之间。当同时使用时save-excursion应该在最外面。&lt;/p&gt;
&lt;p&gt;what-line函数的最后两行用于统计缓冲区中的行数，并显示在回显区。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Line %d"&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-lines&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;message函数在Emacs回显区显示了一行消息。第一个参数是一个双引号单间的字符串。字符串中可以包含%d，%s或%c来打印参数。%d用于打印数字。&lt;/p&gt;
&lt;p&gt;所打印的数字%d是最后一行函数计算出来的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-lines&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它从缓冲区中的第一行统计，从1开始计数直到(poing)，并在这个数字上加1。（1+是一个自增加1的函数。）这里加1是因为在第2行的前面只有一行，count-lines计数时只计算到当前所在行的前一行。&lt;/p&gt;
&lt;p&gt;在count-lines执行完后，将显示消息在回显区，save-excrusion恢复point和mark；save-restriction恢复原来的narrowing。&lt;/p&gt;
&lt;h1&gt;基础函数:car, cdr, cons&lt;/h1&gt;
&lt;p&gt;Lisp中car，cdr和cons都是基础函数。cons用于构造lists，car和cdr用于分割lisp。&lt;/p&gt;
&lt;h2&gt;奇怪的命名&lt;/h2&gt;
&lt;p&gt;cons函数的名称并非没有含意：它是单词'construct'的缩写。car是短语'Contents of the Address part of the Register'；cdr（'could-er'）是短语'Contents of the Decrement part of the Register'。这些短语说明了Lisp是在多么原始的机器上被开发的。&lt;/p&gt;
&lt;h2&gt;car和cdr&lt;/h2&gt;
&lt;p&gt;一个list的CAR是list中的第一个元素。(rose violet daisy buttercup)的CAR就是rose。&lt;/p&gt;
&lt;p&gt;执行下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;rose&lt;/span&gt; &lt;span class="nv"&gt;violet&lt;/span&gt; &lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行这个语句后，回显区将显示rose。&lt;/p&gt;
&lt;p&gt;有一个更合理的car函数：first。&lt;/p&gt;
&lt;p&gt;car并不从list移除第一个元素；它只返回第一个元素。car执行完后list并没有发生改变。car是一个无害的函数（'non-destructive'）。&lt;/p&gt;
&lt;p&gt;CDR是list中的其余部分，cdr函数返回list中首元素后面的其它元素。因此'(rose violet daisy buttercup)的CDR部分是(violet daisy buttercup)。&lt;/p&gt;
&lt;p&gt;对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;rose&lt;/span&gt; &lt;span class="nv"&gt;violet&lt;/span&gt; &lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;求值将在回显区显示(violet daisy butercup)&lt;/p&gt;
&lt;p&gt;cdr也不从列表中移除元素。&lt;/p&gt;
&lt;p&gt;附带说明一下：在这个例子中list前面加了单引号。如果不加，Lisp解释器把rose当作函数执行。在这个例子中我们并不需要那样。&lt;/p&gt;
&lt;p&gt;cdr的一个更合理的名称是：rest。&lt;/p&gt;
&lt;p&gt;当car和cdr应用于符号组成的列表时，比如(pine fir oak maple)，函数car将返回列表中的pine元素，并且pine不会被括号包含。这个list的CDR也是一个list，(fir oak maple)。&lt;/p&gt;
&lt;p&gt;如果car和cdr应用于包含list的list，第一个元素也是list。car将返回list中的第一个list元素。&lt;/p&gt;
&lt;p&gt;car和cdr是无害的，它们不修改list中的数据。这是非常重要的一点。&lt;/p&gt;
&lt;p&gt;在第一章中曾说过：&amp;ldquo;在Lisp中某些原子类型，比如数组，可以被分隔成更小的部分；但这种机制与分割list的机制是不同的。这与Lisp的早期概念有关，list中的原子是不可分隔的。&amp;rdquo;（car和cdr也并不修改list。）car和cdr是用于分割list的基础函数。但它们不能用于分割数组或者访问数组中的一部分。数组被看作原子类型。另一个基础函数cons可以用于构造列表，但也不能用于数组。&lt;/p&gt;
&lt;h2&gt;cons&lt;/h2&gt;
&lt;p&gt;cons函数是构造list的函数。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'pine&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行时回显区将显示(pine fir oak maple)。cons将新的元素放到列表的开头，它将新元素推入list中。&lt;/p&gt;
&lt;h3 id="gou-zao-yi-ge-list_1"&gt;构造一个list&lt;/h3&gt;
&lt;p&gt;cons函数必须要有一个可以被插入的list参数。构造一个list时，至少要提供一个空的list。下面是一些构造list的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'buttercup&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (buttercup)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'daisy&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (daisy buttercup)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'violet&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (violet daisy buttercup)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'rose&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;violet&lt;/span&gt; &lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (rose violet daisy buttercup)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在第一个例子中，()是一个空的list并且用空list和buttercup构造了一个list。可以看到空list并没有显示在被构造的list中。只能看到(buttercup)。空list不会被当作一个list元素，因为空list中没有任何元素。空list是不可见的。&lt;/p&gt;
&lt;h3 id="jian-cha-listde-chang-du-length"&gt;检查list的长度：length&lt;/h3&gt;
&lt;p&gt;可以用函数length检查list中的元素数量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 1&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 2&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'violet&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;daisy&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以将length应用于空list上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当调用length函数而不传递参数给它时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你将得到一个错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Wrong number of arguments: #&amp;lt;subr length&amp;gt;, 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表示函数接收到了错误的参数个数，0，函数需要一定数量的参数。在这里length需要一个参数，参数应该是一个list。（一个list也是一个参数而不管list中有多少元素）&lt;/p&gt;
&lt;p&gt;错误信息中的#&lt;sub length=""&gt;是函数的名称。#&amp;lt;subr，标明函数length是用C写的原生函数而不是用Emacs Lisp编写的。（subr是'subroutine'的缩写）&lt;/sub&gt;&lt;/p&gt;
&lt;h2&gt;nthcdr&lt;/h2&gt;
&lt;p&gt;nthcdr是一个与cdr相关的函数。它用于多次获取list的CDR部分。&lt;/p&gt;
&lt;p&gt;如果获取(pine fir oak maple)的CDR部分，将得到(fir oak maple)。如果在这个结果上再重复操作将得到(oak maple)。（如果你在原来的list上取CDR，将一直得到同样的结果，因为原来的list并没有被修改）如果继续下去，将得到一个空的list，这时将不会显示为()，而是显示为nil。
例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt;(fir oak maple)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (oak maple)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt;(maple)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="ss"&gt;'nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者用下面的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (oak maple)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;nthcdr函数与多次调用cdr类似。下面的例子中，参数2和一个list被传递给nthcdr，返回的值与原list相比，不含前面两个元素，相当于在list上执行了两次cdr。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (oak maple)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Leave the list as it was.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (pine fir oak maple)&lt;/span&gt;

&lt;span class="c1"&gt;;; Return a copy without the first element.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (fir oak maple)&lt;/span&gt;

&lt;span class="c1"&gt;;; Return a copy of the list without three elements.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (maple)&lt;/span&gt;

&lt;span class="c1"&gt;;; Return a copy lacking all four elements.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

&lt;span class="c1"&gt;;; Return a copy lacking all elements.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;fir&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;maple&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;nth&lt;/h2&gt;
&lt;p&gt;nthcdr重复取list的CDR部分。nth函数取nthcdr返回值的CAR部分。它返回list中的Nth元素。&lt;/p&gt;
&lt;p&gt;如果nth没有被因为效率原因而用C定义，那么nth的定义将会是下面的样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Returns the Nth element of LIST.&lt;/span&gt;
&lt;span class="s"&gt;N counts from zero.  If LIST is not that long, nil is returned."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="nv"&gt;n&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（最初的nth在定义在Emacs Lisp文件subr.el中，但后来在1980年被重新用C实现。）&lt;/p&gt;
&lt;p&gt;元素计数从0开始而不是1。这就是说list的第一个元素CAR是第零个元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"one"&lt;/span&gt; &lt;span class="s"&gt;"two"&lt;/span&gt; &lt;span class="s"&gt;"three"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;=&amp;gt; "one"&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nth&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"one"&lt;/span&gt; &lt;span class="s"&gt;"two"&lt;/span&gt; &lt;span class="s"&gt;"three"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;=&amp;gt; "two"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：nth与nthcdr和cdr一样，也不修改原来的list，也是一个无害函数。&lt;/p&gt;
&lt;h2&gt;setcar&lt;/h2&gt;
&lt;p&gt;从命名上就可以猜想到，setcdr和setcar函数用于设置list的CAR或CDR部分为一个新值。与car和cdr不同，它们将修改原始的list。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;antelope&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nv"&gt;animals&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (antelope giraffe lion tiger)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcar&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="ss"&gt;'hippopotamus&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;animals&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (hippopotamus giraffe lion tiger)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到setcar函数并非像cons那样向list中添加元素；它将giraffe替换为hippopotamus；它修改了list。&lt;/p&gt;
&lt;h2&gt;setcdr&lt;/h2&gt;
&lt;p&gt;setcdr与setcar函数类似，它用于替换list中除首元素外的其它元素。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;domesticated-animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;horse&lt;/span&gt; &lt;span class="nv"&gt;cow&lt;/span&gt; &lt;span class="nv"&gt;sheep&lt;/span&gt; &lt;span class="nv"&gt;goat&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nv"&gt;domesticated-animals&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (horse cow sheep goat)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="nv"&gt;domesticated-animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cat&lt;/span&gt; &lt;span class="nv"&gt;dog&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nv"&gt;domesticated-animals&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (horse cat dog)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;剪切和存储文本&lt;/h1&gt;
&lt;p&gt;当使用'kill'命令剪切文本时，Emacs将它存储到一个列表中，可以用'yank'命令重新获取到。&lt;/p&gt;
&lt;h2&gt;存储文本到列表&lt;/h2&gt;
&lt;p&gt;当文本被剪切出缓冲区时，它将被存储到一个list中。文本块连续的存储在list中，这个列表看如下面的形式：
&amp;lt;src lang="emacs-lisp"
("a piece of text" "previous piece")&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;函数cons可以添加文本块到list，如：
```emacs-lisp
(cons "another piece"
      '("a piece of text" "previous piece"))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行上面的语句，回显区将显示&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"another piece"&lt;/span&gt; &lt;span class="s"&gt;"a piece of text"&lt;/span&gt; &lt;span class="s"&gt;"previous piece"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用car和nthcdr函数，可以获取到list中任意的一个文本块。。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"another piece"&lt;/span&gt;
                 &lt;span class="s"&gt;"a piece of text"&lt;/span&gt;
                 &lt;span class="s"&gt;"previous piece"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; "a piece of text"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，Emacs中实际处理这些时更复杂一些。Emacs中编写的剪切函数能猜想出你需要的是list的哪个元素。&lt;/p&gt;
&lt;p&gt;包含这些文本块的list被称作kill ring。&lt;/p&gt;
&lt;h2&gt;zap-to-char&lt;/h2&gt;
&lt;h3 id="wan-zheng-de-zap-to-charshi-xian"&gt;完整的zap-to-char实现&lt;/h3&gt;
&lt;p&gt;这个函数将移除光标和指定的字符之间的文本。被移除的文本被放入kill ring中，可以用C-y（yank）获取到。如果命令带了数字前缀参数n(C-u)，它将移除当前光标位置至遇到的第n个字符之间的文本。&lt;/p&gt;
&lt;p&gt;如果指定的字符不存在，zap-to-char将显示"Search failed"。&lt;/p&gt;
&lt;p&gt;为了决定要移除多少文本，zap-to-char使用了search函数。搜索在文本处理代码中使用得非常广泛。&lt;/p&gt;
&lt;p&gt;下面是zap-to-char在Emacs 19中的完整代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zap-to-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="nv"&gt;char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; version 19 implementation&lt;/span&gt;
  &lt;span class="s"&gt;"Kill up to and including ARG'th occurrence of CHAR.&lt;/span&gt;
&lt;span class="s"&gt;Goes backward if ARG is negative; error if CHAR not found."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"*p\ncZap to char: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
               &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;char-to-string&lt;/span&gt; &lt;span class="nv"&gt;char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="interactiveyu-ju"&gt;interactive语句&lt;/h3&gt;
&lt;p&gt;zap-to-char的interactive语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"*p\ncZap to char: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;引号中的部分"*p\ncZap to char: "，指定了3个不同的东西。第一，星号，如果当前缓冲区是只读缓冲区将产生一个错误信息。这意味着如果将zap-to-char用于只读缓冲将得到错误信息"Buffer is read-only"。&lt;/p&gt;
&lt;p&gt;在Emacs21的实现中没有包含星号。函数与Emacs19中一样能工作，但在只读缓冲区中它不会移除文本，它将复制文本并将文本放到kill ring中。在这种情况下，两个版本中都将显示错误信息。&lt;/p&gt;
&lt;p&gt;在Emacs19中的实现也能从只读缓冲区中复制文本，这只是interactive的一个Bug。interactive的文档中说明了，星号将阻止zap-to-char函数对只读缓冲区做任何操作，这个函数不应该复制文本到kill ring中。&lt;/p&gt;
&lt;p&gt;在Emacs21中interactive的实现是正确的。因此星号不得不被移除。如果你在这个这个函数的定义中插入了星号，并重新执行函数定义，下次你再在只读缓冲区上运行zap-to-char时，将不能再复制文本到kill ring里。&lt;/p&gt;
&lt;p&gt;从这点来看，两个版本中的zap-to-char是一致的。&lt;/p&gt;
&lt;p&gt;"&lt;code&gt;*p\ncZap to char:&lt;/code&gt;"中的第二个部分是p。这个部分与下一部分用\n分隔了。p表示参数应该是一个前缀参数'processed prefix'，这个参数是用C-u加数字或者M-加数字传递的。如果调用时没有加参数，1将作为默认的参数值。&lt;/p&gt;
&lt;p&gt;"&lt;code&gt;*p\ncZap to char:&lt;/code&gt;"中的第三个部分是"cZap to char: "，小写的c指定了参数必须是一个字符。c后面的字符串Zap to char: 是提示字符串。&lt;/p&gt;
&lt;h3 id="zap-to-charde-han-shu-ti"&gt;zap-to-char的函数体&lt;/h3&gt;
&lt;p&gt;zap-to-char函数体包含kill当前光标位置至指定字符之间文本的代码。代码的第一部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(point)是光标的当前位置&lt;/p&gt;
&lt;p&gt;代码的下一个部分是一个progn语句。progn的body部分由search-forward和point组成。&lt;/p&gt;
&lt;p&gt;在学习完search-forward后，很容易懂progn。&lt;/p&gt;
&lt;h3 id="search-forwardhan-shu"&gt;search-forward函数&lt;/h3&gt;
&lt;p&gt;search-forward函数被用于定位字符（zapped-for-character）。如果查找成功，search-forward会将point设置在要查找的目标字符串的最后一个字符的后面。（zap-to-char中目标字符串只有一个字符）如果是向后查找，则search-forward会将point设置在查找目标字符串第一个字符的前面。查找成功后，search-forward将返回t。&lt;/p&gt;
&lt;p&gt;在zap-to-char中，search-forward函数部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;char-to-string&lt;/span&gt; &lt;span class="nv"&gt;char&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;search-forward函数包含四个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一个参数是要查询目标，必须是一个字符串，比如"z"。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;传递给zap-to-char是一个字符。Lisp解释器对字符串和字符的处理是不同的。因为search-forward函数查询的是一个字符串，传递给zap-to-char函数接收到的是一个字符，因此参数必须被转换为字符串，否则search-forward将报错。char-to-string用于处理这种转换。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第二个参数限制查询的范围；它是一个缓冲区位置。在这里，可以查询到缓冲区的结束位置，因此第二个参数为nil。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个参数告诉函数如果查询失败该如何做：比如打印错误信息或者返回nil。第三个参数为nil将在查询失败时显示错误信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;search-forward的第四个参数用于指定重复查询的次数。这个参数是可选，如果没有传递，则默认为1.如果参数是一个负数，查询将向后查询。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用search-forward语句的模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt; &lt;span class="s"&gt;"target-string"&lt;/span&gt;
                &lt;span class="nv"&gt;limit-of-search&lt;/span&gt;
                &lt;span class="nv"&gt;what-to-do-if-search-fails&lt;/span&gt;
                &lt;span class="nv"&gt;repeat-count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="progn"&gt;progn&lt;/h3&gt;
&lt;p&gt;progn是一个特殊的form。它使传递给它的参数依次被执行，并返回最后一个值。前面部分只是被执行，它们的返回值被丢弃。&lt;/p&gt;
&lt;p&gt;progn语句的模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;zap-to-char中的progn语句做了两件事：将point设置到正确的位置；返回point的位置以便kill-region知道要操作的范围。&lt;/p&gt;
&lt;p&gt;progn的第一个参数是search-forward。当search-forward找到了字符串，它会将point设置在查找目标字符串的最后一个字符的后面。（这里目标字符串只有一个字符长）如果是向后查找，search-forward会将poing设置在查找目标的第一个字符的前面。point的移动是side effect（单方面的，不影响界面）。&lt;/p&gt;
&lt;p&gt;progn的第二个参数是表达式(point)。这个表达式返回point的值，即search-forward设置的那个值。这个值被作为progn语句的返回值将作为kill-region的第二个参数传递给kill-region函数。&lt;/p&gt;
&lt;h3 id="zap-to-charde-zong-jie"&gt;zap-to-char的总结&lt;/h3&gt;
&lt;p&gt;前面了解了search-forward和progn是如何工作的，我们可以看到整个zap-to-char函数是如何工作的。&lt;/p&gt;
&lt;p&gt;kill-region的第一个参数是执行zap-to-char命令时的光标位置。在progn的内部，查找函数将poing移动到要查找目标（zapped-to-character）的后面。kill-region函数将这两个point中的第一个作为操作区域（region）的开始位置，第二个参数作为结束位置，然后移除这个区域。&lt;/p&gt;
&lt;p&gt;progn是必需的，因为kill-region命令需要两个参数；如果把search-forward和point语句直接作为kill-region的参数将报错。progn语句是一个单独的参数，它的返回值将作为传递给kill-region的第二个参数。&lt;/p&gt;
&lt;h2&gt;kill-region&lt;/h2&gt;
&lt;p&gt;zap-to-char函数使用了kill-region函数。函数将从一个region中clip文本到kill ring中。&lt;/p&gt;
&lt;p&gt;在Emacs 21中这个函数使用了condition-case和copy-region-as-kill，这两个函数都将在后面解释，confition-case是一个特别重要的form。&lt;/p&gt;
&lt;p&gt;实际上，kill-region函数调用了condition-case，它需要3个参数。第一个参数不做什么，第二个参数包含了正常工作时需要执行的代码。第三个参数包含了出错时需要执行的代码。&lt;/p&gt;
&lt;h3 id="wan-zheng-de-kill-regionding-yi"&gt;完整的kill-region定义&lt;/h3&gt;
&lt;p&gt;下面将介绍condition-case。首先来看kill-region的完整定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;kill-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Kill between point and mark.&lt;/span&gt;
&lt;span class="s"&gt;The text is deleted but saved in the kill ring."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;;; 1. `condition-case' takes three arguments.&lt;/span&gt;
  &lt;span class="c1"&gt;;;    If the first argument is nil, as it is here,&lt;/span&gt;
  &lt;span class="c1"&gt;;;    information about the error signal is not&lt;/span&gt;
  &lt;span class="c1"&gt;;;    stored for use by another function.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;condition-case&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;

      &lt;span class="c1"&gt;;; 2. The second argument to `condition-case'&lt;/span&gt;
      &lt;span class="c1"&gt;;;    tells the Lisp interpreter what to do when all goes well.&lt;/span&gt;

      &lt;span class="c1"&gt;;;    The `delete-and-extract-region' function usually does the&lt;/span&gt;
      &lt;span class="c1"&gt;;;    work.  If the beginning and ending of the region are both&lt;/span&gt;
      &lt;span class="c1"&gt;;;    the same, then the variable `string' will be empty, or nil&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;delete-and-extract-region&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

        &lt;span class="c1"&gt;;; `when' is an `if' clause that cannot take an `else-part'.&lt;/span&gt;
        &lt;span class="c1"&gt;;; Emacs normally sets the value of `last-command' to the&lt;/span&gt;
        &lt;span class="c1"&gt;;; previous command.&lt;/span&gt;
        &lt;span class="c1"&gt;;; `kill-append' concatenates the new string and the old.&lt;/span&gt;
        &lt;span class="c1"&gt;;; `kill-new' inserts text into a new item in the kill ring.&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;last-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="c1"&gt;;; if true, prepend string&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;this-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;;; 3. The third argument to `condition-case' tells the interpreter&lt;/span&gt;
    &lt;span class="c1"&gt;;;    what to do with an error.&lt;/span&gt;
    &lt;span class="c1"&gt;;;    The third argument has a conditions part and a body part.&lt;/span&gt;
    &lt;span class="c1"&gt;;;    If the conditions are met (in this case,&lt;/span&gt;
    &lt;span class="c1"&gt;;;             if text or buffer is read-only)&lt;/span&gt;
    &lt;span class="c1"&gt;;;    then the body is executed.&lt;/span&gt;
    &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;buffer-read-only&lt;/span&gt; &lt;span class="nv"&gt;text-read-only&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;;; this is the if-part&lt;/span&gt;
     &lt;span class="c1"&gt;;; then...&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;copy-region-as-kill&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;kill-read-only-ok&lt;/span&gt;            &lt;span class="c1"&gt;;; usually this variable is nil&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Read only text copied to kill ring"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="c1"&gt;;; or else, signal an error if the buffer is read-only;&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;barf-if-buffer-read-only&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="c1"&gt;;; and, in any case, signal that the text is read-only.&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;signal&lt;/span&gt; &lt;span class="ss"&gt;'text-read-only&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;current-buffer&lt;/span&gt;&lt;span class="p"&gt;)))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="condition-case"&gt;condition-case&lt;/h3&gt;
&lt;p&gt;前面说过，当Emacs Lisp解释器在执行语句发生错误时，它将提供帮助信息，这被称为"signaling a error"。通常，程序将停止执行并显示错误信息。&lt;/p&gt;
&lt;p&gt;然而在一些复杂的情况下。程序不应该在出错的时候只是简单的停止程序执行。在kill-region函数中，一个典型的错误是，如果在只读缓冲区中删除文本时，文本将不会被删除。因此kill-region函数包含了处理这种情况的代码。这些代码在kill-region函数中condition-case语句的内部。&lt;/p&gt;
&lt;p&gt;condition-case的模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;condition-case&lt;/span&gt;
  &lt;span class="nv"&gt;var&lt;/span&gt;
  &lt;span class="nv"&gt;bodyform&lt;/span&gt;
  &lt;span class="nv"&gt;error-handler...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果没有发生错误，解释器将执行bodyform语句。&lt;/p&gt;
&lt;p&gt;错误发生时，函数将产生错误信息，定义一个或者多个错误条件名称（condition name）。&lt;/p&gt;
&lt;p&gt;condition-case的第三个参数是一个错误处理器。一个错误处理器包含了两个部分，一个condition-name和一个body。如果错误处理器的condition-name与发生错误时的condition-name匹配，错误处理器的body部分将执行。&lt;/p&gt;
&lt;p&gt;错误处理器中的错误条件名称（condition-name）可以是一个单一的condition name也可以是包含多个condition name的list。&lt;/p&gt;
&lt;p&gt;condition-case语句可以包含一个或多个错误处理器。当错误发生时，第一个被匹配的处理器被执行。&lt;/p&gt;
&lt;p&gt;最后，condition-case语句的第一个参数var，有时被绑定到包含错误信息的变量上。如果它为nil，比如在kill-region中，错误消息将被丢弃。&lt;/p&gt;
&lt;p&gt;简单来说，在kill-region函数中，condition-case的工作如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;If no errors, run only this code
    but, if errors, run this other code.
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="delete-and-extract-region"&gt;delete-and-extract-region&lt;/h3&gt;
&lt;p&gt;一个condition-case语句有二个部分，一个是正常时执行的，但它有可能会产生错误。另一个部分用于出错时执行。&lt;/p&gt;
&lt;p&gt;先来看kill-region中正常运行的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;delete-and-extract-region&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;last-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;this-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来比较复杂，使用了新的函数：delete-and-extract-region，kill-append和kill-new，和新的变量last-command和this-command。&lt;/p&gt;
&lt;p&gt;delete-and-extract-region函数是一个内置函数，它删除region中的文本并返回这些文本。这个函数实际上是移除（removes）文本。（当不能移除时，它给出错误信号）&lt;/p&gt;
&lt;p&gt;这里的let语句将delete-and-extract-region的返回值赋给局部变量string中。这也就是从缓冲区中删除的文本。&lt;/p&gt;
&lt;p&gt;如果变量string指向了文本，那些文本就被添加到kill ring，如果变量值为nil则表示没有文本被删除。&lt;/p&gt;
&lt;p&gt;这里使用了when来检查变量string是否指向了文本块。when语句是程序员的一种简便写法。when语句是没有else部分的if语句。可以把when理解为if。&lt;/p&gt;
&lt;p&gt;技术上来说，when是一个Lisp宏。Lisp宏允许你定义新的控制结构和其它语言功能。它告诉解释器如何计算另一个Lisp语句的值，并返回计算的结果。这里的'另一个表达式'就是一个if表达式。C语言里也提供了宏。但这是不同的，但它们同样很有用。&lt;/p&gt;
&lt;p&gt;如果string变量有内容，另一个条件表达式被执行。这是一个包含了then部分和else部分的if语句。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;last-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果前一个命令是kill-region，then部分被执行。如果不是，else部分将被执行。&lt;/p&gt;
&lt;p&gt;last-command是一个Emacs变量。通常，当一个函数被执行，Emacs将设置last-command的值为前一个命令。&lt;/p&gt;
&lt;p&gt;在这段定义中，if语句检查前一个命令是否为kill-region。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连续拷贝新文本到kill ring中前一个clipped的文本块中。如果(&amp;lt; end beg)表达式为true，kill-append添加文本到前一个被clipped的文本块中。&lt;/p&gt;
&lt;p&gt;如果yank文本，比如'粘贴'，将一次得到整个文本块。用这种方式，你可以删除一行中的两个单词，然后使用一次yank操作，重新得到这两个单词，（(&amp;lt; end beg)语句保持单词的顺序是正确的）&lt;/p&gt;
&lt;p&gt;如果前一个命令不是kill-region，kill-new函数将被执行，它将文本作为kill ring中的最后一个元素添加进去，然后将变量kill-ring-yank-pointer设置到上面。&lt;/p&gt;
&lt;h2&gt;delete-and-extract-region&lt;/h2&gt;
&lt;p&gt;zap-to-char命令使用了delete-and-extract-region函数，它使用了另外两个函数，copy-region-as-kill和del_range_1。copy-region-as-kill函数将在下节讨论；它复制了region的一份拷贝到kill ring中，因此内容可以yanked回来。&lt;/p&gt;
&lt;p&gt;delete-and-extract-region函数移除region中的内容且不能恢复。&lt;/p&gt;
&lt;p&gt;与其它代码不同，delete-and-extract-region不是用Emacs Lisp编写的；它是用C编写的，这也是Emacs的一个基础系统。&lt;/p&gt;
&lt;p&gt;与其它Emacs原生函数一样，delete-and-extract=region是C宏，宏是一个代码模板。完整宏如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;DEFUN&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"delete-and-extract-region"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;Fdelete_and_extract_region,&lt;/span&gt;
       &lt;span class="nv"&gt;Sdelete_and_extract_region,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
  &lt;span class="s"&gt;"Delete the text between START and END and return it."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start,&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="nv"&gt;Lisp_Object&lt;/span&gt; &lt;span class="nv"&gt;start,&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;{&lt;/span&gt;
  &lt;span class="nv"&gt;validate_region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;&amp;amp;start,&lt;/span&gt; &lt;span class="nv"&gt;&amp;amp;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
  &lt;span class="nb"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;del_range_1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;XINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;XINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DEFUN与Lisp中的defun是同样的用途。DEFUN后面括号中有七个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个部分给出了Lisp函数的名称，delete-and-extract-region&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二部分是C函数的名称，Fdelete_and_extract_region。习惯上以F开头。因为C不能在函数名中使用连字符，因此用下划线替代了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三个部分是记录了供函数内部使用的信息的C常量结构。它的名称与C函数名一致但它以S开头。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四和第五个部分指定了最小和最大的参数个数。这个函数需要2个参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第六部分与Lisp编写的函数中的交互式语句类似：一个字符后跟着可选的提示信息。两者不同之处在于Lisp没有参数时不需要写参数。在这个宏里需要写成0（null string）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第七个部分是文档字符串与Lisp编写的函数中的相同。不同之处在于换行时，需要在\n后面添加一个反斜线并添加回车。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，goto-char的文档字符串的前两行如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        "Set point to POSITION, a number or marker.\n\
      Beginning of buffer is position (point-min), end is (point-max).
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在C宏中，紧接在后面是正式的参数，和参数类型语句，接下来就是宏的'body'部分。delete-and-extract-region的'body'包含了两行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;validate_region (&amp;amp;start, &amp;amp;end);
return del_range_1 (XINT (start), XINT (end), 1, 1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个函数validate_region检查传递的区域起始位置和结束位置是否是在规定的范围内，检查参数类型是否正确。第二个函数del_range_1，执行删除文本的操作。&lt;/p&gt;
&lt;p&gt;del_range_1是一个复杂的函数我们不深入研究。它修改缓冲区并执行其它操作。&lt;/p&gt;
&lt;p&gt;传递给del_range的两个参数XINT (start) and XINT (end)值得研究一下。&lt;/p&gt;
&lt;p&gt;C语言中，start和end是标记了被删除区域的开始位置和结束位置的两个整数。&lt;/p&gt;
&lt;p&gt;早期版本的Emacs中，这两个数字是32bits长，但这个代码运行比较慢。三个bit被用于指定类型信息，四个bit被用于处理内存；其它bits被作为'content'。&lt;/p&gt;
&lt;p&gt;XINT是一个C宏它从bits集合中解析出相关的数字；4个bits被丢弃。&lt;/p&gt;
&lt;p&gt;delete-and-extract-region命令看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;del_range_1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;XINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;XINT&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它删除start和end之间的region。&lt;/p&gt;
&lt;p&gt;从这点来看Emacs Lisp很简单；它隐藏了大量复杂的工作。&lt;/p&gt;
&lt;h2&gt;使用用defvar初始化变量&lt;/h2&gt;
&lt;p&gt;与delete-and-extract-region函数不同，copy-region-as-kill函数是用Emacs Lisp编写的。它内部有两个函数kill-append和kill-new，复制缓冲区区域中的信息到变量kill-ring中。这节讨论kill-ring变量是如何被defvar创建和初始化的。&lt;/p&gt;
&lt;p&gt;在Emacs Lisp中kill-ring之类的变量是用defvar创建和初始化的。这个名称来源于"define variable"。&lt;/p&gt;
&lt;p&gt;defvar与setq设置变量类似。与setq不同的两点：第一，它只给未赋值的变量赋值，如果变量已经有值，defvar将不会覆盖已经存在的值。第二，defvar有一个文档字符串。&lt;/p&gt;
&lt;p&gt;（另一个特别的form是defcustom，被设计为可以让用户自定义。它比defvar有更多的功能。）&lt;/p&gt;
&lt;h3 id="cha-kan-bian-liang-de-dang-qian-zhi"&gt;查看变量的当前值&lt;/h3&gt;
&lt;p&gt;可以使用describe-variable函数查看任何变量的当前值，通常可以用C-h v来调用。比如可以C-h v然后输入kill-ring将看到 当前kill ring的值，同时也能看到kill-ring的文档字符串：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Documentation&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;List&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;killed&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;sequences&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Since&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;kill&lt;/span&gt; &lt;span class="n"&gt;ring&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;supposed&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;interact&lt;/span&gt; &lt;span class="n"&gt;nicely&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;cut&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;and&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;paste&lt;/span&gt;
&lt;span class="n"&gt;facilities&lt;/span&gt; &lt;span class="n"&gt;offered&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;window&lt;/span&gt; &lt;span class="n"&gt;systems&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;should&lt;/span&gt;
&lt;span class="n"&gt;interact&lt;/span&gt; &lt;span class="n"&gt;nicely&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;interprogram&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cut&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="s1"&gt;' and&lt;/span&gt;
&lt;span class="s1"&gt;`interprogram-paste-function'&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;  &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;functions&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;kill&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt;&lt;span class="s1"&gt;',&lt;/span&gt;
&lt;span class="s1"&gt;`kill-append'&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;kill&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;supposed&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;implement&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;
&lt;span class="n"&gt;interaction&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;you&lt;/span&gt; &lt;span class="n"&gt;may&lt;/span&gt; &lt;span class="n"&gt;want&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;them&lt;/span&gt; &lt;span class="n"&gt;instead&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;manipulating&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;kill&lt;/span&gt;
&lt;span class="n"&gt;ring&lt;/span&gt; &lt;span class="n"&gt;directly&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kill ring是使用defvar按下面的方法定义的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
  &lt;span class="s"&gt;"List of killed text sequences.&lt;/span&gt;
&lt;span class="s"&gt;..."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个变量定义中，变量初始化为nil。这意味着如果没有保存任何东西，使用yank时将不会获取到任何信息。文档字符串的写法与使用defun时的文档字符串是一样的，文档字符串的第一行必须是一个完整的语句，因为一些命令，比如apropos只打印文档字符串的第一行。后面的行不应该使用缩进；否则如果用C-h v(describe-variable)查看时将会混乱。&lt;/p&gt;
&lt;h3 id="defvarshi-shi-yong-xing-hao"&gt;defvar时使用星号&lt;/h3&gt;
&lt;p&gt;以前，Emacs使用defvar来定义希望被用户修改的变量和不希望被用户修改的变量。尽管你可以用defvar定义自定义变量，但是请使用defcustom来代替。&lt;/p&gt;
&lt;p&gt;当使用defvar设定变量时，可以在文档字符串的第一个位置添加*号来来区分变量是否为可以设值的变量。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;shell-command-default-error-buffer&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
  &lt;span class="s"&gt;"*Buffer name for &lt;/span&gt;&lt;span class="ss"&gt;`shell-command'&lt;/span&gt;&lt;span class="s"&gt; ... error output.&lt;/span&gt;
&lt;span class="s"&gt;... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表示你可以使用edit-options命令临时修改shell-command-default-error-buffer的值。&lt;/p&gt;
&lt;p&gt;edit-options设置的值只在当前编辑会话中有用。新值并不会被保存。每次Emacs启动时它将读取原始值，除非你在.emacs文件中设定它。&lt;/p&gt;
&lt;h2&gt;copy-region-as-kill&lt;/h2&gt;
&lt;p&gt;这个函数从缓冲区中复制区域中的内容（使用kill-append或kill-new）并保存到kill-ring上。&lt;/p&gt;
&lt;p&gt;如果在调用kill-region后立即调用copy-region-as-kill，Emacs会将新的文本追加到前一个复制的文本中。这意味着你使用yank时将得前面两次操作的所有文本。另一方面，如果在copy-region-as-kill之前执行了一些命令，则函数复制的文本块将不会放在一起。&lt;/p&gt;
&lt;h3 id="wan-zheng-de-copy-region-as-killhan-shu-ding-yi"&gt;完整的copy-region-as-kill函数定义&lt;/h3&gt;
&lt;p&gt;下面是Emacs 21中copy-region-as-kill函数定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;copy-region-as-kill&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Save the region as if killed, but don't kill it.&lt;/span&gt;
&lt;span class="s"&gt;In Transient Mark mode, deactivate the mark.&lt;/span&gt;
&lt;span class="s"&gt;If &lt;/span&gt;&lt;span class="ss"&gt;`interprogram-cut-function'&lt;/span&gt;&lt;span class="s"&gt; is non-nil, also save&lt;/span&gt;
&lt;span class="s"&gt;the text for a window system cut and paste."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;last-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;transient-mark-mode&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;deactivate-mark&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数也可以拆分成多个部分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;copy-region-as-kill&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;argument-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数是beg、end和参数为"r"的交互式函数，因此这两个参数将指向region的开始位置和结束位置。&lt;/p&gt;
&lt;p&gt;一旦设置了一个mark，缓冲区就总会包含一个region。可以使用Transient Mark模式来高亮显示region。（没人会希望region一直处理于高亮状态，因此Transient Mark模式下只会在适当的时候才会高亮显示。许多人都关掉了Transient Mark模式，因此region从不会高亮显示）&lt;/p&gt;
&lt;p&gt;copy-region-as-kill函数体是一个以if开头的子句。这个子句区分了两种情况：这个命令的前一个命令是否是kill-region命令。第一种情况，新的region被追加到前一个被复制的文本块中。否则，它将插入一个新的文本块到kill ring中。&lt;/p&gt;
&lt;h3 id="copy-region-as-killde-bodybu-fen"&gt;copy-region-as-kill的body部分&lt;/h3&gt;
&lt;p&gt;copy-region-as-kill函数和kill-function的工作很相似。两者都是为了将同一行中的两次或多次kill操作合并到同一个块中。如果用yank回来，将一次获得所有的文本块。并且，不管是向前删除还是向后删除，文本块都保持了正确的位置。&lt;/p&gt;
&lt;p&gt;与kill-region相同，copy-region-as-kill函数也使用了last-command（它保持了对次Emacs命令调用的跟踪）变量。&lt;/p&gt;
&lt;h4 id="last-commandhe-this-command"&gt;last-command和this-command&lt;/h4&gt;
&lt;p&gt;通常，任何一个函数被执行，Emacs将在函数被挪时设置this-command为被执行的函数。同时，Emacs将last-command的值设置为this-command的前一个值。&lt;/p&gt;
&lt;p&gt;在copy-region-as-kill函数的body部分，一个if语句检查了last-command的值是否为kill-region。如果是，则if语句被执行；它使用kill-append函数将本次函数调用复制的文本合并到kill ring的第一个元素（CAR）中。如果last-command不为kill-region，则copy-region-as-kill函数将使用kill-new函数在kill ring中添加一个新的元素。&lt;/p&gt;
&lt;p&gt;这个if语句如下，它使用了eq函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;last-command&lt;/span&gt; &lt;span class="ss"&gt;'kill-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; then-part&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;; else-part&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-substring&lt;/span&gt; &lt;span class="nv"&gt;beg&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;eq函数测试它的第二个参数与第一个参数是否为相同的Lisp对象。eq函数与用于测试相等的equal函数类似，不同之处在于：eq测试两个对象是否为指向同一个对象，而equal则检查两个参数的结构和同容是否相同。&lt;/p&gt;
&lt;p&gt;如果前一个命令是kill-region，则Emacs Lisp解释器将调用kill-append函数。&lt;/p&gt;
&lt;h4 id="kill-appendhan-shu"&gt;kill-append函数&lt;/h4&gt;
&lt;p&gt;kill-append函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;kill-append&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="nv"&gt;before-p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Append STRING to the end of the latest kill in the kill ring.&lt;/span&gt;
&lt;span class="s"&gt;If BEFORE-P is non-nil, prepend STRING to the kill.&lt;/span&gt;
&lt;span class="s"&gt;If &lt;/span&gt;&lt;span class="ss"&gt;`interprogram-cut-function'&lt;/span&gt;&lt;span class="s"&gt; is set, pass the resulting kill to&lt;/span&gt;
&lt;span class="s"&gt;it."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;before-p&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kill-append函数使用了kill-new函数。&lt;/p&gt;
&lt;p&gt;首先来看传递给kill-new的参数。它使用了concat连接新文本和kill ring的CAR。是合并到CAR元素的前面还是合并到CAR元素后面取决于if语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;before-p&lt;/span&gt;                            &lt;span class="c1"&gt;; if-part&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;     &lt;span class="c1"&gt;; then-part&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;      &lt;span class="c1"&gt;; else-part&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果被kill的region位于前一个命令kill的region的前面，那么它将被合并到前一次删除的资源的前面，如果被删除的文本在前次删除文本的后面，那它将被合并到前次删除资源的后面。if语句使用before-p决定如何放置。&lt;/p&gt;
&lt;p&gt;符号before-p是kill-append的参数。当kill-append被执行时，它被绑定到实际参数计算出来的值上。在这里是表达式(&amp;lt; end beg)。这个表达式并不能直接决定被删除的文本应该放在上个命令删除的文本的前面还是后面，它决定的是end是否小于beg。意味着用户是向前删除还是向后删除。如果(&amp;lt; end beg)则文本应该加有前一次文本的前面，否则文本应该加在前次文本的后面。&lt;/p&gt;
&lt;p&gt;新文本加到前面时，执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新文本加到后面时，执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以意识到kill-append修改了kill ring。kill ring是一个list，它的每个元素保存了文本。kill-append函数使用kill-new函数，kill-new函数使用了setcar函数。&lt;/p&gt;
&lt;h4 id="kill-newhan-shu"&gt;kill-new函数&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;kill-new&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Make STRING the latest kill in the kill ring.&lt;/span&gt;
&lt;span class="s"&gt;Set the kill-ring-yank pointer to point to it.&lt;/span&gt;
&lt;span class="s"&gt;If &lt;/span&gt;&lt;span class="ss"&gt;`interprogram-cut-function'&lt;/span&gt;&lt;span class="s"&gt; is non-nil, apply it to STRING.&lt;/span&gt;
&lt;span class="s"&gt;Optional second argument REPLACE non-nil means that STRING will replace&lt;/span&gt;
&lt;span class="s"&gt;the front of the kill ring, rather than being added to the list."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fboundp&lt;/span&gt; &lt;span class="ss"&gt;'menu-bar-update-yank-menu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;menu-bar-update-yank-menu&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcar&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-yank-pointer&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先看下面的部分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; then&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcar&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;;; else&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;;; avoid overly long kill ring&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-yank-pointer&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;条件测试(and replace kill-ring)，如果两个kill ring中有内容，并且replace变量为true则返回true。&lt;/p&gt;
&lt;p&gt;kill-append函数将replace设置为true；然后当kill ring至少有一个元素时，setcar语句被执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcar&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setcar函数将kill-ring的第一个元素修改为string的值。它替换了原来的元素。&lt;/p&gt;
&lt;p&gt;如果kill ring为空，或者replace为false，则条件语句的else部分将执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语句先通过在原来的kill ring前添加新元素string，而构造了一个新的kill ring。然后执行了第二个if子句。第二个if子名防止了kill ring增长过大。&lt;/p&gt;
&lt;p&gt;依次来看这两个语句。&lt;/p&gt;
&lt;p&gt;setq的这行将string添加到旧的kill ring组成的新list重新设置给kill-ring。&lt;/p&gt;
&lt;p&gt;第二个if子名，防止了kill ring增长得过长。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码检查kill ring的长度是否已经超过了允许的最大长度&amp;mdash;&amp;mdash;kill-ring-max（默认为60）。如果kill ring过长，则将kill ring的最后一个元素设置为nil。执行这个操作使用了两个函数：nthcdr和setcdr。&lt;/p&gt;
&lt;p&gt;setcdr设置list的CDR部分，setcar设置list的CAR部分。在这里，setcdr不会设置kill ring的CDR部分；nthcdr函数限制了设置CDR的位置。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;trees&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;maple&lt;/span&gt; &lt;span class="nv"&gt;oak&lt;/span&gt; &lt;span class="nv"&gt;pine&lt;/span&gt; &lt;span class="nv"&gt;birch&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (maple oak pine birch)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;trees&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; nil&lt;/span&gt;

&lt;span class="nv"&gt;trees&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (maple oak pine)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setcdr返回值为nil，是因为它设置的CDR是nil。&lt;/p&gt;
&lt;p&gt;kill-new函数中的下一行语句是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-yank-pointer&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kill-ring-yank-pointer也是一个全局变量，它被设置为kill-ring。&lt;/p&gt;
&lt;p&gt;尽管kill-ring-yank-pointer被称为pointer，实际上却是kill ring变量。但选用名字是为了帮助人们懂得这个变量起的作用。这个变量用于yank和yank-pop等函数。&lt;/p&gt;
&lt;p&gt;现在，回到函数的最前面的两行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;fboundp&lt;/span&gt; &lt;span class="ss"&gt;'menu-bar-update-yank-menu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;menu-bar-update-yank-menu&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句第一个元素是函数and。&lt;/p&gt;
&lt;p&gt;and将依次对每个参数求值只到某个参数返回值为nil，这种情况下and语句将返回nil；如果没有参数返回值为nil，返回值将是最后一个参数的值。（这种情况下返回值不会为nil，在Emacs Lisp里可以作为true）。换言之，and语句只有在所有参数都返回true的情况下才返回true。&lt;/p&gt;
&lt;p&gt;在这里，语句测试了menu-bar-update-yank-menu是否是一个函数，如果是则调用它。如果测试的参数符号是一个函数定义而不是'is not void'，则fboundp返回true，如果函数未定义则我们将得到错误信息。&lt;/p&gt;
&lt;p&gt;这个and和if语句效果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;the-menu-bar-function-exists&lt;/span&gt;
  &lt;span class="nv"&gt;then&lt;/span&gt; &lt;span class="nv"&gt;execute-it&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;menu-bar-update-yank-menu函数允许用户使用'Select and Paste'菜单操作，并且可以在菜单上看到文本块。&lt;/p&gt;
&lt;p&gt;最后一个语句kill-new函数添加新的文本到窗口系统中，以便在不同的程序中进行复制粘贴操作。比如：在XWindow系统中x-select-text函数将文本存储在X系统操作的内存中，你可以在另一个程序中粘贴。&lt;/p&gt;
&lt;p&gt;语句结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;funcall&lt;/span&gt; &lt;span class="nv"&gt;interprogram-cut-function&lt;/span&gt; &lt;span class="nf"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果interprogram-cut-function存在，则Emacs执行funcall，它将第一个参数作为函数，并将其它参数传递给这个函数。&lt;/p&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;car&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cdr&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;car返回list的第一个元素；cdr返回list中从第二个元素开始的list。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 1&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (2 3 4 5 6 7)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;cons&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cons将第一个参数添加到第二个参数前面。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (1 2 3 4)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;nthcdr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回对list求'n'次CDR的值。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nthcdr&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (4 5 6 7)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setcar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;setcdr&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;setcar修改list中的第一个元素；setcdr修改list中第二个元素开始的list。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;triple&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcar&lt;/span&gt; &lt;span class="nv"&gt;triple&lt;/span&gt; &lt;span class="ss"&gt;'37&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;triple&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (37 2 3)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;setcdr&lt;/span&gt; &lt;span class="nv"&gt;triple&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"foo"&lt;/span&gt; &lt;span class="s"&gt;"bar"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nv"&gt;triple&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (37 "foo" "bar")&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;progn&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依次执行各个参数并返回最后一个参数的值。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;save-restriction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录当前缓冲区的任何narrowing，在执行完它的参数后，恢复narrowing。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;search-forward&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找字符串，如果找到则将point设置到那个位置。&lt;/p&gt;
&lt;p&gt;它接收4个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;要查找的字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，是一个缓冲区位置，它用于限制查询范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，查询失败执行的代码，返回nil或者显示错误信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询的次数，如果为负数则向前查找&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;kill-region&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete-region&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;copy-region-as-kill&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;kill-region剪切point和mark间的文本到kill ring上，可以用yanking恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete-and-extract-region移除point和mark间的文本并丢弃。不能恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;copy-region-as-kill复制point和mark间的文本到kill ring，可以用yanking恢复。这个函数并不移除原来的文本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;List的实现&lt;/h1&gt;
&lt;p&gt;Lisp中list使用了连续的指针对来保存数据，指针对的第一个指针指向一个原子或者另一个list，指针对的第二个指针指向另一个指针对，或者指向nil，以表明list的结束。&lt;/p&gt;
&lt;h2&gt;List图示&lt;/h2&gt;
&lt;p&gt;举例来说，list(rose violet buttercup)有3个元素，rose，violet和buttercup。在计算机中，rose的地址被保存在计算机内存中，通过这个地址可以知道原子violet被分配在了哪个位置；通过这个地址又可以知道原子buttercup的地址。&lt;/p&gt;
&lt;p&gt;听起来比较复杂，看图就简单多了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    ___ ___      ___ ___      ___ ___
   |___|___|--&amp;gt; |___|___|--&amp;gt; |___|___|--&amp;gt; nil
     |            |            |
     |            |            |
      --&amp;gt; rose     --&amp;gt; violet   --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个图中，每个方框代表一个保存了Lisp对象的内存块，这通常是一个内存地址。在方框中的地址是成对的。每个箭头指向了这个地址的内容，它可能是一个原子也可能是另一个地址对。第一个方框是rose的地址；第二个方框保存了下一个方框对的地址，这个地址的第一个部分指向violet第二个部分指向下一个方框对。最后一个方框指向符号nil，标明list的结束。&lt;/p&gt;
&lt;p&gt;当执行一个设置函数时比如setq，它将第一个方框的地址保存到变量中。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;bouquet&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;rose&lt;/span&gt; &lt;span class="nv"&gt;violet&lt;/span&gt; &lt;span class="nv"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;产生的情况如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --&amp;gt; |___|___|--&amp;gt; |___|___|--&amp;gt; |___|___|--&amp;gt; nil
            |            |            |
            |            |            |
             --&amp;gt; rose     --&amp;gt; violet   --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个例子中符号bouquet保存了第一个方框对的地址。&lt;/p&gt;
&lt;p&gt;同样，list也可以被成有序的方框：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  --&amp;gt;| rose  |   o-------&amp;gt;| violet |   o-------&amp;gt;| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（符号是由地址组成的。实际上bouquet包含了一组地址，一个地址指向可打印的单词bouquet，第二个是地址绑定到该符号上的函数定义（如果存在），第三个地址是list(rose violet buttercup)的第一个地址对的地址，等等。这里只显示了第三个地址的情况。）&lt;/p&gt;
&lt;p&gt;如果符号指向list的CDR部分，这个list本身不会改变；符号将拥有从那个位置开始的list。（CAR和CDR是'non-destructive'的）因此执行下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;flowers&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;bouquet&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将产生下面的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --&amp;gt; |   |   |  --&amp;gt; |   |   |    |   |   |
       |___|___|----&amp;gt; |___|___|--&amp;gt; |___|___|--&amp;gt; nil
         |              |            |
         |              |            |
          --&amp;gt; rose       --&amp;gt; violet   --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;flowers的值是(violet buttercup)，这就是说符号flowers拥有了一个地址对的地址。&lt;/p&gt;
&lt;p&gt;这种地址对被称为cons cell或者dotted pair。&lt;/p&gt;
&lt;p&gt;函数cons添加一个新的地址对到一连串地址对的前面。例如，执行下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;bouquet&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="ss"&gt;'lily&lt;/span&gt; &lt;span class="nv"&gt;bouquet&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;产生的效果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --&amp;gt; |   |   |      |   |   |  --&amp;gt; |   |   |     |   |   |
       |___|___|----&amp;gt; |___|___|----&amp;gt; |___|___|----&amp;gt;|___|___|--&amp;gt; nil
         |              |              |             |
         |              |              |             |
          --&amp;gt; lily      --&amp;gt; rose       --&amp;gt; violet    --&amp;gt; buttercup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而这并不会改变flowers的值，你可以看到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;bouquet&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;flowers&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将返回t。&lt;/p&gt;
&lt;p&gt;到现在为止，flowers的值仍是(violet buttercup)；它拥有violet的cons cell地址。这也不会改变任何之前的cons cells；他们仍然在那里。&lt;/p&gt;
&lt;p&gt;就这样，在Lisp里获取list的CDR，将获取到连续的cons cell串中的第二个；获取list的CAR，将得到第一个。将cons将一个新元素连接到list上，你将会把新元素的cons cell添加到list的前面。&lt;/p&gt;
&lt;p&gt;cons cell串的最后一个指向什么？它指向空list，nil。&lt;/p&gt;
&lt;h2&gt;把符号看作抽屉柜&lt;/h2&gt;
&lt;p&gt;前面章节曾提示过把符号（symbol）想像成抽屉柜。函数定义放到一个抽屉里，变量放到了另一个，等等。&lt;/p&gt;
&lt;p&gt;实际上放在各个抽屉里的是值或函数定义的地址。&lt;/p&gt;
&lt;p&gt;（另外，符号有一个抽屉存放属性列表（property list），它用于记录其它信息。）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;            &lt;span class="n"&gt;Chest&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Drawers&lt;/span&gt;            &lt;span class="n"&gt;Contents&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Drawers&lt;/span&gt;

            &lt;span class="n"&gt;__&lt;/span&gt;   &lt;span class="n"&gt;o0O0o&lt;/span&gt;   &lt;span class="n"&gt;__&lt;/span&gt;
          &lt;span class="o"&gt;/&lt;/span&gt;                 \
         &lt;span class="o"&gt;---------------------&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;     &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;             &lt;span class="n"&gt;bouquet&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;                     &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------+&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;symbol&lt;/span&gt; &lt;span class="n"&gt;definition&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;none&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;                     &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------+&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rose&lt;/span&gt; &lt;span class="n"&gt;violet&lt;/span&gt; &lt;span class="n"&gt;buttercup&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;                     &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------+&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;property&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;             &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;described&lt;/span&gt; &lt;span class="n"&gt;here&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="o"&gt;|&lt;/span&gt;                     &lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;+---------------------+&lt;/span&gt;
        &lt;span class="o"&gt;|/&lt;/span&gt;                   &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;Yanking Text Back&lt;/h1&gt;
&lt;p&gt;当使用'kill'命令剪切文本时，可以用'yank'命令恢复它。被剪切的文本被放到kill ring，yank命令可以将文本恢复。&lt;/p&gt;
&lt;p&gt;C-y（yank）命令插入kill ring中的第一个元素到缓冲区。如果C-y命令后立即跟一个M-y，则插入的文本将被替换为kill ring的第二个元素。连续的按M-y，将使用kill ring中更靠后的文本替换前一次操作插入的文本。当到达最后一个元素时，又将从第一个元素开始。（这也是kill ring被称作ring而不是list的原因）然而实际上保存了文本的数据结构是list。&lt;/p&gt;
&lt;h2&gt;Kill Ring Overview&lt;/h2&gt;
&lt;p&gt;kill ring是被删除字符串的列表。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"some text"&lt;/span&gt; &lt;span class="s"&gt;"a different piece of text"&lt;/span&gt; &lt;span class="s"&gt;"yet more text"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按C-y字符串some text将插入当前缓冲区的光标位置。&lt;/p&gt;
&lt;p&gt;yank命令也可以用于复制文本。复制文本而不从缓冲区剪切文本，文本被复制一份放到kill ring中。&lt;/p&gt;
&lt;p&gt;有三个函数可以将文本从kill ring上恢复：yank，通常被绑定在C-y上；yank-pop，通常绑定在M-y；rotate-yank-pointer它使用了另外两个函数。&lt;/p&gt;
&lt;p&gt;这些函数通过变量kill-ring-yank-pointer指向kill ring。实际上yank和yank-pop插入文本的代码都是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;kill-ring-yank-pointer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了弄清楚yank和yank-pop是如何工作的，先需要了解kill-ring-yank-pointer变量和rotate-yank-pointer函数。&lt;/p&gt;
&lt;h2&gt;变量kill-ring-yank-pointer&lt;/h2&gt;
&lt;p&gt;kill-ring-yank-pointer是与kill-ring类似的变量。&lt;/p&gt;
&lt;p&gt;如果kill ring的内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"some text"&lt;/span&gt; &lt;span class="s"&gt;"a different piece of text"&lt;/span&gt; &lt;span class="s"&gt;"yet more text"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;kill-ring-yank-pointer将指向list第二个部分开始的list，kill-ring-yank-pointer是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"a different piece of text"&lt;/span&gt; &lt;span class="s"&gt;"yet more text"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面关于List实现的章节曾说过：计算机并不会为kill-ring和kill-ring-yank-pointer分别保存拷贝。两个Lisp变量指向同一片文本，下面是图示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---&amp;gt; |   |   |  --&amp;gt; |   |   |    |   |   |
          |___|___|----&amp;gt; |___|___|--&amp;gt; |___|___|--&amp;gt; nil
            |              |            |
            |              |            |
            |              |             --&amp;gt; "yet more text"
            |              |
            |               --&amp;gt; "a different piece of text
            |
             --&amp;gt; "some text"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量kill-ring和kill-ring-yank-pointer都是指针。kill-ring常被称作列表而不是说指向列表，而kill-ring-yank-pointer被称为指向列表。&lt;/p&gt;
&lt;p&gt;rotate-yank-pointer函数修改kill-ring-yank-pointer指向的元素；当指针指向元素的第二个元素为kill ring的结束位置时，它将自动指向kill ring的第一个元素。这也展示了如何将一个list转变为ring。rotate-yank-pointer函数虽然看起来不复杂，但它实际包含了很多细节。&lt;/p&gt;
&lt;h1&gt;循环和递归&lt;/h1&gt;
&lt;p&gt;Emacs Lisp有两种方式循环执行语句：使用while循环，或者使用递归。&lt;/p&gt;
&lt;h2&gt;while&lt;/h2&gt;
&lt;p&gt;while测试它的第一个参数的值，如果为false，解释器将不会执行语句的body部分。如果为true，解释器将执行语句的body部分，然后重新测试第一个参数的值，开始下一轮循环。&lt;/p&gt;
&lt;p&gt;while语句模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;true-or-false-test&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="shi-yong-whilexun-huan_1"&gt;使用while循环&lt;/h3&gt;
&lt;p&gt;如果while语句的true-or-false返回为true则body部分被执行。&lt;/p&gt;
&lt;p&gt;对while求值的返回值是true-or-false-test的值。有趣的是while循环执行时如果没有发生错误将返回nil或false，而不管循环执行了多少次。while语句执行成功也不会返回true。&lt;/p&gt;
&lt;h3 id="whilexun-huan-he-list"&gt;while循环和list&lt;/h3&gt;
&lt;p&gt;通常使用while循环来测试一个list是否包含了元素。如果有循环就执行，如果没有了循环就结束。这是一项重要的技术，下面将举例说明。&lt;/p&gt;
&lt;p&gt;最简单的测试list是否有元素的方法是执行这个list：如果没有元素，则会返回空list，()，它与nil或false同义。如果有元素则将返回这些元素。因为Emacs Lisp把任何蜚nil值当作true，如果把有元素的list作为while的判断条件，将使循环执行。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;empty-list&lt;/span&gt; &lt;span class="p"&gt;())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对empty-list求值将返回nil。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果把animals作为while循环的条件，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;
       &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当while检查它的第一个参数时，变量animals被执行，它将返回一个list。由于这个list不为nil，while将把这个值当作true。&lt;/p&gt;
&lt;p&gt;为了防止while进入无限循环，需要一些机制来逐渐的清空list。一个常用的方法就是将传递给while语句的list替换为原来的list的CDR。每次都使用cdr函数，这样list将变短，最后list将变为空的list。这时while循环结束。&lt;/p&gt;
&lt;p&gt;例如，上面的绑定到animals变量可以用下面的语句设置为原始list的CDR。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用while和cdr函数的模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;test-whether-list-is-empty&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;
  &lt;span class="nv"&gt;set-list-to-cdr-of-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="li-print-elements-of-list"&gt;例：print-elements-of-list&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;print-elements-of-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print each element of LIST on a line of its own."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;print-elements-of-list&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行上面的代码，回显区将显示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;giraffe

gazelle

lion

tiger
nil
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zai-xun-huan-zhong-shi-yong-zi-zeng-ji-shu-qi"&gt;在循环中使用自增计数器&lt;/h3&gt;
&lt;p&gt;模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;set-count-to-initial-value&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="nv"&gt;desired-number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="c1"&gt;; true-or-false-test&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;              &lt;span class="c1"&gt;; incrementer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="zi-zeng-ji-shu-de-li-zi"&gt;自增计数的例子&lt;/h4&gt;
&lt;p&gt;计算三角型中星号的数量，参数为层数，比如四层的三角型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;               *
              * *
             * * *
            * * * *
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-rows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;; Version with&lt;/span&gt;
                                    &lt;span class="c1"&gt;;   incrementing counter.&lt;/span&gt;
  &lt;span class="s"&gt;"Add up the number of pebbles in a triangle.&lt;/span&gt;
&lt;span class="s"&gt;The first row has one pebble, the second row two pebbles,&lt;/span&gt;
&lt;span class="s"&gt;the third row three pebbles, and so on.&lt;/span&gt;
&lt;span class="s"&gt;The argument is NUMBER-OF-ROWS."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;row-number&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nv"&gt;row-number&lt;/span&gt; &lt;span class="nv"&gt;number-of-rows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;row-number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;row-number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;row-number&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行的结果为10，第二行的结果为28。&lt;/p&gt;
&lt;h3 id="zai-xun-huan-zhong-shi-yong-zi-jian-ji-shu-qi_1"&gt;在循环中使用自减计数器&lt;/h3&gt;
&lt;p&gt;模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                    &lt;span class="c1"&gt;; true-or-false-test&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;          &lt;span class="c1"&gt;; decrementer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zi-jian-ji-shu-de-li-zi"&gt;自减计数的例子&lt;/h3&gt;
&lt;p&gt;仍以上面的三角型为例，计算1到任意层的星号总数。&lt;/p&gt;
&lt;p&gt;函数定义的第一版：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; First subtractive version.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-rows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Add up the number of pebbles in a triangle."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-pebbles-in-row&lt;/span&gt; &lt;span class="nv"&gt;number-of-rows&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number-of-pebbles-in-row&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;number-of-pebbles-in-row&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-of-pebbles-in-row&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number-of-pebbles-in-row&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，我们并不需要number-of-pebbles-in-row。&lt;/p&gt;
&lt;p&gt;当执行triangle函数时，符号number-of-rows将被绑定到初始的值上。这个数值可以在函数体内作为局部变量被修改，而不用担心会影响函数外部的值。这是Lisp中一个非常重要的特性；这意味着变量number-of-rows可以用于任何使用了number-of-pebbles-in-row的地方。&lt;/p&gt;
&lt;p&gt;函数第二版如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;; Second version.&lt;/span&gt;
  &lt;span class="s"&gt;"Return sum of numbers 1 through NUMBER inclusive."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单来说，正常情况下while循环包含三个部分：
 1. 在循环执行正确的次数后，while循环的判断语句将返回false。
 2. 被循环执行的语句，它将返回需要的值。
 3. 修改true-or-false-test返回值的语句，以便循环在执行正确的次数后停止。&lt;/p&gt;
&lt;h2&gt;使用dolist和dotimes节约时间&lt;/h2&gt;
&lt;p&gt;dolist和dotimes都是为循环提供的宏。在某些情况下比直接使用while循环简单一些。&lt;/p&gt;
&lt;p&gt;dolist与在while中循环取list的CDR的方法类似，它在每次循环中自动取CDR截短list，并将截短后的list的CAR绑定到它的第一个参数上。&lt;/p&gt;
&lt;p&gt;dotimes循环可以指定循环的次数。&lt;/p&gt;
&lt;h3 id="dolisthong"&gt;dolist宏&lt;/h3&gt;
&lt;p&gt;举例来说，如果你想将一个list倒序排列，可以用reverse函数，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;reverse&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里演示了如何使用while循环实现倒序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;reverse-list-with-while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Using while, reverse the order of LIST."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; make sure list starts empty&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;reverse-list-with-while&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以用dolist宏实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;reverse-list-with-dolist&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Using dolist, reverse the order of LIST."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; make sure list starts empty&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dolist&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;element&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;element&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;reverse-list-with-dolist&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个例子中，使用已存的reverse函数当然是最好的。第一个使用while循环的例子里。while先检查list是否有元素；如果有，它将list的第一个元素添加到另一个list（它的第一个元素是nil）的第一个位置。由于添加元素的顺序是反的，因此原来的list被倒序排列了。&lt;/p&gt;
&lt;p&gt;在使用while循环的语句中，(setq list (cdr list))语句截短了list，因此while循环最后停止了。在循环体中用cons语句创建了一个新的list。&lt;/p&gt;
&lt;p&gt;dolist语句与while语句类似，dolist宏自动完成了在while语句中所写的一些工作。&lt;/p&gt;
&lt;p&gt;while循环与dolist实现的两个方法不同之处在于dolist自动截短了list。'CDRs down the list'。并且它自动将CAR截短了的list的CAR赋给dolist的第一个参数。&lt;/p&gt;
&lt;h3 id="dotimeshong"&gt;dotimes宏&lt;/h3&gt;
&lt;p&gt;dotimes宏与dolist类似，但它可以指定循环次数。&lt;/p&gt;
&lt;p&gt;dotimes的第一个参数是每次循环的计数器，第二个参数是循环次数，第三个参数是返回值。&lt;/p&gt;
&lt;p&gt;举例来说，下例将number绑定到从0开始的数字，但不包含3，然后构造出一个包含3个数字的list。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;; otherwise a value is a void variable&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="nv"&gt;value&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="c1"&gt;;=&amp;gt; (2 1 0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dotimes的返回值是value。&lt;/p&gt;
&lt;p&gt;下面是一个使用defun和dotimes实现的triangle函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-using-dotimes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-rows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Using dotimes, add up the number of pebbles in a triangle."&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;; otherwise a total is a void variable&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;dotimes&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="nv"&gt;number-of-rows&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-using-dotimes&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;递归&lt;/h2&gt;
&lt;p&gt;递归函数使用不同的参数来调用自身。尽管执行的代码是相同的，但它们不是在同一线程执行。（不是同一个实例）&lt;/p&gt;
&lt;h3 id="di-gui-de-zu-cheng"&gt;递归的组成&lt;/h3&gt;
&lt;p&gt;一个递归函数通常包含下面三个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个true-or-false-test决定是否再次调用函数，在这里被称为do-again-test。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数名称。当这个函数被调用时，一个新的函数实例产生了，并被分配任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个函数语句，它在每次执行时返回不同的值。这里称为next-step-expression。这样，传递到新的函数实例的参数前与传递给前一个函数实例的参数不同。这将使得在执行了正确有循环次数后，条件语句do-again-test的值为false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用递归函数的简单模式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;name-of-recursive-function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;argument-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;do-again-test&lt;/span&gt;
    &lt;span class="nv"&gt;body...&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;name-of-recursive-function&lt;/span&gt;
         &lt;span class="nv"&gt;next-step-expression&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归函数每次执行时将产生一个新的函数实例，参数告诉了实例要做什么。一个参数被绑定到next-step-expression。每个实例执行时都有一个不同的next-step-expression。&lt;/p&gt;
&lt;p&gt;next-step-expression的值被用于do-again-text。&lt;/p&gt;
&lt;p&gt;next-step-expression的返回值被传递给新的函数实例，由它来决定是否停止或继续。next-step-expression被设计为在不需要循环后它能使do-again-test返回false。&lt;/p&gt;
&lt;p&gt;do-again-test有时被称为停止条件（stop condition），因为它将在测试值为false时停止循环。&lt;/p&gt;
&lt;h3 id="zai-listshang-shi-yong-di-gui"&gt;在list上使用递归&lt;/h3&gt;
&lt;p&gt;下面的例子使用了递归打印list中的各个元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print each element of LIST on a line of its own.&lt;/span&gt;
&lt;span class="s"&gt;Uses recursion."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;                              &lt;span class="c1"&gt;; do-again-test&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;              &lt;span class="c1"&gt;; body&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt;     &lt;span class="c1"&gt;; recursive call&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;                 &lt;span class="c1"&gt;; next-step-expression&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="yong-di-gui-dai-ti-ji-shu-qi"&gt;用递归代替计数器&lt;/h3&gt;
&lt;p&gt;前面章节说过的triangle函数可以用递归修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-recursively&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return the sum of the numbers 1 through NUMBER inclusive.&lt;/span&gt;
&lt;span class="s"&gt;Uses recursion."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                    &lt;span class="c1"&gt;; do-again-test&lt;/span&gt;
      &lt;span class="mi"&gt;1&lt;/span&gt;                               &lt;span class="c1"&gt;; then-part&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;                         &lt;span class="c1"&gt;; else-part&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-recursively&lt;/span&gt;          &lt;span class="c1"&gt;; recursive call&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;               &lt;span class="c1"&gt;; next-step-expression&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-recursively&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zai-di-gui-zhong-shi-yong-cond"&gt;在递归中使用cond&lt;/h3&gt;
&lt;p&gt;前一节中的triangle-recursively使用了if。它也可以使用cond，cond是conditional的缩写。&lt;/p&gt;
&lt;p&gt;尽管cond不像if那样使用得很普遍，但它还是比较常见的。&lt;/p&gt;
&lt;p&gt;使用cond的模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
 &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;body部分是一连串的list。&lt;/p&gt;
&lt;p&gt;更完整的模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;first-true-or-false-test&lt;/span&gt; &lt;span class="nv"&gt;first-consequent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;second-true-or-false-test&lt;/span&gt; &lt;span class="nv"&gt;second-consequent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;third-true-or-false-test&lt;/span&gt; &lt;span class="nv"&gt;third-consequent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当解释器执行cond语句时，它先执行body区的第一个语句的第一个元素。&lt;/p&gt;
&lt;p&gt;如果true-or-false-test返回nil，则那个list的其它部分将不会执行。程序转到list串中的下一个list。当一个true-or-false-test的返回值不为nil，则那条语句的其它部分将会执行。如果list串包含多个list，则它们依次执行并返回最后一个语句的值被返回。&lt;/p&gt;
&lt;p&gt;如果没有一个true-or-false-test的返回值为true，则cond语句返回nil。&lt;/p&gt;
&lt;p&gt;使用cond实现的triangle函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-using-cond&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-using-cond&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="di-gui-mo-shi"&gt;递归模式&lt;/h3&gt;
&lt;p&gt;下面是3个常用的递归模式。&lt;/p&gt;
&lt;h4 id="every"&gt;every&lt;/h4&gt;
&lt;p&gt;在every模式的递归中，动作将在list的每个元素上执行。&lt;/p&gt;
&lt;p&gt;基本模型如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果list为空，则返回nil。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则，在list的首元素（list的CAR）上执行动作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过递归在list的其它部分（CDR）上执行相同的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这步是可选的使用cons将正在操作的元素和已经操作过的元素列表合并。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;square-each&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Square each of a NUMBERS LIST, recursively."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;; do-again-test&lt;/span&gt;
      &lt;span class="no"&gt;nil&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;square-each&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt; &lt;span class="c1"&gt;; next-step-expression&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;square-each&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;=&amp;gt; (1 4 9)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果number-list为空，则什么也不做。如果它有内容，则通过递归构造一个list各个元素乘方值的list。&lt;/p&gt;
&lt;p&gt;前面介绍过的print-elements-recursively函数，是另一个every模式的递归，不同的是这里使用了cons合并元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;gazelle&lt;/span&gt; &lt;span class="nv"&gt;giraffe&lt;/span&gt; &lt;span class="nv"&gt;lion&lt;/span&gt; &lt;span class="nv"&gt;tiger&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print each element of LIST on a line of its own.&lt;/span&gt;
&lt;span class="s"&gt;Uses recursion."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;                              &lt;span class="c1"&gt;; do-again-test&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;              &lt;span class="c1"&gt;; body&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt;     &lt;span class="c1"&gt;; recursive call&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nf"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;                 &lt;span class="c1"&gt;; next-step-expression&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;print-elements-recursively&lt;/span&gt; &lt;span class="nv"&gt;animals&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;print-elements-recursively函数的处理流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果list为空，不执行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果list含有至少一个元素，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在list的首元素（CAR）上执行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过递归调用在其它的元素上执行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="accumulate"&gt;accumulate&lt;/h4&gt;
&lt;p&gt;accumulate递归模式，在每个元素上都执行动作，动作的执行结果与对下一个元素执行操作的结果进行累积。&lt;/p&gt;
&lt;p&gt;这与在every模式中使用cons类似，只是不是使用cons，而是使用其它的方式合并。&lt;/p&gt;
&lt;p&gt;工作模式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果list为空，返回0或其它常量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则，在list的CAR上执行动作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用+或其它操作合并当前操作的元素和已经操作过的元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归方式在list的其它部分执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;add-elements&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Add the elements of NUMBERS-LIST together."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-elements&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-elements&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="c1"&gt;;=&amp;gt; 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="keep"&gt;keep&lt;/h4&gt;
&lt;p&gt;在keep递归模式中，list中的每个元素被测试，如果被操作的元素符合要求或者对元素的计算结果符合要求则保存该元素。&lt;/p&gt;
&lt;p&gt;这与every模式也很类似，只是在这里如果元素不符合要求则被忽略。&lt;/p&gt;
&lt;p&gt;这种模式的三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果list为空，则返回nil&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果list的CAR符合要求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在元素上执行操作，并使用cons合并它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归调用处理list中的其它元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果list的CAR不符合要求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;忽略这个元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归调用处理list中的其它元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;keep-three-letter-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Keep three letter words in WORD-LIST."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
   &lt;span class="c1"&gt;;; First do-again-test: stop-condition&lt;/span&gt;
   &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

   &lt;span class="c1"&gt;;; Second do-again-test: when to act&lt;/span&gt;
   &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;symbol-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
    &lt;span class="c1"&gt;;; combine acted-on element with recursive call on shorter list&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;keep-three-letter-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

   &lt;span class="c1"&gt;;; Third do-again-test: when to skip element;&lt;/span&gt;
   &lt;span class="c1"&gt;;;   recursively call shorter list with next-step expression&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;keep-three-letter-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;word-list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;keep-three-letter-words&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;one&lt;/span&gt; &lt;span class="nv"&gt;two&lt;/span&gt; &lt;span class="nv"&gt;three&lt;/span&gt; &lt;span class="nv"&gt;four&lt;/span&gt; &lt;span class="nv"&gt;five&lt;/span&gt; &lt;span class="nv"&gt;six&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="c1"&gt;;=&amp;gt; (one two six)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="wu-yan-shi-de-di-gui_1"&gt;无延时的递归&lt;/h3&gt;
&lt;p&gt;这部分讲解了如何将递归函数拆分成多个函数部分（比如：初始化函数、辅助函数），减少递归函数body部分的判断，使得递归函数本身只需要处理好递归操作，提高了递归函数的执行速度。&lt;/p&gt;
&lt;p&gt;这部分显得过于详细，这里省略了该部分。&lt;/p&gt;
&lt;h1&gt;正则表达式查询&lt;/h1&gt;
&lt;p&gt;在Emacs中正则表达式查询使用得很广泛。在forward-sentence和forward-paragraph中使用了正则表达式查找定位。正则表达式'regular expression'常被写作'regexp'。&lt;/p&gt;
&lt;h2&gt;sentence-end的正则表达式&lt;/h2&gt;
&lt;p&gt;符号sentence-end被绑定到匹配名末的正则式上。&lt;/p&gt;
&lt;p&gt;句末通常是用一个句号、问号或者叹号结束的。那么这个正则表达式应该包含下面的字符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[.?!]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，在有些时候句号、问号或叹号也有可能在某个语句的中间，我们并不想在使用forward-sentence的时候跳转到这些符号上去。&lt;/p&gt;
&lt;p&gt;习惯上，你可能会在每个句子后面添加空格或者tab等等。我们可以用下面的表达式来匹配：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;\\($\\| \\|  \\)
       ^   ^^
      TAB  SPC
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;$标明行末，括号前面的两个反斜线和竖线前面的两个反斜线中第一个反斜线是转义符。&lt;/p&gt;
&lt;p&gt;语句的结束位置也可能跟了一个或者多个回车，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[
]*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;星号表明可以有零个或者多个回车。&lt;/p&gt;
&lt;p&gt;一个语句的结束位置可能不只是句号、问号或叹号。它也可能是：一个回括号或其它：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[]\"')}]*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个表达式中，第一个&lt;code&gt;]&lt;/code&gt;是表达式的第一个字符；第二个字符是&lt;code&gt;"&lt;/code&gt;，综前面加了一个转义符。最后三个字符是&lt;code&gt;',),}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;前面的表达式都是用于匹配一个语句的，如果我们对sentence-end求值，将返回下面的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sentence-end
     =&amp;gt; "[.?!][]\"')}]*\\($\\|     \\|  \\)[
]*"
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;re-search-forward函数&lt;/h2&gt;
&lt;p&gt;re-search-forward函数与search-forward函数很相似。&lt;/p&gt;
&lt;p&gt;re-search-forward函数搜索一个正则表达式。如果查找成功，它将point设置在匹配目标的最后一个字符的后面。如果是向后查找，它将point设置在匹配目标的第一个字符的前面。&lt;/p&gt;
&lt;p&gt;与search-forward一样，re-search-forward函数接收四个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一个参数是要查找的正则表达式。表达式是一个被引号包括的字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个参数是可选参数，限制搜索的范围，它是当前缓冲区中的某个位置（point）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个可选参数指定搜索失败时如何处理：如果第三个参数为nil，则导致函数在搜索失败时显示错误信息；其它值将使函数失败时返回nil，搜索成功时返回t。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，用于指定重复次数。负数表示重复的向后搜索。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;re-search-forward使用模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"regular-expression"&lt;/span&gt;
                &lt;span class="nv"&gt;limit-of-search&lt;/span&gt;
                &lt;span class="nv"&gt;what-to-do-if-search-fails&lt;/span&gt;
                &lt;span class="nv"&gt;repeat-count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二、三、四个参数是可选的。如果你想传递给最后两个参数，则必须也给前面的参数全传值。否则解释器将出错。&lt;/p&gt;
&lt;p&gt;在forward-sentence函数中，sentence-end正则表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"[.?!][]\"')}]*\\($\\|  \\|  \\)[
]*"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这限制了查询范围只到当前段落的结束位置（一个句子不可能超过段落）。如果查询失败，函数将返回nil；查询的次数可以由传递给forward-sentence函数的参数来提供。&lt;/p&gt;
&lt;h2&gt;forward-sentence函数&lt;/h2&gt;
&lt;p&gt;这个命令将光标移到下一句，是在Emacs Lisp中使用正则表达式的很好的例子。实际这个函数看起来很长很复杂；这是因为函数被设计为能向前也能向后移动。该函数通常被绑定到M-e上。&lt;/p&gt;
&lt;h3 id="forward-sentenceliao-han-shu-ding-yi"&gt;forward-sentence了函数定义&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;forward-sentence&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Move forward to next sentence-end.  With argument, repeat.&lt;/span&gt;
&lt;span class="s"&gt;With negative argument, move backward repeatedly to sentence-beginning.&lt;/span&gt;
&lt;span class="s"&gt;Sentence ends are identified by the value of sentence-end&lt;/span&gt;
&lt;span class="s"&gt;treated as a regular expression.  Also, every paragraph boundary&lt;/span&gt;
&lt;span class="s"&gt;terminates sentences as well."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;par-beg&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start-of-paragraph-text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-backward&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nv"&gt;sentence-end&lt;/span&gt; &lt;span class="s"&gt;"[^ \t\n]"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;par-beg&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;match-end&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;par-beg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;par-end&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end-of-paragraph-text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;sentence-end&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;skip-chars-backward&lt;/span&gt; &lt;span class="s"&gt;" \t\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数看起来太长了，最好是先弄清楚它的骨架，然后再了解细节。我们先从最左边开始看：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;forward-sentence&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;body-of-while-loop&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nv"&gt;body-of-while-loop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样看起来简单多了。函数定义由文档字符串，一个interactive语句，一个or语句和while循环组成。&lt;/p&gt;
&lt;p&gt;依次来看看各个部分。&lt;/p&gt;
&lt;p&gt;文档简单易懂。&lt;/p&gt;
&lt;p&gt;interactive函数有一个"p"参数。这表示处理前缀参（C-u）。如果没有传递这个参数将被设置为1。如果在调用forward-sentence时，不是使用的交互式模式并且没有带参数，arg将被设置为nil。&lt;/p&gt;
&lt;h3 id="whilexun-huan-bu-fen"&gt;while循环部分&lt;/h3&gt;
&lt;p&gt;or语句后面有两个while循环。第一个while循环的true-or-false-test测试前缀参数是否为负数。这决定是否向后查询。循环体与第二个while的循环体类似，但不完全相同。我们跳过第一个while循环，集中看第二个循环&lt;/p&gt;
&lt;p&gt;第二个循环将向前移动point。代码骨架如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;            &lt;span class="c1"&gt;; true-or-false-test&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="nv"&gt;varlist&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;true-or-false-test&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;then-part&lt;/span&gt;
      &lt;span class="nv"&gt;else-part&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;     &lt;span class="c1"&gt;; while loop decrementer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个while循环是一个递减循环。它的true-or-false-test检查计数器（arg）是否大于0；并每次循环中将计数器减1。&lt;/p&gt;
&lt;p&gt;如果没有前缀参数传递给forward-sentence，arg将被设置为1，while循环将只运行一次。&lt;/p&gt;
&lt;p&gt;while循环体如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;par-end&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end-of-paragraph-text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;sentence-end&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;skip-chars-backward&lt;/span&gt; &lt;span class="s"&gt;" \t\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;let语句创建了一个局部变量par-end。前面我们看过，这局部变量用于限制正则表达式搜索的范围。如果它没有找到段落中的语句的结束位置，它将段落结束位置前停止搜索。&lt;/p&gt;
&lt;p&gt;首先，我们来研究一下par-end是如何被绑定到段落结束位置的。程序使用了let语句将下面语句的结果赋给了par-end变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end-of-paragraph-text&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个语句中，(end-of-paragraph-text)将point移动到段落的结束位置，(point)返回当前的point，然后用save-excursion恢复point到原来的位置。因此，let将par-end绑定到了save-excursion的返回值，即段落的结束位置。（(end-of-paragraph-text)函数使用了forward-paragraph函数）&lt;/p&gt;
&lt;p&gt;接下来Emacs继续执行let的body部分，一个if语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;sentence-end&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;; if-part&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;skip-chars-backward&lt;/span&gt; &lt;span class="s"&gt;" \t\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;              &lt;span class="c1"&gt;; then-part&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;par-end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;                        &lt;span class="c1"&gt;; else-part&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="zheng-ze-biao-da-shi-cha-xun"&gt;正则表达式查询&lt;/h3&gt;
&lt;p&gt;re-search-forward函数根据sentence-end定义的正则表达式查找名末。如果找到，re-search-forward函数将做两件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;re-search-forward函数将point移到找到的目标的结束位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;re-search-forward函数返回true。这个值被if接收，表明查找成功。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当查找成功后，if语句执行then部分，这部分表达式&lt;code&gt;(skip-chars-backward "\t\n")&lt;/code&gt;这个语句向后移过任何空白字符直到遇到一个可打印字符，然后把point设置在这个字符的后面。&lt;/p&gt;
&lt;p&gt;如果re-search-forward函数找不到句末位置，则函数返回false。false将使if语句执行它的第三个参数，(goto-char par-end)：它将point移到段落末尾。&lt;/p&gt;
&lt;h2&gt;forward-paragraph函数&lt;/h2&gt;
&lt;p&gt;forward-paragraph函数将point移到段落结束位置。通常被绑定到M-}上，它使用了大量重要的函数，包括：let*，match-beginning和looking-at。&lt;/p&gt;
&lt;p&gt;forward-paragraph函数定义比forward-sentence的长很多，因为它工作于段落上，段落的每行可能以是填充前缀开头。&lt;/p&gt;
&lt;p&gt;填充前缀是放在行的开头，通常是由一些重复的字符组成的字符串。比如，在Lisp代码中通常在一大段注释的每行前面添加;;;。在文本模式下(Text mode)，四个空格标明了一个段落的缩进。&lt;/p&gt;
&lt;p&gt;这意味着在查找段落时，需要查找那些最左边的列有填充前缀的行。&lt;/p&gt;
&lt;p&gt;有些情况下需要忽略这些前缀，特别是在使用空行来分隔段落时。这更增加了这个函数的复杂性。&lt;/p&gt;
&lt;h3 id="forward-paragraphhan-shu-ding-yi-de-gu-jia"&gt;forward-paragraph函数定义的骨架&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;forward-paragraph&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kp"&gt;&amp;amp;optional&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt;
      &lt;span class="nv"&gt;varlist&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;; backward-moving-code&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;; forward-moving-code&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一部分是常见部分：参数列表，包含一个可选参数。而后是文档字符串。&lt;/p&gt;
&lt;p&gt;interactive的参数p表示可以处理前缀参数（C-u）。这是一个数字，用于设置执行的次数。or语句处理没有传递参数时的情况。&lt;/p&gt;
&lt;h3 id="letyu-ju"&gt;let*语句&lt;/h3&gt;
&lt;p&gt;符号let*不是let。&lt;/p&gt;
&lt;p&gt;let*与let类似，不同之处在于Emacs将依次给各个变量赋值，给后面的变量赋值语句可以使用前面已经赋值的变量。&lt;/p&gt;
&lt;p&gt;在这个let*语句中，Emacs设置了两个变量：fill-prefix-regexp和paragraph-separate。变量fill-paragraph-separate的值，依赖于fill-prefix-regexp的值。&lt;/p&gt;
&lt;p&gt;依次来看，符号fill-prefix-regexp的值被设置为下面的list的返回值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;paragraph-ignore-fill-prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;regexp-quote&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在前面学习kill-new函数时，我们知道and将执行传递给它的每个参数直到有一个参数的返回值为nil，这种情况下and语句返回nil；如果没有参数返回nil，and语句将返回最后一个参数的值。简单来说，and语句在所有参数都为true时返回true。&lt;/p&gt;
&lt;p&gt;变量fill-prefix-regexp只有在上面四个语句都为true时，才会设置为一个非nil值，否则fill-prefix-regexp将被设置为nil。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;fill-prefix&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当这个变量被执行时，如果没有填充前缀，变量返回nil。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句检查填充字符串是否为一个空字符串。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;paragraph-ignore-fill-prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果paragraph-ignore-fill-prefix设了值（比如t），这个表达式将返回nil。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;regexp-quote&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是and语句的最后一个语句。如果and中所有的语句都为true，这条语句的返回值将作为and语句的返回值，这个返回值被设置到变量fill-prefix-regexp。&lt;/p&gt;
&lt;p&gt;and语句的将fill-prefix-regexp设置为被regexp-quote函数修改过的fill-prefix上。regexp-quote函数读取一个字符串并返回能精确匹配这个字符串的正则表达式。这意味着fill-prefix-regexp将被设置为通匹配填充前缀的正则表达式。&lt;/p&gt;
&lt;p&gt;let*语句设置的第二个局部变量是paragraph-separate。它被设置为下面语句的返回值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;
            &lt;span class="s"&gt;"\\|^"&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt; &lt;span class="s"&gt;"[ \t]*$"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句显示了let*与let的区别。if语句的true-or-false-test检查fill-prefix-regexp是否为nil。&lt;/p&gt;
&lt;p&gt;如果fill-prefix-regexp没有值，Emacs将执行if语句的else部分，将paragraph-separate设置为它的原始值。（paragraph-separate是一个匹配段落分隔的正则表达式）&lt;/p&gt;
&lt;p&gt;如果fill-prefix-regexp有值，Emacs将执行if语句的then部分并将paragraph-separate设置为包含fill-prefix-regepx的正则表达式。&lt;/p&gt;
&lt;p&gt;特别的是，paragraph-separate被设置为由它的原始值与fill-prefix-regexp组成的新值上。&lt;code&gt;^&lt;/code&gt;表示fill-prefix-regexp必须在行首，行末可以是空白字符，这由&lt;code&gt;"[ \t]*$"&lt;/code&gt;来定义。&lt;code&gt;\\|&lt;/code&gt;表示"或"关系。&lt;/p&gt;
&lt;p&gt;接下来进入let&lt;em&gt;语句的body部分。let&lt;/em&gt;语句的第一部分处理给定的参数为负数，需要向后移动的情况。我们跳过这一部分。&lt;/p&gt;
&lt;h3 id="whilexun-huan-zhong-de-xiang-qian-yi-dong"&gt;while循环中的向前移动&lt;/h3&gt;
&lt;p&gt;let*的body的第二部分处理向前移动。由于个while循环执行arg参数指定的循环次数。通常情况下参数被设置为1，循环只执行一次，光标向前移动一个段落。&lt;/p&gt;
&lt;p&gt;这个部分共处理了三种情况：当point在段落中间时，当point在有填充前缀的段落内部时，当point在没有段落前缀的段落内部时。&lt;/p&gt;
&lt;p&gt;while循环部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

  &lt;span class="c1"&gt;;; between paragraphs&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="c1"&gt;;; within paragraphs, with a fill prefix&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
      &lt;span class="c1"&gt;;; There is a fill prefix; it overrides paragraph-start.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;;; within paragraphs, no fill prefix&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;paragraph-start&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;match-beginning&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们马上就可以看出这是一个递减的while循环，使用了&lt;code&gt;(setq arg (1- arg))&lt;/code&gt;作为递减语句。&lt;/p&gt;
&lt;p&gt;循环体包含了三个语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; between paragraphs&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;
    &lt;span class="nv"&gt;body-of-while&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;; within paragraphs, with fill prefix&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;true-or-false-test&lt;/span&gt;
    &lt;span class="nv"&gt;then-part&lt;/span&gt;

&lt;span class="c1"&gt;;; within paragraphs, no fill prefix&lt;/span&gt;
  &lt;span class="nv"&gt;else-part&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当解释器执行while循环体时，第一件事就是执行(begion-of-line)语句将point移到行首位置。接下来是一个内部的while循环。这个while循环被设计为将光标从段落间的空白部分移出。最后是一个if语句将point移到段落的结束位置。&lt;/p&gt;
&lt;h3 id="duan-luo-zhi-jian"&gt;段落之间&lt;/h3&gt;
&lt;p&gt;首先，我们来看内部的while循环。这个循环处理point位于段落之间的情况；它使用了三个新的函数：prog1, eobp 和 looking-at。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;prog1与progn类似，但是progn1返回的是它的第一个参数的值。（progn返回它的最后一个参数的值）后面的语句也将被执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;eobp是End Of Buffer P的缩写，检查point是否在缓冲区的结束位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;looking-at函数检查point后面的文本是否与传递给它的正则表达式参数匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个while循环部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个没有循环体的while循环！true-or-false-test部分如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;prog1的第一个参数是一个and语句。它检查point是否到了缓冲区的结束位置，也检查point后面的文本是否与正则表达式paragraph-separate匹配。&lt;/p&gt;
&lt;p&gt;如果光标不在缓冲区结束位置且光标后面的文本是一个段落分隔，则and语句返回true。执行完and语句后，解释器执行prog1的第二个参数forward-line。它将光标向前移动一行。由于prog1的返回值是它的第一个参数，因此while循环将在point不在缓冲区结束位置或位于段落之间时继续执行。最后，point将在and语句测试为false时被移到一个新段落，由于这时forward-line已经被执行了。这意味着point已经从段落之间的位置移到了段落中，它停留在新段落第二行的开始位置。&lt;/p&gt;
&lt;h3 id="duan-luo-nei-bu"&gt;段落内部&lt;/h3&gt;
&lt;p&gt;外部while循环的第二个部分是一个if语句。解释器将在fill-prefix-regexp不为nil时执行它的then部分，如果fill-prefix-regexp为nil，它将执行else部分（当段落没有填充前缀时）。&lt;/p&gt;
&lt;h3 id="mei-you-tian-chong-qian-zhui"&gt;没有填充前缀&lt;/h3&gt;
&lt;p&gt;代码包含了一个if语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;paragraph-start&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;match-beginning&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它查找一个正则表达式，直到下一个段落的开始位置，如果找到，就将point设置到那时在，如果下一个段落的开始位置未找到，则将point移到当前缓冲区可访问区域的结束位置。&lt;/p&gt;
&lt;p&gt;这段代码里只有match-beginning比较陌生。它返回一个数字，这个数字标明了上一个正则表达式所匹配位置。&lt;/p&gt;
&lt;p&gt;在这里使用match-beginning函数是由于forward search的一个特性：forward search查找成功时不管理普通查找还是正则表达式查找，它都会将point移到查找到的文本的结束位置。在这里，这样操作将使point移动到下一个段落的开始位置，而不是当前段落的结束位置。而这两个位置可能是不同的，因为段落之间可能有空行&lt;/p&gt;
&lt;p&gt;当传的参数为0时，match-beginning函数返回的位置是最近一次匹配正则表达式的文本的开始位置。在这里，最近一次使用正则表达式查找的就是paragraph-start，因此match-begnning返回匹配的开始位置，而不是匹配的结束位置。这个开始位置即段落的结束位置。&lt;/p&gt;
&lt;h3 id="you-tian-chong-qian-zhui-shi-de-qing-kuang"&gt;有填充前缀时的情况&lt;/h3&gt;
&lt;p&gt;前面讨论了if语句的else部分。如果if语句检测到有填充前缀，它将执行then部分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当下面三个条件都为true时，它将point向前移动一行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;point不是位于缓冲区结束位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;point后面的文本不是段落分隔符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;point后面的文本与填充前缀的正则表达式匹配&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;在向前移动时，forward-paragraph函数执行了下面三个操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将point移到行首&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;忽略段落之间的行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查是否有填充前缀，如果有：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向前移动一行直到该行不为段落分隔行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有填充前缀：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查找下个段落的开始位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转到下个段落的开始位置，也就是前一个段落的结束位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者转到缓冲区的结束的位置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是格式化过的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"p"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt; &lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;paragraph-ignore-fill-prefix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;regexp-quote&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;
                    &lt;span class="s"&gt;"\\|^"&lt;/span&gt;
                    &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
                    &lt;span class="s"&gt;"[ \t]*$"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="nv"&gt;omitted-backward-moving-code&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;; forward-moving-code&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eobp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;; then-part&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;not&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;paragraph-separate&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;looking-at&lt;/span&gt; &lt;span class="nv"&gt;fill-prefix-regexp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                                  &lt;span class="c1"&gt;; else-part: the inner-if&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="nv"&gt;paragraph-start&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;match-beginning&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-max&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;        &lt;span class="c1"&gt;; decrementer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的代码不光有向前移动的代码，也包括了向后移动的代码。&lt;/p&gt;
&lt;p&gt;在Emacs中可以用C-h f(describe-function)和函数名来查看整个函数。&lt;/p&gt;
&lt;p&gt;可以使用M-.(find-tag)并输入函数名来查找函数定义。&lt;/p&gt;
&lt;h2&gt;创建自己的TAGS文件&lt;/h2&gt;
&lt;p&gt;M-.命令可以查看函数源码，变量或其它的源码。这个函数依赖于tags表告诉他该到哪里查找源码。&lt;/p&gt;
&lt;p&gt;经常会需要自己创建tags表。tags表被称为TAGS文件。&lt;/p&gt;
&lt;p&gt;可以用Emacs发行版中的etags程序来创建TAGS文件。通常etags不是Emacs Lisp函数，而是一个C程序。&lt;/p&gt;
&lt;p&gt;创建TAGS文件前，先进入要创建这个文件的目录。在Emacs中可以用M-x cd命令，或者直接访问某个目录C-x d(dired)。然后运行编译命令并执行etags *.el。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x compile RET etags *.el RET
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;etags命令支持通配符。如果你有两个目录，你可以使用一个TAGS文件，输入&lt;code&gt;*.el ../elisp/*.el&lt;/code&gt;，在这里&lt;code&gt;../elisp/&lt;/code&gt;是第二个目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x compile RET etags *.el ../elisp/*.el RET
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x compile RET etags --help RET
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看etags支持的选项列表。&lt;/p&gt;
&lt;p&gt;etags程序支持20多种语言，包括：Emacs Lisp、Common Lisp、Scheme、C、C++、Ada、Fortran、Java、Latex、Pascal、Perl、Python、Texinfo、makefiles等等。程序没有开关指定语言；它会根据输入的文件名和文件内容来识别语言的种类。&lt;/p&gt;
&lt;p&gt;使用：&lt;code&gt;M-x locate RET TAGS RET&lt;/code&gt;Emacs将列出你的所有TAGS文件的完整路径。&lt;/p&gt;
&lt;p&gt;如果你想访问你创建的TAGS文件，可以使用&lt;code&gt;M-x visit-tags-table&lt;/code&gt;命令。&lt;/p&gt;
&lt;h3 id="chuang-jian-emacsyuan-ma-de-tagswen-jian"&gt;创建Emacs源码的TAGS文件&lt;/h3&gt;
&lt;p&gt;GNU Emacs的源码中的Makefile文件包含了复杂的etags命令，它创建，合并所有Emacs源码中的tags放到src顶层目录中的一个TAGS文件中。&lt;/p&gt;
&lt;p&gt;你可以在Emacs源码的顶层目录中执行下面的命令来创建TAGS文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x compile RET make tags RET
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;while
循环执行直到传递给它的第一个参数为true。然后返回nil。
例：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;format&lt;/span&gt; &lt;span class="s"&gt;"foo is %d.\n"&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

     &lt;span class="c1"&gt;;=&amp;gt;      foo is 2.&lt;/span&gt;
             &lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="mi"&gt;1.&lt;/span&gt;
             &lt;span class="no"&gt;nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（insert函数插入它的参数到point所在的位置；format函数格式化它的参数；&lt;code&gt;\n&lt;/code&gt;产生新行。
）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;re-search-forward&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找一个正则表达式，如果找到了就将point设置到目标位置的后面。&lt;/p&gt;
&lt;p&gt;与search-forward类似，它接收四个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;要查找的正则表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，限制查询范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，查找失败时如何处理，返回nil或者显示错误信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选参数，查找的重复数次；如果为负数，则向后查找&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;let*&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将变量值绑定到各个变量上，并执行其它的参数，返回最后一个的值。在设置变量时，可以使用前面已经设置过的局部变量。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let*&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;foo&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;bar&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="ss"&gt;`bar'&lt;/span&gt;&lt;span class="s"&gt; is %d."&lt;/span&gt; &lt;span class="nv"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; `bar' is 21.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;match-beginning&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回上一次正则表达式查找时查找的文本的开始位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;looking-at&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果point后面的文本与函数的参数（是一个正则表达式）匹配则返回t。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eobp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果point在可访问的缓冲区的结束位置则返回t。如果缓冲区未被narrowed，则可访问缓冲区结束位置是缓冲区的结束位置。如果缓冲区被narrowed，则结束位置为narrowed部分的结束位置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prog1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依次执行各个参数并返回第一个参数的值。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;prog1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;计数：重复和正则表达式&lt;/h1&gt;
&lt;p&gt;重复执行和正则表达式是Emacs Lisp中非常强大的工具。这章讲解使用while循环和递归结合正则表达式进行查找进行字数统计。&lt;/p&gt;
&lt;h2&gt;字数统计&lt;/h2&gt;
&lt;p&gt;标准的Emacs发行版中包含了一个统计region中行数的函数。但没有统计字数的函数。&lt;/p&gt;
&lt;h2&gt;count-words-region 函数&lt;/h2&gt;
&lt;p&gt;字数统计函数可以统计行、段落、region、或者整个缓冲区。到覆盖范围该多大？Emacs的鼓励使用弹性的方式。可以将函数设计为处理region。这样即使需要统计整个缓冲区，也可以先用C-x h(mark-whole-buffer)先选定整个缓冲区。&lt;/p&gt;
&lt;p&gt;统计字数是一个重复的动作：从region的开始位置，开始统计第一个词，然后是第二个，然后第三个，如此继续直到缓冲区的结束位置。这意味着单词统计的工作适合于使用递归或者while循环。&lt;/p&gt;
&lt;h3 id="she-ji-count-words-regionhan-shu"&gt;设计count-words-region函数&lt;/h3&gt;
&lt;p&gt;首先，我们将使用while循环实现单词统计，然后是递归。当然，这个命令需要交互。&lt;/p&gt;
&lt;p&gt;交互式函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;name-of-function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;argument-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;interactive-expression...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们所要做的就是填空。&lt;/p&gt;
&lt;p&gt;函数名应该是自描述的与已存在的count-lines-region类似。这可以让命令名容易被记住。count-words-region是一个较好的名称。&lt;/p&gt;
&lt;p&gt;这个函数统计region中的字数。这说明参数列表中需要两个符号，分别绑定到region的开始位置和结束位置。这两个位置可以被称为beginning和end。文档字符串的第一行必须是一个完整的句子，因为有些命令将只打印文档的第一行，比如apropos命令。交互式语句(interactive "r")将把缓冲区开始位置和结束位置放到参数列表中。&lt;/p&gt;
&lt;p&gt;函数体需要完成三个任务：第一，设置条件，在这个条件下while循环可以统计字数。第二，执行while循环。第三，向用户显示信息。&lt;/p&gt;
&lt;p&gt;当用户调用count-words-region时point可能位于region的开始位置或结束位置。但是，计数处理只能从region的开始位置到结束位置计数。这意味着如果point没有在region的开始位置，则我们需要将point设置到region的开始位置，执行(goto-char beginning)。为了保证在函数执行完后，point可以恢复原来的位置，将需要用到save-excursion语句。&lt;/p&gt;
&lt;p&gt;函数体的中心部分是由一个while循环组成，它内部有一个每次向前跳转一个单词的语句，另一个语句负责计数。while语句的true-or-false-test应该在point达到region结束位置时返回false，在此之前返回true。&lt;/p&gt;
&lt;p&gt;我们可以使用(forward-word 1)作为向前移动一个单词的语句，如果我们使用正则表达式搜索就很容易明白Emacs中对于'word'的界定。&lt;/p&gt;
&lt;p&gt;通过一个正则表达式查找到那个位置并把point设置在最后一个字符的后面。这表示成功的向前移了一个单词。&lt;/p&gt;
&lt;p&gt;实际上还有一个问题，我们需要这个正则表达式跳过单词间的空格和标点符号。这表明正则表达式需要能匹配单词后面的空白和标点符号。（一个单词后面也可能没有空白和标点,因此正则表达式的这一部分应该是可选的）&lt;/p&gt;
&lt;p&gt;因此，我们需要的正则表达式，要能匹配一个或多个构词字符（能构成单词的字符），后面跟一个可选的由一个或多个非构词字符（不能用于构成单词的字符）。正则表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;\w+\W*
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缓冲区的语法表决定了哪些是构词字符。&lt;/p&gt;
&lt;p&gt;查找语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（注意w和W前面的双斜线。单个斜线对于Emacs Lisp解释器来说有特殊意义。它表明后面一个字符需要不同的处理。比如，&lt;code&gt;\n&lt;/code&gt;表示换行。两个斜线表示斜线）&lt;/p&gt;
&lt;p&gt;我们还需要一个计数器用于计数；这个变量初始时必须为0，然后在每次执行while循环体时增加。这个语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后我们需要告诉用户region中有多少个字符。message函数用于向用户显示信息。显示信息只需要一个短语，我们并不需要很复杂。到底是简单还是复杂。我们可以用一个条件语句来解决定个问题。共有三种可能：region中没有单词，region只有一个单词，或者有多个单词。这时crond比较合适。&lt;/p&gt;
&lt;p&gt;初步的函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; First version; has bugs!&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print number of words in the region.&lt;/span&gt;
&lt;span class="s"&gt;Words are defined as at least one word-constituent&lt;/span&gt;
&lt;span class="s"&gt;character followed by at least one character that&lt;/span&gt;
&lt;span class="s"&gt;is not a word-constituent.  The buffer's syntax&lt;/span&gt;
&lt;span class="s"&gt;table determines which characters these are."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Counting words in region ... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. Set up appropriate conditions.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;beginning&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. Run the while loop.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. Send a message to the user.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zerop&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region does NOT have any words."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has 1 word."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has %d words."&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数能够工作，但并不是在所有的情况下。&lt;/p&gt;
&lt;h3 id="count-words-regionhan-shu-zhong-kong-bai-chu-li-de-bug"&gt;count-words-region函数中空白处理的Bug&lt;/h3&gt;
&lt;p&gt;前面描述的count-words-region命令有两个Bug，或者说一个Bug的两个表现。首先，如果region中只在某些文本间有空白，count-words-region命令将告诉你region中只包含了一个单词。第二，如果region中只有缓冲区结束位置或者narrowed缓冲区的可访问域的结束位置有空白，命令在执行时将显示错误信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Search failed: "\\w+\\W*"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以在Emacs中先安装这个函数，然后将它绑定到按键上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-c="&lt;/span&gt; &lt;span class="ss"&gt;'count-words-region&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以在设置region后按&lt;code&gt;C-c =&lt;/code&gt;执行（如果没有绑定按键，可以用M-x count-words-region执行）。&lt;/p&gt;
&lt;p&gt;对下面的内容执行时Emacs将告诉你，region有3个单词。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    one   two  three
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果把mark设置在这行的开头位置，point放在&lt;code&gt;one&lt;/code&gt;的前面。重新执行&lt;code&gt;C-c =&lt;/code&gt;。Emacs应该要告诉你region中没有单词，因为region只有空白。但是，Emacs告诉你region中只有一个单词。&lt;/p&gt;
&lt;p&gt;第三个测试，复制上面例的整行到&lt;em&gt;scratch&lt;/em&gt;缓冲区中并在行的结束位置输入一些空格。将mark设置在单词&lt;code&gt;three&lt;/code&gt;的后面，然后point设置在行的结束位置（在这里即缓冲区的结束位置）。输入&lt;code&gt;C-c =&lt;/code&gt;。这次Emacs应该告诉你region中没有单词。但是Emacs这次却显示了一个错误信息&lt;code&gt;Search failed&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这两个bug来自于同一个问题。&lt;/p&gt;
&lt;p&gt;思考这个Bug的第一个表现，命令告诉你行的开始位置的空白包含一个单词。它是这样产生的：count-words-region命令先将point移到region的开始位置。然后测试当前point的位置是否小于end变量的值。结果为true。接下来，通过表达式查找第一个单词。它将point设置在第一个单词的后面。count被设置为1。while循环重复，但这时point已经大于end的值了，循环退出；函数显示信息说在region中有一个单词。简单来说就是由于正则表达式查询时，它查找到的单词的结束位置超过了region的区域。&lt;/p&gt;
&lt;p&gt;Bug的第二个表现中，region是缓冲区结束位置的空白。Emacs说Search failed。这是由于在while的true-or-false-test返回true，search语句被执行。但是由于没找到匹配项，因此查询失败。&lt;/p&gt;
&lt;p&gt;这两种情况都是由于查询时扩展或者试图扩展到region的外部。&lt;/p&gt;
&lt;p&gt;解决办法就是限制查询的区域，一个很简单的动作，但并没有想像的那么简单。&lt;/p&gt;
&lt;p&gt;前面在讲re-search-forward函数时，它接收四个参数。第一个参数是必需的，其它三个是可选参数。它的第二个参数是用于限定查询范围的。第三个可选参数，如果为t，则函数将在查询失败时返回nil，而不显示错误信息。第四个可选参数是重复次数。（可以用C-h f查找函数的文档）&lt;/p&gt;
&lt;p&gt;在count-words-region函数定义中，region的结束位置被以设置到end参数上，它将作为函数参数传入。因此我们可以把end作为正则表达式查询时的参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果只对count-words-region的定义作上面的修改，在遇到一些空白字符时，仍将得到Search failed的错误。&lt;/p&gt;
&lt;p&gt;这是因为，有可能在限制的范围内，搜索不到构词字符。搜索将失败，并显示错误信息。但我们在这时并不想要获取错误信息，我们需要显示"The region does NOT have any words."。&lt;/p&gt;
&lt;p&gt;解决这一问题的办法就是将re-search-forward的第三个参数设置为t，这样在函数在搜索失败时将返回nil。&lt;/p&gt;
&lt;p&gt;如果你尝试运行程序，你将看到信息"Couting words in region..."并一直看到这条消息，直到你输入C-g(keyboard-quit)。&lt;/p&gt;
&lt;p&gt;当在限制查询范围的region中搜索时，和前面一样，如果region中没有构词字符，搜索将失败。re-search-forward语句返回nil。这时point也不会被移动，而循环中的下一条语句将被执行。这条语句将计数增加。然后循环继续。true-or-false-test将一直返回true，因为point仍小于end参数，程序将陷入死循环。&lt;/p&gt;
&lt;p&gt;count-words-region的定义还需要一些修改，以便在搜索失败时让true-or-false-test返回false。可以在true-or-false-test中增加一个条件，true-or-false-test在增加计数前需要满足下面的条件：point必须在region之内，且查询的语句必须找到了一个单词。&lt;/p&gt;
&lt;p&gt;因为两个条件都必须为true。所以区域范围检查和搜索语句可以用and连接起来，都作为while循环的true-or-false-test：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;re-search-forward在成功搜索到单词后将返回t，并移动point，只要能找到单词，point将继续移动。当搜索失败或者point达到region的结束位置时，true-or-false-test将返回false。while循环退出，count-words-region函数显示一个或多个信息。&lt;/p&gt;
&lt;p&gt;修改完后的count-words-region函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Final version: while&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print number of words in the region."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Counting words in region ... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. Set up appropriate conditions.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;beginning&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. Run the while loop.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. Send a message to the user.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zerop&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region does NOT have any words."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has 1 word."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has %d words."&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;递归方式统计单词数量&lt;/h2&gt;
&lt;p&gt;上一节已经编写过了通过while循环进行计数的函数。&lt;/p&gt;
&lt;p&gt;在这个函数中，count-words-region函数完成了三个工作：为计数设置适当的条件；计算region中的字数；将字数显示给用户。&lt;/p&gt;
&lt;p&gt;如果我们在一个递归函数中执行所有的操作，则我们将在每次递归调用时都会得到字数的消息。如果region中包含了13个单词，消息将显示13次。这并不是我们需要的，我们需要写两个函数来做这个工作，一个函数（递归函数）将在另一个函数内部被使用。一个设置条件和显示信息，国一个返回字数。&lt;/p&gt;
&lt;p&gt;开始编写函数。我们仍把这个函数叫作count-words-region。&lt;/p&gt;
&lt;p&gt;根据前一个版本，我们可以描述出这个程序的结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Recursive version; uses regular expression search&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;interactive-expression...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. Set up appropriate conditions.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;explanatory&lt;/span&gt; &lt;span class="nf"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-up&lt;/span&gt; &lt;span class="nv"&gt;functions...&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. Count the words.&lt;/span&gt;
    &lt;span class="nv"&gt;recursive&lt;/span&gt; &lt;span class="nv"&gt;call&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. Send a message to the user.&lt;/span&gt;
    &lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="nv"&gt;providing&lt;/span&gt; &lt;span class="nv"&gt;word&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义很直接，不同的地方是递返回的数字必须传递给message来显示。这可以用let语句来完成：我们可以用let语句把字数赋给一个变量，并把这个值作为递归部分的返回值。使用cond语句，用于设置变量和显示信息给用户。&lt;/p&gt;
&lt;p&gt;通常let语句总被作为函数的'次要工作'。但在这里，let将作为函数的主要工作，统计字数的工作就是在let语句中。&lt;/p&gt;
&lt;p&gt;使用let时函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print number of words in the region."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. Set up appropriate conditions.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Counting words in region ... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;beginning&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. Count the words.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. Send a message to the user.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zerop&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region does NOT have any words."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has 1 word."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has %d words."&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们需要编写递归计数函数。&lt;/p&gt;
&lt;p&gt;递归函数至少有三个部分：'do-again-test'，'next-step-expresssion'和递归调用。&lt;/p&gt;
&lt;p&gt;do-again-test决定函数是否继续调用。因为我们在统计region中的单词时我们使用了移动point的函数，do-again-test可以检查point是否位于region中。do-again-test需要检查point是位于region结束位置的前面还是后面。我们可以使用point函数获取point的位置信息，我们还需要传递将region的结束位置作为参数传递到递归计数函数里。&lt;/p&gt;
&lt;p&gt;另外，do-again-test还需要检查是否找到了一个单词。如果没有，函数就不再需要继续调用它自己了。&lt;/p&gt;
&lt;p&gt;next-step-expression修改某个值以便递归函数能在适当的时候停止递归调用。在这里next-step-expression可以是移动point的语句。&lt;/p&gt;
&lt;p&gt;递归函数的第三个部分是递归调用。&lt;/p&gt;
&lt;p&gt;在这个函数中我们也需要在某个地方执行计数工作。&lt;/p&gt;
&lt;p&gt;这样，我们有了一个递归计数函数的原型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
   &lt;span class="nv"&gt;do-again-test&lt;/span&gt;
   &lt;span class="nv"&gt;next-step-expression&lt;/span&gt;
   &lt;span class="nv"&gt;recursive&lt;/span&gt; &lt;span class="nv"&gt;call&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们需要填空。首先我们从最简单的一种情况开始：point位于region结束位置或位于region之外，region中没有单词，因此函数需要返回0。同样，如果搜索失败，函数也需要返回0。&lt;/p&gt;
&lt;p&gt;另一方面，如果point在region内部，并且搜索成功，函数应该再次调用它自己。&lt;/p&gt;
&lt;p&gt;这样，do-again-test应该如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，查找语句是do-again-test函数的一部分，在搜索成功时返回t，失败时返回nil。&lt;/p&gt;
&lt;p&gt;do-again-test是if语句的true-or-false子句。如果do-again-test成功，则if语句的then部分执行，如果失败，则应该返回0，因为不管point是位于region的外面还是搜索失败都表示region中没有单词。&lt;/p&gt;
&lt;p&gt;另外，do-again-test返回t或nil时，re-search-forward将在搜索成功时移动point。这是修改point的值并让递归函数在point移出region后停止递归调用的操作。因此，re-earch-foreard语句就是next-step-expression。&lt;/p&gt;
&lt;p&gt;recursive-count-words函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;do-again-test-and-next-step-combined&lt;/span&gt;
    &lt;span class="c1"&gt;;; then&lt;/span&gt;
    &lt;span class="nv"&gt;recursive-call-returning-count&lt;/span&gt;
  &lt;span class="c1"&gt;;; else&lt;/span&gt;
  &lt;span class="nv"&gt;return-zero&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怎样加入计数机制呢？&lt;/p&gt;
&lt;p&gt;我们知道计数机制应该与递归调用联合起来。由于next-step-expression将point一个个单词的移动，因此，针对每个单词都会调用一次递归函数，计数机制必须有一个语句将recursive-count-words的返回值加1。&lt;/p&gt;
&lt;p&gt;思考下面几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果region中有两个单词，函数在遇到第一个单词时，需要返回region中其它单词数量（这里为1）加1的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果region中只有一个单词，函数在遇到第一个单词时，需要返回region中其它单词数量（这里为0）加1的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果region中没有单词，函数需要返回0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的描述中可以看出if语句的else部分在没有单词时返回0。而if语句的then部分必须返回1加上region中其它单词数量的值。&lt;/p&gt;
&lt;p&gt;语句如下，使用了函数1+使它的参数加1。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个recursive-count-words函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. do-again-test&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. then-part: the recursive call&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. else-part&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;研究一下它是如何工作的：&lt;/p&gt;
&lt;p&gt;当region中没有单词时，if语句的else部分被执行，函数返回0。&lt;/p&gt;
&lt;p&gt;如果region中有一个单词，point的值小于region-end并且搜索成功。这时，if语句的true-or-false-test为true，if语句的then部分被执行。计数语句被执行。这个语句将返回（整个函数的返回值）递归调用的返回值加1的结果。&lt;/p&gt;
&lt;p&gt;与此同时，next-step-expression将使point跳过region中的第一个单词。这表示当(recursive-count-words region-end)在第二次时被执行，并作为递归调用的结果，point的值将等于或大于region的结束位置。这样，recursive-count-words将返回0。最初的recursive-count-words将返回0+1，计数正确。&lt;/p&gt;
&lt;p&gt;如果region中有两个单词，第一次调用recursive-count-words将返回1加上在包含其它单词的region上调用recursive-count-words的返回值，这里将是1加1，2是正确的返回值。&lt;/p&gt;
&lt;p&gt;类似地，如果region中包含有3个单词，第一次调用recursive-count-words将返回1加上在包含其它单词的region上调用recursive-count-words的返回值，如此继继续。&lt;/p&gt;
&lt;p&gt;整个程序包含了两个函数：&lt;/p&gt;
&lt;p&gt;递归函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Number of words between point and REGION-END."&lt;/span&gt;

&lt;span class="c1"&gt;;;; 1. do-again-test&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"\\w+\\W*"&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 2. then-part: the recursive call&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="nf"&gt;region-end&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;;;; 3. else-part&lt;/span&gt;
    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;包装函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Recursive version&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print number of words in the region.&lt;/span&gt;

&lt;span class="s"&gt;Words are defined as at least one word-constituent&lt;/span&gt;
&lt;span class="s"&gt;character followed by at least one character that is&lt;/span&gt;
&lt;span class="s"&gt;not a word-constituent.  The buffer's syntax table&lt;/span&gt;
&lt;span class="s"&gt;determines which characters these are."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Counting words in region ... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;beginning&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-count-words&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zerop&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region does NOT have any words."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"The region has 1 word."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
              &lt;span class="s"&gt;"The region has %d words."&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;统计defun中的单词数量&lt;/h1&gt;
&lt;p&gt;我们的下一个计划是统计函数定义中的单词数量。我们可以使用count-word-region函数的一些变种（正则表达式方式）来完成这个工作。如果我们只是需要统计定义中的单词数量的话，可以简单的使用C-M-h(mark-defun)命令，然后调用count-word-region。&lt;/p&gt;
&lt;p&gt;但我们要进行的是一项雄心勃勃的计划：我们需要统计Emacs源码中所有的函数和符号并打印出各个长度的函数分别有多少个：包含40至49个单词或符号的有多少，包含50到59个单词或符号的有多少，等等。&lt;/p&gt;
&lt;h2&gt;分割任务&lt;/h2&gt;
&lt;p&gt;这个任务目标使人畏惧；但如果将它分割成多个小的步骤，每次我们只处理其中的一部分，这样这个目标将不那么令人畏惧。先来思考一下有哪些步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编写一个用于统计函数定义中字数的函数。这也包括了把符号当作单词的处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写一个能列出一个文件中各个函数各有多少单词的函数。这个函数将调用count-words-in-defun函数（第1中定义的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写一个能列出多个文件中各个函数各有多少单词的函数。负责自动查找多个文件，然后切换到这些文件中，并统计这些文件内的函数定义中的单词数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写一个函数将第3步中得到的数据列表转换为适合打印的形式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写函数打印结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;统计什么？&lt;/h2&gt;
&lt;p&gt;在上节所说的几个步骤中，首先就是需要决定哪些是需要进行统计的？当我们针对Lisp函数定义说'单词'('word')时，我们实际上很大程序上是在说'符号'（'symbols'）。举例来说，multiply-by-seven函数包含了5个符号defun,multiply-by-seven,number,*,和7。另外，文档字符串包含了四个单词Multiply,Number,by,和seven。符号number是重复的，因此定义包含了十个单词和符号。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Multiply NUMBER by seven."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，如果我们对上面的函数定义执行C-M-h(mark-defun)，然后调用count-words-region，count-words-region将报告定义中有11个单词，而不是10。哪里出错了！&lt;/p&gt;
&lt;p&gt;原因有两个：count-words-region不把*当作一个单词。把符号multiply-by-seven当作三个单词。连字符被作为单词间的空白。&lt;/p&gt;
&lt;p&gt;这是由于count-words-region定义中的正则表达式引起的。在一个典型的count-words-region函数定义中，正则表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"\\w+\\W*"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个正则表达式匹配一个或多个构词字符被一个或多个非构词字符包围。&lt;/p&gt;
&lt;h2&gt;单词和符号由什么组成？&lt;/h2&gt;
&lt;p&gt;Emacs把不同的字符归属到不同的语法分类中。比如，正则表达式&lt;code&gt;\\w+&lt;/code&gt;匹配一个或多个构词字符。构词字符是一个语法分类中的成员。另一个语法分类包含了标点符号，例如：句号和逗号，空白符号，空白字符和tab。&lt;/p&gt;
&lt;p&gt;语法名指定了字符属于哪个分类。通常，连字符号不被当作构词字符。而是被作为'符号的一部分但不是单词'('class of characters that are part of symbol names but not words.')的一类。这意味着count-words-region函数将把它当作词间的空白一样对侍，这也说明了为什么count-words-region会把multiply-by-seven当作3个单词处理。&lt;/p&gt;
&lt;p&gt;有两种办法让Emacs把multiply-by-sevn当作一个符号来处理：修改语法表或修改正则表达式。&lt;/p&gt;
&lt;p&gt;我们可以重新在语法表中将连字符定义为构词字符，Emacs将在每个mode中保持这个设置。这个操作能达到我们的目的，除了连字符不是一个典型的构词字符外..&lt;/p&gt;
&lt;p&gt;另外，我们也可以重新定义count-words函数中的正则表达式以包含连字符。这种处理的优点是比较明确，但任务有点刁。&lt;/p&gt;
&lt;p&gt;这个正则表达式的第一个部分简单：必须匹配"至少由一个字符或符号构成"：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"\\(\\w\\|\\s_\\)+"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表达式的第一部分是&lt;code&gt;\\(&lt;/code&gt;,括号中包含了两个部分&lt;code&gt;\\w&lt;/code&gt;和&lt;code&gt;\\s_&lt;/code&gt;，两者之间用&lt;code&gt;\\|&lt;/code&gt;分隔表示或关系。&lt;code&gt;\\w&lt;/code&gt;匹配任何构词字符，&lt;code&gt;\\s_&lt;/code&gt;符号中的所有非构词字符。括号外面的+号表示单词或者构成符号的字符至少要出现一次。&lt;/p&gt;
&lt;p&gt;表达式的第二个部分更难设计。我们需要在第一个部分后可以有一个非构词字符。首先，我想可以定义成下面的形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"\\(\\W\\|\\S_\\)*"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大写的W和S匹配非构词和非符号字符。&lt;/p&gt;
&lt;p&gt;然后我们注意到region中每个单词或符号后面有空白字符（空格、tab、或空行）。因此我们需要让表达式匹配一个或多个构词（或构成符号）字符后面跟一个或多个空白字符，但实际单词和符号有可能紧跟在括号或标点的后面。最后，我们设计的正则表达式匹配将单词或符号后面跟有可选的非空白字符，然后跟可选的空白。&lt;/p&gt;
&lt;p&gt;完整的表达式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;count-words-in-defun函数&lt;/h2&gt;
&lt;p&gt;前面已经看到过，有多个方法实现count-word-region函数。我们只选用其中一个合适的方式来实现count-words-in-defun。&lt;/p&gt;
&lt;p&gt;使用while循环的版本容易理解，因此我们准备采用。因为count-words-in-defun函数将变成更复杂的函数的一部分，它不需要交互也不要显示信息，只需要返回数量。&lt;/p&gt;
&lt;p&gt;另外，count-words-in-defun将被用于包含函数定义的缓冲区。因此，需要函数决定当point位于函数定义内部时是否能被调用，如果point位于函数定义内，它需要返回当前所在的函数定义的单词数量。这增加了这个函数的性。&lt;/p&gt;
&lt;p&gt;根据上面的需求，我们准备了下面的模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-in-defun&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;up...&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;loop...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="nb"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与之前一样，我们的工作就是填空。&lt;/p&gt;
&lt;p&gt;函数有可能在包含函数定义的缓冲区中。Point有可能位于某个函数定义的内部。count-words-in-defun必须先将point移到这个函数定义的起始位置，计数器置0，计数循环必须在到达函数定义结束位置时停止。&lt;/p&gt;
&lt;p&gt;beginning-of-defun函数向后查找左括号。比如行开始位置的&lt;code&gt;(&lt;/code&gt;，并将point移到那个位置或到达查询的限制的边界。实际上，beginning-of-defun将point移到左括号前面或者函数定义的前面，或者缓冲区的开始位置。我们可以使用beginning-of-defun将point放到我们希望有开始位置。&lt;/p&gt;
&lt;p&gt;while循环部分需要一个计数器来保存计数。可以使用let语句创建局部变量，并将局部变量初始化为0，来达到这个目的。&lt;/p&gt;
&lt;p&gt;end-of-defun函数与beginning-of-defun类似，它将point移到定义的结束位置。end-of-defun可以用于检查是否位于函数定义的结束位置。&lt;/p&gt;
&lt;p&gt;count-words-in-defun的开始部分：首先，将point移到定义的开始位置，然后创建一个局部变量保存计数器，最后，记录下定义结束的位置以便while循环知道什么时候停止循环。&lt;/p&gt;
&lt;p&gt;代码结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning-of-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end-of-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码比较简单，唯一复杂点的是"end"部分：它将end设置为save-excursion语句的返回值，这个语句返回end-of-defun（它将point移到定义的结束位置）执行后point的位置。&lt;/p&gt;
&lt;p&gt;在初始化工作完成后，count-words-in-defun的第二个部分就是while循环。&lt;/p&gt;
&lt;p&gt;这个循环必须包含按单词或符号向前移动的语句，另一个语句则用于统计移动的次数。while循环的true-or-false-test应该跳到定义结束位置时返回false。在这里我们可以使用前面讨论过的正则表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt;
             &lt;span class="s"&gt;"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数定义的第三个部分返回符号或单词的数量。这个部分是函数内部的let语句的最后一个表达式。很简单，返回局部变量count。&lt;/p&gt;
&lt;p&gt;这几个部分放在一起就构成了count-words-in-defun：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-in-defun&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Return the number of words and symbols in a defun."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;beginning-of-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;end-of-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt;
              &lt;span class="s"&gt;"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"&lt;/span&gt;
              &lt;span class="nv"&gt;end&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;怎样测试它呢？这个函数是非交互式的函数，但我们可以很容易的将它包装成一个交互式的函数；可以使用与count-words-region中类似的方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Interactive version.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;count-words-defun&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Number of words and symbols in a function definition."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
   &lt;span class="s"&gt;"Counting words and symbols in function definition ... "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;count&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-words-in-defun&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
     &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;zerop&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
       &lt;span class="s"&gt;"The definition does NOT have any words or symbols."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
       &lt;span class="s"&gt;"The definition has 1 word or symbol."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;t&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt;
       &lt;span class="s"&gt;"The definition has %d words or symbols."&lt;/span&gt; &lt;span class="nv"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以将它绑定到&lt;code&gt;C-c =&lt;/code&gt;上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-c="&lt;/span&gt; &lt;span class="ss"&gt;'count-words-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们可以试试count-words-defun：安装count-words-in-defun和count-words-defun，设置按键绑定，然后将光标放到下面的定义中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;multiply-by-seven&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Multiply NUMBER by seven."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将显示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Success! The definition has 10 words and symbols.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下一个问题就是如何统计同一个文件中的多个定义中的单词和符号。&lt;/p&gt;
&lt;h2&gt;统计一个文件中的多个defun&lt;/h2&gt;
&lt;p&gt;文件simple.el可能包含超过80个函数定义。我们的终极目标是要对很多的文件进行统计，但第一步，我们当前的目标是要对一个文件进行统计。&lt;/p&gt;
&lt;p&gt;这个信息将会是一连串的数字，每个数字是一个函数定义的长度。我们可以将这些数字保存到一个list中。&lt;/p&gt;
&lt;p&gt;我们需要将多个文件的信息合并到一起，因此统计对一个文件进行统计时不需要显示信息，只需要返回长度信息。&lt;/p&gt;
&lt;p&gt;在字数统计命令包含了一个语句用于按单词向前移动另一个语句计数。这个返回函数定义长度的函数同样可以使用这种方式，一个语句用于向前跳转一个函数定义，另一个语句用于计数。&lt;/p&gt;
&lt;p&gt;编写函数字义。我们需要从文件开始位置计数，因此第一个命令使用(goto-char (point-min))。接下来，我们开始while循环，循环的true-or-false-test可以是一个查询下一个函数定义的正则表达式查询，如果查询成功，则将point向前移动，循环体被执行。循环体需要一个语句构造包含长度的list。&lt;/p&gt;
&lt;p&gt;代码片段如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"^(defun"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;lengths-list&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-words-in-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们还少了缺少查找函数定义文件的机制。&lt;/p&gt;
&lt;h2&gt;查找文件&lt;/h2&gt;
&lt;p&gt;在Emacs中可以使用C-x C-f(find-file)命令。这个命令并不是很符合处理当前问题。&lt;/p&gt;
&lt;p&gt;先来看find-file的源码（可以使用find-tag命令C-h f(describe-functin)来查找源文件）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;find-file&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Edit file FILENAME.&lt;/span&gt;
&lt;span class="s"&gt;Switch to a buffer visiting file FILENAME,&lt;/span&gt;
&lt;span class="s"&gt;creating one if none already exists."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"FFind file: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;switch-to-buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;find-file-noselect&lt;/span&gt; &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义很短，一个interactive用于执行命令时的交互。定义的body部分包含个函数，find-file-noselect和switch-to-buffer。&lt;/p&gt;
&lt;p&gt;使用C-h f（describe-function命令）查看find-file-noselect函数的文档，这个函数读取指定的文件到缓冲区中，并返回这个缓冲区。但是这个缓冲区未被选中。Emacs并不会将焦点转移到它。这个工作由switch-to-buffer完成，它将Emacs焦点转到指定的缓冲区，并将这个缓冲区在窗口中显示出来。&lt;/p&gt;
&lt;p&gt;在这个工程中，我们并不需要在屏幕上显示每个文件。因此我们使用set-buffer来替代switch-to-buffer，它将程序的焦点转移到另一个缓冲区，但不会改变屏幕显示。因此，我们不调用find-file，而是需要自己编写一个。&lt;/p&gt;
&lt;p&gt;可以使用find-file-noselect和set-buffer来完成这个工作。&lt;/p&gt;
&lt;h2&gt;lengths-list-file函数的细节&lt;/h2&gt;
&lt;p&gt;lengths-list-file函数的核心是一个while循环，它包含了将point向前（'defun by defun'）移动的函数和用于统计每个defun中符号或单词数量的函数。这个核心将被包含在执行各种任务的函数中，包括文件查找，确保point位于文件的开始位置。这个函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;lengths-list-file&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return list of definitions' lengths within FILE.&lt;/span&gt;
&lt;span class="s"&gt;The returned list is a list of numbers.&lt;/span&gt;
&lt;span class="s"&gt;Each number is the number of words or&lt;/span&gt;
&lt;span class="s"&gt;symbols in one function definition."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"Working on &lt;/span&gt;&lt;span class="ss"&gt;`%s'&lt;/span&gt;&lt;span class="s"&gt; ... "&lt;/span&gt; &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-excursion&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;buffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;find-file-noselect&lt;/span&gt; &lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;set-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;buffer-read-only&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;widen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;re-search-forward&lt;/span&gt; &lt;span class="s"&gt;"^(defun"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;lengths-list&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;count-words-in-defun&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;kill-buffer&lt;/span&gt; &lt;span class="nv"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数有一个参数，需要处理的文件名。有4行文档字符串，但没有交互式语句。body部分的第一行是一个message，用于提示用户机器正在执行操作。&lt;/p&gt;
&lt;p&gt;下一行包括了一个save-excursion它将在函数结束时，将Emacs焦点恢复到当前缓冲区。这通常用于将一个函数嵌入另一个函数时，可以恢复原缓冲区中的point。&lt;/p&gt;
&lt;p&gt;在let语句的变量列表中，Emacs打开文件，并将包含该文件缓冲区设置到buffer变量。同时，Emacs创建了局部变量lengths-list。&lt;/p&gt;
&lt;p&gt;接下来，Emacs将焦点转到这个缓冲区。&lt;/p&gt;
&lt;p&gt;在下一行中，Emacs将缓冲区设置为只读。理想情况下，这行是不必要的。没有哪个计数函数需要修改缓冲区。并且，即使我们修改了缓冲区，缓冲区也不会被保存。这主要是防止不小心修改了Emacs的源码造成麻烦。&lt;/p&gt;
&lt;p&gt;接下来，如果缓冲区被narrowed，则调用widen。这个函数在Emacs创建一个新的缓冲区时不需要，但如果文件已经在缓冲区中时，有可能缓冲区被narrowed了，这时必须调用widen。如果我们要完全的"user-friendly"，我们还需要保存point的位置，但我们不需要。&lt;/p&gt;
&lt;p&gt;(goto-char (point-min))语句将point移到缓冲区的开始位置。&lt;/p&gt;
&lt;p&gt;后面的while循环中，Emacs决定每个定义的长度并构造一个包含长度信息的列表。&lt;/p&gt;
&lt;p&gt;然后，Emacs关闭缓冲区，继续后面的操作。这是为了保存Emacs的空间。在Emacs 19中包含了超过300个源码文件；Emacs 21包含了超过800个源码文件。另一个函数将在每个文件上执行length-list-file。&lt;/p&gt;
&lt;p&gt;你可以安装并测试一下这个文件。将光标放在下面的语句的后面，执行C-x C-e(eval-last-sexp)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt;
 &lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/lisp/emacs-lisp/debug.el"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;统计不同文件中的defun中的单词&lt;/h2&gt;
&lt;p&gt;前一节，我们创建了一个可以返回单个文件中各个函数长度列表的函数。现在我们需要定一个函数返回文件列表中所有定义长度的函数。&lt;/p&gt;
&lt;p&gt;使用while循环或递归在每个文件上执行相同的操作。&lt;/p&gt;
&lt;h3 id="jue-ding-defunde-chang-du"&gt;决定defun的长度&lt;/h3&gt;
&lt;p&gt;使用while循环作为程序主干。传递给函数的是一个文件列表。前面看过，可以写一个while循环，如果列表中包含了元素，则执行循环，否则退出循环。循环体必须在每次执行时缩短list的长度，直到list为空退出循环。通常的技巧是将list设置为原来的list的CDR。&lt;/p&gt;
&lt;p&gt;模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;test-whether-list-is-empty&lt;/span&gt;
  &lt;span class="nv"&gt;body...&lt;/span&gt;
  &lt;span class="nv"&gt;set-list-to-cdr-of-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;while循环将返回nil（true-or-false-test的返回值），而不是循环体的执行结果。因此我们需要将while循环包含在let语句中，并让let语句的最后一个语句包含要返回的list。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Use while loop.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;lengths-list-many-files&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return list of lengths of defuns in LIST-OF-FILES."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; true-or-false-test&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;lengths-list&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt;
             &lt;span class="nv"&gt;lengths-list&lt;/span&gt;

&lt;span class="c1"&gt;;;; Generate a lengths' list.&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;expand-file-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="c1"&gt;;;; Make files' list shorter.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="c1"&gt;;;; Return final value of lengths' list.&lt;/span&gt;
    &lt;span class="nv"&gt;lengths-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;expand-file-name是一个内置函数，它将文件名转换为绝对路径。&lt;/p&gt;
&lt;p&gt;如果在debug.el上执行expand-file-nameEmacs将得到&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/usr/local/share/emacs/21.0.100/lisp/emacs-lisp/debug.el
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数定义的中的另一个新元素是未学习过的函数append。&lt;/p&gt;
&lt;h3 id="appendhan-shu"&gt;append函数&lt;/h3&gt;
&lt;p&gt;append函数将一个list添加到另一个list，如下，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将产生list&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这恰好是我们需要结果。如果使用cons，
&amp;lt;src lang="emacs-lisp"
(cons '(1 2 3 4) '(5 6 7 8))&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;则，将得到：
```emacs-lisp
((1 2 3 4) 5 6 7 8)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;递归统计不同文件中的单词数量&lt;/h2&gt;
&lt;p&gt;除了while循环，你可以在文件列表中使用递归处理。递归版本的lengths-list-many-files简洁一些。&lt;/p&gt;
&lt;p&gt;递归函数通常有这些部分：'do-again-test'，'next-step-expression'和递归调用。'do-again-test'决定是否再次调用自身，它需要检查list-of-files是否还包含有元素；'next-step-expression'将list-of-files重新设置为它的CDR部分，因此，最后这个list将变为空；递归调用则在缩短后的list上调用它自身。代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-lengths-list-many-files&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return list of lengths of each defun in LIST-OF-FILES."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;                     &lt;span class="c1"&gt;; do-again-test&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;expand-file-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-lengths-list-many-files&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;list-of-files&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单来说，函数将第一次返回的list-of-files追加到其它次调用返回的list-of-files中。&lt;/p&gt;
&lt;p&gt;这里是一个recursive-lengths-list-many-files的测试。&lt;/p&gt;
&lt;p&gt;安装recursive-lengths-list-many-files和lengths-list-file。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;cd&lt;/span&gt; &lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt; &lt;span class="s"&gt;"./lisp/macros.el"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (273 263 456 90)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt; &lt;span class="s"&gt;"./lisp/mail/mailalias.el"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (38 32 26 77 174 180 321 198 324)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;lengths-list-file&lt;/span&gt; &lt;span class="s"&gt;"./lisp/makesum.el"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="c1"&gt;;=&amp;gt; (85 181)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-lengths-list-many-files&lt;/span&gt;
 &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"./lisp/macros.el"&lt;/span&gt;
   &lt;span class="s"&gt;"./lisp/mail/mailalias.el"&lt;/span&gt;
   &lt;span class="s"&gt;"./lisp/makesum.el"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
       &lt;span class="c1"&gt;;=&amp;gt; (273 263 456 90 38 32 26 77 174 180 321 198 324 85 181)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;recursive-lengths-list-many-files函数产生了我们想要的输出。&lt;/p&gt;
&lt;p&gt;下一步是准备显示图表的数据。&lt;/p&gt;
&lt;h2&gt;准备显示图表的数据&lt;/h2&gt;
&lt;p&gt;recursive-lengths-list-many-files函数返回了一个包含计数的列表。每个数字记录了一个函数定义的长度。我们需要将数据转换到适于生成图表的list中。新的list将告诉我们有多少个定义包含少于10个单词或符号，多少个处于10到19个单词或符号之间，等等。&lt;/p&gt;
&lt;p&gt;我们需要遍历recursive-lengths-list-many-files函数返回的list中的值，并计算处于各个范围中的数量，并产生包含这些数量的list。&lt;/p&gt;
&lt;p&gt;基于之前我们所做的，我们可以预想到编写这个函数并不难。可以用截取CDR的方式遍历各个元素，决定这个长度位于哪个范围，并增加这个范围的计数。&lt;/p&gt;
&lt;p&gt;但是，在编写这个函数前，我们需要思考对list排序的优点，数字按从小到大的顺序排列。首先，排序将使计数容易一些，因为相信的数字将会处于同一个范围中。第二，检查排序后的list，可以知道最大的数字和最小的数字，便于决定我们所需要的最大和最小的范围。&lt;/p&gt;
&lt;h3 id="listpai-xu"&gt;List排序&lt;/h3&gt;
&lt;p&gt;Emacs包含了一个排序函数sort。sort带两个参数，被排序的list和一个决定list元素大小关系的参数。&lt;/p&gt;
&lt;p&gt;sort函数可以基于任意的属性进行排序；这意味着sort可以用于对非数字进行排序，比如按字母。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;函数用于对数字类型的list排序。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sort&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ss"&gt;'&amp;lt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nv"&gt;produces&lt;/span&gt; &lt;span class="nv"&gt;this:&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，两个参数前都使用了单引号，表示不需要对它们求值。&lt;/p&gt;
&lt;p&gt;也可以使用&lt;code&gt;&amp;lt;&lt;/code&gt;对recursive-lengths-list-many-files函数的返回值排序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sort&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-lengths-list-many-files&lt;/span&gt;
  &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"../lisp/macros.el"&lt;/span&gt;
    &lt;span class="s"&gt;"../lisp/mailalias.el"&lt;/span&gt;
    &lt;span class="s"&gt;"../lisp/makesum.el"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="ss"&gt;'&amp;lt;&lt;/span&gt;

&lt;span class="nv"&gt;which&lt;/span&gt; &lt;span class="nv"&gt;produces:&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;85&lt;/span&gt; &lt;span class="mi"&gt;86&lt;/span&gt; &lt;span class="mi"&gt;116&lt;/span&gt; &lt;span class="mi"&gt;122&lt;/span&gt; &lt;span class="mi"&gt;154&lt;/span&gt; &lt;span class="mi"&gt;176&lt;/span&gt; &lt;span class="mi"&gt;179&lt;/span&gt; &lt;span class="mi"&gt;265&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（注意，这个例子中第一个参数没加单引号，因为它在传递给sort前需要被执行。）&lt;/p&gt;
&lt;h3 id="chan-sheng-wen-jian-lie-biao"&gt;产生文件列表&lt;/h3&gt;
&lt;p&gt;recursive-lengths-list-many-files函数需要一个文件列表作为参数。在测试的例子中，我们手工构造了一个文件列表；但Emacs List源码目录太大了。我们需要编写函数来完成这个工作。在这个函数中，我们将要同时使用while循环和递归调用。&lt;/p&gt;
&lt;p&gt;在旧版本的GNU Emacs中我们不需要编写这样的函数，因为它将所有的.el文件放在同一个目录中。我们可以使用directory-files函数，它将返回单个目录中匹配指定表达式的文件名的列表。&lt;/p&gt;
&lt;p&gt;但是，在新版本的Emacs中Emacs将Lisp文件放到了顶级lisp目录的子目录中。比如所有mail相关的文件放到了mail子目录中。&lt;/p&gt;
&lt;p&gt;我们可以创建函数files-in-below-directory，使用car，nthcdr和substring连接已经存在的函数调用directory-files-and-attributes。这个函数不只是返回目录中的文件名列表，还将返回子目录的名称，和它们的属性。&lt;/p&gt;
&lt;p&gt;重新描述我们的目标：创建一个函数能传递下面结构的参数给recursive-lengths-list-many-files函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"../lisp/macros.el"&lt;/span&gt;
 &lt;span class="s"&gt;"../lisp/mail/rmail.el"&lt;/span&gt;
 &lt;span class="s"&gt;"../lisp/makesum.el"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;directory-files-and-attributes函数返回包含list的list。list中的每个元素是一个包含了13的元素的子list。第一个元素是包含了文件名，在GNU/Linux中，它可能是一个'directory file'，也就是说，它是一个有特殊属性的目录文件。第二个元素为t的表示是一个目录，为字符串时表示是一个符号文件（该字符串表示连接的目标文件），或者为nil。&lt;/p&gt;
&lt;p&gt;比如，&lt;code&gt;lisp/&lt;/code&gt;目录中第一个&lt;code&gt;.el&lt;/code&gt;文件是abbrev.el。它的文件名是&lt;code&gt;/usr/local/share/emacs/21.0.100/lisp/abbrev.el&lt;/code&gt;它不是一个目录也不是一个链接。&lt;/p&gt;
&lt;p&gt;下面是directory-files-and-attributes返回的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/lisp/abbrev.el"&lt;/span&gt;
&lt;span class="no"&gt;nil&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;1000&lt;/span&gt;
&lt;span class="mi"&gt;100&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15019&lt;/span&gt; &lt;span class="mi"&gt;32380&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;14883&lt;/span&gt; &lt;span class="mi"&gt;48041&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15214&lt;/span&gt; &lt;span class="mi"&gt;49336&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="mi"&gt;11583&lt;/span&gt;
&lt;span class="s"&gt;"-rw-rw-r--"&lt;/span&gt;
&lt;span class="no"&gt;t&lt;/span&gt;
&lt;span class="mi"&gt;341385&lt;/span&gt;
&lt;span class="mi"&gt;776&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而表示&lt;code&gt;mail/&lt;/code&gt;目录下的&lt;code&gt;mail/&lt;/code&gt;目录的list如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/lisp/mail"&lt;/span&gt;
&lt;span class="no"&gt;t&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（查看file-attributes的文档可以了解这些属性。记住，file-attributes函数不会列出文件名，它的第一个元素是directory-files-and-attributes的第二个元素。）&lt;/p&gt;
&lt;p&gt;我们需要让新函数，files-in-below-directory列出目录及其子目录中的&lt;code&gt;.el&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;这为我们构造files-in-below-directory给出了提示：在一个目录中，函数需要添加&lt;code&gt;.el&lt;/code&gt;文件名到一个list中；如果是一个目录，则要进入这个子目录重复上面的操作。&lt;/p&gt;
&lt;p&gt;但是，我们不需要进入表示目录自身的"."目录，也不需要进入上级目录".."。&lt;/p&gt;
&lt;p&gt;因此，我们的files-in-below-directory函数必须完成这些任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检查是否有文件以.el尾；如果是则添加到list。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查是否有文件名是一个目录，如果是，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查它是否为&lt;code&gt;.&lt;/code&gt;或&lt;code&gt;..&lt;/code&gt;；如果是则跳过，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果不是则进入那个目录重复上面的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们将使用while循环在同一个目录中从一个文件移到另一个文件，检查文件是否是需要的；如果是一个子目录则递归调用。递归使用"acumulate"模式，使用append合并结果。&lt;/p&gt;
&lt;p&gt;这里是函数定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;files-in-below-directory&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;directory&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"List the .el files in DIRECTORY and in its sub-directories."&lt;/span&gt;
  &lt;span class="c1"&gt;;; Although the function will be used non-interactively,&lt;/span&gt;
  &lt;span class="c1"&gt;;; it will be easier to test if we make it interactive.&lt;/span&gt;
  &lt;span class="c1"&gt;;; The directory will have a name such as&lt;/span&gt;
  &lt;span class="c1"&gt;;;  "/usr/local/share/emacs/21.0.100/lisp/"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"DDirectory name: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;el-files-list&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;current-directory-list&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;directory-files-and-attributes&lt;/span&gt; &lt;span class="nv"&gt;directory&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="c1"&gt;;; while we are in the current directory&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
       &lt;span class="c1"&gt;;; check to see whether filename ends in `.el'&lt;/span&gt;
       &lt;span class="c1"&gt;;; and if so, append its name to a list.&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="s"&gt;".el"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mi"&gt;-3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;el-files-list&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="nv"&gt;el-files-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
       &lt;span class="c1"&gt;;; check whether filename is that of a directory&lt;/span&gt;
       &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
        &lt;span class="c1"&gt;;; decide whether to skip or recurse&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;or&lt;/span&gt; &lt;span class="s"&gt;"."&lt;/span&gt; &lt;span class="s"&gt;".."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="c1"&gt;;; then do nothing if filename is that of&lt;/span&gt;
            &lt;span class="c1"&gt;;;   current directory or parent&lt;/span&gt;
            &lt;span class="p"&gt;()&lt;/span&gt;
          &lt;span class="c1"&gt;;; else descend into the directory and repeat the process&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;el-files-list&lt;/span&gt;
                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;append&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;files-in-below-directory&lt;/span&gt;
                  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                 &lt;span class="nv"&gt;el-files-list&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
      &lt;span class="c1"&gt;;; move to the next filename in the list; this also&lt;/span&gt;
      &lt;span class="c1"&gt;;; shortens the list so the while loop eventually comes to an end&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;current-directory-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="c1"&gt;;; return the filenames&lt;/span&gt;
    &lt;span class="nv"&gt;el-files-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;files-in-below-directory directory-files函数需要一个参数，目录名称。&lt;/p&gt;
&lt;p&gt;在我的系统上，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;files-in-below-directory&lt;/span&gt; &lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/lisp/"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我的版本是12.0.100，Lisp源码目录包含754个&lt;code&gt;.el&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;files-in-below-directory返回的list是按字母逆序排列的，可以用一个语句来按字母顺序排列：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;sort&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;files-in-below-directory&lt;/span&gt; &lt;span class="s"&gt;"/usr/local/share/emacs/21.0.100/lisp/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="ss"&gt;'string-lessp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="tong-ji-han-shu-ding-yi-de-shu-liang"&gt;统计函数定义的数量&lt;/h3&gt;
&lt;p&gt;我们当前的目标是产生一个list告诉我们有多少个函数定义包含少于10个单词和符号，多少个函数包含10到19个单词和符号，等等。&lt;/p&gt;
&lt;p&gt;对于一个排了序的list这很简单：统计list中有多少个元素小于10，然后计算有多少个小于20，如些继续。每个范围的数字，我们可以用一个列表top-of-ranges来定义。&lt;/p&gt;
&lt;p&gt;如果需要，我们可以自动生成这个list，手写也比较简单。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;
 &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;  &lt;span class="mi"&gt;20&lt;/span&gt;  &lt;span class="mi"&gt;30&lt;/span&gt;  &lt;span class="mi"&gt;40&lt;/span&gt;  &lt;span class="mi"&gt;50&lt;/span&gt;
   &lt;span class="mi"&gt;60&lt;/span&gt;  &lt;span class="mi"&gt;70&lt;/span&gt;  &lt;span class="mi"&gt;80&lt;/span&gt;  &lt;span class="mi"&gt;90&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;
  &lt;span class="mi"&gt;110&lt;/span&gt; &lt;span class="mi"&gt;120&lt;/span&gt; &lt;span class="mi"&gt;130&lt;/span&gt; &lt;span class="mi"&gt;140&lt;/span&gt; &lt;span class="mi"&gt;150&lt;/span&gt;
  &lt;span class="mi"&gt;160&lt;/span&gt; &lt;span class="mi"&gt;170&lt;/span&gt; &lt;span class="mi"&gt;180&lt;/span&gt; &lt;span class="mi"&gt;190&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;
  &lt;span class="mi"&gt;210&lt;/span&gt; &lt;span class="mi"&gt;220&lt;/span&gt; &lt;span class="mi"&gt;230&lt;/span&gt; &lt;span class="mi"&gt;240&lt;/span&gt; &lt;span class="mi"&gt;250&lt;/span&gt;
  &lt;span class="mi"&gt;260&lt;/span&gt; &lt;span class="mi"&gt;270&lt;/span&gt; &lt;span class="mi"&gt;280&lt;/span&gt; &lt;span class="mi"&gt;290&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="s"&gt;"List specifying ranges for &lt;/span&gt;&lt;span class="ss"&gt;`defuns-per-range'&lt;/span&gt;&lt;span class="s"&gt;."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要修改范围，我们只需要编辑这个list。&lt;/p&gt;
&lt;p&gt;接下来我们需要编写函数创建一个包含各个范围数量的列表。这个函数必须传递两个参数，sorted-lengths和top-of-ranges。&lt;/p&gt;
&lt;p&gt;defuns-per-range函数必须重复做两件事：它必须统计当前top-of-range值范围内的数字的数量；在一个范围内的数字统计完成后，它必须移到top-of-ranges的下一个值。由于，每个操作都是重复的，我们可以使用while循环来完成这个工作。一个循环统计一个top-of-ranges中当前范围中定义的数量，另一个循环依次取top-of-range的下一个值。&lt;/p&gt;
&lt;p&gt;sorted-lengths列表需要在各个范围内进行多次计数，因此处理sorted-lengths的循环应该在处理top-of-ranges列表的循环的内部。&lt;/p&gt;
&lt;p&gt;内部的循环统计一定范围内的数量。可以用一个简单的循环。循环的true-or-false-test检查sorted-lengths列表是否小于top-of-range的当前值。如果是，则函数将计数器加1，然后检查sorted-lengths列表的下一个值。&lt;/p&gt;
&lt;p&gt;内部的循环如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;length-element-smaller-than-top-of-range&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;外部的循环从top-of-ranges列表的最小值开始，依次设置为更大的值。循环如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;
  &lt;span class="nv"&gt;body-of-loop...&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个循环放在一起如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;

  &lt;span class="c1"&gt;;; Count the number of elements within the current range.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;length-element-smaller-than-top-of-range&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

  &lt;span class="c1"&gt;;; Move to next range.&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，每上外部循环，Emacs都要在一个list中记录这个范围内的数量(number-within-range)。我们可以使用cons来达到这个目的。&lt;/p&gt;
&lt;p&gt;cons函数工作得很好，它构造的list中，最大范围的将位于开始位置，小范围的位于结束位置。这是因为cons将新元素添加到list的开始位置，在两个循环中将从小到大的顺序执行，defuns-per-range-list将以最大的数字开始。但我们打印的图表需要以小数字开始。解决的办法是逆序排列。使用nreverse函数。&lt;/p&gt;
&lt;p&gt;举例来说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nreverse&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="nv"&gt;produces:&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，nreverse函数是一个"destructive"（破坏性的函数）类型的函数，它将修改所操作的list；相反的函数是car和cdr函数，它们是"非破坏性的"。在这里，我们不需要原始的defun-per-range-list，因此不必担心破坏性的问题。（reverse函数担任了逆序复制list的功能，它也不修改原始的list。）&lt;/p&gt;
&lt;p&gt;整个defuns-per-range函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;defuns-per-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;sorted-lengths&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"SORTED-LENGTHS defuns in each TOP-OF-RANGES range."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;top-of-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;;; Outer loop.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;

      &lt;span class="c1"&gt;;; Inner loop.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt;
              &lt;span class="c1"&gt;;; Need number for numeric test.&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
              &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;top-of-range&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

        &lt;span class="c1"&gt;;; Count number of definitions within current range.&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

      &lt;span class="c1"&gt;;; Exit inner loop but remain within outer loop.&lt;/span&gt;

      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-within-range&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;; Reset count to zero.&lt;/span&gt;

      &lt;span class="c1"&gt;;; Move to next range.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="c1"&gt;;; Specify next top of range value.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;top-of-range&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;top-of-ranges&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Exit outer loop and count the number of defuns larger than&lt;/span&gt;
    &lt;span class="c1"&gt;;;   the largest top-of-range value.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
           &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Return a list of the number of definitions within each range,&lt;/span&gt;
    &lt;span class="c1"&gt;;;   smallest to largest.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;nreverse&lt;/span&gt; &lt;span class="nv"&gt;defuns-per-range-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个函数很直观，除了一个地方。内部循环的true-or-false-test：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;sorted-lengths&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;top-of-range&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被替换为了
&amp;lt;src lang="emacs-lisp"
(and (car sorted-lengths)
     (&amp;lt; (car sorted-lengths) top-of-range))&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;这个测试的目的是为了决定sorted-lengths列表的第一个元素是否小于范围的值。

简单版本的test在sorted-lengthslist有一个nil值时可以工作。在那种情况下，(car sorted-lengths)将返回nil。而`&amp;lt;`函数不能比较数字和nil，因此Emacs将产生错误信息并停止执行。

在统计到list的结束位置时，sorted-lengths列表将变为nil。这样如果使用简单版本的函数在test时也将出错。

解决这个问题的办法就是使用(car sorted-length)语句和and语句。(car sorted-lengths)语句在list中有至少一个值时，会返回一个non-nil值，但如果list为空时将返回nil。and语句先执行(car sorted-lengths)，如果它返回nil，则返回false而不执行`&amp;lt;`语句。如果(car sorteed-lengths)语句返回的是non-nil值，and语句将执行`&amp;lt;`语句，返回值将是and语句的值。

这样，我们避免了一个错误。

这里有一个简短版本的defuns-per-range函数。首先，将top-of-ranges设置为一个list，然后设置sorted-lengths，执行defuns-per-range函数
```emacs-lisp
;; (Shorter list than we will use later.)
(setq top-of-ranges
 '(110 120 130 140 150
   160 170 180 190 200))

(setq sorted-lengths
      '(85 86 110 116 122 129 154 176 179 200 265 300 300))

(defuns-per-range sorted-lengths top-of-ranges)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回的list如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上，sorted-lengths中有两个元素小于110，两个元素在110和119之间，两个元素在120和129之间，等等。有四个元素大于或等于200。&lt;/p&gt;
&lt;h1&gt;准备图表&lt;/h1&gt;
&lt;p&gt;我们的目标是构造一个图表显示Emacs lisp源码中所有函数定义的长度范围。&lt;/p&gt;
&lt;p&gt;在实际应用中，如果你要创建一个图表，你可能会使用gnuplot之类的程序来完成这个工作。（gnuplot与GNU Emacs集成得很好。）但在这里，我们将使用前面我们所学的知识来完成这个工作。&lt;/p&gt;
&lt;p&gt;在这章，我们将先编写一个简单的图表打印函数。第一个版本将作为原型，在此基础上来增强。&lt;/p&gt;
&lt;h2&gt;打印图表列&lt;/h2&gt;
&lt;p&gt;由于Emacs被设计为能在各种终端上工作，包括字符终端，图表需要是可打印字符。我们可以使用星号来打印图表。&lt;/p&gt;
&lt;p&gt;我们把这个函数命名为graph-body-print；它使用numbers-list作为参数。&lt;/p&gt;
&lt;p&gt;graph-body-print函数根据numbers-list中的每个原素，分别插入垂直方向的星号列。每一列的高度取决于numbers-list上元素值的大小。&lt;/p&gt;
&lt;p&gt;插入列是一个重复动作，因此函数可以用while循环或递归实现。&lt;/p&gt;
&lt;p&gt;我们面临的第一个挑战就是如何打印星号列。通常，在Emacs我们打印字符的时候是横向打印的，一行一行的打印。我们有两个办法来实现：编写我们自己的列插入函数或者查找Emacs中是否有现成的方法。&lt;/p&gt;
&lt;p&gt;为查找Emacs中的函数，我们可以使用M-x apropos命令。这个命令与C-h a(command-apropos)命令类似，但后者只查找作为命令的函数。而M-x apropos命令将列出所有匹配正则表达式的符号，包括那些非交互式的函数。&lt;/p&gt;
&lt;p&gt;我们想找到那些可以打印或插入纵向列的命令。这个函数的名称肯定包含有'print'或'insert'或'column'等单词。因此，我们只要输入&lt;code&gt;M-x apropos RET print\|insert\|column RET&lt;/code&gt;并查看结果。在我们系统上，这个命令执行需要一些时间，结果包含有79个函数和变量。查找这个列表，我们看到有个insert-rectangle函数有可能能完成这个工作。&lt;/p&gt;
&lt;p&gt;这个函数文档如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;insert-rectangle:
Insert text of RECTANGLE with upper left corner at point.
RECTANGLE's first line is inserted at point,
its second line is inserted at a point vertically under point, etc.
RECTANGLE should be a list of strings.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以测试一下，以确认它是否如我们期望的那样工作。&lt;/p&gt;
&lt;p&gt;把光标放在insert-rectange语句的后面按C-u C-x C-e(eval-last-sexp)。这个函数将在point的下面插入"first","second","third"。函数返回值为nil。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;insert-rectangle&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"first"&lt;/span&gt; &lt;span class="s"&gt;"second"&lt;/span&gt; &lt;span class="s"&gt;"third"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="nv"&gt;first&lt;/span&gt;
                                              &lt;span class="nv"&gt;second&lt;/span&gt;
                                              &lt;span class="nv"&gt;third&lt;/span&gt;
&lt;span class="no"&gt;nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在绘制图表的程序中使用这上函数。我们需要先确保point位于需要插入的位置，然后用insert-rectangle函数插入列。&lt;/p&gt;
&lt;p&gt;如果你是在Info中读取这个文档，你可以切换到另一个缓冲区，比如&lt;code&gt;*scratch*&lt;/code&gt;，将point放在任何地方，输入&lt;code&gt;M-:&lt;/code&gt;，在提示区输入insert-rectangle语句，然后回车。Emacs将执行输入的语句，交把&lt;code&gt;*scratch*&lt;/code&gt;缓冲区中的point位置作为point的值。（&lt;code&gt;M-:&lt;/code&gt;被绑定到eval-expression上。）&lt;/p&gt;
&lt;p&gt;我们将发现当执行完成插入后，point被设置在了最后插入的那行，也就是说这个函数移动了point。如果我们重复执行这个命令，下次插入的内容将在上次插入内容的下面。我们并不需要这样，我们需要的是一个柱状图表，一列挨着一列。&lt;/p&gt;
&lt;p&gt;我们看出每次while循环插入列时必须重新设置point的位置，这个位置必须在列的顶部，而不是在底部。并且，我们打印图表时，并不需要每个列都一样高。这意味着每个列的顶部并不是一样高的。我们不能简单在一同一行上执行同一个操作，而是需要先将point移到正确的位置。&lt;/p&gt;
&lt;p&gt;我们准备用星号来描述柱状图。星号的数量取决于当前numbers-list中元素的值。我们需要构造一个包含星号的列表以便insert-rectangle来画出正确高度的列。如果这个list只包含一定数量的星号，那我们就必须在绘制前将point设置到正确的高度。这比较困难。&lt;/p&gt;
&lt;p&gt;我们可以想出另外一种方式，每次传递给insert-rectangle一个同样长度的list，它们可以在同一行插入，每次插入时只需要向右移动一列。比如，如果最高的高度为5，但实际高度只有3，则insert-rectangle需要的参数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一个需求不是很难，我们需要决定列的高度。有两种方法：我们可以使用任意的值或使用整个list中最大的数字作为最大高度值。Emacs中提供了内置的函数检查参数中的最大值。我们可以使用这个函数。这个函数被称为max它返回它所有参数中的最大值。例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;max&lt;/span&gt;  &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将返回7。（相反的函数是min它返回参数中最小的值）&lt;/p&gt;
&lt;p&gt;但是，我们不能简单的在numbers-list上调用max；max函数需要数字类型的参数，而不是包含数字的list。因此，下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;max&lt;/span&gt;  &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将出错：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Wrong type of argument:  number-or-marker-p, (3 4 6 5 7 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要一个函数将list拆开作为参数传递给函数。这个函数是apply。这个函数将其它的参数传递给它的第一个参数，它的最后一个参数可以是一个list。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply&lt;/span&gt; &lt;span class="ss"&gt;'max&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将返回8。&lt;/p&gt;
&lt;p&gt;（顺便说一句，我不知道你如何学习书本上没有介绍过的函数。可以根据函数名称，比如search-forward或insert-rectangle，根据他们的部分名称使用apropos查找函数的相关信息。）&lt;/p&gt;
&lt;p&gt;传递给apply的第二个参数是可选参数，我们可以使用aplly调用一个函数并将list中的元素传递给这个函数，比如下面的代码也将返回8：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply&lt;/span&gt; &lt;span class="ss"&gt;'max&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面我们将使用apply。函数recursive-lengths-list-many-files返回包含数字的list，我们对其调用max。&lt;/p&gt;
&lt;p&gt;这样，查找图表中的最大数量的代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;max-graph-height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply&lt;/span&gt; &lt;span class="ss"&gt;'max&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们回到如何构造包含列图表字符串的list的问题上。知道图表的最大高度和星号的数量后，函数应该可以返回一个传递给insert-rectangle的list了。&lt;/p&gt;
&lt;p&gt;每一列由星号或空格构成。因为函数传递了列高度和列中的星号数量两个参数，空白的数量应该是高度减去星号数量。给出空白数量和星号数量后，两个循环可以构造出这个list：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; First version.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;column-of-graph&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;max-graph-height&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return list of strings that is one column of a graph."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;max-graph-height&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Fill in asterisks.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Fill in blanks.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Return whole list.&lt;/span&gt;
    &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装这个函数后，执行下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;column-of-graph&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将返回：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面所写，column-of-graph包含一个瑕疵：用于标识空白和列的符号是硬编码的，使用了空白和星号。这是一个很好的原型，如果其它人想换成其它的符号。比如用逗号代替空白，用加号代替星号等。程序应该更具弹性一些。应该使用两个变量来代替空白和星号：将graph-blank和graph-symbol定义为两个独立的变量。&lt;/p&gt;
&lt;p&gt;上面也没有编写文档。我们可以编写这个函数的第二个版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;graph-symbol&lt;/span&gt; &lt;span class="s"&gt;"*"&lt;/span&gt;
  &lt;span class="s"&gt;"String used as symbol in graph, usually an asterisk."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;defvar&lt;/span&gt; &lt;span class="nv"&gt;graph-blank&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt;
  &lt;span class="s"&gt;"String used as blank in graph, usually a blank space.&lt;/span&gt;
&lt;span class="s"&gt;graph-blank must be the same number of columns wide&lt;/span&gt;
&lt;span class="s"&gt;as graph-symbol."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;(For an explanation of defvar, see Initializing a Variable with defvar.)&lt;/span&gt;

&lt;span class="c1"&gt;;;; Second version.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;column-of-graph&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;max-graph-height&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph-symbols.&lt;/span&gt;
&lt;span class="s"&gt;The graph-symbols are contiguous entries at the end&lt;/span&gt;
&lt;span class="s"&gt;of the list.&lt;/span&gt;
&lt;span class="s"&gt;The list will be inserted as one column of a graph.&lt;/span&gt;
&lt;span class="s"&gt;The strings are either graph-blank or graph-symbol."&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;max-graph-height&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Fill in graph-symbols.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;graph-symbol&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;actual-height&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Fill in graph-blanks.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="nv"&gt;graph-blank&lt;/span&gt; &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1-&lt;/span&gt; &lt;span class="nv"&gt;number-of-top-blanks&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

    &lt;span class="c1"&gt;;; Return whole list.&lt;/span&gt;
    &lt;span class="nv"&gt;insert-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要，我们可以再次重写column-of-graph，使用线型图表代替柱状图表。这不会很困难。其中一个办法就是让柱状图中第一个星号以下的显示为空白。在构造线型图表的一个列时，函数首先构造一个空的list，长度比元素的值小1，然后用cons将符号和列表连接；然后再次使用cons将顶部用空白填充。&lt;/p&gt;
&lt;p&gt;现在，我们终于完成第一个打印图表的函数。它只打印了图表的body部分，而没有水平和垂直方向的轴，因此我们把这个函数称为graph-body-print。&lt;/p&gt;
&lt;h2&gt;graph-body-print函数&lt;/h2&gt;
&lt;p&gt;上一节，graph-body-print函数完成了打印图表列的功能。这应该是一个重复执行的动作。我们可以使用递减的while循环或递归函数来完成这些操作。这节，我们使用while循环来编写函数定义。&lt;/p&gt;
&lt;p&gt;column-of-graph函数需要图表高度作为参数，因此我们需要决定图表高度并将它保存到一个局部变量中。&lt;/p&gt;
&lt;p&gt;我们的使用while循环的函数模板如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;graph-body-print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"documentation..."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;height&lt;/span&gt;  &lt;span class="o"&gt;...&lt;/span&gt;
         &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;
      &lt;span class="nv"&gt;insert-columns-and-reposition-point&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要填空。&lt;/p&gt;
&lt;p&gt;我们可以用&lt;code&gt;(apply 'max numbers-list)&lt;/code&gt;获取图表的高度。&lt;/p&gt;
&lt;p&gt;while循环遍历numbers-list。并用&lt;code&gt;(setq numbers-list (cdr numbers-list))&lt;/code&gt;截短它。每次list的CAR值，就是传递给column-of-graph的参数。&lt;/p&gt;
&lt;p&gt;每个循环周期中，insert-rectangle函数使用column-of-graph插入list。由于insert-rectangle函数将point移到了插入的矩形区域的右下解，我们需要保存当前point的位置，在插入矩形区域后恢复point的位置，然后将point水平移动到下一个列，并再次调用insert-rectangle。&lt;/p&gt;
&lt;p&gt;如果被插入的列是一个字符宽（比如星号或一个空格），这个命令比较简单&lt;code&gt;(forward-char 1)&lt;/code&gt;；但如果列宽超过1。这时命令需要写为&lt;code&gt;(forward-char symbol-width)&lt;/code&gt;symbol-width是graph-blank的长度，可以使用&lt;code&gt;(length graph-blank)&lt;/code&gt;。可以在let语句的变量列表中设置symbol-width变量。&lt;/p&gt;
&lt;p&gt;函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;graph-body-print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print a bar graph of the NUMBERS-LIST.&lt;/span&gt;
&lt;span class="s"&gt;The numbers-list consists of the Y-axis values."&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply&lt;/span&gt; &lt;span class="ss"&gt;'max&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;symbol-width&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;graph-blank&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;from-position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;from-position&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;insert-rectangle&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;column-of-graph&lt;/span&gt; &lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;from-position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-char&lt;/span&gt; &lt;span class="nv"&gt;symbol-width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Draw graph column by column.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;sit-for&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="c1"&gt;;; Place point for X axis labels.&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-line&lt;/span&gt; &lt;span class="nv"&gt;height&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里出现了一个新的函数&lt;code&gt;(sit-for 0)&lt;/code&gt;。这个语句将使Emacs重绘屏幕。放在这里，Emacs将一列列的绘制。如果没有，Emacs在函数退出前都不会绘制。&lt;/p&gt;
&lt;p&gt;我们可以使用一个较短的包含数字的list来测试graph-body-print。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装graph-symbol,graph-blank,column-of-graph，graph-body-print。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制下面的语句：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;graph-body-print&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;切换到&lt;code&gt;*scratch*&lt;/code&gt;缓冲区并把光标放置在要绘制的开始位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入&lt;code&gt;M-:(eval-expresion)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Yank(C-Y) graph-body-print语句到缓冲区中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;6.　回车执行graph-body-print语句。&lt;/p&gt;
&lt;p&gt;Emacs将打印出下面的图表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                    *
                *   **
                *  ****
               *** ****
              ********* *
             ************
            *************
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;recursive-graph-body-print函数&lt;/h2&gt;
&lt;p&gt;graph-body-print函数也可以用递归来编写。递归分解为两个部分：外部使用let包装，决定几个变量的值，比如图表最大高度，内部的函数调用是递归调用，用于打印图表，&lt;/p&gt;
&lt;p&gt;包装部分不复杂：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-graph-body-print&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print a bar graph of the NUMBERS-LIST.&lt;/span&gt;
&lt;span class="s"&gt;The numbers-list consists of the Y-axis values."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;apply&lt;/span&gt; &lt;span class="ss"&gt;'max&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;symbol-width&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;length&lt;/span&gt; &lt;span class="nv"&gt;graph-blank&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="nv"&gt;from-position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-graph-body-print-internal&lt;/span&gt;
     &lt;span class="nv"&gt;numbers-list&lt;/span&gt;
     &lt;span class="nv"&gt;height&lt;/span&gt;
     &lt;span class="nv"&gt;symbol-width&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归函数部分有点复杂。它有四个部分：'do-again-test'打印操作的代码，递归调用，'next-step-expression'。'do-again-test'是一个if语句用于检查numbers-list是否还有元素，如果有函数将使用打印操作的代码打印一个列，并再次调用自身。函数调用自身时'next-step-expressin'将截短numbers-list。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;recursive-graph-body-print-internal&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;numbers-list&lt;/span&gt; &lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="nv"&gt;symbol-width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Print a bar graph.&lt;/span&gt;
&lt;span class="s"&gt;Used within recursive-graph-body-print function."&lt;/span&gt;

  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;from-position&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;insert-rectangle&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;column-of-graph&lt;/span&gt; &lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;car&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;from-position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;forward-char&lt;/span&gt; &lt;span class="nv"&gt;symbol-width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;sit-for&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;; Draw graph column by column.&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-graph-body-print-internal&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cdr&lt;/span&gt; &lt;span class="nv"&gt;numbers-list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;height&lt;/span&gt; &lt;span class="nv"&gt;symbol-width&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在安装这个函数后，可以用下面的例子测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;recursive-graph-body-print&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;                *
               **   *
              ****  *
              **** ***
            * *********
            ************
            *************
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;.emacs文件&lt;/h1&gt;
&lt;h2&gt;Emacs的缺省配置&lt;/h2&gt;
&lt;p&gt;Emacs缺省配置的优点。Emacs在你编辑C文件时将启动C mod，编写Fortan源文件时启动Fortran mode，编写未知文件时使用Fundamental mod。这些都是自动检测的，不需要干预。&lt;/p&gt;
&lt;p&gt;可以通过~/.emacs对Emacs进行定制。这是你个人的初始化文件；它的内容是Emacs Lisp代码。&lt;/p&gt;
&lt;h2&gt;全局初始化文件&lt;/h2&gt;
&lt;p&gt;除了个人初始化文件外，Emacs将自动加载全局初始化文件，这与.emacs文件一样，但它将被所有的用户加载。&lt;/p&gt;
&lt;p&gt;有两个全局初始化文件site-load.el和site-init.el，在被加载到Emacs后被'dumped'（如果Emacs 'dumped'版本被创建，Dumped的Emacs复制版本加载更快）。但是，一旦文件被加载并被dumped，对文件的修改将不会影响Emacs除非你re-dump Emacs（详情，请查找INSTALL文件）。&lt;/p&gt;
&lt;p&gt;有3个全局文件在每次启动Emacs时被执行（如果他们存在）。site-start.el在.emacs文件执行前执行，default.el和终端类型文件，这两上在.emacs加载后执行。&lt;/p&gt;
&lt;p&gt;.emacs中的设置将覆盖site-start.el中的设置。default.el或终端类型文件将覆盖.emacs文件。（可以通过设置term-file-prefix为nil来防止与终端类型文件冲突）&lt;/p&gt;
&lt;p&gt;发行版本中的INSTALL文件描述了site-init.el和site-load.el文件。&lt;/p&gt;
&lt;p&gt;loadup.el,startup.el,loaddefs.el文件控制加载的过程。这些文件在Emacs发行版本的lisp目录中，值得精读。&lt;/p&gt;
&lt;p&gt;loaddefs.el包含了大量设置.emacs文件或全局初始化文件的建议。&lt;/p&gt;
&lt;h2&gt;使用defcustom设置变量&lt;/h2&gt;
&lt;p&gt;可以使用defcustom以使用使用Emacs的customize功能设置变量的值。（不可以将customize用于函数定义；但可以在.emacs中使用defuns）实际上，可以在.emacs中写任何的Lisp语句。&lt;/p&gt;
&lt;p&gt;customize功能取决于defcustom。忙乎你可以使用defvar或setq来设置变量，但defcustom是被设计为做此项工作的。&lt;/p&gt;
&lt;p&gt;你可以将defvar的知识运用到defcustom的3个参数中。第一个参数是变量名称。第二个参数如果存在则表示变量实始值，并且这个值只会在变量未设置值时设置。第三个参数是文档字符串。&lt;/p&gt;
&lt;p&gt;第四个和后面的参数是为defcustom设置类型和选项的；这些是defvar所没有的功能。(这些参数是可选的)&lt;/p&gt;
&lt;p&gt;这些参数的每个值由键值对组成。每个键以一个字母开头：&lt;/p&gt;
&lt;p&gt;举例来说，用户自定义变量text-mode-hook如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defcustom&lt;/span&gt; &lt;span class="nv"&gt;text-mode-hook&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;
  &lt;span class="s"&gt;"Normal hook run when entering Text mode and many related modes."&lt;/span&gt;
  &lt;span class="nb"&gt;:type&lt;/span&gt; &lt;span class="ss"&gt;'hook&lt;/span&gt;
  &lt;span class="nb"&gt;:options&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;turn-on-auto-fill&lt;/span&gt; &lt;span class="nv"&gt;flyspell-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nb"&gt;:group&lt;/span&gt; &lt;span class="ss"&gt;'data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量text-mode-hook；没有缺省值；并且它的文档字符串告诉你它起什么作用。&lt;/p&gt;
&lt;p&gt;:type关键字告诉Emacs应该给text-mode-hook设置什么样的数据，在一个自定义缓冲区中如何显示它的值。&lt;/p&gt;
&lt;p&gt;:options关键词，指定了一个备选值的列表。可以用于这个hook的:options。列表中的仅是建议值，并不是唯一备选值；人们可以设置为其它的任意值；:options关键字给用户提出了最合适的建议。&lt;/p&gt;
&lt;p&gt;最后是:group关键字，它告诉Emacs的自定义命令将这个变量分到哪个组，以便于查找这个变量。&lt;/p&gt;
&lt;p&gt;以text-mode-hook为例。&lt;/p&gt;
&lt;p&gt;有两种方式来定制这个变量。你可以使用自定义变量的命令或者编写适当的语句。&lt;/p&gt;
&lt;p&gt;使用自定义变量命令，可以输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x customize
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找到对就的分组'data'。进入这个分组。TextMode Hook是第一个成员。你可以点击它的选项来设置它的值。最后点击下面的按钮&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Save for Future Sessions
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Emacs将会向.emacs文件中写入下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;custom-set-variables&lt;/span&gt;
  &lt;span class="c1"&gt;;; custom-set-variables was added by Custom --&lt;/span&gt;
  &lt;span class="c1"&gt;;;                           don't edit or cut/paste it!&lt;/span&gt;
  &lt;span class="c1"&gt;;; Your init file should contain only one such instance.&lt;/span&gt;
 &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;text-mode-hook&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;turn-on-auto-fill&lt;/span&gt; &lt;span class="nv"&gt;text-mode-hook-identify&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（text-mode-hook-identify函数告诉toggle-text-mode-auto-fill哪个缓冲区处于Text mode。）&lt;/p&gt;
&lt;p&gt;你可以不用管警告信息来修改这些语句。警告的目的是为了恐吓那些不明白自己在做什么的人。&lt;/p&gt;
&lt;p&gt;custom-set-variables的工作与setq不同。我从不去了解这些不同，我不手工修改.emacs中的custom-set-variables语句。&lt;/p&gt;
&lt;p&gt;另一个custom-set-...函数是custom-set-faces。这个函数设置字体外观。&lt;/p&gt;
&lt;p&gt;第二种定制text-mode-hook的方法是在.emacs中编写代码，与custom-set-...函数无关。&lt;/p&gt;
&lt;h2&gt;开始编写一个.emacs文件&lt;/h2&gt;
&lt;p&gt;启动Emacs时，将加载你的.emacs文件，除非你在命令行使用了-q命令（emacs -q）。&lt;/p&gt;
&lt;p&gt;.emacs文件包含了Lisp语句。通常是设值语句，有时有函数定义。&lt;/p&gt;
&lt;p&gt;这章将以作者的.emacs文件为例。&lt;/p&gt;
&lt;p&gt;文件的第一个部分是注释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;;; Bob's .emacs file&lt;/span&gt;
&lt;span class="c1"&gt;;; Robert J. Chassell&lt;/span&gt;
&lt;span class="c1"&gt;;; 26 September 1985&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看看时间，在很久以前加的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Each section in this file is introduced by a&lt;/span&gt;
&lt;span class="c1"&gt;;; line beginning with four semicolons; and each&lt;/span&gt;
&lt;span class="c1"&gt;;; entry is introduced by a line beginning with&lt;/span&gt;
&lt;span class="c1"&gt;;; three semicolons.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段描述是Emacs Lisp的习惯性注释方式。分号后面是注释。两个、三个或四个分号用于区分章节。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;;; The Help Key&lt;/span&gt;
&lt;span class="c1"&gt;;; Control-h is the help key;&lt;/span&gt;
&lt;span class="c1"&gt;;; after typing control-h, type a letter to&lt;/span&gt;
&lt;span class="c1"&gt;;; indicate the subject about which you want help.&lt;/span&gt;
&lt;span class="c1"&gt;;; For an explanation of the help facility,&lt;/span&gt;
&lt;span class="c1"&gt;;; type control-h two times in a row.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;记住：输入C-h两次显示帮助。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; To find out about any mode, type control-h m&lt;/span&gt;
&lt;span class="c1"&gt;;; while in that mode.  For example, to find out&lt;/span&gt;
&lt;span class="c1"&gt;;; about mail mode, enter mail mode and then type&lt;/span&gt;
&lt;span class="c1"&gt;;; control-h m.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;'Mode help'非常有用，它告诉你所有你需要知道的。&lt;/p&gt;
&lt;p&gt;当然你不需要在你的.emacs文件包含这些。我添加这些只是为了记住Model help或者注释约定。&lt;/p&gt;
&lt;h2&gt;Text 和 Auto Fill Mode&lt;/h2&gt;
&lt;p&gt;接下来到'tuns on' Text mode和Auto Fill mode。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Text mode and Auto Fill mode&lt;/span&gt;
&lt;span class="c1"&gt;;; The next three lines put Emacs into Text mode&lt;/span&gt;
&lt;span class="c1"&gt;;; and Auto Fill mode, and are for writers who&lt;/span&gt;
&lt;span class="c1"&gt;;; want to start writing prose rather than code.&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;default-major-mode&lt;/span&gt; &lt;span class="ss"&gt;'text-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook-identify&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook&lt;/span&gt; &lt;span class="ss"&gt;'turn-on-auto-fill&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面两行告诉Emacs在打开文件时，如果找不到对应的mode就打开Text mode。&lt;/p&gt;
&lt;p&gt;当Emacs读取一个文件时，它查找文件的扩展名，如果有，如果以.c或.h结尾，Emacs开启C mode。Emacs也会检查文件的第一个非空白行；如果行上有&lt;code&gt;-*- C -*-&lt;/code&gt;，Emacs也会开启C mode。Emacs处理了一个扩展名列表。In addition, Emacs looks near the last page for a per-buffer, "local variables list",if any.&lt;/p&gt;
&lt;p&gt;现在，回到.emacs文件。&lt;/p&gt;
&lt;p&gt;又出现了这行；它是如何工作的？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;default-major-mode&lt;/span&gt; &lt;span class="ss"&gt;'text-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这行是一个完整的Emacs Lisp语句。&lt;/p&gt;
&lt;p&gt;它使用了我们早已经熟悉的setq。它设置变量default-major-mode为text-mode。单引号告诉Emacs把text-mode直接作为变量。&lt;/p&gt;
&lt;p&gt;接下来的两行是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook-identify&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;add-hook&lt;/span&gt; &lt;span class="ss"&gt;'text-mode-hook&lt;/span&gt; &lt;span class="ss"&gt;'turn-on-auto-fill&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两行中，add-hook首先添加了text-mode-hook-identify到变量text-mode-hook中，然后添加了turn-on-auto-fill到这个变量中。&lt;/p&gt;
&lt;p&gt;turn-on-auto-fill是程序名称，它开启Auto Fill mode。text-mode-hook-identify是一个函数，它告诉toggle-text-mode-auto-fill哪个缓冲区处于Text mode。&lt;/p&gt;
&lt;p&gt;每次Emacs进入Text mode，Emacs将会执行'hooked'命令。因此，每次Emacs开启Text mode时，Emacs也将开启Auto Fill mode。&lt;/p&gt;
&lt;p&gt;简单来说，第一行让Emacs在编辑文件时自动进入Text mode，除非文件扩展名或第一个非空行或局部变量能告诉Emacs该进入哪种mode。&lt;/p&gt;
&lt;p&gt;Text mode中有其它动作，设置语法表以便于编写。在Text mode中，Emacs像处理信件一样把省略号当作单词的一部分；但Emacs不会把逗号或空白当作单词的一部分。因此M-f将移过it's。另一方面，在C mode中，M-f将在it's中t的后面停止。&lt;/p&gt;
&lt;p&gt;第二和第三行将使Emacs在进入Text mode时开启Auto Fill mode。在Auto Fill mode中，Emacs自动换行，并将过长的部分移到下一行。Emacs会在单词之间换行，而不会把单词截断。&lt;/p&gt;
&lt;p&gt;当Auto Fill mode关闭时，文件中的行将与输入时保持一致。取决于trucate-lines变量的值，你输入的单词有可能消失在屏幕的右边，也有可以显示以非常乱的方式显示，也有可能显示为一个非常长的行。&lt;/p&gt;
&lt;p&gt;另外，在我的.emacs文件的这一部分，我告诉Emacs在分号后添加两个空格：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;colon-double-space&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;邮件别名&lt;/h2&gt;
&lt;p&gt;这里使用setq开启邮件别名，也有一些用于提醒的注释。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Mail mode&lt;/span&gt;
&lt;span class="c1"&gt;;; To enter mail mode, type `C-x m'&lt;/span&gt;
&lt;span class="c1"&gt;;; To enter RMAIL (for reading mail),&lt;/span&gt;
&lt;span class="c1"&gt;;; type `M-x rmail'&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;mail-aliases&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;setq命令设置变量mail-aliases为t。因为t表示true，这行就是在说"Yes,use mail aliases."&lt;/p&gt;
&lt;p&gt;邮件别名是一种email地址的缩写。别名保存在~/.mailrc中。你可以这样书写：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alias geo george@foobar.wiz.edu
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当你给George发邮件时，地址可以输入geo；邮件发送者将自动将geo展开为完整的邮箱地址。&lt;/p&gt;
&lt;h2&gt;Indent Tabs Mode&lt;/h2&gt;
&lt;p&gt;缺省情况下，Emacs在格式化一个区域时会在需要空白的位置插入tab。（比如在需要缩进时）。Tab在使用终端或普通打印机时看起来很正常，但如果是在TeX或Texinfo中就会不正常。因为TeX将忽略tab。&lt;/p&gt;
&lt;p&gt;下面的代码关闭Tabs mode：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Prevent Extraneous Tabs&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq-default&lt;/span&gt; &lt;span class="nv"&gt;indent-tabs-mode&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，这里使用了setq-default而不是使用setq。setq-default命令只会在局部变量没有值时设置这个变量的值。&lt;/p&gt;
&lt;h2&gt;一些按键绑定&lt;/h2&gt;
&lt;p&gt;下面是一些个性化的按键绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Compare windows&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-cw"&lt;/span&gt; &lt;span class="ss"&gt;'compare-windows&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;compare-window将比较当前窗口中的文本和下一个窗口中的文本。&lt;/p&gt;
&lt;p&gt;这里也显示了如何设置一个全局按键绑定，它在任何mode下都有效。&lt;/p&gt;
&lt;p&gt;命令global-set-key后面跟按键绑定。在.emacs文件中，按键绑定被书写为：&lt;code&gt;\C-c&lt;/code&gt;表示'control-c'，表示'按住control键的同时按c键'。w表示'按w键'。按键设置用双引号包含。在编写文档的时候，你可以写成C-c w。（如果绑定的键是&lt;meta/&gt;键，比如M-c则书写为&lt;code&gt;\M-c&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;这个按键组成将调用compare-windows命令。注意，compare-windows前面有一个单引号；如果不加Emacs将对它求值。&lt;/p&gt;
&lt;p&gt;三件事：双引号，C前面的反余线和单引号。&lt;/p&gt;
&lt;p&gt;这里还有另一个按键绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Keybinding for `occur'&lt;/span&gt;
&lt;span class="c1"&gt;;; I use occur a lot, so let's bind it to a key:&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-co"&lt;/span&gt; &lt;span class="ss"&gt;'occur&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;occur命令显示当前缓冲区中匹配某个正则表达式的所有行。匹配的行被显示在&lt;code&gt;*Occur*&lt;/code&gt;缓冲区中。&lt;/p&gt;
&lt;p&gt;下面演示了如何取消一个按键绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Unbind `C-x f'&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-unset-key&lt;/span&gt; &lt;span class="s"&gt;"\C-xf"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取消这个绑定的原因是：我经常在需要输入C-x C-f时输入了C-x f。&lt;/p&gt;
&lt;p&gt;下面的语句重新设置了一个已经存在的绑定：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Rebind `C-x C-b' for `buffer-menu'&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-x\C-b"&lt;/span&gt; &lt;span class="ss"&gt;'buffer-menu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缺省情况下C-x C-b执行list-buffer命令。这个命令在另一个window中列出缓冲区。因为我几乎一直都需要在那个窗口中做一些操作，我比较喜欢buffer-menu命令，它不只是列出缓冲区，也会将point移到那个窗口中。&lt;/p&gt;
&lt;h2&gt;Keymaps&lt;/h2&gt;
&lt;p&gt;Emacs使用keymaps记录按键与命令的对应关系。当使用global-set-key设置按键绑定时，就是在current-global-map中指定了一个按键绑定。&lt;/p&gt;
&lt;p&gt;特殊的模式下，比如C mode或Text mode，有他们自己的按键绑定；它将覆盖全局keymap。&lt;/p&gt;
&lt;p&gt;global-set-key函数用于绑定或重新绑定全局keymap。比如，下面的代码将C-x C-b绑定到buffer-menu函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-x\C-b"&lt;/span&gt; &lt;span class="ss"&gt;'buffer-menu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特殊模式下的keymap用defin-key设置，它接收一个指定的keymap作为参数，还有按键组合和命令。比如，我的.emacs文件包含下面的语句绑定textinfo-insert-@group命令到C-c C-c g：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;define-key&lt;/span&gt; &lt;span class="nv"&gt;texinfo-mode-map&lt;/span&gt; &lt;span class="s"&gt;"\C-c\C-cg"&lt;/span&gt; &lt;span class="ss"&gt;'texinfo-insert-@group&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;text-info-insert-@group函数是一个Texinfo mode下的扩展，它用于在Texinfo文件中插入@group标记。我可以用三次按键C-c C-c g来输入，而不需要按六个键@ g r o u p。（@group与@end匹配，group命令用于保持它所包含的文本被放在同一页上）&lt;/p&gt;
&lt;p&gt;下面是texinfo-insert-@group函数的定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;texinfo-insert-@group&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Insert the string @group in a Texinfo buffer."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;beginning-of-line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"@group\n"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（当然，我也可以用Abbrev来完成类似工作，而不需要编写一个函数来插入单词；但是我更喜欢与Texinfo mode的其它按键保持一致。）&lt;/p&gt;
&lt;p&gt;在loaddefs.el中你可以在各种mode中看到无数多的define-key语句，比如cc-mode.el和lisp-mode.el中。&lt;/p&gt;
&lt;h2&gt;加载文件&lt;/h2&gt;
&lt;p&gt;很多GNU Emacs社区的人们都自己编写Emacs的扩展。随着时间的推移，这些扩展通常都会出现新的版本。比如，Calendar和Diary包现在已经变成了GNU Emacs标准发行包中的一部分了。&lt;/p&gt;
&lt;p&gt;可以使用load命令来执行整个文件，而将文件中的函数和变量设置安装到Emacs中。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;load&lt;/span&gt; &lt;span class="s"&gt;"~/emacs/slowsplit"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它个语句执行，或者说加载了slowsplit.el这个文件（如果文件存在），或者加载编译过的slowsplit.elc文件。这个文件包含了split-window-quietly函数，它是John Robinson于1989年编写的。&lt;/p&gt;
&lt;p&gt;split-window-quietly函数在分隔窗口时，只使用了少量的重绘。我在1989年安装了它因为它与当时我使用的慢速的1200 baud终端工作得很好。现在很少遇到这种慢速连接了，但我仍然使用这个函数，因为我喜欢这种方式：缓冲区的下半部分在下面的新窗口中，而缓冲区的上半部分在上面的窗口中。&lt;/p&gt;
&lt;p&gt;为了替换split-window-vertically的缺省按键绑定，你需要先取消split-window-quietly的按键绑定，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-unset-key&lt;/span&gt; &lt;span class="s"&gt;"\C-x2"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="s"&gt;"\C-x2"&lt;/span&gt; &lt;span class="ss"&gt;'split-window-quietly&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要加载很多扩展，你需要指定扩展文件所在的位置，需要将扩展所在目录添加到Emacs的load-path中。在Emacs加载文件时，它将搜索这个目录列表中的目录。（缺省的列表在Emacs构建时在paths.h中指定。）&lt;/p&gt;
&lt;p&gt;下面的命令将你的~/emacs目录添加到load-path中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Emacs Load Path&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;load-path&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;cons&lt;/span&gt; &lt;span class="s"&gt;"~/emacs"&lt;/span&gt; &lt;span class="nv"&gt;load-path&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;load-library是一个交互式的load函数。完整的函数如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;load-library&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;library&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Load the library named LIBRARY.&lt;/span&gt;
&lt;span class="s"&gt;This is an interface to the function &lt;/span&gt;&lt;span class="ss"&gt;`load'&lt;/span&gt;&lt;span class="s"&gt;."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"sLoad library: "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;load&lt;/span&gt; &lt;span class="nv"&gt;library&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;load-library函数的名称来自于将'file'称为'library'。load-library命令在files.el中。&lt;/p&gt;
&lt;p&gt;另一个交互式命令load-file完成的工作有些许不同。&lt;/p&gt;
&lt;h2&gt;自动加载&lt;/h2&gt;
&lt;p&gt;与通过加载文件的方式或者执行函数定义等方式加载函数不同，可以使用函数在被调用时自动加载。这被称作自动加载（autoloading）。&lt;/p&gt;
&lt;p&gt;当执行自动加载函数时，Emacs自动执行文件中包含定义然后调用这个函数。&lt;/p&gt;
&lt;p&gt;使用自动加载可以使Emacs启动得更快一些，因为库没有被立即加载；但是在第一次执行函数时，在加载对应的文件时需要稍等一下。&lt;/p&gt;
&lt;p&gt;那些使用得较少的函数通常使用自动加载。loaddefs.el库包含了数百个自动加载函数，从bookmark-set到wordstar-mode。当然，如果有可能经常需要使用一些'罕见'的函数，可以在.emacs文件中使用load语句加载它。&lt;/p&gt;
&lt;p&gt;autoload是一个内置函数可以传递5个参数，最后三个是可选的。第一个参数是需要自动加载的函数名称；第二个参数是要加载的文件名。第三个参数是函数的文档，第四个用于说明这个函数是否可以以交互的方式运行。第五个参数说明对象的类型&amp;mdash;&amp;mdash;autoload可以处理按键或者宏或者函数（缺省是函数）。&lt;/p&gt;
&lt;p&gt;下面是一个典型的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;autoload&lt;/span&gt; &lt;span class="ss"&gt;'html-helper-mode&lt;/span&gt;
  &lt;span class="s"&gt;"html-helper-mode"&lt;/span&gt; &lt;span class="s"&gt;"Edit HTML documents"&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（html-helper-mode是html-mode的另一选择，它是标准发行版的一部分）&lt;/p&gt;
&lt;p&gt;自动加载html-helper-mode函数。它将从html-helper-mode.el（或从编译过的html-helper-mode.elc）加载。这个文件必须位于load-path指定的目录列表中。文档字符串说明这个mode是用于编辑html文件的。你可以以交互的方式输入M-x html-helper-mode来执行。（你需要在这里提供文档字符串，虽然函数定义中有，但在这里函数还没有加载，它的文档字符串还不可用）&lt;/p&gt;
&lt;h2&gt;一个简单的扩展：line-to-top-of-window&lt;/h2&gt;
&lt;p&gt;这里是一个简单的Emacs扩展它将point移到窗口的顶部。&lt;/p&gt;
&lt;p&gt;你可以将下面的代码放到独立的文件中，然后在.emacs文件中加载，或者你可以在.emacs文件中直接包含这些代码。&lt;/p&gt;
&lt;p&gt;定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;;; Line to top of window;&lt;/span&gt;
&lt;span class="c1"&gt;;;; replace three keystroke sequence  C-u 0 C-l&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;line-to-top-of-window&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"Move the line point is on to top of window."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;recenter&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在设置按键绑定。&lt;/p&gt;
&lt;p&gt;现在，功能键和鼠标按键事件和非ASCII字符写在方括号中，不需要使用引号。（在Emacs 18或以前的版本中，你需要为不同的终端编写不同的功能键绑定）&lt;/p&gt;
&lt;p&gt;我们将line-to-top-of-window绑定到&lt;f6&gt;功能键上。&lt;/f6&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;global-set-key&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;f6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="ss"&gt;'line-to-top-of-window&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你运行有两个版本的GNU Emacs，比如20和21，并使用同一个.emacs文件，你可以使用下面的方法选择执行不同的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;cond&lt;/span&gt;
 &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;string-equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;number-to-string&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;emacs-version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;;; evaluate version 20 code&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nf"&gt;string-equal&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;number-to-string&lt;/span&gt; &lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;emacs-version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="c1"&gt;;; evaluate version 21 code&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如，在21版中光标缺省是闪烁的。我不喜欢这种效果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-equal&lt;/span&gt; &lt;span class="s"&gt;"21"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;emacs-version&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;progn&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;blink-cursor-mode&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Insert newline when you press `C-n' (next-line)&lt;/span&gt;
      &lt;span class="c1"&gt;;; at the end of the buffer&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;next-line-add-newlines&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Turn on image viewing&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;auto-image-file-mode&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Turn on menu bar (this bar has text)&lt;/span&gt;
      &lt;span class="c1"&gt;;; (Use numeric argument to turn on)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;menu-bar-mode&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Turn off tool bar (this bar has icons)&lt;/span&gt;
      &lt;span class="c1"&gt;;; (Use numeric argument to turn on)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;tool-bar-mode&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; Turn off tooltip mode for tool bar&lt;/span&gt;
      &lt;span class="c1"&gt;;; (This mode causes icon explanations to pop up)&lt;/span&gt;
      &lt;span class="c1"&gt;;; (Use numeric argument to turn on)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;tooltip-mode&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="c1"&gt;;; If tooltips turned on, make tips appear promptly&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;tooltip-delay&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;; default is one second&lt;/span&gt;
       &lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（注意这里没有使用&lt;code&gt;(number-to-string 21)&lt;/code&gt;，没有使用函数将整数转化为字符串。短的表达式比长的更好，但&lt;code&gt;(number-to-string 21)&lt;/code&gt;更通用。然而如果你不知道前面返回值的类型时，就需要使用number-to-string函数了。）&lt;/p&gt;
&lt;h2&gt;X11颜色&lt;/h2&gt;
&lt;p&gt;在MIT X Windowing系统上使用Emacs时可以指定颜色。&lt;/p&gt;
&lt;p&gt;我不喜欢缺省的颜色而指定了自己的颜色。&lt;/p&gt;
&lt;p&gt;.emacs中的这些语句指定了这些值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Set cursor color&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-cursor-color&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;; Set mouse color&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-mouse-color&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;; Set foreground and background&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-foreground-color&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-background-color&lt;/span&gt; &lt;span class="s"&gt;"darkblue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;;; Set highlighting colors for isearch and drag&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-foreground&lt;/span&gt; &lt;span class="ss"&gt;'highlight&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-background&lt;/span&gt; &lt;span class="ss"&gt;'highlight&lt;/span&gt; &lt;span class="s"&gt;"blue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-foreground&lt;/span&gt; &lt;span class="ss"&gt;'region&lt;/span&gt; &lt;span class="s"&gt;"cyan"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-background&lt;/span&gt; &lt;span class="ss"&gt;'region&lt;/span&gt; &lt;span class="s"&gt;"blue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-foreground&lt;/span&gt; &lt;span class="ss"&gt;'secondary-selection&lt;/span&gt; &lt;span class="s"&gt;"skyblue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-background&lt;/span&gt; &lt;span class="ss"&gt;'secondary-selection&lt;/span&gt; &lt;span class="s"&gt;"darkblue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;;; Set calendar highlighting colors&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;calendar-load-hook&lt;/span&gt;
      &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;lambda&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-foreground&lt;/span&gt; &lt;span class="ss"&gt;'diary-face&lt;/span&gt;   &lt;span class="s"&gt;"skyblue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-background&lt;/span&gt; &lt;span class="ss"&gt;'holiday-face&lt;/span&gt; &lt;span class="s"&gt;"slate blue"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-face-foreground&lt;/span&gt; &lt;span class="ss"&gt;'holiday-face&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不同色调的蓝色防止人感觉屏幕的闪烁。&lt;/p&gt;
&lt;p&gt;另一种选择是在X初始化文件中指定彩色。比如，可以在~/.Xresources文件中设置前景色、背景色、光标和指针颜色等：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Emacs*foreground:   white
Emacs*background:   darkblue
Emacs*cursorColor:  white
Emacs*pointerColor: white
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这并不是Emacs的一部分，还可以在~/.xinitrc文件中指定X window根窗口的颜色：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# I use TWM for window manager.
xsetroot -solid Navy -fg white &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;.emacs中的杂项设置&lt;/h2&gt;
&lt;p&gt;一些杂项设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置鼠标光标的颜色和外观：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Cursor shapes are defined in&lt;/span&gt;
&lt;span class="c1"&gt;;; `/usr/include/X11/cursorfont.h';&lt;/span&gt;
&lt;span class="c1"&gt;;; for example, the `target' cursor is number 128;&lt;/span&gt;
&lt;span class="c1"&gt;;; the `top_left_arrow' cursor is number 132.&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;mpointer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;x-get-resource&lt;/span&gt; &lt;span class="s"&gt;"*mpointer"&lt;/span&gt;
                                &lt;span class="s"&gt;"*emacs*mpointer"&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
  &lt;span class="c1"&gt;;; If you have not set your mouse pointer&lt;/span&gt;
  &lt;span class="c1"&gt;;;     then set it, otherwise leave as is:&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="nv"&gt;mpointer&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;mpointer&lt;/span&gt; &lt;span class="s"&gt;"132"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="c1"&gt;; top_left_arrow&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;x-pointer-shape&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;string-to-int&lt;/span&gt; &lt;span class="nv"&gt;mpointer&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;set-mouse-color&lt;/span&gt; &lt;span class="s"&gt;"white"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;状态栏(Modified Mode Line)&lt;/h2&gt;
&lt;p&gt;当我在网络中工作时，会忘记使用的是哪台机器。也有可能忘记point位于什么位置。&lt;/p&gt;
&lt;p&gt;因此我重置了mode line：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s s-Atom"&gt;-:--&lt;/span&gt; &lt;span class="s s-Atom"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;texi&lt;/span&gt;   &lt;span class="nn"&gt;rattlesnake&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bob&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;  &lt;span class="nv"&gt;Line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;Texinfo&lt;/span&gt; &lt;span class="nv"&gt;Fill&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;Top&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示访问的文件名为foo.texi，在rattlesnake这台机器的/home/bob缓冲区中。位于第一行，处于Texinfo mode，位于缓冲区的顶部。&lt;/p&gt;
&lt;p&gt;.emacs文件中有如下的部分：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;;; Set a Mode Line that tells me which machine, which directory,&lt;/span&gt;
&lt;span class="c1"&gt;;; and which line I am on, plus the other customary information.&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;default-mode-line-format&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;quote&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;"-"&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;help-echo&lt;/span&gt;
      &lt;span class="s"&gt;"mouse-1: select window, mouse-2: delete others ..."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="nv"&gt;mode-line-mule-info&lt;/span&gt;
   &lt;span class="nv"&gt;mode-line-modified&lt;/span&gt;
   &lt;span class="nv"&gt;mode-line-frame-identification&lt;/span&gt;
   &lt;span class="s"&gt;"    "&lt;/span&gt;
   &lt;span class="nv"&gt;mode-line-buffer-identification&lt;/span&gt;
   &lt;span class="s"&gt;"    "&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;:eval&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;system-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-match&lt;/span&gt; &lt;span class="s"&gt;"\\..+"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;system-name&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
   &lt;span class="s"&gt;":"&lt;/span&gt;
   &lt;span class="nv"&gt;default-directory&lt;/span&gt;
   &lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;help-echo&lt;/span&gt;
      &lt;span class="s"&gt;"mouse-1: select window, mouse-2: delete others ..."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;line-number-mode&lt;/span&gt; &lt;span class="s"&gt;" Line %l "&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="nv"&gt;global-mode-string&lt;/span&gt;
   &lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;"   %[("&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;help-echo&lt;/span&gt;
      &lt;span class="s"&gt;"mouse-1: select window, mouse-2: delete others ..."&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;:eval&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mode-line-mode-name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
   &lt;span class="nv"&gt;mode-line-process&lt;/span&gt;
   &lt;span class="nv"&gt;minor-mode-alist&lt;/span&gt;
   &lt;span class="o"&gt;#(&lt;/span&gt;&lt;span class="s"&gt;"%n"&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;help-echo&lt;/span&gt; &lt;span class="s"&gt;"mouse-2: widen"&lt;/span&gt; &lt;span class="nv"&gt;local-map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;keymap&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
   &lt;span class="s"&gt;")%] "&lt;/span&gt;
   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;-3&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;"%P"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="c1"&gt;;;   "-%-"&lt;/span&gt;
   &lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里重定义了缺省的mode line。多数设置来自于原始值；但作了一些修改。设置了default mode line format以便支持多种mode，比如Info。&lt;/p&gt;
&lt;p&gt;列表中的很多元素是自描述的：mode-line-modified是一个变量，它说明了缓冲区是否被修改了，mode-name说明mode的名称，等等。format看起来复杂一些，因为它使用了两个我们没有讨论过的功能。&lt;/p&gt;
&lt;p&gt;mode line字符串的第一行是一个短线-。在原来，它只能是一个简单的"-"。但现在，Emacs允许给字符串添加属性，比如高亮，或者像这里一样，是一个帮助功能。如果你将鼠标光标放在短线上，一些帮助信息将会显示出来。（缺省情况下，你需要等1秒。你也可以通过修改tooltip-delay变量来修改这个时间。）&lt;/p&gt;
&lt;p&gt;新的字符串有一个特定的格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#("-" 0 1 (help-echo "mouse-1: select window, ..."))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;#(&lt;/code&gt;开头的list。第一个元素是字符串本身，只有一个"-"。第二个和第三个元素指定第四个元素的应用范围。范围从一个字符后面开始，0表示从第一个字符之前开始；1表示范围在第一个字符后面结束。第三个元素是范围的属性。它包含了一个属性列表，属性名help-echo，后面跟了一个属性值，是一个字符串。第二、三和四个元素可以重复出现。&lt;/p&gt;
&lt;p&gt;mode-line-buffer-identification显示当前缓冲区名称。它是以&lt;code&gt;(#("%12b" 0 4 ....&lt;/code&gt;开头的list。&lt;/p&gt;
&lt;p&gt;"%12b"显示缓冲区的名称，使用buffer-name函数；'12'设置了最大显示的字符数量。当名称的长度小于这个长度时会将空白添加到字符串中。（缓冲区名称通常大于12个字符，这个长度在典型的80列的窗口中工作得很好）&lt;/p&gt;
&lt;p&gt;:eval是GNU Emacs 21中的新功能。它执行后面的语句交把结果作为字符串显示。在这里，这个语句显示完整的系统名称的第一个部分。第一个部分的结束位置是一个'.'，因此使用了string-match函数计算第一个部分的长度。substring取从0到那个位置的字符串。&lt;/p&gt;
&lt;p&gt;语句如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;:eval&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;substring&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;system-name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-match&lt;/span&gt; &lt;span class="s"&gt;"\\..+"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;system-name&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;%[和%]这对括号显示每个递归编辑的层次。%n表示'Narrow'（在narrowed时）。%P表示窗口底部上缓冲区的百分比，或者'Top'或'Bottom'或'All'。（小写的p表示离窗口顶部上的百分比。）%-插入用于填充的连字符。&lt;/p&gt;
&lt;p&gt;如果想要在启动时不加载~/.emacs，可以使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;emacs -q
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;调试&lt;/h1&gt;
&lt;p&gt;GNU Emacs中有两个高度器，debug和edebug。第一个是Emacs内建的可以随时使用它；第二个需要借助一些函数才能使用。&lt;/p&gt;
&lt;h2&gt;debug&lt;/h2&gt;
&lt;p&gt;假设你编写了用于加1的函数。但函数有个bug。你误将1-输入为1=了。函数定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-bugged&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return sum of numbers 1 through NUMBER inclusive."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;      &lt;span class="c1"&gt;; Error here.&lt;/span&gt;
    &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当传递4给这个函数时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-bugged&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Emacs 21中，将产生一个&lt;em&gt;Backtrace&lt;/em&gt;缓冲区，并进入这个缓冲区：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
  (1= number)
  (setq number (1= number))
  (while (&amp;gt; number 0) (setq total (+ total number))
        (setq number (1= number)))
  (let ((total 0)) (while (&amp;gt; number 0) (setq total ...)
    (setq number ...)) total)
  triangle-bugged(4)
  eval((triangle-bugged 4))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（重新格式化了一下；调试不会自动折行。可以用q退出调试器）&lt;/p&gt;
&lt;p&gt;实际上，像这样简单的bug，'Lisp error'这行告诉了我们如何修改定义。函数1=为'void'。&lt;/p&gt;
&lt;p&gt;在Emacs 20中，你将看到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Symbol's function definition is void: 1=
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这与21版中的&lt;em&gt;Backtrace&lt;/em&gt;缓冲区中的意思是一样的。&lt;/p&gt;
&lt;p&gt;假设你还不是很清楚要如何做？你可以阅读完整的回溯信息。&lt;/p&gt;
&lt;p&gt;在GNU Emacs 21中，它将自动启动调试器，并将信息放到&lt;em&gt;Backtrace&lt;/em&gt;缓冲区中；如果有使用Emacs21，可能需要按下面的方法手工启动调试器。&lt;/p&gt;
&lt;p&gt;在&lt;em&gt;Backtrace&lt;/em&gt;中从下向上读；它说明了Emacs是如何出错的。Emacs执行了一个交互式命令C-x C-e(eval-last-sexp)，它执行了triangle-bugged语句。上面的每一行显示了Lisp解释器执行内容。&lt;/p&gt;
&lt;p&gt;缓冲区的顶部是:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Emacs试图执行这个语句；依次来执行，它首先执行内部的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里发生了错误，如错误信息所说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Debugger entered--Lisp error: (void-function 1=)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以修正这个错误，然后重新执行函数定义，再运行测试代码。&lt;/p&gt;
&lt;h2&gt;debug-on-entry&lt;/h2&gt;
&lt;p&gt;GNU Emacs 21在函数出错时自动启动了调试器。GNU Emacs 20不会这样做；它只显示一条出错信息。你需要手工启动调试器。&lt;/p&gt;
&lt;p&gt;手工启动的好处是在程序没有bug的时候也可以调试。&lt;/p&gt;
&lt;p&gt;你可以调用debug-on-entry函数进入调试器。&lt;/p&gt;
&lt;p&gt;输入:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x debug-on-entry RET triangle-bugged RET
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，执行下面的语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-bugged&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有版本的Emacs都将产生一个&lt;em&gt;Backtrace&lt;/em&gt;缓冲区告诉你它将执行triangle-debugged函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在&lt;em&gt;Backtrace&lt;/em&gt;缓冲区中输入d。Emacs将执行triangle-bugged的第一行语句；缓冲区看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (let ((total 0)) (while (&amp;gt; number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，再次输入d，连续8次慢慢的输入d，Emacs将执行函数定义的另一个语句。&lt;/p&gt;
&lt;p&gt;最后缓冲区看起来如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (&amp;gt; number 0) (setq total (+ total number))
        (setq number (1= number)))
* (let ((total 0)) (while (&amp;gt; number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后再输入两次d，Emacs将到达错误的位置，&lt;em&gt;Backtrace&lt;/em&gt;缓冲区顶部的两行将显示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
...
---------- Buffer: *Backtrace* ----------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入d可以单步执行函数。&lt;/p&gt;
&lt;p&gt;可以输入q退出&lt;em&gt;Backtrace&lt;/em&gt;缓冲区；这将退出跟踪，但并不会退出debug-on-entry。&lt;/p&gt;
&lt;p&gt;要退出debug-on-entry，需要调用cancel-debug-on-entry并输入函数名称：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x cancel-debug-on-entry RET triangle-bugged RET
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;debug-on-quit和(debug)&lt;/h2&gt;
&lt;p&gt;除了debug-on-error或调用debug-on-entry，还有另外两种方法启动debug。&lt;/p&gt;
&lt;p&gt;可以通过将变量debug-on-quit设置为t，随时输入C-g(keyboard-quit)来启动debug。这在调试无限循环时很用效。&lt;/p&gt;
&lt;p&gt;或者，你可以在代码中插入(debug)以启动调试器，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-bugged&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return sum of numbers 1 through NUMBER inclusive."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;total&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                         &lt;span class="c1"&gt;; Start debugger.&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;      &lt;span class="c1"&gt;; Error here.&lt;/span&gt;
    &lt;span class="nv"&gt;total&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;edebug源码级的调试器&lt;/h2&gt;
&lt;p&gt;Edebug是一个源码级的调试器。Edebug通常显示你要调试的源码，并在左边用箭头指出当前执行的行。&lt;/p&gt;
&lt;p&gt;你可以单步执行函数，或者快速的执行到断点位置。&lt;/p&gt;
&lt;p&gt;下面是tringle-recursively的调试函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;triangle-recursively-bugged&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"Return sum of numbers 1 through NUMBER inclusive.&lt;/span&gt;
&lt;span class="s"&gt;Uses recursion."&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-recursively-bugged&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;1=&lt;/span&gt; &lt;span class="nv"&gt;number&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;               &lt;span class="c1"&gt;; Error here.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，你可以在函数定义后面使用C-x C-e(eval-last-sexp)安装函数，或者将光标放到定义的内部输入C-M-x(eval-defun)。（缺省情况下，eval-defun命令只在Emacs Lisp或Lisp交互模式下才可以工作。）&lt;/p&gt;
&lt;p&gt;但是，为了使用Edebug调试函数，你必须使用另一个命令。可以将停留在函数内部然后输入&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;M-x edebug-defun RET
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将使Emacs自动加载Edebug。在加载完成后，可以将光标放在下面语句的后面输入C-x C-e(eval-last-sexp):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;triangle-recursively-bugged&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将跳到triangle-recursively-bugged的源码，光标被设置在函数if语句所在的开始行。并且，可以在这行的左边看到一个箭头。箭头标明了函数当前执行的位置。（在例子中，我们使用=&amp;gt;代替；在窗口系统中，你可以看到一个实心的三角形）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;=&amp;gt;-!-(if (= number 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，point的位置显示为-!-。&lt;/p&gt;
&lt;p&gt;如果你输入&lt;spc&gt;，point将移到下一个语句；这行将显示如下：&lt;/spc&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;=&amp;gt;(if -!-(= number 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果继续输入&lt;spc&gt;，point将继续从一个语句移到另一个语句。每次只要语句返回了值，它都会显示到回显区。比如，在point移过number时，你将看到：&lt;/spc&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Result&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表示number的值为3，它的ASCII值是'control-c'。&lt;/p&gt;
&lt;p&gt;你可以继续执行，直到错误的位置。在执行之前，这行如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;=&amp;gt;        -!-(1= number)))))               ; Error here.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当再次输入&lt;spc&gt;时，将产生错误信息：&lt;/spc&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Symbol's function definition is void: 1=
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入q退出Edebug。&lt;/p&gt;
&lt;p&gt;要从函数上移除调试的机制，可以重新使用C-x C-e执行函数定义。&lt;/p&gt;
&lt;p&gt;Edebug除了跟踪执行外可以做更多的工作。你可以设置它在遇到错误时停止；可以让它显示或修改变量的值；你可以查找出函数被执行了多少次，等等。&lt;/p&gt;
&lt;h1&gt;终结&lt;/h1&gt;</content><category term="emacs"></category></entry><entry><title>OA Framework应用构建之——创建属性集</title><link href="/build_attrsets.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/build_attrsets.html</id><summary type="html">&lt;h1&gt;设计属性集&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt; 这节是为Oracle EBS开发者内部使用的。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;设计属性集&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt; 这节是为Oracle EBS开发者内部使用的。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>OA Framework应用构建之——实现模型</title><link href="/build_model.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/build_model.html</id><summary type="html">&lt;h1&gt;设计模型对象&lt;/h1&gt;
&lt;h2&gt;客户／服务代码分离&lt;/h2&gt;
&lt;p&gt;在OA Framework的MVC框架中，OA Framework划出了客户端和服务端类的清析界限，典型的JSP应用有3个物理层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浏览器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;web应用服务（中间层包含UI web bean结构和应用业务逻辑）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库服务器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在中间层OA Framework对&amp;ldquo;客户端&amp;rdquo;和&amp;ldquo;服务端&amp;rdquo;类划出了界限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端类（视图类和控制器代码）驱动HTML用户界面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端类（模型代码）支持任何客户端（不只是OA Framework）用户界面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个区别是非常重要的，它保证了从不同客户端访问服务代码的能力。&lt;/p&gt;
&lt;p&gt;OA Framework&amp;ldquo;洋葱形&amp;rdquo;的代码层次边界：&lt;/p&gt;
&lt;p&gt;&lt;img alt="onion" src="/oaf_build_model/onion.gif"/&gt;&lt;/p&gt;
&lt;p&gt;通常可以在这些边界征用，对象引用下层的数据流，而不会引用上层的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;模型代码不应该直接引用控制器代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要在客户端引用或导入任何服务端的实现类或接口（位于oracle.apps.fnd.framework.server包中的类和接口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要服务端代码执行一些操作，应该一直通过使用根应用模块接口（oracle.apps.fnd …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;设计模型对象&lt;/h1&gt;
&lt;h2&gt;客户／服务代码分离&lt;/h2&gt;
&lt;p&gt;在OA Framework的MVC框架中，OA Framework划出了客户端和服务端类的清析界限，典型的JSP应用有3个物理层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浏览器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;web应用服务（中间层包含UI web bean结构和应用业务逻辑）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库服务器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在中间层OA Framework对&amp;ldquo;客户端&amp;rdquo;和&amp;ldquo;服务端&amp;rdquo;类划出了界限：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端类（视图类和控制器代码）驱动HTML用户界面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端类（模型代码）支持任何客户端（不只是OA Framework）用户界面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个区别是非常重要的，它保证了从不同客户端访问服务代码的能力。&lt;/p&gt;
&lt;p&gt;OA Framework&amp;ldquo;洋葱形&amp;rdquo;的代码层次边界：&lt;/p&gt;
&lt;p&gt;&lt;img alt="onion" src="/oaf_build_model/onion.gif"/&gt;&lt;/p&gt;
&lt;p&gt;通常可以在这些边界征用，对象引用下层的数据流，而不会引用上层的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;模型代码不应该直接引用控制器代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要在客户端引用或导入任何服务端的实现类或接口（位于oracle.apps.fnd.framework.server包中的类和接口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要服务端代码执行一些操作，应该一直通过使用根应用模块接口（oracle.apps.fnd.framework.OAApplicationModule）调用根应用模块的通用远程方法调用invokeMethod()方法，或者为你的应用模块创建一个接口，以便于在编译时检查方法的调用。应用模块可以代理或实现所需要的逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OAApplicationModule接口位于oracle.apps.fnd.framework包中，所有位于这个包中的类、接口、异常都可以在客户端和服务端代码中使用&lt;/p&gt;
&lt;p&gt;如果选择为你的应用模块创建接口而不是使用invokeMethod()方法，应该在应用模块所在包的直接上级包中创建。比如，为oracle.apps.fnd.framework.toolbox.labsolution.server.EmployeeAMImpl所创建的接口EmployeeAM应该位于oracle.apps.fnd.framework.toolbox.labsolution包中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;永远不要直接在客户端代码中包含JDBC或其它服务端处理的代码。如果UI客户端需要服务端的信息，它应该通过应用模块，由应用模块代理或实现适当的响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;保持编码规范一致&lt;/h2&gt;
&lt;p&gt;阅读下面的文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Oracle Application Java Coding Standards&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Oracle Framework Nameing/File/Package/Directory Structure Standards&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Oracle Framework Model Coding Standards&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;推荐的构建方法&lt;/h1&gt;
&lt;p&gt;编写OA Framework应用模块时，按下面的流程编写会简单一些。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建BC4J模型对象所需要的业务组件包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现公布的BC4J应用模块，实体对象，实体关联对象和页面所需要的视图对象和视图链接义。将视图对象添加到根应用模块中。这一步不要担心编写代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建应用的菜单定义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为页面创建OA用户界面组件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建和实现控制器代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为页面实现UI应用模块代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现实体对象业务逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;业务组件包&lt;/h1&gt;
&lt;p&gt;包有BC4J模型组件必须属于业务组件包（Business Components(BC4J)）。&lt;/p&gt;
&lt;p&gt;如果要修改已经存在的BC4J包使用的数据库连接，可以如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;选择OA Project中的业务组件包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右键，选择Edit Business Components Project。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在Business Componets Project Wizard中，选择Connection。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定新的数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择OK保存修改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;实体对象&lt;/h1&gt;
&lt;p&gt;实体对象为指定的表、视图或同义词实现业务规则。实体对象被确定为用于多种客户端，应该处理与表相关的校验和行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个表应该只有至多一个实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实体对象应该在它的属性中包含表中的所有列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以创建自己的公用实体对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常需要为实体添加对象初始化，属性校验，实体级的验证和其它功能性的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也可以在综合性的业务对旬中创建"entity expert"的单例对象用于在多个相关实体对象间共享。比如，定购单有定单头、定单行和销售信息。其它相引用的实体可以使用entity expert来执行轻量的校验（比如，定单可能需要使用供应商的entity expert检查自己所使用供应商id是否有效）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，你可以根据需要为模型代码创建"helper"对象和接口。比如，在OA Framework的ToolBox教程中，你可以创建一个或多个helper对象在多种实体对象上执行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;实体关联（关联对象）&lt;/h1&gt;
&lt;p&gt;关联可以创建实体之间的关系。在运行时，BC4J使用这些关系来协调相关的对象。有两种基本类型的关联：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;聚合 这是强关联，源实体对象拥有目标实体对象。也就是说，目标不能离开源对象独立存在。比如，定单头由多个行组成，离开它们的头信息后就没有含义了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用 这是弱关联，源对象只引用目标实体。比如，定单引用供应商，但供应商在没有被定单引用的时候仍然可以存在。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;聚合关系适合于在运行时创建、初始化和管理。BC4J自动将聚合作为一个逻辑单元。比如，定单对象将在修改它的条目时被锁定。&lt;/p&gt;
&lt;p&gt;引用关系适合于在运行时候修改、引用。比如，在定单和供应商之间建立关联，如果在编辑定单时可以修改供应商，并不需在供应商和货品条目间建立关联。&lt;/p&gt;
&lt;h2&gt;编程控制&lt;/h2&gt;
&lt;p&gt;关联对象没有代码，并不需要为它们编写代码。&lt;/p&gt;
&lt;h1&gt;视图对象和视图行&lt;/h1&gt;
&lt;p&gt;视图对象包含了数据库查询，通过它可以访问相关的实体对象。关于视图对象的设计的重要决策就是它是应该基于SQL还是实体对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有锁碎的UI视图对象，比如Lists of Values (LOV)和poplists等基于SQL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有验证性的视图对象，用于为实体对象实现简单业务规则的基于SQL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为UI创建的视图对象，不管它们是否可以更新，应该基于实体对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于性能的原因，视图对象需要被优化。在一些UI组件中，创建多个小型的处理特定任务的视图对象优于共同一个单一的大型的视图对象。视图对象应该是为UI而定制的。&lt;/p&gt;
&lt;p&gt;只要可能就应该避免使用动态WHERE子句（视图对象支持用编程的方式修改它的定义）。如果可能，为相同的SELECT定义3个不同的视图对象，每个带一个WHERE子句，用于在运行时绑定。但是，在复杂查询时修改WHERE子句是合适的，因为不可能为所有可能的查询定义独立的视图对象。&lt;/p&gt;
&lt;p&gt;视图对象，与任何BC4J对象一样，可以用申明的方式或编程的方式创建。基于性能的原因，如果可以的话通过申明的方式定义视图对象。&lt;/p&gt;
&lt;p&gt;所有视图对象都是oracle.apps.fnd.framework.server.OAViewObjectImpl的子类。&lt;/p&gt;
&lt;p&gt;视图对象有SQL视图对象，实体视图对象和混合视图对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主键&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几个所有视图对象都需要主键。可以在定义属性时指定主键，或者通过编程的方式调用OAViewObjectImpl类的setKeyAttributeDefs()方法设置主键。&lt;/p&gt;
&lt;h2&gt;编程控制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;查询处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个视图对象都实现了查询，如果需要，它应该能够翻译传递进来的参数，并将它绑定到WHERE子名中的变量上。在编码上通常处理这个工作的方法被命名为initQuery()或其它类似initNameEmployeesQuery()之类的&amp;ldquo;init&amp;rdquo;方法上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 必须使用Oracle风格的参数绑定方式（FOO &amp;gt;= :1）而不是ANSI风格的（FOO &amp;gt;=?）。尽管代码只复杂一点点，OA Framework团队计划在Fusion版本中不支持ANSI风格的绑定。&lt;/p&gt;
&lt;p&gt;下面是修改WHERE子名和绑定查询条件的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Initialize and execute the querypublic void initQuery(String name, String onHold, String number){       StringBuffer whereClause = new StringBuffer(100);   Vector parameters = new Vector(3);   int clauseCount = 0;   int bindCount = 0;       setWhereClauseParams(null); // Always reset&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;()))))&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" NAME like :"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(++&lt;/span&gt;&lt;span class="n"&gt;bindCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;"%"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;clauseCount&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;()))))&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;

     &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;supplierId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

     &lt;span class="c1"&gt;// SUPPLIER_ID is a NUMBER; datatypes should always&lt;/span&gt;
     &lt;span class="c1"&gt;// match, and the parameter passed to this method is a&lt;/span&gt;
     &lt;span class="c1"&gt;// String.&lt;/span&gt;
     &lt;span class="k"&gt;try&lt;/span&gt;
     &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;supplierId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="o"&gt;}&lt;/span&gt;
     &lt;span class="k"&gt;catch&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{}&lt;/span&gt;

     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clauseCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" AND "&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="o"&gt;}&lt;/span&gt;

     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" SUPPLIER_ID = :"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(++&lt;/span&gt;&lt;span class="n"&gt;bindCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supplierId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;clauseCount&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;onHold&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;onHold&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;()))))&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clauseCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" AND "&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="o"&gt;}&lt;/span&gt;

     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" ON_HOLD_FLAG = :"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;append&lt;/span&gt;&lt;span class="o"&gt;(++&lt;/span&gt;&lt;span class="n"&gt;bindCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addElement&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Y"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;clauseCount&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="n"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;whereClause&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;toString&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bindCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;bindCount&lt;/span&gt;&lt;span class="o"&gt;];&lt;/span&gt;

     &lt;span class="c1"&gt;// the copyInto() is 1.1.8 compliant which, as of 4/02/03, is required by ARU&lt;/span&gt;

     &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;copyInto&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;setWhereClauseParams&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
 &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end initQuery( )&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;业务逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;视图对象不适合放置业务逻辑；不应该在视图对象或视图行对象编写校验规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;视图行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管应该总是创建视图行对象，但很大程度上，你不需要编写视图行代码。视图行代码用于需要计算临时属性的的情况下。比如，你不能或不希望在查询中包含逻辑（可能性能开销太大）。你可以使用视图行代码执行简单的校验或添加用于UI的临时性变量，或者调用实体对象的自定义方法。&lt;/p&gt;
&lt;p&gt;自定义视图行方法不能直接从客户端访问。客户端必须先在应用模块中调用一个方法，由它将任务委派给视图对象。由视图对象来访问视图行。此外，对于有视图行类的应该使用生成的setter/getter方法。因为它比调用通用的setAttribute("&lt;attributename&gt;")和getAttribute("&lt;attributename&gt;")更快。&lt;/attributename&gt;&lt;/attributename&gt;&lt;/p&gt;
&lt;h1&gt;视图链接&lt;/h1&gt;
&lt;p&gt;与上面描述过的实体关联类似。视图链接定义了两个视图间的关系，通过它BC4J能自动从当前的源视图对象查询到相对应的目标视图对象。&lt;/p&gt;
&lt;p&gt;视图链接可以基于关联对象或者申明两个视图对象间的join链接。比如，两个表有基于外键的主从关系。相应的实体对象通过关联对象关联，基于这两个实体的视图对象可以通过基于关联对象的视图链接相关联。&lt;/p&gt;
&lt;p&gt;尽管视图链接可以非常方便，但在web应用页面上应该保守的使用。因为它缓存了主表和从表的记录，当用户从一个主表记录移到另一个主表记录时，这个开销可能相当大。使用视图链接通常只在下面的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当特定的beans（比如HGrid）需要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你有一个可更新的主／从视图对象（在同一个页面或不同的页面），这们下面的实体对象是使用 &lt;strong&gt;&lt;em&gt;聚合&lt;/em&gt;&lt;/strong&gt; 关联的， &lt;strong&gt;&lt;em&gt;你必须在他们之间定义视图链接&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你在同一个页面上有一个只读的主／从视图对象时，导航到一个主记录行的时候将导致自动查询子对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;编程控制&lt;/h2&gt;
&lt;p&gt;由于视图链接没有实现类，所以不需要编写代码。&lt;/p&gt;
&lt;p&gt;但可以使用oracle.jbo.ApplicationModule.createViewLinkBetweenViewObjects动态创建视图对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 编程方式产生的视图链接中的主／从视图对象必须属于同一个应用模块实例。&lt;/p&gt;
&lt;h1&gt;应用模块&lt;/h1&gt;
&lt;p&gt;这里介绍的是应用模块创建／重用的基础。&lt;/p&gt;
&lt;h2&gt;应用模块使用&lt;/h2&gt;
&lt;p&gt;下面列出来在应用中的应用模块的承担的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UI根应用模块（UI Root Application Module）为一个或多个相关的UI页面建立事务环境。每个页面有一个根应用模块它可以包含任何视图对象或这个页面使用的嵌套应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UI共同区域应用模块（UI Shared Region Application Module）任何用于在多个页面使用的UI区域（region）应该包含自己的应用模块。当这个区域在页面中使用时，OA Framework自动嵌套于页面的根应用模块之下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UI List of Values Application Module这是前一个角色中的一种特殊情况。当创建List of Values (LOV)视图对象时，你将这些组件添加到一个应用模块中用于获取LOV集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证应用模块（Validation Application Module）校验应用模块聚集相关视图，执行轻量级的SQL校验。实体对象或experts使用校验应用模块，它与用户界面无关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用模块是oracle.apps.fnd.framework.server.OAApplicationModuleImpl的子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要：&lt;/strong&gt; 如果你没有完全实现和保证页面的钝化支持，就不要设置应用模块的Retention Level为MANAGE_STATE。&lt;/p&gt;
&lt;p&gt;可以在应用模块属性的Peoperties页，创建一个属性，属性名为RETENTION_LEVEL，属性值为MANAGE_STATE。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成应用模块接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;产生应用模块接口可以便于编译时检查，而不用使用invokeMethod()来调用，可以在应用模块编译页面，选择Client Methods启用invoke remotely选择好Available list。&lt;/p&gt;
&lt;h2&gt;编程控制&lt;/h2&gt;
&lt;p&gt;不要将数据校验等业务逻辑放在应用模块中；这些应该放在下层的实体中。应用模块适合放下面的逻辑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;访问任何BC4J相关的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行多种服务端动作，或者跨多个视图对象的单个事件或方法调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从服务端返回客户端从OAPageContext访问不到的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用特殊的PL/SQL程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 如果PL/SQL程序是用于处理单行（或行的集合）时你应该使用基于PL/SQL的实体对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;方法命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何直接用于UI支持的应用模块中的方法应该命名为相应的UI "events"。比如，如果用户按了Create按钮，应用模块方法应该被命名为"create"。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实体对象创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下列描述了应用模块方法创建新插入一行到SuppliersVO视图对象。这个视图对象是基于SupplierEOImpl实体对象的，因此BC4J在行被创建时在幕后处理这些。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;createSupplier&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSuppliersVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;Row&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRow&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;insertRow&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// As specified in OA Framework Model Coding Standards,   // set the new row state to STATUS_INITIALIZED.&lt;/span&gt;
  &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setNewRowState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STATUS_INITIALIZED&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;视图对象查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面显示了一个应用应用模块方法查询SuppliersVO视图对象，用于搜索客户端设置的条件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;query&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;supplierName&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;onHoldFlag&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;supplierNumber&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="n"&gt;SuppliersExpVOImpl&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSuppliersExpVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OBJECT_NAME"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"SuppliersExpVO"&lt;/span&gt;&lt;span class="o"&gt;)};&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_OBJECT_NOT_FOUND"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initQuery&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supplierName&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;onHoldFlag&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;supplierNumber&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end query()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的例子显示了当用户导航到页面上时初始中化页面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;init&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;PoSimpleSummaryVOImpl&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPoSimpleSummaryVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MessageToken&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"OBJECT_NAME"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"PoSimpleSummaryVO"&lt;/span&gt;&lt;span class="o"&gt;)};&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_OBJECT_NOT_FOUND"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tokens&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="c1"&gt;// Follows Back Button standard of never performing a blind query without&lt;/span&gt;
  &lt;span class="c1"&gt;// checking to see if this is necessary.&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isPreparedForExecution&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initQuery&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end init()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实体删除&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Deletes a purchase order from the PoSimpleSummaryVO using the&lt;/span&gt;
&lt;span class="cm"&gt; * poHeaderId parameter.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;poHeaderId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// First, we need to find the selected purchase order in our VO.&lt;/span&gt;
  &lt;span class="c1"&gt;// When we find it, we call remove( ) on the row which in turn&lt;/span&gt;
  &lt;span class="c1"&gt;// calls remove on the associated PurchaseOrderHeaderEOImpl object.&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;poToDelete&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;parseInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;poHeaderId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPoSimpleSummaryVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// This tells us the number of rows that have been fetched in the&lt;/span&gt;
  &lt;span class="c1"&gt;// row set, and will not pull additional rows in like some of the&lt;/span&gt;
  &lt;span class="c1"&gt;// other "get count" methods.&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getFetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// We use a separate iterator -- even though we could step through the&lt;/span&gt;
  &lt;span class="c1"&gt;// rows without it -- because we don't want to affect row currency.&lt;/span&gt;
  &lt;span class="c1"&gt;// Note that there are also convenience methods for finding matching rows&lt;/span&gt;
  &lt;span class="c1"&gt;// in a view object (see javadoc).&lt;/span&gt;

  &lt;span class="n"&gt;RowSetIterator&lt;/span&gt; &lt;span class="n"&gt;deleteIter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"deleteIter"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeStart&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRowAtRangeIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

          &lt;span class="c1"&gt;// For performance reasons, we generate ViewRowImpls for all&lt;/span&gt;
      &lt;span class="c1"&gt;// View Objects. When we need to obtain an attribute value,&lt;/span&gt;
      &lt;span class="c1"&gt;// we use the named accessors instead of a generic String lookup.&lt;/span&gt;

      &lt;span class="c1"&gt;// Number primaryKey = (Number)row.getAttribute("HeaderId");&lt;/span&gt;
      &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;primaryKey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHeaderId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;primaryKey&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;poToDelete&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;getTransaction&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// only one possible selected row in this case&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;closeRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end deletePurchaseOrder()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;自定义的动作"Approve"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里描述了如何查找到视图对象的行并调用自定义的实体事件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Steps through the POSimpleSummaryVO to look for selected rows. For&lt;/span&gt;
&lt;span class="cm"&gt; * each selected row, this calls the approve( ) method on the&lt;/span&gt;
&lt;span class="cm"&gt; * PurchaseOrderHeaderEOImpl class.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;approvePurchaseOrders&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// To call a custom method on an Entity Object you should add a wrapper&lt;/span&gt;
  &lt;span class="c1"&gt;// in the VO's *RowImpl class (see&lt;/span&gt;
  &lt;span class="c1"&gt;// oracle.apps.fnd.framework.toolbox.schema.server.PoSimpleSumaryVORowImpl).&lt;/span&gt;

  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPoSimpleSummaryVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;matches&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// This tells us the number of rows that have been fetched in the&lt;/span&gt;
  &lt;span class="c1"&gt;// row set, and will not pull additional rows in like some of the&lt;/span&gt;
  &lt;span class="c1"&gt;// other "get count" methods.&lt;/span&gt;
  &lt;span class="c1"&gt;// Note that there are also convenience methods for finding matching rows&lt;/span&gt;
  &lt;span class="c1"&gt;// in a view object (see javadoc).&lt;/span&gt;

  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getFetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// We use a separate iterator -- even though we could step through the&lt;/span&gt;
  &lt;span class="c1"&gt;// rows without it -- because we don't want to affect row currency.&lt;/span&gt;

  &lt;span class="n"&gt;RowSetIterator&lt;/span&gt; &lt;span class="n"&gt;approveIter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"approveIter"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;approveIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeStart&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;approveIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="c1"&gt;// For every row with a selected checkbox, we want call&lt;/span&gt;
      &lt;span class="c1"&gt;// the approve( ) wrapper on the POSimpleSummaryVORowImpl which&lt;/span&gt;
      &lt;span class="c1"&gt;// in turn calls the approve ) method on the PurchaseOrderHeaderEOImpl.&lt;/span&gt;

      &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;approveIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRowAtRangeIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

          &lt;span class="c1"&gt;// For performance reasons, we generate ViewRowImpls for all&lt;/span&gt;
      &lt;span class="c1"&gt;// View Objects. When we need to obtain an attribute value,&lt;/span&gt;
      &lt;span class="c1"&gt;// we use the named accessors instead of a generic String lookup.&lt;/span&gt;

      &lt;span class="c1"&gt;// String selectFlag = (String)row.getAttribute("SelectFlag");&lt;/span&gt;
      &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;selectFlag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSelectFlag&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Y"&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;selectFlag&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
      &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;approve&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;matches&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;approveIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;closeRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// If the user didn't actually select any rows, display an error message.&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;matches&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;getTransaction&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_T_SELECT_FOR_APPROVE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end approve()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;提交&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Commit&lt;/span&gt; &lt;span class="n"&gt;Example&lt;/span&gt; &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Provides a "commit" wrapper so UI controller code doesn't need to&lt;/span&gt;
&lt;span class="cm"&gt; * get a handle to the transaction itself which is a violation of the&lt;/span&gt;

&lt;span class="cm"&gt; * client/sever tier separation rules.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;getTransaction&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end apply()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;测试应用模块&lt;/h2&gt;
&lt;p&gt;在应用模块中添加完视图对象后，可以使用Business Component Browser（BC4J Tester）在为它们构建UI前执行视图对象，或者编写代码支持BC4J对象。&lt;/p&gt;
&lt;h1&gt;Entity Objects, Entity Experts, 'Validation' Application Modules and 'Validation' View Objects&lt;/h1&gt;
&lt;p&gt;这节介绍这些对象在一个应用中所扮演的角色。&lt;/p&gt;
&lt;h2&gt;Validation View Objectc&lt;/h2&gt;
&lt;p&gt;在实体对象中实现业务逻辑时，经常会发现需要执行一些简单的SQL语句，而不是纯校验目的。在执行这种SQL之前，你可以使用SQL语句动态创建一个视图对象，或者先定义一个视图对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从实现的角度来看，Validation View object与正规的view object没有区别；这们的主要区别是在使用上。&lt;/p&gt;
&lt;h2&gt;Validation Application Modules(VAMs)&lt;/h2&gt;
&lt;p&gt;预先定义的视图对象必须被赋给应用模块以便在运行时被访问。也就是说，视图对象不能存在于应用模块环境之外。&lt;/p&gt;
&lt;p&gt;由于实体对象（和他们的关联校验视图对象）可以被多个UI客户端（根应用模块可以当作客户端）共享，它不适合为具体的页面包含视图校验功能。将这些有用的视图对象进行分组，便于重用，并为每个业务逻辑对象创建一个validation application module包含它们。业务对象可以是实体对象聚合的顶级定义，或者是一个单独的实体对象。比如OA Framework ToolBox教程中定单由3个实体组成，但PurchaseOrderHeaderEOImpl类描绘出了定单业务对象。&lt;/p&gt;
&lt;p&gt;比如，在OA Framework ToolBox教程中，我们创建了业务对象级的校验应用模块PurchaseOrderVAM并将所有定单校验视图对象添加给了它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从实现的角度来看，validation application对象与正规的应用对象没有区别；只是使用方式的不同。创建validation application module并把相关的validation view objects关联给它。&lt;/p&gt;
&lt;h2&gt;Entity Experts&lt;/h2&gt;
&lt;p&gt;entity expert被定义为一个单例对象，是业务对象一个特殊的分支（聚合中的顶级实体对象，或一个单独的实体对象）。它包含有能被拥有它的业务对象调用，或者被其它业务对象调用的简单校验例程。比如，PurchaseOrderHeaderEOImpl类不需要整个SupplierEOImpl类，只需要查找出外键supplierId是否有效。因此，它调用了supplier的entity expert单例对象的isSupplierIdValue(Number supplierId)方法，这是一个更加轻量级的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建entity expert，先创建一个oracle.apps.fnd.framework.server.OAEntityExpert的子类。然后将它关联到一个实体对象上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 对于聚合类的业务对象，将expert关联到顶级的对象上。否则关联到单独的实体对象。&lt;/p&gt;
&lt;h1&gt;重用业务对象&lt;/h1&gt;
&lt;h2&gt;Entity Objects, Associations, Validation AMs, Validation VOs, Entity Experts&lt;/h2&gt;
&lt;p&gt;如果希望创建可重用的Entity Objects,Associations,Validation AMs,Validation VOs,Entity Experts，应该知道下面的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下层数据库方案的拥有者，拥有对应的Entity Objects,Associations,Validation Application Modules,Validation View Objects,和Entity Experts。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥有业务对象的产品团队必须编写并发布相应的文档供其它产品团队重用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你创建包括你的EO和另一个产品团队的OtherBaseEO的关联对象时，在创建关联前，你必须继承OtherBaseEO到你的产品空间中(OtherExtendedEO)，并将关联建立在EO和OtherExtendedEO之间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个产品团队使用你拥有的业务对象时应该要继承你提供的校验。那种情况下，消费产品团队应该继承Entity Object,Validation Application Module,Validation View Object和Entity Expert and包括扩展的自定义代码。继承校验方法时，确保在继承的校验方法的开始位置调用了super()。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;扩展业务对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下表描述了创建业务对象和关联到需要扩展的校验时要的相关对象。&lt;/p&gt;
&lt;p&gt;&lt;img alt="modelobjects" src="/oaf_build_model/modelobjects.gif"/&gt;&lt;/p&gt;
&lt;p&gt;第一行列举了定义实体时所有可能创建的对象。第一个格子说明了创建一个实体对象时将产生两个文件：元数据定义的XML文件，和实际的Java实现类文件。实体对象处理属性级和记录级的校验。这些校验通常需要使用Validation View Objects (VVO)。校验对象在Validation Application Module(VAM)中分组。与实体对象类似，创建VVO和VAM产生了元数据定义XMl文件，并为每个对象产生了Java实现类文件。最后，实体对象有时会接收辅助类提供的一些服务，为实体对象提供的验证服务。辅助类是Entity Expert通过实体对象的属性连接到实体对象。&lt;/p&gt;
&lt;p&gt;上图描述了所有业务对象继承时的情况。虽然并不总是这样。多数情况下，将对继承的结果满意。注意，不应该修改蕨类的定义或复制基类。应该使用继承。&lt;/p&gt;
&lt;p&gt;未完！！！！！&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>OA Framework应用构建之——实现视图</title><link href="/build_view.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/build_view.html</id><summary type="html">&lt;h1&gt;页面&lt;/h1&gt;
&lt;p&gt;创建页面的基本步骤是创建pages，region，items。&lt;/p&gt;
&lt;h2&gt;Page LayoutRegion的关键属性&lt;/h2&gt;
&lt;p&gt;创建一个pageLayout区域时，应该特别注意下面的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AutoFooter将这个设置为true以保证在页面上有应用的保密和版权说明链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Help Target如果你需要为当前页显示帮助按钮，必须在这里指定帮助文件（通常是文件名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AM Definition用于设置页面的根应用模块。必须使用类的全名，比如：oracle.apps.fnd.framework.toolbox.tutorial.server.SearchAM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Function Name总是设置页面的保密函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Window Title浏览器窗口标题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Title显示在page header中的文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Form在pageLayout中设置为true，这通常是默认设置，不要在其子对象中添加亲折form。OA Framework在同一个页面中只支持一个form。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pageLayout Components注意OA Framework页面基础　一文中提到的，页面包含了特殊的被命名的组件，其中一个就是标识图案。为了在页面关联标识图案，选择pageLayout区域或pageLayoutComponents节点，然后右键菜单中选择创建image item，并把它的Image URI属性设置为&lt;imagename&gt;.gif。&lt;/imagename&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;页面&lt;/h1&gt;
&lt;p&gt;创建页面的基本步骤是创建pages，region，items。&lt;/p&gt;
&lt;h2&gt;Page LayoutRegion的关键属性&lt;/h2&gt;
&lt;p&gt;创建一个pageLayout区域时，应该特别注意下面的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AutoFooter将这个设置为true以保证在页面上有应用的保密和版权说明链接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Help Target如果你需要为当前页显示帮助按钮，必须在这里指定帮助文件（通常是文件名）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AM Definition用于设置页面的根应用模块。必须使用类的全名，比如：oracle.apps.fnd.framework.toolbox.tutorial.server.SearchAM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Function Name总是设置页面的保密函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Window Title浏览器窗口标题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Title显示在page header中的文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Form在pageLayout中设置为true，这通常是默认设置，不要在其子对象中添加亲折form。OA Framework在同一个页面中只支持一个form。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pageLayout Components注意OA Framework页面基础　一文中提到的，页面包含了特殊的被命名的组件，其中一个就是标识图案。为了在页面关联标识图案，选择pageLayout区域或pageLayoutComponents节点，然后右键菜单中选择创建image item，并把它的Image URI属性设置为&lt;imagename&gt;.gif。&lt;/imagename&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Item 的关键属性&lt;/h2&gt;
&lt;p&gt;每个item类型都有自己的一套属性，不可能每个都介绍，这里介绍一些通常的公共属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Extends说明新的item继承于一个已存在的item。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Attribute Set命名了的item的属性集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Destination URI对于支持页面导航的对象，这个是导航的目标，比如：OA.jsp?page=/oracle/apps/fnd/framework/toolbox/tutorial/webui/PoDetailsPG&amp;amp;retainAM=Y。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(Client Action)Action Type标明item是否可以提交表单，或者产生局部页面渲染事件（partialpage rendering (PPR)）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSS Class指定item使用的样式表。（多数item，UIX将把这个值按BLAF UI指导方案中的值设置）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rendered指明相应的对象是否包含了webbean层级结构，需要UIX将HTML发送给浏览器渲染。对于多数item来说，这用于指定一个item是否显示，但有些item是不会实际显示出来的（比如隐藏域），实际上是指定对象是否存在于页面上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;View Instance让item绑定到下层的视图对象上以便读写数据，这里标明将item绑定到哪个视图对象实例（包含在一个应用模块中的）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;View Attribute将视图对象实例的属性与item绑定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Admin Personalization决定是否允许系统管理员进行个性化定制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;User Personalization决定是否允许用户个性化定制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Initial Value定义item的缺省值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Simplest Possible Expression Language (SPEL)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于所选的属性，OA Framework支持使用SPEL表达式快速的将属性绑定到下层数据源提供的属性值上。比如，你可以将按钮的Rendered属性绑定到一个视图对象的属性上以检查是否需要显示或隐藏。属性中使用的SPEL语法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;oa&lt;/span&gt;&lt;span class="o"&gt;.&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ViewInstanceName&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;.&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ViewAttributeName&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; SPEL是一个业界标准的表达式语言，它包含于JSTL中。&lt;/p&gt;
&lt;h2&gt;组件重用&lt;/h2&gt;
&lt;p&gt;OA Component开发环境所宣称的一项关键优势就是可以重用通用的page,region,item定义。&lt;/p&gt;
&lt;h2&gt;Regions共享&lt;/h2&gt;
&lt;p&gt;可以按下面的步骤创建共享的region。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 共享region可以包含一个或多个子region。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顶级共享region必须保存在它的XML文件中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以将共享region设置为接收其它region的值。值可能通过&amp;ldquo;状态管理&amp;rdquo;一文中描述的方式通过请求传递，或者使用页面事务缓存的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享region必须处理失效的情况。比如，如果没有合适的参数传递到region，共享region应该接收或者抛出一个有意义的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果region的scope被设置为Public：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顶级region必须有自己的应用模块。应用模块应该包含与这个region相关的视图对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顶级region必须有自己的控制器。如果需要可以为子region添加控制器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享region必须添加完整的注释文档。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;特殊情况： LOV&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LOV与共享region的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LOV不需要关联控制器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当在页面上使用LOV时，并不从它继承，而是将页面字段的External LOV属性配置为页面与LOV的数据交换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Pages共享&lt;/h2&gt;
&lt;p&gt;page实际上只是顶级region为共享region的pageLayout组件。共享page与共享region的创建过程类似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果要重用一个单独的page或page flow，只要简单的创建一个新的菜单功能并将它指向主页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要将页面插入到另一个使用了不同根应用模块的page flow，则必须创建一个新的page，并继承共享的page的pageLayout region下的内容。记住正确设置将新页面的根应用模块。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Items共享&lt;/h2&gt;
&lt;p&gt;可以从任何区域的单个item继承，尽管我们推荐将准备重用的item放到一个重用region中。共享容器region将确保不会任意的修改item而不明确这样修改将影响使用这个item的页面。&lt;/p&gt;
&lt;p&gt;通过设置item的Extends属性设置共享。&lt;/p&gt;
&lt;h1&gt;属性集 Atribute Sets&lt;/h1&gt;
&lt;p&gt;属性集是一个命名了的可重用的属性集合，可以用于任何OA组件，包括regions，items和其它属性集。它被设计为可以在整个Oracle Application中可以重用的组件，它有效的节约了Oracle和其客户的开销。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Oracle节约了翻译和管理的开销&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户可以更快的定制应用的全局个性化效果。另外，少数UI元素占用更少的中间层内存，提高了性能和伸缩性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，attributes sets被组织到OA组件包中（独立的XML包文件中），这个包与数据训表对应，一个包对应一个表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;包名与不带下划线的数据库表名对应。比如，在OA Framework ToolBox中，有一个表FWK_TBX_PO_HEADERS。对应的属性集包名为FwkTbxPoHeaders。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各个属性集是为了显示表中各个列而设置的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于列的属性集命名与列一致。比如，在FWK_TBS_PO_HEADERS表有一个名为HEADER_ID的列。对应的属性集被命名为HeaderId。如果多个属性集对应于同一个列（这个值被用于不同的情况并使用了不同的prompt属性）时根据实际使用的位置使用不同的前缀来区分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;属性集也可以包含通用域头部和按钮等的设置。命名则使用与它们相关联的标签。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;使用属性集&lt;/h2&gt;
&lt;p&gt;在下面的情况下使用属性集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有的items都与table.column数值关联。比如，供应商查询字段和数据列表中的供应商字段可以使用同样的属性集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有通用按钮（确定、应用、退出等等）。这种情况下也可以继承按钮的快捷键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; OA Framework通用按钮属性集包位于/oracle/apps/fnd/attributesets/Buttons/&lt;attributesetname&gt;。&lt;/attributesetname&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有通用表格动作列（像删除、修改等等）应该使用相应的 OA Framework按钮属性集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产品中任何通用的按钮；不应该为单独使用的按钮创建或使用属性集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产品中任何共同区域的头部；不应该为单独使用头部创建或使用属性集。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在item上使用属性集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;item的Attribute Set属性可以设置它的属性集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将光标放在Attribute Set字段，使用Property Inspector的Set to Default按钮可以清除属性集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程方式访问属性集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以在控制器中访问属性集。比如，下面代码显示了如何保留通用的Create控制属性集的prompt属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;oracle.apps.fnd.framework.webui.AttributeSet&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
 &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

 &lt;span class="n"&gt;AttributeSet&lt;/span&gt; &lt;span class="n"&gt;attrSet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;AttributeSet&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"/oracle/apps/fnd/attributesets/Buttons/Create"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
 &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;createPrompt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;attrSet&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAttributeValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PROMPT_ATTR&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;URL 参数：Tokens，Encryption，Encoding&lt;/h1&gt;
&lt;h2&gt;Tokens&lt;/h2&gt;
&lt;p&gt;当在页面定义中指定URL参数时，可以直接指定字符串值或使用token-substituted值，在渲染时它保留了从相关的视图对象的属性（item与视图对象绑定的情况下）。这是很常见的，比如，在表格的列中传递主键到明细页面以便于查询。&lt;/p&gt;
&lt;p&gt;Token Sustitution的例子（使用了视图对象的&amp;ldquo;OrderNum&amp;rdquo;属性）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OA.jsp?OAFunc=FWK_TBX_T_PO_PAGE&amp;amp;order={@OrderNum}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;产生的链接为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OA.jsp?OAFunc=FWK_TBX_T_PO_PAGE&amp;amp;order=123
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Token类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tokens使用了特殊的字符前缀告诉OA Framework如何获取值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;{!Attr} 当URL中存在{!}时将加密属性值（比如，OA.jsp?...&amp;amp;ssn={!SSN}&amp;amp;...）。使用OAPageContext.getParameter("ssn")将返回解密后的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{@Attr} 当URL中存在{@}时属性值将被编码（比如，OA.jsp?...&amp;amp;addr={@EmpAdd}&amp;amp;...）。使用OAPageContext.getParameter("addr")将得到解码后的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{$attr} 原token substitution（不进行编码和加密）因此你必须确保参数值不会打断URL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{@@RETURN_TO_MENU} 可以用于指定应用组件的Destination URI属性，如果你希望用户返回EBS套件的个人主页。如果需要在执行JSP forward时指定这个，可以使用常量OAWebBeanValues.RETURN_TO_MENU_URL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;{@@RETURN_TO_PORTAL} 用于指定组件的Destination URI属性，以便让用户返回Portal页。在JSP forward中可以使用常量OAWebBeanValues.RETURN_TO_PORTAL_URL。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;编码&lt;/h2&gt;
&lt;p&gt;任何为请求指定的参数必须遵循HTTP语法规则。比如，不能在URL参数值传递空格；当访问的URL中包含：&lt;code&gt;buyerName=John Doe&lt;/code&gt;时将产生运行时错误。&lt;/p&gt;
&lt;p&gt;为修正这个错误，我们将对这些值进行编码，编码将替换有问题的字符，将值变为：&lt;code&gt;byerName=John%20Doe&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当OA Framework添加参数到请求中时（比如表字段的值），它将对它们自动编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当调用setForward*方法设置参数时，OA Framework将自动编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你自己组装URL参数时（比如，通过调用setDestination方法设置某个bean的URL时），必须对字符串中可能出现的非法字符进行编码。可以将字符串传递给oracle.apps.fnd.framework.webui.OAUrl工具类的encode方法进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 如果手工设置URL参数不包含非法字符（比如，&amp;ldquo;value=Y&amp;rdquo;）则不需要担心编码的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当使用OAPageContext.putParameter设置参数时，如果需要也必须对字符串进行编码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用OAPageContext.getParameter*方法时OA Framework将自动解码参数值，下列情况除外：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当为JavaScript函数tokens使用&amp;ldquo;#&amp;rdquo;字符时，OA Framework对token值编码，但不会在你调用pageContext.getParameter("&lt;tokenname&gt;")时自动解码。如果需要，你可以自己使用OAUrl类的decode方法对getParameter方法的返回值进行解码。&lt;/tokenname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当你使用一个已经编码了参数调用putParameter方法时，OA Framework将不会对它进行解码。你也必须使用OAUrl的decode方法对getParameter的返回值进行解码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;加密&lt;/h2&gt;
&lt;p&gt;加密处理将混淆参数值。由于URL请求参数可能是对用户可见的（用户查找HTML页面源码时也可以看到隐藏域的值），总是应该对存储于URL参数或隐藏域的数据进行加密。&lt;/p&gt;
&lt;p&gt;另外，上面描述了基于token的加密，OA Framework在oracle.apps.fnd.framework.webui.OAPageContext中提供了方法用于编程中加密和解密请求中的参数值。&lt;/p&gt;
&lt;h1&gt;样式&lt;/h1&gt;
&lt;p&gt;OA Framework使用blaf.xss统一定义用户界面样式。&lt;/p&gt;
&lt;h2&gt;使用样式&lt;/h2&gt;
&lt;p&gt;所有添中到页面的的region和大多数的item都会自动设置风格。&lt;/p&gt;
&lt;p&gt;几种必须为items设置CSS Class属性的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果创建了一个staticStyledText item，用于instruction text，则必须将它的CSS Class设置为OraInstruction Text。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何文本输入域，多选框，poplists和radio必须将CSS Class设置为OraFieldText。不要在radio和checkboxes上使用OraPromptText。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果使用messageStyledText item来显示只读数据，必须将CSS Class设置为OraDataText以便将文字加粗（不要在table columns中使用这个设置）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; OA Framework新手通常犯的错误是试图修改CSS style来修改组件&amp;ldquo;原生&amp;ldquo;的外观。如果发现这样做出了问题（比较困难因为样式设置不会在运行时起作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;确认你使用了正确的bean（region或item style）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果确认使用了正确的bean，检查它是否公开了一个用于达到这个目的的方法。比如，oracle.apps.fnd.framework.webui.beans.layout.OAHeaderBean继承了setSize(int size)方法以便于你控制header text的size。你不能通过设置header的CSS Class为OraHeaderSubSub来改变这个效果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;创建风格&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;自定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OA Framework自动将custom.xss设置为了主样式。任何自定义设置可以添加到这个样式表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E-Business Suite Application开发者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面所说的custom.xss包含了oa.xss，它依次包含了blaf.xss。&lt;/p&gt;
&lt;p&gt;oa.xss用于包含任何对于BLAF样式的修改。你不应该创建自己的样式表。&lt;/p&gt;
&lt;h1&gt;无障碍环境&lt;/h1&gt;
&lt;p&gt;OA Framework应用是无障碍的，可以由盲人、弱视、色盲或聋人使用。&lt;/p&gt;
&lt;h1&gt;国际化&lt;/h1&gt;
&lt;p&gt;OA Framework应用被设计为完全本地化。国际化相关的章节讨论了关于语言、时区、日期的数字的国际化。&lt;/p&gt;
&lt;h1&gt;模型交互&lt;/h1&gt;
&lt;p&gt;在指定好数据源绑定后，OA Framework自动从模型中读取数据以便视图显示，并自动将用户输入视图中的数据回写到模型。不需要编写代码（除了为下层的实体编写校验）。&lt;/p&gt;
&lt;h2&gt;读取模型数据&lt;/h2&gt;
&lt;p&gt;OA Framework每次渲染页面时，它将为每个web bean关联的视图对象属性调用当前视图对象行的get&lt;attributename&gt;方法。&lt;/attributename&gt;&lt;/p&gt;
&lt;p&gt;例如，对于&amp;ldquo;Suppliers&amp;ldquo;表，绑定到了SuppliersVO视图对象。SuppliersVO映射到了SupplierEOImpl，尽管它也包含了一个&amp;ldquo;计算&amp;rdquo;属性（&amp;ldquo;OnHoldDisplay&amp;rdquo;），它与不对应的实体的属性对应。&lt;/p&gt;
&lt;p&gt;OA Framework在执行查询后读取模型数据：&lt;/p&gt;
&lt;p&gt;&lt;img alt="read_data_flow" src="/oaf_build_view/read_data_flow.gif"/&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户选择&amp;ldquo;Search&amp;ldquo;区域中的&amp;ldquo;Go&amp;ldquo;按钮查询&amp;rdquo;Suppliers&amp;ldquo;表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;Search&amp;ldquo;区域中的控制器处理按钮事件调用根应用模块的search方法，它返回代理了SuppliersVOImpl类，因此它可以查询自己。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在executeQuery方法中，SuppliersVOImpl视图对象在数据库中执行SQL SELECT。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于结果集中的第一行，视图对象创建一个SupplierEOImpl实体对象的实例并根据查询结果设置它的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 实体对象的属性值实际不是存储于视图对象中的。它们&amp;ldquo;生存&amp;rdquo;于实体对象，可以被需要的视图对象访问。&amp;ldquo;计算（Calculated）&amp;rdquo;或&amp;ldquo;临时（Transient）&amp;rdquo;类型的视图属性是存储在SuppliersVORowImpl对象中的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在页面渲染时（在所有查询处理完成后），OA Framework依次为每个web bean调用SuppliersVORowImpl对象中适当的getAttribute("&lt;attributename&gt;")方法绑定数据。&lt;/attributename&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SuppliersVORowImpl get&lt;attributename&gt;方法返回调用对应的SupplierEOImpl get&lt;attributename&gt;方法获得的值。对于&amp;ldquo;计算（calculated）列OnHoldDisplay属性，视图行对象从它自己的缓存中获取值。&lt;/attributename&gt;&lt;/attributename&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;写入模型数据&lt;/h1&gt;
&lt;p&gt;不论何时，浏览器发出POST请求，OA Framework将自动把用户输入表单的数据写入下层的视图对象，它再依次更新对应的实体。&lt;/p&gt;
&lt;p&gt;HTTP POST数据过程：&lt;/p&gt;
&lt;p&gt;&lt;img alt="write_data_flow" src="/oaf_build_view/write_data_flow.gif"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 下面的步骤假设数据库行所对应的实体对象已经被实例化和初始化（比如在进入Create页面时已经调用了视图对象的create方法创建实体对象）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;UIX执行onSubmit的JavaScript校验（必填字段，数据类型，格式），并在校验通过时发送POST请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器发送POST请求，OA Framework调用web bean结构中的processFormData方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在processFormData内部，OA Framework自动为每个web bean调用下层视图对象的当前行对象的setAttribute(String name, Object value)方法。这也执行编写于视图行对象中任何属性级别（attribute-level）的校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在setAttribute方法中，视图行自动自动调用对应的下层的实体对象中的set&lt;attributename&gt;方法，这也将执行实体对象中相关的属性级别的校验。&lt;/attributename&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一旦所有属性被设置后，OA Framework为修改过的每一行调用视图对象的validate方法以执行任何相关的行级（row-level）的校验。。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，在validate方法中，视图行对象调用下层实体的validateEntity方法以执行相关的实体级别（entity-level）的校验。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework自动显示模型层在执行processFormData过程中抛出的任何异常，并不会继续调用processFormRequest的下一部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跳过校验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上所述，OA Framework在每次form提交时写入模型数据，这意味着所有属性和实体级的校验都被执行。有几个机会让你&amp;ldquo;短路（short-circuit）&amp;ldquo;这些错误以防在不方便的时候报告给用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺省值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当使用&amp;ldquo;Create&amp;rdquo;页面创建新行时，可以在3个地方指定默认值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;[Model] 如果你的视图对象是基于一个或多个实体，你可以覆盖它们的create()方法以编程的方式设置属性级的缺省值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[Model] 也可以在使用BC4J实体定义向导时定义实体属性的缺省值。注意Oracle内部的EBS开发者不应该使用这个选项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[View] 也可以在Oracle JDeveloper OA Extension中设置各个item的Initial Value属性。这个做法的好处是&amp;mdash;&amp;mdash;对于静态值可以在设计时决定&amp;mdash;&amp;mdash;它可以很容易的由用户个性化这些缺省值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺省值功能默认是关闭的，必须根据FND:OA:Enable Defaults/FND OA ENABLE DEFAULTS将值设置为Y来启用这个功能。&lt;/p&gt;
&lt;p&gt;如果在首选项中启用了并且在视图中（OA Extension或个性化）的表单元素（不能是messageChoice或messageRadioGroup）中指定了默认值，则OA Framework将根据下面的规则设置item的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果item与视图对象数据源没有关联，则首选项的设置将不产生影响。OA Framework在页面被渲染后自动设置item为默认值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果item与视图对象关联，OA Framework会在你调用视图对象的createRow()方法时设置缺省值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在首选项中启用了并且在视图对象中（OA Extension或个性化）的表单元素是messageChoice或messageRadioGroup，则OA Framework将根据下面的规则设置适当的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果当前行需要显示的这个属性值不为null，则值被设置为指定的默认值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前需要显示的这个属性值为null，则显示的值将决定于指定的默认值，并且值将被应用于视图对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的例子显示了创建新行的典型代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;createSupplier&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSuppliersVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// The OA Framework applies UI defaults during the scope of this&lt;/span&gt;
  &lt;span class="c1"&gt;// method call.&lt;/span&gt;
  &lt;span class="n"&gt;Row&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRow&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;insertRow&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// As specified in OA Framework Model Coding Standards,&lt;/span&gt;
  &lt;span class="c1"&gt;// always set the new row state to STATUS_INITIALIZED&lt;/span&gt;
  &lt;span class="c1"&gt;// after you create it.&lt;/span&gt;
  &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setNewRowState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STATUS_INITIALIZED&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;createRow()方法调用各个ViewRowImpl的create()方法。在调用create()过程中，OA Framework调用需要指定了缺省值的每个UI组件的setter方法，如果需要这些值将被应用（译：根据下文，应该是指应用到视图对象）。这确保了视图行的校验和相关的实体对象属性的校验。然后OA Framework将视图行对象的状态重置为STATUS_INITIALIZED，以便它不被BC4J组件修改。这确保了用户导航到其它页面时将持有默认值而不会产生丢失工作的警告。在缺省值的处理过程中检查到的任何异常通常都将显示出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 在视图行被创建后默认值只会被应用一次。如果你有一个多页面流带有多个区域，这个区域绑定到相同的下层视图对象&amp;mdash;&amp;mdash;每个区域都对一个视图属性指定了一个不同的Initial Value&amp;mdash;&amp;mdash;只有第一个区域渲染时设置的缺省值会被关联。其它的将被忽略。同样，如果在Page A创建了一个新行，然后导航到Page B，在这里设置了一个属性的Initial Value，缺省值不会被应用，因为行对象是在Page B渲染前创建的。&lt;/p&gt;
&lt;p&gt;对于下面的三种情况，OA Framework遵守下面的优先级：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;（最高级）item属性缺省使用在OA Extension设计的值或Personalizations模块中指定的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编程方式指定的实体对象属性值（在执行vo.createRow()方法时将代理实体对象的create()方法）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（最低级）在设计时指定的实体对象属性值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果需要确保默认值总是被设置而不管值有可能在设计器中指定，你可以覆盖视图对象的insertRow()方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;EmployeesVOImpl&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;OAViewObjectImpl&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;

  &lt;span class="o"&gt;...&lt;/span&gt;

  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;insertRow&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Row&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Always call super.insertRow() first.&lt;/span&gt;
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;insertRow&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;


    &lt;span class="c1"&gt;// Now call whatever attribute setters you need to call to ensure&lt;/span&gt;
    &lt;span class="c1"&gt;// that your defaults always take precedence.&lt;/span&gt;
    &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setAttribute&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;attributeName&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;attributeValue&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;);&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;

  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;菜单和页面安全&lt;/h1&gt;
&lt;p&gt;在OA Framework应用中，页面中的菜单是用tab模型来实现的。&lt;/p&gt;
&lt;p&gt;OA Framework ToolBox 教程的菜单：&lt;/p&gt;
&lt;p&gt;&lt;img alt="toolbox_menu" src="/oaf_build_view/toolbox_menu.gif"/&gt;&lt;/p&gt;
&lt;p&gt;菜单结构提供了两个明显的用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将内容组织成有含意的单元&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方便用户在这些单元中导航&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;菜单实现&lt;/h2&gt;
&lt;p&gt;在后台，OA Framework实际上包含了Oracle Applications功能和菜单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导航功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导航功能表示出应用中的各个页面；每个页面与一个预先定义的功能关联。或许最重要的是，这个功能包含了页面的Web HTML Call。比如，在ToolBox Tutorial 应用中，当用户选择Lesson 3菜单项时，Purchase Order Search页被显示出来。我们为这个页面建立了一个功能，并设置它的Web HTML Call指向我们需要显示的XML页面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OA.jsp?page=/oracle/apps/fnd/framework/toolbox/webui/PoSearchPG
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当用户选择Lesson 3菜单项时，请求被路由到OA.jsp，它初始化一个oracle.apps.fnd.framework.webui.OAPageBean对象处理对应的页面XML文件（OA.jsp是访问OA Framework应用页面的唯一的JSP）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 单个页面可以被多个功能调用（每个可能通过URL传递不同的参数），它可以用于多个不同的菜单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;导航菜单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;导航菜单是一组可重用的功能和子菜单的集合，它最终创建了上面所描述的tab结构。每个OA Framework菜单项都关联到某个Type，这决定了它应该如何被渲染。比如，在上面图表中的Lesson 2 tab的Type为&amp;ldquo;HTML Tab&amp;ldquo;。&lt;/p&gt;
&lt;p&gt;导航菜单包含了所有可以显示于应用中的功能。你可以有选择的为导航菜单中的单个功能授权。这将在应用安全一节中详细描述。&lt;/p&gt;
&lt;h2&gt;应用安全&lt;/h2&gt;
&lt;p&gt;应用安全包含的范围很广泛，在这个章节中我们将涉及一些关键的概念，以便对于它支持的内容及它与菜单定义的关系有个基本的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户和责任&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Oracle应用中的责任是任务的集合，它被授给一个或多个用户。比如，你可能创建一个Benefits Manager和一个普通的Employee责任，两个都在HR应用中使用。你将把这些责任授给单个用户，以便用户快速访问这些模块。&lt;/p&gt;
&lt;p&gt;所有的责任都与应用中单个顶级导航菜单相关联。导航菜单最终将包含你的应用支持的所有tab。&lt;/p&gt;
&lt;p&gt;之前，责任是将用户按角色分组的主要机制。你可以将菜单分配给责任，并通过从你的责任中排除个别的菜单项来创建安全规则。在运行时，当前责任，组织机构和安全组一起包含了安全环境（secutiry context）。&lt;/p&gt;
&lt;p&gt;在R12中，责任的概念被扩展为更广泛的角色（role）。用户可以属于一个或多个角色。所有用户被指定给一个特殊的责任时也被指定给也相应的角色（role）。安全规则是基于许可发放（permission grants）机制，而不是功能排除规则。在运行时，这些许可的发放是在当前安全环境（security context）中被评估（evaluated）的，现在,责任，组织机构和安全组（secutiry group）中了也包含了角色（也被称为接受人（grantee））。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;授权和许可&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建导航功能时，必须为页面创建授权功能（Authorization Fuctions也被称为&amp;ldquo;permissions&amp;rdquo;）。然后将这些许可（permission）分组到一个平坦（flat）的菜单结构中（也被你为许可集合（permission set）），以允许用户访问相关的页面。&lt;/p&gt;
&lt;p&gt;介绍许可集合（permission set）最简单的办法就是通过一个简单的用例。比如，假设你有一个非常简单的Benefits应用，它包含下面四个页面：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;页面&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;th align="left"&gt;Benefits（利益）经理访问？&lt;/th&gt;
&lt;th align="left"&gt;员工访问？&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Benefits管理&lt;/td&gt;
&lt;td align="left"&gt;查看、修改、审核、取消审核benefits&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;td align="left"&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;创建Benefits&lt;/td&gt;
&lt;td align="left"&gt;创建新的Benefits&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;td align="left"&gt;No&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;我的Benefits&lt;/td&gt;
&lt;td align="left"&gt;查看当前选择的benefit，并可将新选择的benefit设为自己的&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;修改Beneficiaries（受益人）&lt;/td&gt;
&lt;td align="left"&gt;修改设置beneficiaries&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;td align="left"&gt;Yes&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如上面所说的，你需要为每个页面创建导航功能（Navigation Functions）并将它们组织到导航菜单中。为确保用户可以访问正确的页面，你需要按下面的过程处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步，创建许可（permissions）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与导航功能类似，许可是FND表单函数，但在这个环境中，它们只被用于应用安全。&lt;/p&gt;
&lt;p&gt;在我们的例子中，我们可以使用为每个页面创建导航功能作为许可。不需要创建额外的许可功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第二步，创建角色（role）或接受人（grantees）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接受人可以是一个用户（FND_USER）或用户组（被称为role）或&amp;ldquo;global&amp;rdquo;。用户（User）（译注：泛指系统用户，可以是人或组织）在FND_USERS中被创建，应该被与单个的具体的人或组织一一对应。角色（Roles）在WF_ROLES中被定义，可以在客户的LDAP系统中被映射到用户组。尽管成员没有被显式的增加，仍然有一个全局（Global）组包含有&amp;ldquo;所有人（everyone）&amp;rdquo;&lt;/p&gt;
&lt;p&gt;在上面的例子中需要两个用户角色：一个用于将所有管理员（managers）分到管理员角色，另一个用户将包含所有的员工（employees）。由于员工包含了所有人，因此也可以使用全局（Global）角色。&lt;/p&gt;
&lt;p&gt;另外，你也可以创建一个责任并把它赋给所有管理员，用这种方式设置授权（grant）。&lt;/p&gt;
&lt;p&gt;我们将在第四步创建授权（grants）时将讨论这两种方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建许可集合（permission sets）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;许可集合&lt;/strong&gt; 被作为菜单来实现，但它们只是简单的将许可分组为平面的列表中以便获取许可。概念上，应该将根据角色需要将许可集合分组为一个或多个许可集。&lt;/p&gt;
&lt;p&gt;上面的例子需要两个许可集：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个管理员许可集合可以访问所有管理员需要操作的页面。这包含导航功能&amp;ldquo;Benefits管理&amp;ldquo;和&amp;ldquo;创建Benefit&amp;rdquo;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个Global许可集合允许任何人访问。这包含了导航功能&amp;ldquo;我的Benefits&amp;ldquo;和&amp;rdquo;修改Beneficiaries&amp;ldquo;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建授权&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Grant&lt;/strong&gt; 定义了安全规则，公允许系统中的某些用户访问你的应用中指定的功能或页面。一次 &lt;strong&gt;授权（grant）&lt;/strong&gt; 使 &lt;strong&gt;接受人（grantee）&lt;/strong&gt; 可以访问上面描述的许可集。简单来说，授权将接受人和许可集连接起来。&lt;/p&gt;
&lt;p&gt;对上面的例子需要两个 &lt;strong&gt;授权(grants)&lt;/strong&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;管理员被作为管理员角色（manager role）授权关联到管理员许可集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;员工被作为global接受人与Global许可集关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于这个grant是与global grantee（任何人）关联，并没有其它的安全约束（不受任何责任、组织或安全组的约束），它可以被你为global grant。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以通过其它安全环境因素约束指定接受者（grantee）的授权（grant）。这些因素包括当前用户责任、组织机构、安全组。比如，为了将对管理员的授权（grant）限制在特定组织机构中，可以将组织机构信息与授权（grant）相关联。&lt;/p&gt;
&lt;p&gt;可以将管理员许可集合授予管理员角色，也可以将它授予全局接受者（global grantee）。可以将带有安全环境信息的责任与那些允许访问的管理员关联，以限制哪些管理员可以访问。但是，OA Framework推荐使用基于角色的授权替代责任。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;页面安全&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上面的例子中，我们注意到可以将页面与许可链接来限制访问。这是使用许可来保护页面渲染的情况。&lt;/p&gt;
&lt;p&gt;其它需要使用许可保护页面渲染的情况，包括匿名登录页面，页面需要自动责任设置或切换，且为共享／重用页面。&lt;/p&gt;
&lt;p&gt;详细介绍请阅读Chapter 4: Page Security。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>实现服务端功能之——服务</title><link href="/bus_svc_overview.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/bus_svc_overview.html</id><summary type="html">&lt;h1&gt;面向服务的架构预览&lt;/h1&gt;
&lt;p&gt;服务的概念已经出现了很长时间，但面向服务的概念相对是比较新的。面向服务的架构是一种有助于降低应用耦合的一种构建应用的风格，独立管理的组件可以被重用和重新安排到其它完整功能的应用中。SOA提供下面的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构建和注册服务的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用户发现和调用服务的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行服务的平台&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的图演示了SOA的基本概念：&lt;/p&gt;
&lt;p&gt;SOA的基本概念&lt;/p&gt;
&lt;p&gt;&lt;img alt="srv_overview" src="/oaf_bus_svc_overview/srv_overview.gif"/&gt;&lt;/p&gt;
&lt;p&gt;使用面向服务的架构你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容易的将Oracle Applications和其它的应用集成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;影响已经部署的应用保护现有投资&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易适应更多的需求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;服务预览&lt;/h1&gt;
&lt;p&gt;服务在EBS的开发、测试、分类、公共安全和私有接口架构中是一个关键组件。开发者使用统一的指导方针和实现方式来创建服务，然后当它们控制源代码时被自动发布到集中的接口仓库。&lt;/p&gt;
&lt;p&gt;服务时自描述的，独立的组件可以被部署为web service、EJB session beans或作为共设的Java API（与客户端被部署在同一个JVM中）。服务接口根据用途分为多种不同的类型。Oracle支持业务对象服务。&lt;/p&gt;
&lt;p&gt;业务对象是自包含的代表了真实世界的业务领域对象：一个文档、一个地方、一个人或一件事。从实现的角度来说，业务对象包含一个或多个视力对象（VO）映射到下层的复合实体（EO）（子实体不能没有父对象）。比如，在OA Framework Toolbox Tutorial中采购单业务对象包含了一个头部信息并带有一行或多行明细，每个包含一个或多个供货。供货不能离开明细行独立存在 …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;面向服务的架构预览&lt;/h1&gt;
&lt;p&gt;服务的概念已经出现了很长时间，但面向服务的概念相对是比较新的。面向服务的架构是一种有助于降低应用耦合的一种构建应用的风格，独立管理的组件可以被重用和重新安排到其它完整功能的应用中。SOA提供下面的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构建和注册服务的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用户发现和调用服务的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行服务的平台&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的图演示了SOA的基本概念：&lt;/p&gt;
&lt;p&gt;SOA的基本概念&lt;/p&gt;
&lt;p&gt;&lt;img alt="srv_overview" src="/oaf_bus_svc_overview/srv_overview.gif"/&gt;&lt;/p&gt;
&lt;p&gt;使用面向服务的架构你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容易的将Oracle Applications和其它的应用集成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;影响已经部署的应用保护现有投资&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容易适应更多的需求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;服务预览&lt;/h1&gt;
&lt;p&gt;服务在EBS的开发、测试、分类、公共安全和私有接口架构中是一个关键组件。开发者使用统一的指导方针和实现方式来创建服务，然后当它们控制源代码时被自动发布到集中的接口仓库。&lt;/p&gt;
&lt;p&gt;服务时自描述的，独立的组件可以被部署为web service、EJB session beans或作为共设的Java API（与客户端被部署在同一个JVM中）。服务接口根据用途分为多种不同的类型。Oracle支持业务对象服务。&lt;/p&gt;
&lt;p&gt;业务对象是自包含的代表了真实世界的业务领域对象：一个文档、一个地方、一个人或一件事。从实现的角度来说，业务对象包含一个或多个视力对象（VO）映射到下层的复合实体（EO）（子实体不能没有父对象）。比如，在OA Framework Toolbox Tutorial中采购单业务对象包含了一个头部信息并带有一行或多行明细，每个包含一个或多个供货。供货不能离开明细行独立存在，明细行不能没有头信息。（供货和行是子业务对象组件）。如果删除头，将删除所有的行和供货。通常业务对象视图对象和下层实体对象的区别在于视图对象中出现外键属性，比如定单中的供应商名称。&lt;/p&gt;
&lt;p&gt;下面的摘要是使用业务对象服务的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;业务－业务的集成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用－应用的集成（服务－服务）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BPEL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据导入、导出和同步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;富客户端报表框架，比如XML Publisher&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持SDO标准&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实时数据的企业安全搜索（Secure Enterprise Search of real-time data）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自动创建Web Services&lt;/h2&gt;
&lt;h2&gt;术语&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;业务对象（Business Object）&lt;/th&gt;
&lt;th&gt;自包含的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>Emacs Tips</title><link href="/emacs-tips.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/emacs-tips.html</id><summary type="html">&lt;h1&gt;一 基本概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.常见的按键组合：
    a.最常见的命令都被绑定到了"C-n"(n可以是任意符号)&lt;/p&gt;
&lt;p&gt;b.次常见的命令被绑定到了"ESC n"形式&lt;/p&gt;
&lt;p&gt;c.其它常见的命令被绑定到了"C-x something"&lt;/p&gt;
&lt;p&gt;d.某些特殊命令被绑定到了&amp;ldquo;C-c something"的形式。这些命令通常都与某些特殊的编辑模式有关&lt;/p&gt;
&lt;p&gt;e.有些命令没有被绑定到按钮上。而是通过"ESC x long-command-nam RETURN&amp;rdquo;命令方式执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.如果用F10无法打开菜单,可以用"ESC `"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3."C-x C-v"读错文件时修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4."C-x i"插件文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.使用"C-s"保存时遇到麻烦时,试试使用"C-x C-w …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;一 基本概念&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.常见的按键组合：
    a.最常见的命令都被绑定到了"C-n"(n可以是任意符号)&lt;/p&gt;
&lt;p&gt;b.次常见的命令被绑定到了"ESC n"形式&lt;/p&gt;
&lt;p&gt;c.其它常见的命令被绑定到了"C-x something"&lt;/p&gt;
&lt;p&gt;d.某些特殊命令被绑定到了&amp;ldquo;C-c something"的形式。这些命令通常都与某些特殊的编辑模式有关&lt;/p&gt;
&lt;p&gt;e.有些命令没有被绑定到按钮上。而是通过"ESC x long-command-nam RETURN&amp;rdquo;命令方式执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.如果用F10无法打开菜单,可以用"ESC `"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3."C-x C-v"读错文件时修正&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4."C-x i"插件文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.使用"C-s"保存时遇到麻烦时,试试使用"C-x C-w"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6.帮助系统：
    a."C-h t"启动教程&lt;/p&gt;
&lt;p&gt;b."C-h k"获取按键描述&lt;/p&gt;
&lt;p&gt;c."C-h f"获取函数的描述&lt;/p&gt;
&lt;p&gt;d."C=h"进入帮助系统&lt;/p&gt;
&lt;p&gt;e."C-h i"启动Info页阅读器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;7.看不到菜单时可以使用"ESC x menu-bar-mode"&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;二 文件编辑&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1."ESC x auto-fill-mode RETURN"切换自动换行模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2."ESC G g"中转到指定的行号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3."ESC }"前一段,"ESC {"后一段。"ESC ]"前一页,"ESC ["后一页&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4."ESC n"或"C-u n"重复执行命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5."ESC DEL"向后删除一个单词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;6."C-x C-x"在选择区首尾切换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;7."ESC h"标记段落,"C-x h"标记整个文件,"C-x C-p"标记整页&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;8."ESC q"段落重排&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;9."C-t"交换两个字符的位置,"ESC t"交换两个单词的位置,"C-x C-t"交换两个文本行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;10."ESC c"把单词的首字母改为大写,"ESC u"将整个单词修改为大写,"ESC l"将整个单词修改为小写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;11."C-x u","C-_","C-/"都是撤销命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;12."ESC x recover-file RETURN"从自动保存的文件中恢复文本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;13.Emacs的自动保存文件有一个重要的注意事项:如果在一个文件里进行了一次大规模的删除操作,Emacs将停止自动保存这个文件并显示一条消息通知用户,要想让Emacs再次开始自动保存这个文件,用"C-x C-s"保存一次,或者输入"ESC 1 ESC x auto-save RETURN"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;14."ESC %"查找替换&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="emacs"></category></entry><entry><title>wxPython In Action的读书笔记</title><link href="/wxpython-in-actionde-du-shu-bi-ji.html" rel="alternate"></link><published>2008-07-08T00:00:00+08:00</published><updated>2008-07-08T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-08:/wxpython-in-actionde-du-shu-bi-ji.html</id><summary type="html">&lt;h1&gt;Chap 1 Welcome to wxPython&lt;/h1&gt;
&lt;p&gt;一个20行的wxPython程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"My Frame"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MOTION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnMove&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StaticText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Pos"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;posCtrl …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Chap 1 Welcome to wxPython&lt;/h1&gt;
&lt;p&gt;一个20行的wxPython程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"My Frame"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MOTION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnMove&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StaticText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"Pos"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;posCtrl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TextCtrl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnMove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetPosition&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;posCtrl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;,&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MyFrame&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.1 开始wxPython&lt;/h2&gt;
&lt;p&gt;运行wxPython需要安装的软件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;工具&lt;/th&gt;
&lt;th align="left"&gt;注意点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;操作系统&lt;/td&gt;
&lt;td align="left"&gt;任何Windows 32位系统，Win98以后的版本（如果需要在Win95上运行需要下载一些额外的软件）；Unix或Linux系统兼容GTK；Mac OS X 10.2.3或更高的版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Python&lt;/td&gt;
&lt;td align="left"&gt;任何2.3或以上版本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wxPyhon&lt;/td&gt;
&lt;td align="left"&gt;可以从www.wxpython.org&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;文本编辑器&lt;/td&gt;
&lt;td align="left"&gt;Python源码编辑器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;1.2 构建一个最小的wxPython程序&lt;/h2&gt;
&lt;p&gt;bare.py的源码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Bare'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序运行产生一个空窗口。多数人会把它叫作&amp;ldquo;window&amp;rdquo;。在wxPython中称为&amp;rdquo;frame&amp;ldquo;。在wxPython中&amp;ldquo;window&amp;rdquo;是一个通用的术语，它表示任何可以显示在屏幕上的对象（有些工具包中称为&amp;ldquo;widget&amp;rdquo;）。&lt;/p&gt;
&lt;p&gt;这个程序说明了编写wxPython程序必需的5个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;导入必需的wxPython包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建wxPython application类的子类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义application初始化方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个application类的实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入application的主事件循环&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="121-dao-ru-wxpython"&gt;1.2.1 导入wxPython&lt;/h3&gt;
&lt;p&gt;导入wxPython包&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入包后，可以使用wx包前缀引用wxPython类，函数等：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;旧风格的导入：&lt;/strong&gt; 旧的包名为wxPython它包含了一个内置的模块wx。有两种方法从wxPython包中导入wx模块：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wxPython&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt; &lt;span class="c1"&gt;#DEPRECATED-DON'T DO THIS ANY MORE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者，可以wx模块中的所有内容。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;from&lt;/span&gt; &lt;span class="nv"&gt;wxPython.wx&lt;/span&gt; &lt;span class="nb"&gt;import&lt;/span&gt; &lt;span class="nb"&gt;*&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="nv"&gt;DEPRECATED-DON&lt;/span&gt;&lt;span class="ss"&gt;'T&lt;/span&gt; &lt;span class="nv"&gt;DO&lt;/span&gt; &lt;span class="nv"&gt;THIS&lt;/span&gt; &lt;span class="nv"&gt;ANY&lt;/span&gt; &lt;span class="nv"&gt;MORE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种方式都有严重的缺陷。使用第二种方式import &lt;em&gt;有可能导致命令空间混乱。旧的wx模块通过在所有属性前添加wx前缀避免了这个问题。尽管使用这种安全机制，但是import &lt;/em&gt;仍然可能导致问题，但很多wxPython程序员选择了这种风格，在旧代码中经常能看到这样的代码。这种风格使得类名以小写字母开头（使用wx前缀），而大多数wxPython方法名以大写字母开头。这与Python编程习惯是相反的。&lt;/p&gt;
&lt;p&gt;在导入wxPython的其它东西之前时，必须先导入wx。通常，Python中的导入顺序不相关，可以以任何顺序导入。但在wxPython中，尽管它看起来像一个模块，实际上它是一个复杂的模块集合（多数是由Simplified Wrapper and Interface Generator或SWIG自动产生的），它包装了下层的wxWidget C++ toolkit。当第一次导入wx模块时， wxPython执行其它wxPython模块所必须的初始化工作。一些wxPython的子包，比如xrc模块，可能在导入wx模块前不会工作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;                       &lt;span class="c1"&gt;# Always import wx before&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wrc&lt;/span&gt;              &lt;span class="c1"&gt;# any other wxPython packages,&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;html&lt;/span&gt;             &lt;span class="c1"&gt;# just to be on the safe side.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种要求只是针对wxPython模块；对于其它模块仍可以使用原来的方式，那些模块可以在导入wxPython模块之前或之后导入。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;xrc&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;urllib&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="122-applications-he-frames"&gt;1.2.2 applications 和 frames&lt;/h3&gt;
&lt;p&gt;任何wxPython程序必须有一个application对象和至少一个frame对象。application对象必须是wx.App或其子类的一个实例，子类中需要定义一个OnInit()方法。OnInit()方法将在程序启动时被wx.App父类调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wxPython application类&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyApp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Bare"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MyApp是一个常用的名称。OnInit()方法通常是创建frame对象的地方。但不必像这里一样直接创建wx.Frame的实例，而可以使用wx.Frame的子类。wx.Frame的构造器可以接收多个参数，上面提供的3个参数中只有第一个是必须的，其它的有默认值。&lt;/p&gt;
&lt;p&gt;调用Show()方法使frame可见。如果不调用则frame将被创建而不可见。可以向Show()方法传递一个Boolean参数切换frame显示或隐藏：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;# 使frame可见&lt;/span&gt;
&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                &lt;span class="c1"&gt;# True是缺省参数值&lt;/span&gt;
&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Hide&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                    &lt;span class="c1"&gt;# 与frame.Show(False)相等&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;定义一个应用初始化方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意代码中没有在application类中定义__init__()方法。在Python中，这意味着父类方法，wx.App.&lt;strong&gt;init&lt;/strong&gt;()，将在对象创建时被调用。如果自己定义了__init__()方法，不要忘记调用基类的__init__()：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c1"&gt;# 调用基类的构造器&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="c1"&gt;# 执行其它代码...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不这样做，wxPython将不会初始化，并且OnInit()方法也不会被调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建一个application类实例并进入它的主事件循环&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后一步是创建wx.App子类的实例，并调用它的MainLoop()方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;application主事件循环进入后，控制权被传给wxPython。与过程式程序不同，wxPython GUI程序主要实现为事件机制，多数决定于用户的鼠标点击和键盘输入。当应用中所有的frame被关闭后，app.MainLoop()方法将返回，程序将退出。&lt;/p&gt;
&lt;h2&gt;1.3 扩展最小的wxPython程序&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="sd"&gt;'''Spare.py is a starting point for a wxPython programs. '''&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Spare'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetTopWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 设置为程序的主 frame&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;文件的第一行是一个 &lt;em&gt;shebang&lt;/em&gt; 行。它看起来像一个Python注释，在一些操作系统上，比如Linux和Unix，shebang 告诉操作系统如何找到适当的解释器来执行程序文件。如果程序文件有执行权限我们可以在命令行直接运行程序：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;spare&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;shebang行有益于Unix和Mac OS X用户，其它平台将忽略这行。即使你不使用这些系统，仍然可以包含这行以方便跨平台执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加了模块的的 &lt;em&gt;docstring&lt;/em&gt; 。当模块的第一行是一上字符串时，这个字符串变成模块的docstring 。它被存储在模块的__doc__属性中。可以在代码里，开发环境中，甚至Python解释器中访问到docstring：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;spare&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;spare&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="vm"&gt;__doc__&lt;/span&gt;
&lt;span class="n"&gt;Spare&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;starting&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;wxPython&lt;/span&gt; &lt;span class="n"&gt;programs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应该尽量在Python支持的地方添加docstring 以便于Python开发工具，比如PyCrust，在编码时提供辅助信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在bare.py中程序只是创建了wx.Frame的实例。在spare.py中，使用了自定义的wx.Frame的子类。可以在Frame上添加按钮、文本框等。实际上如果Frame类变得复杂时，可以将它放到独立的模块中，然后导入到主程序中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在application类的实例中添加了一个指向frame实例的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在OnInit()方法中我们调用了App类的SetTopWindow()方法，并将创建的frame作为参数传递给了它。这个方法可以使frame或dialog作为主窗口。一个wxPython程序可以有多个frame，其中一个作为应用的顶级窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后添加了一些Python方法测试程序是作为程序运行还是作为模块被导入。通过检查模块的__name__属性：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果模块被导入，它的 &lt;strong&gt;name&lt;/strong&gt; 属性值将与模块文件名相同（不含扩展名）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;spare&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;spare&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="vm"&gt;__name__&lt;/span&gt;
&lt;span class="s1"&gt;'spare'&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果模块是被执行，而不是被导入，Python将覆盖默认的__name__属性，将它设置为'&lt;strong&gt;main&lt;/strong&gt;'。我们使用这个机制让模块在被执行进入application实例的主循环。&lt;/p&gt;
&lt;h2&gt;1.4 创建hello.py程序&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python           # Shebang&lt;/span&gt;

&lt;span class="sd"&gt;'''Hello, wxPython! program.'''&lt;/span&gt; &lt;span class="c1"&gt;# docstring&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;                       &lt;span class="c1"&gt;# 导入wx包&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;          &lt;span class="c1"&gt;# wx.Frame子类&lt;/span&gt;
    &lt;span class="sd"&gt;'''Frame class that displays an image.'''&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;# 图像参数&lt;/span&gt;
                 &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DefaultPosition&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Hello, wxPython!'&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;'''Create a Frame instance and display image.'''&lt;/span&gt;
        &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConvertToBitmap&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# 显示图像&lt;/span&gt;
        &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetWidth&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetHeight&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StaticBitmap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bitmap&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;              &lt;span class="c1"&gt;# wx.App子类&lt;/span&gt;
    &lt;span class="sd"&gt;'''Application class.'''&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;image&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'./wxPython.jpg'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;BITMAP_TYPE_JPEG&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 图像处理&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetTopWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;                     &lt;span class="c1"&gt;# main()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="c1"&gt;# Import vs. execute&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.5 wxPython可以做什么&lt;/h2&gt;
&lt;h2&gt;1.6 为什么选择wxPython ？&lt;/h2&gt;
&lt;p&gt;Python与wxWidget 结合&lt;/p&gt;
&lt;h2&gt;1.7 wxPython如何工作&lt;/h2&gt;
&lt;p&gt;wxPython是对C++版本的wxWidgets的封装。&lt;/p&gt;
&lt;p&gt;wxPython 用了SWIG产生C++ wxWidgets库的封装函数（glue code）。但也有大量的widgets是C++版本中不存在的。&lt;/p&gt;
&lt;p&gt;对比wxPython和C++ wxWidget，可以看到wxPython不需要创建starting point。由于Python的动态特性，可以使用 wx.Bind()方法动态绑定事件。C++ 程序中必须使用宏在编译时静态的处理。&lt;/p&gt;
&lt;h1&gt;Chap 2 Giving your wxPython program a solid foundation&lt;/h1&gt;
&lt;p&gt;wxPython程序的两个基础对象：application object和top-level window object。&lt;/p&gt;
&lt;h2&gt;2.1 必需的对象&lt;/h2&gt;
&lt;p&gt;application对象管理主事件循环，它是整个wxPython程序的心跳。application的主要工作是启动主事件循环。另外application对象有最后处理任何事件的机会。没有application对象，wxPython应用不能运行。&lt;/p&gt;
&lt;p&gt;顶层窗口对象通常管理展示给用户的最重要的数据和控件。&lt;/p&gt;
&lt;p&gt;这两个对象的关系如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_2_1.png" src="/wxPython/figure_2_1.png"/&gt;&lt;/p&gt;
&lt;p&gt;这个图显示，application对象&amp;ldquo;拥有&amp;rdquo;顶层窗口和主事件循环，顶层窗口管理窗口中的组件和赋给它的数据。窗口和其中的组件在用户动作时触发事件，并在接收到事件通知时改变显示的内容。&lt;/p&gt;
&lt;h2&gt;2.2 如何创建和使用application对象&lt;/h2&gt;
&lt;p&gt;第个wxPython程序都需要一个application对象。application对象必须是一个wx.App或其子类的一人实例。application对象的主要目的是在后台管理主事件循环。主事件循环响应窗口系统的事件并分配它们到适当的事件处理器。application对象对于wxPython是如此重要，以至于如果没有application对象，将不能创建任何的wxPython图形对象。&lt;/p&gt;
&lt;p&gt;wx.App父类也定义了少量整个应用的全局属性。多数情况下，这就是所有你需要的application对象的功能。在自定义application类中，你可以用它管理全局数据或连接（数据库连接）等。某些情况下你或许需要扩展主事件循环以处理特殊的错误或事件。但是，缺省的事件循环几乎适合于所有你将编写的wxPython程序。&lt;/p&gt;
&lt;h3 id="221-chuang-jian-wxappzi-lei"&gt;2.2.1 创建wx.App子类&lt;/h3&gt;
&lt;p&gt;开始一个新应用的时候创建application的子类是一个好的主意，即使你不需要任何自定义的功能，也可以为将来预留扩展。创建wx.App的子类，需要四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义子类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写OnInit()方法的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在程序中创建这个类的实例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用application实例的MainLoop()方法。这个方法将程序控制权传递给wxPython。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OnInit()方法将在wxPython应用启动后，在进入主事件循环开始之前被调用。这个方法不接收参数并返回一个布尔值&amp;mdash;&amp;mdash;如果返回值为False，则应用程序立即退出。多数情况下，将会返回True。退出应该只会出现在错误处理中，比如缺少必要的资源。&lt;/p&gt;
&lt;p&gt;由于OnInit()方法的存在，它是wxPython框架的一部分，任何自定义初始化工作通常在这个里处理，而不是在Python的__init__方法中。如果你决定使用__init__方法，则必须调用父类的__init__方法，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常，你需要在OnInit()方法中至少创建一个frame对象，并调用它的Show()方法。你可以调用SetTopWindow()将这个frame指定为应用程序的顶级窗口。顶级窗口被作为没有父窗口的对话框的缺省父窗口&amp;mdash;&amp;mdash;本质上就是程序的主窗口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎样省略wx.App子类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以不创建wx.App的子类。通常需要在OnInit()方法中创建顶级窗口。但这并不能阻止我们在应用的其它地方创建frame，比如__main__语句。唯一的约束是wx.App实例必须先创建。通常创建wx.App子类是个好的办法，如果系统只有一个frame，这样application的初始化工作没有多少价值。这种情况下，wxPython提供了wx.PySimpleApp类。这个类提供了OnInit()方法的骨架，它的定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;useBestVisible&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clearSigInt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;useBestVisible&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="n"&gt;clearSigInt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个使用wx.PySimpleApp例子，如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MyNewFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行创建了一个wx.PySimpleApp()的实例。因为使用wx.PySimpleApp类，我们没有OnInit方法，因此我们在第二行定义了frame，由于没有指定parent，因此它是一个顶级frame。第三行显示frame。最后，调用application的主循环。&lt;/p&gt;
&lt;p&gt;使用wx.PySimpleApp不需要自定义application类。但应该只在非常简单的应用中使用这种方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;命名约定&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;wxPython是从C++ wxWidget派生的，使用了C++的命名约定。Python中，方法名通常使用lower_case_separated_by_underscores或者lowerCaseInterCap风格。但在C++ 中，方法名通常使用UppserCaseInterCap风格。为了保持一致性，推荐在 wxPython 类中使用wxWidgets的风格。&lt;/p&gt;
&lt;p&gt;wxPython类也在属性上使用了Get和Set方法。这是C++风格，因为在Python程序通常不定义特殊的访问方法。C++数据成员通常是private的，多数情况下你必须使用访问方法来访问wxPython类成员，而不能访问原始的属性名。&lt;/p&gt;
&lt;h3 id="222-li-jie-applicationdui-xiang-de-sheng-ming-zhou-qi"&gt;2.2.2 理解application对象的生命周期&lt;/h3&gt;
&lt;p&gt;wxPython的生命周期开始于application实例创建，结束于最后一个窗口被关闭。并不是需要在Python脚本的开始和结束位置使用这些代码。可以在创建wxPython程序前做一些操作，在application的MainLoop()退出后执行一些清理操作。但所有wxPython的操作必须在application对象的生命周期中操作。这说明主窗口（frame）必须在wx.App对象创建后才能创建。（这也是推荐在OnInit()中创建顶级窗口的原因，这里保证了application对象已经存在了。）&lt;/p&gt;
&lt;p&gt;如图所示，创建application对象触发OnInit()方法并允许创建新的窗口。OnInit()执行后，将执行MainLoop()，表示wxPython事件被处理。应用继续执行，事件处理直到窗口被关闭才结束。所有顶层窗口被关闭后，MainLoop()函数返回后application对象被销毁。接下来，脚本可以关闭任何连接或存在的线程。&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_2_2.png" src="/wxPython/figure_2_2.png"/&gt;&lt;/p&gt;
&lt;h2&gt;2.3 如何重定向 wxPython 程序的输出？&lt;/h2&gt;
&lt;p&gt;所有Python程序可以通过两个标准流输出文本：标准输出流sys.stdout和标准错误流sys.stderr。但是，在创建application对象时你可以控制wxPython将这些标准流重定向到一个窗口中。这个重定向行为在Windows下是默认行为。在Unix系统中，它更像是一个实际的终端窗口，wxPython缺省不控制标准流。在所有系统中，重定向行为可以在创建application对象时显式的指定。推荐使用这个功能的优点，总是指定重定向以避免在不同平台间产生不同的行为。&lt;/p&gt;
&lt;h3 id="231-zhong-ding-xiang-shu-chu"&gt;2.3.1 重定向输出&lt;/h3&gt;
&lt;p&gt;如果wxPython控制标准流，发送到流中的文本（包括print语句或system trackback）被重定向到单独的wxPython frame。在wxPython应用开始前或之后发送到流中的文本，仍然会像的方式那样处理。下例演示了应用生命周期和stdout/stderr重定向。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="c1"&gt;# -*- coding: cp936 -*-&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"Frame __init__"&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"App __init__"&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnInit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"OnInit"&lt;/span&gt;                  &lt;span class="c1"&gt;# 写到stdout&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'Startup'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# 创建frame&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetTopWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"A pretend error message"&lt;/span&gt; &lt;span class="c1"&gt;# 写到stderr&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnExit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"OnExit"&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;redirect&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;            &lt;span class="c1"&gt;# 1.文本重定向从这行开始，这行后，所有文本被重定向到frame中&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"before MainLoop"&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                      &lt;span class="c1"&gt;# 2.进入主循环&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"after MainLoop"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这行创建了application对象。从这行后面开始，所有发送到stderr和stdout的文本被wxPython重定向到一个frame中。构造器参数决定了是否进行重定向。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当运行时，application创建了一个空的frame，也创建了一个显示用于重定向输出的frame。注意，stdout和stderr的信息都被定向到这个窗口中。在运行这个程序后只能在终端看到下面的输出：
&lt;example&gt;
App &lt;strong&gt;init&lt;/strong&gt;
after MainLoop
&lt;/example&gt;
第一行产生于frames被打开之前，第二行产生于它们关闭后。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过查看终端和用于输出的frame，我们可以获知整个应用的生命周期。&lt;/p&gt;
&lt;p&gt;1所示的位置是脚本的启点，从脚本的__main__子句开始运行。接下来在实例上调用wx.App__init__()，控制权转到OnInit()方法，它被wxPython自动调用。从那里，程序转评戏wx.Frame.&lt;strong&gt;init&lt;/strong&gt;()，当wx.Frame实例化后被执行。最后控制转回__main__子句，MainLoop()被调用。主循环结束后，wx.App.OnExit()被wxPython调用，然后执行其余的脚本完成整个过程。&lt;/p&gt;
&lt;p&gt;从OnExit()中发出的消息既没有显示在窗口中也没有显示在终端中。实际上在窗口被关闭前执行了显示消息的操作，只是由于速度太快看不到。&lt;/p&gt;
&lt;p&gt;快速消失的OnExit()消息对于重定向输出的frame有更大的问题。尽管它在开发阶段是个有用的功能，但你不需要在运行时将带有错误消息流的Frame在用户界面中弹出。而且，如果在执行OnInit()方法时发生了错误，它将把消息发送到重定向frame，但错误将导致应用退出，因为OnInit()将在遇到错误时返回False。结果就会出现文本显示了但消失得很快而看不到。&lt;/p&gt;
&lt;h3 id="xiu-gai-que-sheng-de-zhong-ding-xiang-xing-wei"&gt;修改缺省的重定向行为&lt;/h3&gt;
&lt;p&gt;为了修正上面的行为，wxPython允许在创建应用时设置两个参数。第一个参数，redirect，如果被设置为True输出将被重定向到frame中，如果设置为False，输出仍然输出到终端。如果redirect参数为True，第二个参数，filename，可以被设置。如果设置了，输出被重定向到这个参数所指定的文件名，而不是wxPython frame。因此，修改wx.App创建的代码为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将导致下面的输出显示在终端：
&lt;example&gt;
App &lt;strong&gt;init&lt;/strong&gt;
OnInit
Frame &lt;strong&gt;init&lt;/strong&gt;
A pretend error message
before MainLoop
OnExit
after Mainloop
&lt;/example&gt;
注意这里的OnExit()消息显示出来了。将这行代码改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;App&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"output"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将使输出发送到名为filename的文件中。App __init__和after MainLoop消息将被发送到终端，这是由于这们发生在wx.App对象控制输出流的周期之外。&lt;/p&gt;
&lt;h2&gt;2.4 如何关闭wxPython应用&lt;/h2&gt;
&lt;p&gt;当应用中最后一个顶级窗口（top-level）被用户关闭后，wxPython应用退出。top-level，指没有parent，不仅仅指使用了SetTopWindow()方法设置的frame。也包括那些由wxPython自己创建的frame。比如，在上例中应用只有在主frame和重定向输出的frame都被关闭时才会被关闭，即使只用主frame使用了SetTopWindow()，即使在应用中没有显式的创建重定向的frame。编程的方式触发关闭，可以在所有top-level窗口中调用Close()。&lt;/p&gt;
&lt;h3 id="241-guan-li-zheng-chang-guan-bi"&gt;2.4.1 管理正常关闭&lt;/h3&gt;
&lt;p&gt;在关闭的过程中，wxPython删除所有窗口和释放相关资源。有一个勾子可以使你在退出时执行自己的代码。如果在wx.App的子类中定义了OnExit()方法，它将在最后一个窗口被关闭后在wxPython进行清理前执行。你可以使用这个方法清理你创建的非wxPython的资源（比如数据库连接）。即使应用是使用wx.Exit()关闭的，OnExit()方法也将被触发。&lt;/p&gt;
&lt;p&gt;如果由于某些原因你希望在最后一个窗口被关闭后继续执行，你可以使用wx.App的方法SetExitOnFrameDelete(flag)改变这个默认行为。如果flag参数被设置为False，程序将继续执行即使最后一个窗口被关闭。这意味着wx.App实例继续存活，事件循环将继续处理事件。你可以创建新的顶级窗口。应用将继续存活直到全局函数wx.Exit()被显式的调用。&lt;/p&gt;
&lt;p&gt;wxPython在进入主事件循环前不会触发这个关闭过程。比如，你在OnInit()方法中打开一个对话框，你可以关闭它而不用担心wxPython会将这个操作解释为最后一个顶级窗口被关闭而关闭程序。&lt;/p&gt;
&lt;h3 id="242-guan-li-jin-ji-guan-bi"&gt;2.4.2 管理紧急关闭&lt;/h3&gt;
&lt;p&gt;某些时候你需要应用立即结束而不关心程序的清理工作。比如系统关闭，你不能执行所有的清理工作。&lt;/p&gt;
&lt;p&gt;紧急情况下有两种机制退出wxPython应用。可以调用wx.App的方法ExitMainLoop()。这个方法显式的导致主消息循环中断，导致程序控制权离开MainLoop()函数。这通常将结束应用程序&amp;mdash;&amp;mdash;效果与关闭所有顶级窗口相等。&lt;/p&gt;
&lt;p&gt;也可以调用全局方法wx.Exit()。两个方法都不推荐在正常情况下使用，因为它可能导致一些清理函数被跳过。&lt;/p&gt;
&lt;p&gt;有时，你的应用由于不可控的外部原因需要关闭。比如当操作系统被关闭或用户登出。这种情况下，你的应用能获得一个机会清理或保存文档或关闭连接。如果应用绑定了一个事件处理器到wx.EVT_QUERY_END_SESSION事件，则那个事件处理器将在应用关闭时被wxPython通知。（第三章将介绍如何绑定事件到事件处理器）事件参数是一个wx.CloseEvent。关闭事件允许应用否决应用的关闭。应用使用事件的方法CanVeto()来否决应用的关闭。如果你不能成功的保存或关闭所有资源，你可能需要这么做。默认的wx.EVT_QUERY_END_SESSION事件处理器调用顶级窗口的Close()方法，这样将依次发送wx.EVT_CLOSE事件到顶级窗口，给了你另一个机会来控制关闭的过程。如果任何Close()方法返回False则应用将试图阻止应用关闭。&lt;/p&gt;
&lt;h2&gt;2.5 如何创建和使用顶级窗口对象&lt;/h2&gt;
&lt;p&gt;顶级窗口对象是一个构件（widget）（通常是一个frame）它不被应用中的其它构件所包含。顶级窗口通常是应用程序的主窗口，它包含构件和用于与用户交互的界面对象。前面说过，当所有顶级窗口被关闭时应用程序将退出。&lt;/p&gt;
&lt;p&gt;应用至少有一个顶级窗口对象。顶级窗口对象通常是wx.Frame类的子类，尽管它也可以是wx.Dialog的子类。多数情况下你会在应用中自定义wx.Frame的子类。但wxPython中定义了许多典型的wx.Dialog的子类。&lt;/p&gt;
&lt;p&gt;通常&amp;ldquo;顶级窗口（top-level）&amp;rdquo;指应用中任何（any）没有父容器的构件。你的应用必须有至少一个，但也可以有多个顶级窗口。但这些窗口中，只有一个被显式的使用SetTopWindow()指定为主顶级窗口（main top window）。如果你不使用SetTopWindow指定一个主顶级窗口，则在wx.App的顶级窗口中的第一个frame被作为主顶级窗口。因此显式的指定主顶级窗口并不是必须的，比如，应用中只有一个顶级窗口。重复调用SetTopWindow()将替换当前的顶级窗口&amp;mdash;&amp;mdash;应用中同一时刻只能有一个顶级窗口。&lt;/p&gt;
&lt;h3 id="251-wxframe"&gt;2.5.1 wx.Frame&lt;/h3&gt;
&lt;p&gt;在wxPython的叫法中，frame通常是被GUI用户称作窗口。也就是说，frame是一个可以由用户在屏幕上移动的容器，它通常包含标题条，菜单条，并能调整大小。wx.Frame是所有frame类的父类。也有一些特殊的wx.Frame的子类。&lt;/p&gt;
&lt;p&gt;当创建wx.Frame的子类时，在__init__()方法中应该调用父对象的构造器wx.Frame.&lt;strong&gt;init&lt;/strong&gt;()。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DefaultPosition&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DefaultSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEFAULT_FRAME_STYLE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"frame"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造器包含了多个参数。通常，应该包含一些合理的默认值。在其它构件的构造器中也可以看到这种参数&amp;mdash;&amp;mdash;这与wxPython中的模式类似。&lt;/p&gt;
&lt;p&gt;parent | 创建这个frame的父窗体。对于top-level窗口，这个值为None。如果窗口使用了parent参数，则新的frame将属于那个父窗口。在父窗口销毁时被销毁。根据具体的平台，新的frame可能被限制于显示在父窗的上面。在MDI窗口中，新的frame只能在父窗口内部移动和改变大小。
id | 新窗口的wxPython ID号。可以显式的传递一个值，或传入-1以由wxPython自动产生一个新的ID。
title | 窗口标题&amp;mdash;&amp;mdash;多数风格下，它将在窗口的标题条上。
pos | 一个wx.Point对象指定新窗口的左上角在屏幕上的位置。在典型的图形应用中，(0,0)指屏幕的左上解。默认的值为(-1,-1)，这将窗口摆放的位置交给下层的系统自动处理。
size | 一个wx.Size对象指定窗口的大小。默认为(-1,-1)指定由下层的系统自动处理。
style | 一个位常量决定窗口的风格。可以使用位或操作符（|）组合一种或多种效果。
name | 给frame设置的内部名称，用于在Motif中设置资源的值。也可以在后面用于通过名称查找窗口&lt;/p&gt;
&lt;p&gt;设置默认值的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"My Friendly Window"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="252-wxpython-id"&gt;2.5.2 wxPython ID&lt;/h3&gt;
&lt;p&gt;ID号是wxPython中所有构件都有的。wxPython应用中每个构件都有一个窗口标识。ID号在每个frame中必须是唯一的，但在不同的frame间可以重用ID。我们建议，在整个应用中使用唯一的ID号，以防止在事件处理时发生错误和混乱。在wxPython中有少量预定义的ID号，它们在部分代码中的特定的含义（比如，wx.ID_OK和wx.ID_CANCEL假设为对话框中的OK和Cancel按钮的ID值）。通常在应用中重用标准ID并没有问题。ID值参数通常是传递给wxPython构件构造器的第二个参数，放在父构件参数的后面。在wxPython中使用ID值最重要的作用是创建对象事件和事件响应函数之间的关系。使用重复的ID有可以导致对事件触发错误的响应。&lt;/p&gt;
&lt;p&gt;有三种方法创建构件所使用的ID值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;的传递一个正整数值给构造器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过wxPython提供的wx.NewId()函数创建ID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传递全局常量wx.ID_ANY或-1给构造的构造器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="xian-shi-di-jue-ding-id"&gt;显式地决定ID&lt;/h4&gt;
&lt;p&gt;最直接的方式，是传递正整数值给构造器作为构件的ID。如果你传递了这个值，则应该确保这个值在同一个frame中的唯一性或者它为一个预定义的常量值。可以使用全局函数ex.RegisterID()来确认wxPython没有在其它地方使用你指定的值。为了防止你的ID与wxPython预定义的ID重复，你使用的ID值应该处于全局变量wx.ID_LOWEST和wx.HIGHEST之间。&lt;/p&gt;
&lt;h4 id="shi-yong-quan-ju-han-shu-newid"&gt;使用全局函数NewId()&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="shi-yong-chang-liang"&gt;使用常量&lt;/h4&gt;
&lt;p&gt;传递wx.ID_ANY或-1给构造器，则wxPython将自动生成一个新的ID。然后你可以用GetId()方法获取这个ID。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetId&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的三种方法并没有明显的区别。&lt;/p&gt;
&lt;h3 id="253-wxsizehe-wxpoint_1"&gt;2.5.3 wx.Size和wx.Point&lt;/h3&gt;
&lt;p&gt;wx.Frame构造器的参数中使用到了wx.Size和wx.Point。这两个类在wxPython程序中使用较频繁。wx.Point类描述点或位置。构造器接收2个参数作为点的x值和y值。如果没有设置参数则缺省为0。使用Set(x,y)设置两个维的值。使用Get()可以获取这两个值，它将把返回值作为包含两个元素的Python元组返回。与多数wxWidgets类不同，wx.Point有访问x和y值的定义。像访问典型的Python属性一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，wx.Point实例可以作相加，相减，比较操作。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="n"&gt;bigger&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在wx.Point实例中，属性是整数。如果需要浮点坐标，可以使用wx.RealPoint，它与wx.Point类似。&lt;/p&gt;
&lt;p&gt;wx.Size类几乎与wx.Point一样，除了实例变量被命名为width和height而不是x和y。他们有同样的属性和操作符定义。&lt;/p&gt;
&lt;p&gt;当在wxPython程序中需要wx.Point和wx.Size实例时&amp;mdash;&amp;mdash;比如，传递给另一个对象的构造器&amp;mdash;&amp;mdash;你不需要创建实例。只需要传递Python元组给构造器，wxpython将隐式的创建wx.Point和wx.Size实例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这不可以用于构造器，也可以用于被封装的C++方法调用。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetPosition&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="wxframefeng-ge"&gt;wx.Frame风格&lt;/h3&gt;
&lt;p&gt;wx.Frame构造器可接收一个位参数作为style参数。每个wxPython构件对象都有一个类似style的参数，尽管不同类型构件的定义是不同的。这节讨论wx.Frame的风格。其中一些也适用于其它wxPython构件。&lt;/p&gt;
&lt;p&gt;所有wxPython构件的风格定义是通过向构造器传递一个位参数来实现的。一些构件也定义了SetStyle()方法，允许你在创建构件后再修改。所有单个的风格元素都对应有预定义的常量（比如wx.MINIMIZE_BOX）。要将多种风格放在一起，可以使用Python位或操作符，|。比如，wx.DEFAULT_FRAME_STYLE的定义是由一些基础风格元素组成的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MAXIMIZE_BOX&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MINIMIZE_BOX&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RESIZE_BORDER&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SYSTEM_MENU&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CAPTION&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CLOSE_BOX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要移除单个风格位时，可以使用异或操作符，^。比如，创建一个基于默认的窗口，但不想它改变大小，可以这么做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEFAULT_FRAME_STYLE&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;RESIZE_BORDER&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MINIMIZE_BOX&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MAXIMIZE_BOX&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;强烈建议在顶级frame上使用默认风格以便用户可以很容易的识别他们是顶级的窗体。至少，你需要确保顶级的frame可以被关闭。这只需要在风格中包含wx.SYSTEM_MENU。要注意不要使用与操作（&amp;amp;）代替或操作（|）。如果没有风格设置，frame将没有边框，不能移动或关闭。&lt;/p&gt;
&lt;p&gt;wx.Frame中常用的风格参数&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;风格&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.CAPTION&lt;/td&gt;
&lt;td align="left"&gt;在frame上添加标题条，显示frame的标题属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.CLOSE_BOX&lt;/td&gt;
&lt;td align="left"&gt;指示系统在frame的标题条上显示关闭按钮，并使用系统默认的位置和风格。如果可以的话也将启用系统菜单上的关闭选项。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.DEFAULT_FRAME_STYLE&lt;/td&gt;
&lt;td align="left"&gt;如果没有指定style则这个值被作为默认值。它的定义是&lt;code&gt;wx.MAXIMIZE_BOX&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.FRAME_SHAPED&lt;/td&gt;
&lt;td align="left"&gt;使用这个风格创建的frame可以使用SetShape()方法创建一个非矩形的窗口。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.FRAME_TOOL_WINDOW&lt;/td&gt;
&lt;td align="left"&gt;通过缩小标题条使用frame看起来像一个toolbox窗口。在Windows中以这种风格创建的窗口不会显示在任务栏的窗口列表中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.MAXMIZE_BOX&lt;/td&gt;
&lt;td align="left"&gt;在frame上添加最大化按钮，使用系统参数来决定按钮的位置和外观。如果可以也将启用系统菜单上的最大化按钮。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.MINIMIZE_BOX&lt;/td&gt;
&lt;td align="left"&gt;在frame上添加最小化按钮，使用系统参数来决定按钮的位置和外观。如果可以也将启用系统菜单上的最小化按钮。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.RESIZE_BORDER&lt;/td&gt;
&lt;td align="left"&gt;在frame边框上添加调整大小的功能。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.SIMPLE_BORDER&lt;/td&gt;
&lt;td align="left"&gt;在边框上取消装饰。可能不能工作于所有的平台。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.SYSTEM_MENU&lt;/td&gt;
&lt;td align="left"&gt;添加系统菜单（关闭，移动，改变大小，等等。使用系统的外观）和关闭按钮。菜单中的改变窗口大小和关闭操作依赖于wx.MAXMIZE_BOX，wx.MINIMIZE_BOX和wx.CLOSE_BOX的设置。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;2.6 如何添加对象和子窗体到frame上&lt;/h2&gt;
&lt;h3 id="261-tian-jia-gou-jian-dao-frameshang"&gt;2.6.1 添加构件到frame上&lt;/h3&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;InsertFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Frame With Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;# （1）创建面板&lt;/span&gt;
        &lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Close"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;125&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="c1"&gt;# （2）将按钮添加到面板&lt;/span&gt;
                &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （3）绑定按钮点击事件&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_CLOSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="c1"&gt;# （4）绑定窗口关闭事件&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Destroy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;InsertFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;InsertFrame类的__init__方法创建了两个子窗口（1）和（2）。第一个为wx.Panel，它本质上是一个包含其它窗口的容器它自己只有很少的功能。第二个是wx.Button，它是一个普通的按钮。按钮事件的窗口关闭事件绑定到函数是在（3）和（4）。&lt;/p&gt;
&lt;p&gt;多数情况下，你将创建一个单独的wx.Panel实例它的大小和你的wx.Frame的大小是一样的由它来包含所有需要显示在frame中的内容。这样做以保持用户的内容与窗口的其它元素，如工具条、状态条等分离。另外，在Windows操作系统中，wx.Frame的缺省的背景色不是标准的（它是灰色的，不是白色），当然wx.Panel默认是白色背景（假设你没有修改你的系统的主题设置）。wx.Panel类允许使用tab键遍历内部的元素，而wx.Frame不支持。&lt;/p&gt;
&lt;p&gt;与其它UI工具包不同，你不需要调用方法将子窗口插入到父窗口中。在wxPython中你只需要在创建子窗口时指定父窗口，这样子窗口就被添加到父窗口内部。&lt;/p&gt;
&lt;p&gt;在上面的代码中wx.Button创建时指定了位置和大小，而wx.Panel没有指定。在wxPython中，如果frame中只有一个子窗口，则那个子窗口（这里的wx.Panel）将自动改变大小到填充整个frame的客户区域。这个自动处理的过程将覆盖子窗口中设置的位置和大小信息&amp;mdash;&amp;mdash;即使panel指定了位置和大小信息，它也将被忽略。这种自动改变大小的行为只发生在frame或dialog中只有一个元素的情况下。按钮是panel的子对象，而不是frame，因此它指定的大小和位置被使用。如果按钮的位置和大小没有指定则将使用默认的位置，位于panel的左上角，它的大小取决于标签文本的长度。&lt;/p&gt;
&lt;p&gt;显式的指定每个子窗口大小和位置很快就让人觉得泛味。更重要的是，它不允许你的应用在用户调整窗口大小时重新配置对象的位置。为了解决这些问题，wxPython使用sizers对象来管理复杂的子窗口的定位。&lt;/p&gt;
&lt;h3 id="262-tian-jia-cai-dan-tiao-gong-ju-tiao-huo-zhuang-tai-tiao-dao-frame"&gt;2.6.2 添加菜单条、工具条或状态条到frame&lt;/h3&gt;
&lt;p&gt;通常，一个应用程序窗口将有一到三个特殊的子窗口&amp;mdash;&amp;mdash;顶部的菜单条，工具条和底部的状态条。wxPython提供了特殊的快捷方法来创建工具条和状态条（菜单条不是那么困难）。&lt;/p&gt;
&lt;p&gt;下面的代码中的__init__方法在普通窗口上装钸了所有这三种子窗口。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;images&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ToolbarFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Toolbars'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'White'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;statusBar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateStatusBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="c1"&gt;# （1）创建状态条&lt;/span&gt;
        &lt;span class="n"&gt;toolbar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CreateToolBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;     &lt;span class="c1"&gt;# （2）创建工具条&lt;/span&gt;
        &lt;span class="n"&gt;toolbar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AddSimpleTool&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getNewBitmap&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
                              &lt;span class="s2"&gt;"New"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Long help for 'New'"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （3）添加工具条按钮&lt;/span&gt;
        &lt;span class="n"&gt;toolbar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Realize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                                   &lt;span class="c1"&gt;# （4）准备显式工具条&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MenuBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                              &lt;span class="c1"&gt;# （5）创建菜单条&lt;/span&gt;
        &lt;span class="n"&gt;menu1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                                   &lt;span class="c1"&gt;# （6）创建两个独立的菜单&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;File"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Copy"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Copy in status bar"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"C&amp;amp;ut"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"Paste"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AppendSeparator&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Options..."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Display Options"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （7）创建独立的菜单项&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Edit"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                            &lt;span class="c1"&gt;# （8）将菜单加到菜单条&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetMenuBar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                                  &lt;span class="c1"&gt;# （9）将菜单条加到frame&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ToolbarFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（1）创建了状态条，它是类wx.StatusBar的一个实例。作为frame来说，它是一个放置在frame底部的子窗体，它的宽度与frame相同，高度决定于下层的操作系统。状态条的目的是为了显式应用中事件所设置的文本信息。文本的大小和字体也取决于所处的操作系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（2）创建了一个wx.ToolBar的实例，它是一个自动定位于frame顶部的包含命令按钮的容器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（3）有两个方法可以添加工具到工具条，这行显式带少量参数的一种，AddSimpleTool()。参数是一个ID、位图、作为帮助信息显式的tips、显式在状态条上的较长的提示信息。尽管工具在工具条上看起来像按钮，但对于事件系统，它的行为更像一个菜单项，它使工具表现得与菜单条中的项一样。特别是点击工具按钮触发的wxPython事件类型与菜单项的一样，这意味着它们可以使用同样的方法来响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（4）Realize()方法告诉工具条计算按钮应该放在什么位置，这是需要的，因为工具条添加工具依赖于动态定位，因为它没有显式指定自己的大小和位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（5）创建一个wx.Menu对象，它描述一个菜单项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（6）创建独立的菜单项，参数有ID、项上的文本、显示在状态栏上的文本。&amp;ldquo;&amp;amp;&amp;rdquo;指定菜单项的快捷键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2.7 使用通用对话框&lt;/h2&gt;
&lt;p&gt;wxPython库提供了丰富的预定义的对话框，它使你的应用有统一、熟悉的外观。这节我们讨论三种基本的获取用户信息的对话框：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;消息对话框&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文本输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;列表选择&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;wxPython中有许多标准的对话框，包括文件选择、颜色选择、进度条对话框、打印设置、字体选择、&lt;/p&gt;
&lt;h3 id="fa-song-xiao-xi"&gt;发送消息&lt;/h3&gt;
&lt;p&gt;最常用的与用户通话的方式是使用wx.MessageDialog，它是一个简单的警告框。wx.MessageDialog可以用于简单的OK对话框，或yes/no对话框。下面的片段显式了yes/no的行为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;dlg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MessageDialog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Is this the coolest thing ever!'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                       &lt;span class="s1"&gt;'MessageDialog'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;YES_NO&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ICON_QUESTION&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ShowModal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Destroy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的构造器结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MessageDialog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;caption&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Message box"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OK&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;CANCEL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DefaultPosition&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;parent是父窗口，或None如果对话框为顶级对话框。message是显示在对话框中的，catption是显示在标题栏中的字符串。style参数是决定显示在对话框中的按钮和图标的bitmask，pos参数可以接收wx.Point类型或Python元组，允许你指定对话框显示在屏幕上的位置，如果你需要的话。&lt;/p&gt;
&lt;p&gt;ShowModal()方法将对话框显示为模态frame，这表示应用中的其它窗口在用户关闭这个对话框后才能响应用户事件。这个方法通常用于所有对话框。ShowModal()的返回值是一个整数，表示对话框的结果。在这里，结果取决于用户按的按钮。对于wx.MessageDialog，它将返回下面的常量：wx.ID_YES，wx.ID_NO，wx.ID_CANCEL，或wx.ID_OK。&lt;/p&gt;
&lt;p&gt;控制风格的bit位可以组合来控制按钮的显示，规定的值为wx.OK，wx.CANCEL，wx.YES_NO。风格位可以用于设置显示于窗口中的图标，它可以是这些值中的一种：wx.ICON_ERROR，wx.ICON_EXCEPTION，wx.ICON_INFORMATION，wx.ICON_QUESTION。&lt;/p&gt;
&lt;h3 id="shu-ru-dan-xing-wen-ben"&gt;输入单行文本&lt;/h3&gt;
&lt;p&gt;如果你需要从用户获取单行文本，你可以使用wx.TextEntryDialog类。下面的片段创建了这种对话框，如果用户点击OK按钮退出则获取输入框中的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;dlg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TextEntryDialog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Who is buried in Grant's tomb?"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="s1"&gt;'A Question'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Cary Grant'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ShowModal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ID_OK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetValue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wx.TextEntryDialog构造器的参数依次是，父窗口，显示于窗口中的文本，显示于窗口标题栏上的文本（默认为&amp;ldquo;Please enter text&amp;rdquo;），输入框的默认值（默认为空字符串）。也有一个style参数它默认被设置为wx.OK | wx.CANCEL。你可以只向style属性传递wx.OK来创建一个没有cancel按钮的对话框。与wx.MessageDialog类似，ShowModal()方法返回被按下的按钮的ID。GetValue()方法包含用户输入到文本框的值（对应的方法为SetValue()，它允许你修改输入框的值）。&lt;/p&gt;
&lt;h3 id="lie-biao-xuan-ze-kuang"&gt;列表选择框&lt;/h3&gt;
&lt;p&gt;列表选择对话框使用wx.SingleChoiceDialog类。举例如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;dlg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SingleChoiceDialog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="s1"&gt;'What version of Python are you using?'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="s1"&gt;'Single Choice'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;'1.5.2'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'2.0'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'2.1.3'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'2.2'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'2.3.1'&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ShowModal&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ID_OK&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dlg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetStringSelection&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数与文本输入对话框类似，除了传递的字符串文本，在这里传递的是一个列表中的字符串列表。有两种方式区取选择的返回值。GetSelection()返回用户选中的元素的编号，而GetStringSelection()返回选中的实际字符串。&lt;/p&gt;
&lt;h2&gt;2.8 应用程序对象和frame的常见错误&lt;/h2&gt;
&lt;p&gt;在创建wxPython application对象或初始化顶级窗体时有少量错误在发生时可能难于跟踪，特别是当第一次遇到这些错误时。下面的错误列表列出了出错时错误信息没有完全描述清楚实际问题的情况，或者错误验证于分析的情况。这些对于wxPython初学者都是常见的错误：&lt;/p&gt;
&lt;p&gt;常见问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误消息：&amp;ldquo;unable to import module wx.&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因&amp;mdash;&amp;mdash;wxPython模块不在PYTHONPATH中。这表示wx.Python可能没有正确安装。如果系统中安装了多个Python系统，wxpython可能不是被安装到当前使用的那个Python环境中。&lt;/p&gt;
&lt;p&gt;解决办法&amp;mdash;&amp;mdash;检查你使用的Python版本。在Unix系统中，which python命令可以告诉你默认的Python。在Windows系统中，可以通过查看.py文件关联的解释器。如果wxPython没有正确安装，需要装它放到&lt;python-home&gt;/Lib/site-packages子目录中。有可能需要安装或重装wxPython。&lt;/python-home&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用在启动时立即崩溃或显示一个空窗口后崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因&amp;mdash;&amp;mdash;一个wxPython对象先于wx.App之前创建。&lt;/p&gt;
&lt;p&gt;解决办法&amp;mdash;&amp;mdash;在启动时立即创建wx.App。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶级窗口在创建后立即被关闭。应用立即退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因&amp;mdash;&amp;mdash;没有调用wx.App.MainLoop()。&lt;/p&gt;
&lt;p&gt;解决办法&amp;mdash;&amp;mdash;在所有设置完成后调用MainLoop()方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶级窗口在创建后立即被关闭。应用立即退出，并且调用了MainLoop()方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因&amp;mdash;&amp;mdash;在应用的OnInit()方法中发生了错误，或者其中调用的方法发生了错误（比如frame的__init__()方法）。&lt;/p&gt;
&lt;p&gt;解决办法&amp;mdash;&amp;mdash;在调用MainLoop()之前发生的错误将触发异常并退出程序。如果应用设置了重定向stdout和stderr到窗口，则这个窗口将不能停留足够长的时间显示错误信息。创建应用（application）对象时设置redirect=False以便看到错误信息。&lt;/p&gt;
&lt;h2&gt;2.9 总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;wxPython程序的基础是基于两个对象：一个应用程序对象和顶级窗口。每个wxPython应用需要实例化一个wx.App对象，至少要有一个顶级窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用程序对象包含wx.App.OnInit()方法，它在启动时被调用。这个方法是初始化frame和其它全局对象的首选位置。wxPython应用程序在所有顶级窗口被关闭，或主事件循环被退出时被正常关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用程序对象也控制wxPython的文本输出的重定向。默认情况下，wxPython将stdout和stderr重定向到一个特殊的窗口。这个行为可能导致启动故障检测困难。可以改变这种行为将错误信息发送到文件或终端窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.Python应用程序通常至少使用一个wx.Frame的子类。一个wx.Frame对象在创建时可以使用多种style参数。每个wxWidget对象，包括frame，都有一个ID,它可以由应用显式的赋值或由wxPython自动生成。子窗体通过通过指定parent参数插入父窗体中。通常一个frame包含一个wx.Panel其它子窗体放在panel上。frame的单个子窗体将随父窗体缩放而缩放。frame有显式的管理机制管理菜单条、工具条和状态条。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽管使用frame可以适用于任何复杂的需求，当你需要简单快捷的从用户获取信息时，你可以给用户显示标准对话框。这些标准对话框可以完成许多任务，包括：警告框、简单的文本录入或列表选择框。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Chap 3 事件驱动环境&lt;/h1&gt;
&lt;p&gt;事件处理机制是让wxPython工作的基础。一个主要通过事件处理来工作的程序被称作事件驱动。&lt;/p&gt;
&lt;p&gt;事件指系统中发生的一些事情，你的应用可以响应来触发一些功能。事件可以是低级用户动作，比如鼠标移动或按键按下，或由wxPython指定的高级用户事件，因为它在wxPython构件内部被替换了，比如按钮的click或菜单选择事件。事件也可以由下层的操作系统创建，比如请求关机。你甚至可以创建自己的对象来产生你自己的事件。wxPython应用程序通过关联响应代码段与指定类型的事件类型来工作。事件映射到代码的处理被称作事件处理。&lt;/p&gt;
&lt;h2&gt;3.1了解事件之前&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;术语&lt;/th&gt;
&lt;th align="left"&gt;定义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件（event）&lt;/td&gt;
&lt;td align="left"&gt;应用中发生的需要响应的事情&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件对象（event object）&lt;/td&gt;
&lt;td align="left"&gt;wxPython中事件的具体描述包括针对具体事件的数据属性。事件被描述为wx.Event类和其子类的实例，比如wx.CommandEvent和wx.MouseEvent。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件类型（event type）&lt;/td&gt;
&lt;td align="left"&gt;一个整数ID，wxPython将添加到每个事件对象。事件类型给出了事件更详细的信息。比如，wx.MouseEvent的事件类型指明了事件是鼠标点击还是鼠标移动。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件源（event source）&lt;/td&gt;
&lt;td align="left"&gt;任何创建事件的wxPython对象。比如按钮，菜单项，列表框或其它构件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件驱动（event-driven）&lt;/td&gt;
&lt;td align="left"&gt;一种程序结构花大量时间等侍或响应事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件队列（event queue）&lt;/td&gt;
&lt;td align="left"&gt;连续的事件列表包含已经发生但没有被处理的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件处理器（event handler）&lt;/td&gt;
&lt;td align="left"&gt;用于响应事件的函数或方法。也称为事件处理函数或事件处理方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;事件绑定器（event binder）&lt;/td&gt;
&lt;td align="left"&gt;一个wxPython对象，维护构件与特定事件类型的关系。为了能被调用，所有事件处理器必须注册到一个事件绑定器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.EvtHandler&lt;/td&gt;
&lt;td align="left"&gt;一个wxPython类，它的实例能创建针对特定类型事件的事件绑定器，事件源，和与事件处理器之间的绑定关系。wx.Evthandler与事件处理函数或先前的方法定义&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;3.2 什么是事件驱动编程&lt;/h2&gt;
&lt;p&gt;事件驱动程序的主要控制结构就是接收事件和响应它们。wxPython程序的结构（或者任何事件驱动程序）与典型的Python脚本是根本不同的。典型的Python脚本有特定的起点的终点，程序员使用条件、循环和函数控制执行顺序。程序不是线性的，但它的顺序通常是不依赖于用户的动作。&lt;/p&gt;
&lt;p&gt;从用户的角度看，一个wxPython程序花大量时间什么也不做。通常，它处理空闲状态直到用户或系统做了什么触发wxPython程序进入动作。wxPython程序结构是一个事件驱动程序架构的例子。&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_1.png" src="/wxPython/figure_3_1.png"/&gt;&lt;/p&gt;
&lt;p&gt;表3.1显示了事件驱动程程序的主要部分。&lt;/p&gt;
&lt;p&gt;把事件驱动系统中的主事件循环想像成类似一个客户服务中心的操作员。当没有电话时这个操作员处于侍命状态。终于，有一个事件发生了，比如电话铃响了。这个操作员启动响应处理，包括与客户谈话直到操作员有足够信息来将客户分配到它请求的人。操作然等侍下个事件。&lt;/p&gt;
&lt;p&gt;尽管每个事件驱动系统都有些不同，但他们也有相似的地方。事件驱动程序结构的主要特征如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;初始化后，程序花多数的时间在等侍循环中，在这里它执行很少的或不执行处理。进入这个循环表示程序用户交互部分的开始，离开循环表示结束。在wxPython中，这个循环是方法wx.App.MainLoop()，它在你的脚本中被显示的调用。当所有顶级窗口被关闭时主循环自动退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;程序包含事件对应于程序环境中发生的事件。事件通常由用户触发，但也可以由系统触发，或程序中其它地方的任意代码。在wxPython中，所有事件都是wx.Event类或它的子类的实例。每个事件都有一个事件类型属性它标识出不同事件的特点。比如，鼠标向上和向下移动都是作为相同类型的实例来分派的，但它们具有不同的事件类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作为等侍循环的一部分，程序定期检查是否有需要响应的事件发生。事件驱动系统有两种机制可以得到事件的通知。比较流行的方法，也是wxPython中使用的方法是将事件发送到中央队列，在那里触发对事件的处理。另一种事件驱动系统是使用轮询方法，那些可以发生事件的地方被中央处理进程周期性的查询，检查是否有事件未处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当事件发生时，基于事件的系统处理尝试决定哪段代码需要被执行。在wxPython中，本地系统事件（native system event）被翻译为wx.Event实例，然后被传递给wx.EvtHandler.ProcessEvent()来分派给合适的处理器代码。图表3.3描述了处理的概况。事件机制的一部分组件是事件绑定对象和事件处理器，两者的定义在表3.1中。事件绑定器是一个预先定义的wxPython对象。每种事件类型有一个独立的事件绑定器。一个事件处理器是一个函数或方法可以获得一个wxPython事件实例作为参数。事件处理器将在用户触发适当的事件时被调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="321-shi-jian-chu-li-qi-bian-ma"&gt;3.2.1 事件处理器编码&lt;/h3&gt;
&lt;p&gt;在wxPython代码中，事件和事件处理器是在单个构件中管理的。比如，一个按钮的click事件被分配到基于被点击的按钮的处理器。为将事件绑定到绑定到指定构件的指定处理器方法，你需要使用绑定器（binder）对象来管理连接。比如，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aButton&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用预定义的事件绑定器wx.EVT_BUTTON关联到aButton的click事件到self.OnClick方法。Bind()方法是wx.EvtHander的一个方法，它是所有可显示对象的父对象。因此，例子中的这行代码可用于任何可显示的类。&lt;/p&gt;
&lt;p&gt;尽管你的wxPython程序看起来像在被动的等侍事件，实际上它仍在做一些事件。比如，它运行wx.App.MainLoop()方法，它是一个while无限循环。MainLoop()可以下面的简单的Python伪码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Pending&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ProcessIdle&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DoMessage&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;换句话说，如果没有消息要处理，执行一些空处理直到有消息进来，然后将消息分配到适当的事件处理方法。&lt;/p&gt;
&lt;h3 id="322-she-ji-shi-jian-qu-dong-cheng-xu"&gt;3.2.2 设计事件驱动程序&lt;/h3&gt;
&lt;p&gt;wxPython事件驱动程序有一些隐式的设计和编码规则。由于不能假设事件何时发生，程序员放弃了许多对程序的控制权给用户。在wxPython程序中多数执行的代码是直接或间接的由用户或系统产生。比如，程序的保存工作通常发生在用户选择菜单项，点击工具条按钮或通过快捷键之后。这些事件触发一个处理器来保存用户的工作。&lt;/p&gt;
&lt;p&gt;事件驱动架构的另一种后果是这个架构经常会扩展。用于响应一种事件的代码通常不定义在触发事件的构件中。或者说，绑定的事件和处理器之间不需要有任何联系。比如，用于响应按钮点击的代码不需是按钮定义的一部分，它可以定义在包含按钮的frame中，或其它地方。当与可靠的面向对象设计结合时，这个构架可以带来松耦合，高复用的代码。你将发现Python的灵活使得不同wxPython应用间重用通用事件处理器和结构非常容易。另一方面，由于程序的分解导致事件驱动的程序难于跟踪和维护。当按钮的click事件发生时绑定到frame中的代码，事件调用了模型类中的方法，它可能难于跟踪。&lt;/p&gt;
&lt;h3 id="323-shi-jian-hong-fa"&gt;3.2.3 事件触发&lt;/h3&gt;
&lt;p&gt;在wxPython中，多数构件将高级事件用于响应低级事件。比如，在wx.Button的内部点击鼠标导致产生一个EVT_BUTTON事件，它是wx.CommandEvent的一个特殊类型。类似的，鼠标拖动窗口的一角导致一个wx.SizeEvent被wxPython自动创建。这些高级事件的优点在于它们使系统集中焦点于最相关的事件，而不用跟踪所有鼠标点击。比如，我们说鼠标点击一个按钮的活动，这个特殊的点击对于系统有上下文含义，而另一个鼠标点击事件可能对于上下文没有含义。高级事件也能包含更多关于事件的信息。当你创建自己的自定义构件时，你可以定义你自己的自定义事件来管理这个过程。&lt;/p&gt;
&lt;p&gt;事件被wxPython描述为对象。wxPython中的事件对象是类wx.Event或其子类的实例。wx.Event类是一个很小的抽像类由getter、setter方法和少数所有事件都需要的通用属性，比如EventType，EventObject和Timestamp。不同的wx.Event子类添加了更丰富的信息。比如，wx.MouseEvent包含了事件发生时鼠标的精确位置，并包含了是哪个鼠个按钮点击，等。&lt;/p&gt;
&lt;p&gt;在wxPython中有许多不同的wx.Event的子类。表3.2包含了常用事件类的列表。记住，一个事件类可以有多个不同的事件类型，每个对应于不同的用户动作。&lt;/p&gt;
&lt;p&gt;表3.2 重要的wx.Event的子类&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;事件&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.CloseEvent&lt;/td&gt;
&lt;td align="left"&gt;当frame关闭时触发。事件类型用于区分frame被正常关闭或者是系统关机事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.CommandEvent&lt;/td&gt;
&lt;td align="left"&gt;广泛用于简单的与构件交互，比如按钮被点击，菜单项被选择，或radio被选择。每个动作都有自己的事件类型。许多复杂的构件，比如list或grid，定义了wx.CommandEvent的子类。命令事件由不同的事件处理系统不同的对侍，而不是由其它事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.KeyEvent&lt;/td&gt;
&lt;td align="left"&gt;按键事件。事件类型有按键被按下，弹起和完整的按键动作。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.MouseEvent&lt;/td&gt;
&lt;td align="left"&gt;鼠标事件。事件类型有鼠标移动和鼠标点击。这些事件类型取决于哪个鼠标按键被点击和它是单击还是双击。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.PaintEvent&lt;/td&gt;
&lt;td align="left"&gt;当窗口的内容需要重绘时触发。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.SizeEvent&lt;/td&gt;
&lt;td align="left"&gt;当窗口调整大小时，通常导致改变窗口的布局。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;wx.TimerEvent&lt;/td&gt;
&lt;td align="left"&gt;可以被wx.Timer类创建，它允许周期性的事件。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;通常，事件对象自己只做很少的操作，但它们需要传递给相关的事件处理器方法或用于事件绑定器和事件处理系统的方法。&lt;/p&gt;
&lt;h2&gt;3.3 如何将事件绑定到处理器&lt;/h2&gt;
&lt;p&gt;事件绑定器由wx.PyEventBinder的实例组成。提供了一个预定义的wx.PyEventBinder的实例用于所有支持的事件类型，如果需要你可以为自己的自定义事件创建自己的事件绑定器。对于每个事件类型只有一个事件绑定器，这意味着多种绑定器可以应用于任何wx.Event子类。这是因为事件类型比wx.Event子类有更多的细节信息。比如，wx.MouseEvent类有十四个独立的事件类型，当用户动作产生时每个都使用了相同的鼠标基础状态信息。（比如，左键，右键，双击）。&lt;/p&gt;
&lt;p&gt;在wxPython中，事件绑定器实例的名称是全局的。为了清楚的将事件类型与处理器关联，这些名称以wx.EVT_开头加上C++ wxWidget代码中的宏名。当讨论wxPython代码时，趋向于使用wx.EVT_绑定器名称作为实际事件类型的标准名称。wx.EVT绑定器名称不是实际的事件类型的整数代码。你可以调用wx.Event实例的GetEventType()方法获取实际的代码。事件类型事件代码有一个全局的唯一名称，在实践中通常不使用。&lt;/p&gt;
&lt;p&gt;作为wx.EVT命名的实例，我们看一下wx.MouseEvent的事件类型。前面提到，一共有14个，其中9个包含了鼠标向下，鼠标向上，双击事件。这9个事件类型使用了下面的名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_LEFT_DOWN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_LEFT_UP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_LEFT_DCLICK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_MIDDLE_DOWN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_MIDDLE_UP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_MIDDLE_DCLICK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_RIGHT_DOWN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_RIGHT_UP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wx.EVT_RIGHT_DCLICK&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，wx.EVT_MOTION由鼠标移动产生。wx.ENTER_WINDOW和WX.LEAVE_WINDOW由于鼠标进入或离开构件产生。wx.EVT_MOUSEWHEEL由鼠标滚轮产生。最后，你可以将所有鼠标事件同时的绑定到一个单一的wx.EVT_MOUSE_EVENTS类型。&lt;/p&gt;
&lt;p&gt;类似的，wx.CommandEvent类有28个不同的事件类型与之关联；只有少量是为旧的Windows操作系统。它们中的多数都是针对于特定的单一构件，比如wx.EVT_BUTTON用于按钮点击，wx.EVT_MENU用于菜单项选择。为特殊构件准备的命令事件将在第二部分讨论。&lt;/p&gt;
&lt;p&gt;这种绑定机制的好处是允许wxPython在非常小粒度的基础上来处理事件，允许类似的事件实例化相同的类，共享数据和功能。这使得在wxPython中编写事件处理器比在其它界面工具包中更加清析。&lt;/p&gt;
&lt;p&gt;事件达赖顺用于将wxPython构件连接到事件对象和事件处理器函数。这个连接允许wxPython系统通过执行处理器函数来响应事件。在wxPython中，任何wx.EvtHandler类的子类对象都能响应事件。所有窗口对象都是wx.EvtHandler类的子类，因此wxPython应用中的所有构件都可以响应事件。wx.EvtHandler　类也可以用于非构件对象，比如wx.App，因此事件处理不只限于可视的构件。也就是说构件可以响应事件意味着那个构件可以创建wxPython在分发时能识别的事件绑定。在事件处理函数中被绑定器代码并不需要位于wx.EvtHandler类中。&lt;/p&gt;
&lt;h3 id="331-shi-yong-wxevthandlerfang-fa"&gt;3.3.1 使用wx.EvtHandler方法&lt;/h3&gt;
&lt;p&gt;wx.EvtHandler类定义了大量方法，这些方法并不是在通常环境下被调用。wx.EvtHandler的方法中你最常用到的是Bind()，它创建事件绑定。方法签名如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ID_ANY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;id2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ID_ANY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bind()函数将对象与事件处理函数关联。event参数是必需的，它是一个wx.PyEventBinder的实例，在3.3中讨论过。handler参数，也是必需的，是一个Python callable对象，通常绑定到方法或函数。handler必须使用一个参数调用，参数为事件对象本身。处理器参数也可以为None，这种情况下将取消事件与它当前关联的处理器之间的关联。source参数是事件源构件。这个参数用于当触发事件的构件与事件处理器所在的构件不是同一个构件时。通常，这是需要的，因为你在使用自定义的wx.Frame类作为处理器时将事件绑定到了包含构件的frame中。父窗口的__init__是一个便于申明绑定的地方。但是，如果父窗口包含超过一个按钮点击事件时（比如，OK按钮和Cancel按钮），source参数用于wxPython区别它们。下面是一个特殊的例子：&lt;/p&gt;
&lt;p&gt;程序 3.1&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个调用将名为button的按钮（只绑定名为button的对象）的按钮事件绑定到包含它的实例的OnClick()方法。程序 3.1，根据第二章中的代码修改，描述了绑定事件时不带source参数。你不需要将你的处理器方法命名为On&lt;event&gt;，但这是一个公共的约定。&lt;/event&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Frame With Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                      &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Close"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;130&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                       &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_CLOSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （1）绑定frame的关闭事件&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （2）绑定按钮事件&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Destroy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（1）这行将frame的关闭事件绑定到self.OnCloseWindow方法。因为事件触发和处理都是在frame中，这里不需要传递source参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（2）这行将按钮点击事件绑定到self.OnCloseMe方法。在这种情况下，产生事件的按钮与绑定它的frame不同。因此，按钮的ID必须传递给Bind方法，使wxPython区别按钮button的点击事件和frame中其它按钮的点击事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你也可以使用source参数来标识项，即使项不是事件源。比如，你可以绑定菜单事件到事件处理器即使菜单事件是由frame触发。程序 3.2描述了绑定菜单事件的例子。&lt;/p&gt;
&lt;p&gt;程序 3.2 绑定菜单事件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MenuEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Menus'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MenuBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;menu1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;menuItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Exit..."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;File"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetMenuBar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;menuItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseMe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MenuEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bind()方法的id和id2参数使用ID数指定事件源，而不是构件自己。通常，id和id2不是必需的，因为事件源的ID可以从source参数中获取。但是，直接使用ID提高了可读性。比如，如果你为对话框使用预定义的ID，使用ID数比使用构件更容易。如果你同时使用id和id2参数，你可以绑定两个ID范围之间的所有构件到事件上。这只在你要绑定的构件的ID是有序的时候。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;旧的事件绑定&lt;/em&gt;&lt;/strong&gt; Bind()方法是wxPython 2.5中新增的。在前面的版本中，EVT_*被作为函数对象，因此绑定使用下面的结构：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;旧和风格不好的地方是它看起来不像面向对象的方法调用。但，旧的风格在2.5中仍然可以使用（因为wx.EVT*对象仍然是callable的），因此你仍将在wxPython代码中看到。&lt;/p&gt;
&lt;p&gt;表3.3列出了你在处理事件时，wx.EvtHandler中最常用的方法。&lt;/p&gt;
&lt;p&gt;表3.3wx.EvtHandler的常用方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;方法&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;AddPendingEvent(event)&lt;/td&gt;
&lt;td align="left"&gt;将事件参数放到事件处理系统。与ProcessEvent()类似，但它不会立即触发事件处理。而是将事件添加到事件队列。在基于事件的线程通讯时非常有用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Bind(event, handler, source=None, id=wx.ID_ANY, id2=wx.ID_ANY)&lt;/td&gt;
&lt;td align="left"&gt;看3.3.1的描述。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;GetEvtHandlerEnabled()和SetEvtHandlerEnabled(boolean)&lt;/td&gt;
&lt;td align="left"&gt;如果处理器当前正在处理事件这个属性为True，否则为False。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ProcessEvent(event)&lt;/td&gt;
&lt;td align="left"&gt;将事件对象放到事件处理系统立即进行处理。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;3.4 wxPython是如何处理事件的？&lt;/h2&gt;
&lt;p&gt;基于事件的系统的一个关键组件是当事件进入系统分派到哪个代码片段来响应。这节我们将讨论当事件进入时wxPython处理的过程。图表3.2显示了一个带有按钮的简单窗口，它用于产生简单的事件。&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_2.png" src="/wxPython/figure_3_2.png"/&gt;&lt;/p&gt;
&lt;p&gt;程序3.3包含了产生这个窗口的代码。这个代码中，wxPython事件在点击按钮和鼠标移过按钮时产生。&lt;/p&gt;
&lt;p&gt;程序3.3 绑定多种鼠标事件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MouseEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Frame With Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Not Over"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnButtonClick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;# （1）绑定按钮事件&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_ENTER_WINDOW&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnEnterWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （2）绑定鼠标进入事件&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_LEAVE_WINDOW&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                         &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnLeaveWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （3）绑定鼠标离开事件&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnButtonClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Green'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Refresh&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnEnterWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetLabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Over Me!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Skip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnLeaveWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetLabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Not Over"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Skip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MouseEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MouseEventFrame中间包含了一个按钮。点击鼠标将改变frame的背景为绿色。鼠标点击事件绑定在（1）行的动作。当鼠标指向中间的按钮，按钮的文字将改变，这绑定的（2）。当鼠标离开按钮时按钮文字也将改变，这绑定在（3）行。&lt;/p&gt;
&lt;p&gt;查看鼠标事件的例子带出了几个关于wxPython中事件处理的问题。在（1），触发事件的按钮在frame中。wxPython是怎么样知道在frame对象中查找绑定，而不是在按钮对象中？在（2）和（3），鼠标进入和离开事件绑定到按钮对象。为什么这些事件也可以绑定到frame上？这些问题的答案在于wxPython怎样来响应事件。&lt;/p&gt;
&lt;h3 id="341-li-jie-shi-jian-chu-li-guo-cheng"&gt;3.4.1 理解事件处理过程&lt;/h3&gt;
&lt;p&gt;wxPython事件处理过程被设计为易于程序员在最常见的地方创建事件绑定，而忽略不重要的事件。常用的情况设计简单，而实际上下层的机制有点复杂。下面，我们将跟踪按钮点击事件的鼠标进入事件。&lt;/p&gt;
&lt;p&gt;图表3.3显示了一个基本的事件处理流程图。矩形表示流程的开始和结束，贺表示作为流程中各步骤的各种wxPython对象，菱形表示判断点，带边的矩形表示实际的事件处理方法。&lt;/p&gt;
&lt;p&gt;图表3.3 事件处理过程，开始于事件被触发，过程中各步骤来查找处理器。&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_3.png" src="/wxPython/figure_3_3.png"/&gt;&lt;/p&gt;
&lt;p&gt;事件处理开始于触发事件的对象。通常，wxPython首先查看触发事件的对象中是否有相应的事件类型的事件处理函数。如果找到了，就执行。如果没有，wxPython向容器层次结构上层查找。上层的父构件被搜索，直到wxPython找到一个处理函数或达到顶级对象。如果还同有找到，wxPython将在结束前检查应用程序对象中是否有处理方法。当事件处理器运行时，这个处理过程正常结束。但是，这个函数将告诉wxPython继续查找事件处理器。&lt;/p&gt;
&lt;p&gt;仔细看这个流程的每个步骤。在讨论每个步骤前，我们先查看图表3.3的各个部分。&lt;/p&gt;
&lt;h4 id="di-yi-bu-chuang-jian-shi-jian"&gt;第一步 创建事件&lt;/h4&gt;
&lt;p&gt;处理过程开始于事件创建时。&lt;/p&gt;
&lt;p&gt;图表 3.4 创建事件将焦点转到触发的对象&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_4.png" src="/wxPython/figure_3_4.png"/&gt;&lt;/p&gt;
&lt;p&gt;多数预先存在的事件类型在响应特殊的用户动作或系统通知时被创建。比如，鼠标进入事件在在wxPython注意到鼠标进入一个新构件对象的边界时触发，按钮点击事件在鼠标左键在同一个按钮上按下和弹起时被创建。&lt;/p&gt;
&lt;p&gt;事件首先被创建事件的对象处理。对于按钮点击，这个对象就是按钮，对于鼠标进入事件，这个对象就是所进入的构件。&lt;/p&gt;
&lt;h4 id="di-er-bu-jue-ding-dui-xiang-shi-fou-yun-xu-chu-li-shi-jian"&gt;第二步 决定对象是否允许处理事件&lt;/h4&gt;
&lt;p&gt;事件处理过程的下一步是查看产生当前事件的构件（wx.EvtHandler）是否允许处理事件。&lt;/p&gt;
&lt;p&gt;窗口可以通过调用wx.EveHandler的SetEvtHandlerEnabled(boolean)来设置是否允许事件处理。禁用事件处理产生的效果就是那个构件完全忽略事件处理，关联到这个对象上的绑定不会被搜索，处理流程进入 &lt;strong&gt;&lt;em&gt;no&lt;/em&gt;&lt;/strong&gt; 分支。&lt;/p&gt;
&lt;p&gt;在事件处理级别启用或禁用构件与在UI级别禁用构件是不同的。在UI级别禁用构件是使用wx.Window的Disable()和Enable()方法。在UI场景中禁用构件意味着用户不能与被禁用的构件交互。通常，被禁用的构件显示在屏幕上的状态是灰色的。在UI级别被禁用的窗口不能产生任何事件；但是，如果它处理其它事件的层级容器中，它仍然将处理它接收到的事件。在这节，我们在wx.EvtHandler场景中使用enabled和disabled，查看构件是否允许处理事件。&lt;/p&gt;
&lt;p&gt;检查启动的对象的enabled/disabled状态发生在ProcessEvent()方法中它被wxPython系统用于启动和处理事件分派机制。我们将在这个处理过程中多次看到ProcessEvent()方法，它是wx.EvtHandler类中的方法，它实际上比图表3.3中描绘的做了更多的处理。如果事件处理在这个方法结束的时候完成了则ProcessEvent()方法返回True。如果处理器函数找到了并且事件组合被处理完，则这个处理过程结束。事件处理函数可以显示的调用wx.Event的方法Skip()来要求更多的处理。另外，如果启动的对象是wx.Window的子类，它可以使用一个特殊的对象来过滤事件，这个对象被称为validator。Validator将在第9章讨论。&lt;/p&gt;
&lt;p&gt;图表 3.5 检查触发的对象是否为enabled&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_5.png" src="/wxPython/figure_3_5.png"/&gt;&lt;/p&gt;
&lt;h4 id="di-san-bu-ding-wei-bang-ding-qi-dui-xiang"&gt;第三步 定位绑定器对象&lt;/h4&gt;
&lt;p&gt;图表 3.6 检查触发事件的对象是否有合适的绑定器&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_6.png" src="/wxPython/figure_3_6.png"/&gt;&lt;/p&gt;
&lt;p&gt;ProcessEvent()方法查找能识别事件类型和当前对象间的绑定器对象。&lt;/p&gt;
&lt;p&gt;如果在对象自身没有找到绑定器，处理流程将检查这个对象的父类中是否有这样的绑定器&amp;mdash;&amp;mdash;这与查找容器对象层级结构是不同的。如果找到了绑定器，wxPython调用关联的处理器函数。处理器被调用后，针对这个事件的事件处理流程停止，除非事件处理函数显式的要求更多的处理。&lt;/p&gt;
&lt;p&gt;在程序 3.3中，鼠标进入事件被捕获，因为和按钮对象间定义了绑定，绑定对象wx.EVT_ENTER_WINDWO，和关联的方法OnEnterWindow()，这个方法被调用。由于我们没有绑定鼠标点击事件，wx.EVT_LEFT_DOWN，wxPython在这种情况下将继续搜索。&lt;/p&gt;
&lt;h4 id="di-si-bu-jue-ding-shi-fou-ji-xu-chu-li-liu-cheng"&gt;第四步 决定是否继续处理流程&lt;/h4&gt;
&lt;p&gt;调用第一个事件处理器后，wxPython检查是有要求需要进行更多的处理。事件处理器可以调用wx.Event的Skip()方法来要求更多的处理。如果Skip()方法被调用，处理将继续，那些定义于父类中的处理器将被依次查找到并被执行。Skip()方法可以出现在处理器的任何地方，或任何被处理器调用的代码中。Skip()方法在事件实例中设置一个标记，wxPython在处理器方法完成后检查它。代码 3.3的OnButtonClick()没有调用Skip()，因此在那种情况下事件处理在处理器方法结束后事件处理流程结束。另外两个事件处理器调用了Skip()因此系统将继续查找匹配的事件绑定，最后为鼠标进入和离开事件调用本地构件的默认功能，比如鼠标划过（mouse-over）的事件。&lt;/p&gt;
&lt;h4 id="di-wu-bu-jue-ding-shi-fou-chuan-bo"&gt;第五步 决定是否传播&lt;/h4&gt;
&lt;p&gt;最后wxPython决定事件处理是否传播到容器层级结构中查找事件处理器。容器层级是从特定的构件到顶级frame的路径，转移到每个构件的父容器，并继续向上。&lt;/p&gt;
&lt;p&gt;如果当前对象没有针对这个事件的处理器，或如果事件处理器调用Skip()，wxPython决定事件是否需要向层级结构的上层传播。如果这个答案是No，处理过程在wx.App实例中再次查找处理器，然后停止。如果答案为Yes，事件处理过程将在当前被搜索的窗口的容器中重新开始。处理流程继续向上直到wxPython找到一个适当的绑定，或达到没有父窗口的顶级frame对象，或达到wx.Dialog对象（即使dialog不是顶级的）。如果那个对象的ProcessEvent()返回True，则事件被认为找到了一个合适的绑定，表示处理结束。在wx.Dialog中停止的的基本原理就是阻止父frame处理来自对话框的事件。&lt;/p&gt;
&lt;p&gt;一个事件是否应该被传播到父容器层级结构是每个事件实例的一个动态属性，尽管实践中总是使用默认值。缺省情况下，只有一个wx.CommandEvent实例，或它的子类，传播到容器层级结构中。其它事件不会。&lt;/p&gt;
&lt;p&gt;图表 3.8 事件处理过程继续查找容器层级结构。如果事件是一个命令事件，或它被申明为传播&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_3_8.png" src="/wxPython/figure_3_8.png"/&gt;&lt;/p&gt;
&lt;p&gt;代码 3.3中，在按钮上点击鼠标产生一个wx.EVT_BUTTON类型的命令事件。由于wx.EVT_BUTTON是wx.CommandEvent类型的，wxPython在按钮对象上查找绑定失败时，它查找父容器对象&amp;mdash;&amp;mdash;面板对象，然后是frame。由于frame上有一个匹配的绑定，ProcessEvent()调用适当的方法，在这里是OnButtonClick()方法。&lt;/p&gt;
&lt;p&gt;第五步也解释了为什么鼠标进入和鼠标离开事件需要被绑定到按钮而不是frame。由于鼠标事件不是wx.CommandEvent的子类，鼠标进入和离开事件不会传播到父容器，因此wxPython在按钮的鼠标进入事件和frame之间找不到绑定。如果在鼠标进入或离开事件绑定到了frame，则当鼠标进入或离开整个frame时将被触发。&lt;/p&gt;
&lt;p&gt;在这里命令事件有特权，因为它们是被实现为高级事件，用于标识用户在应用层面所做的事件，而不是在窗口系统。假定窗口系统类型的事件只对最初接收它们的构件感兴趣，但应用级事件可能对高级的容器层级结构感兴趣。这个规则并不阻止我们在任何地方绑定事件，与被绑定的对象或定义事件处理器的对象无关。比如，尽管鼠标点击事件被绑定到按钮对象，但绑定自己被定义在frame类中，调用frame类中的方法。换言之，低级非命令事件通水地发生到（to）构件的事情或一些系统级的提醒，比如鼠标点击，按键按下，绘制请求，改变大小或移动。另外，命令事件，比如鼠标在按钮上点击或列表选择，通常由构件自己产生和发出。比如，按钮命令事件在鼠标向下并向上的事件发生在相应的构件上后产生。&lt;/p&gt;
&lt;p&gt;最后，如果事件在通过容器层级结构后没有被处理，ProcessEvent()将在wx.App对象上调用。缺省情况下，这不做任何操作，但你可以在你的wx.App中添加事件绑定以非标准的方式来路由事件。比如，如果你编写GUI构造程序，你可能需要你构建的窗口的事件传播到你的代码窗口中，尽管它们都是顶级窗口。实现这种效果的一种办法就是在应用对象中捕获事件并将它们传递到代码窗口。&lt;/p&gt;
&lt;h3 id="342-shi-yong-skipfang-fa_1"&gt;3,4.2 使用Skip()方法&lt;/h3&gt;
&lt;p&gt;事件遇到的第一个事件处理函数将挂起那个事件的处理除非在那个处理函数返回前调用了Skip()方法。调用Skip()允许搜索额外的被绑定的处理器，跟据3.4.1的第四步所描述的，父类和父窗口被搜索就像第一个处理器不存在一样。在某些情况下，你需要事件继续处理以便表现本地构件默认行为。代码3.4显示了一个Skip()的例子，它允许程序响应在同一按钮上的左键按下事件和按钮点击事件。&lt;/p&gt;
&lt;p&gt;代码3.4 同一时间响应鼠标按下和按钮点击事件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DoubleEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Frame With Button'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Click Me"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnButtonClick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="c1"&gt;# （1）绑定按钮点击事件&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_LEFT_DOWN&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnMouseDown&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （2）绑定左键按下事件&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnButtonClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'Green'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Refresh&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnMouseDown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetLabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Again"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Skip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                    &lt;span class="c1"&gt;# （3）Skip()确保更多处理&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DoubleEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（1）这行绑定按钮点击事件到OnButtonClick()处理器，它修改frame的背景色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（2）这行绑定鼠标左键按下事件到OnMouseDown()处理器，它修改按钮的标签文本。由于左键按下不是命令事件，这个事件必须被绑定到按钮而不是frame。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当鼠标经过按钮用户点击，通过与下层操作系统交互，左键按下事件首先产生。通常，左键起来时改变按钮的状态，左键起来时创建了一个wx.EVT_BUTTON点击事件。DoubleEventFrame保持了这个处理过程，因为它在（3）处调用了Skip()方法。当没有Skip()语句时，事件处理算法查找（2）创建的绑定，并在按钮生成wx.EVT_BUTTON事件前停止。通过Skip()调用，事件处理继续按钮点击事件被创建。&lt;/p&gt;
&lt;p&gt;在这个例子中，选择wx.EVT_LEFT_DOWN和wx.EVT_BUTTON没有很特殊的。任何一个事件处理器被找到时的情况都是一样的。比如，修改wx.EVT_LEFT_DOWN事件为另一个wx.EVT_BUTTON事件将产生相同的效果。为使两个处理器都被调用，Skip()调用仍然需要。&lt;/p&gt;
&lt;p&gt;遇到相关处理地，默认行为是先到先服务。为允许更多的处理，你必须调用Skip()。尽管这个选择应该按具体案例来，但要记住当绑定到低级事件，比如鼠标按下弹起，wxPython期望捕获这些事件来产生更多的事件。如果你不调用Skip()，将阻止预期的行为；比如，在按钮被点击时丢失可视的通知效果（注：按钮被按下和弹起的动态效果）。&lt;/p&gt;
&lt;h2&gt;3.5 应用对象中还包含哪些事件属性？&lt;/h2&gt;
&lt;p&gt;为了更直接的管理主事件循环，你可以使用wx.App中的一些方法。举例来说，你可能希望按自己的排程启动下一个可用的事件，而不是等侍wxPython来开始这处理。如果你需要执行一个长时间的排程，而不希望GUI被冻结，这个功能是需要的。在这节你不需要经常使用这个方法，但有时这个功能是非常重要的。&lt;/p&gt;
&lt;p&gt;表3.4列出了可用来修改主循环的wx.App的方法。&lt;/p&gt;
&lt;p&gt;表3.4wx.App的主事件循环方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;方法名&lt;/th&gt;
&lt;th align="left"&gt;方法描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Dispatch()&lt;/td&gt;
&lt;td align="left"&gt;编程方式强制发送事件队列中的下个事件。比如由MainLoop()使用，或在自定义的事件循环中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Pending()&lt;/td&gt;
&lt;td align="left"&gt;如果在wxPython应用中的事件队列中存在挂起的事件，则返回True。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Yield(onlyIfNeeded=False)&lt;/td&gt;
&lt;td align="left"&gt;允许挂起的wxWidget事件被分派到那些可能阻塞窗口系统显示或更新的长时间的处理中。如果有挂起事件在被处理则返回True，否则返回False。如果为True，如果有挂起事件onlyIfNeeded参数强制处理yield。如果参数为False，则是一个错误在递归调用Yield。有一个全局函数wx.SafeYield()，它防止用户在yield期间输入数据（通过临时禁止用户输入构件）。这阻止了用户改变一些妨碍yielding任务的状态。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;另一种自定义管理事件的方法是创建自己的事件类型来匹配你的应用中的特殊的数据和构件。下一节，我们将讨论如何创建自己的自定义事件。&lt;/p&gt;
&lt;h2&gt;3.6 如何创建自己的事件？&lt;/h2&gt;
&lt;p&gt;除了使用wxPython提供的事件类，你可以创建自己的自定义事件。当事件实例被请求携带自定义数据时，你可以在你的应用的响应中修改数据或做其它的修改。&lt;/p&gt;
&lt;h3 id="361-wei-zi-ding-yi-gou-jian-ding-yi-zi-ding-yi-shi-jian"&gt;3.6.1 为自定义构件定义自定义事件&lt;/h3&gt;
&lt;p&gt;图表3.9显示了一个构件，一个容器面板包含两个按钮。自定义事件TwoButtonEvent在用户点击两个按钮时触发。这个事件包含了用户点击构件的时间。这个例子展示了新的命令事件是如何由小的事件构成的&amp;mdash;&amp;mdash;这里是独立按钮的左键按下事件。&lt;/p&gt;
&lt;p&gt;创建自定义事件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义新的事件类，该类为wx.PyEvent的子类。如果你需要把事件作为命令事件，则创建wx.PyCommandEvent的子类。在wxPython中与许多其它重构的情况一样，Py版本的类允许wxWidget系统查看使用Python编写的用于覆盖C++编写的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建事件类型和绑定器对象将事件绑定到特定的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加代码以便创建新的事件的实例，使用ProcessEvent()方法将实例介绍给事件处理系统。一旦事件被创建，你可以创建绑定和处理器方法，就像使用其它wxPython事件一样。代码3.5显示了管理构件的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码3.5创建一个带两个按钮事件的自定义构件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TwoButtonEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PyCommandEvent&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c1"&gt;# （1）定义事件&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;evtType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PyCommandEvent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;evtType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;GetClickCount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;SetClickCount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;

&lt;span class="n"&gt;myEVT_TWO_BUTTON&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewEventType&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;    &lt;span class="c1"&gt;# （2）产生一个事件类型&lt;/span&gt;
&lt;span class="n"&gt;EVT_TWO_BUTTON&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PyEventBinder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myEVT_TWO_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （3）创建一个绑定器对象&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TwoButtonPanel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;leftText&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Left"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="n"&gt;rightText&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"Right"&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Parent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;leftText&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;rightText&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftButton&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_LEFT_DOWN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnLeftClick&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （4）绑定低级事件&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightButton&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_LEFT_DOWN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnRightClick&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnLeftClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Skip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                    &lt;span class="c1"&gt;# （5）调用Skip()方法以获取更多的处理&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnRightClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Skip&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                    &lt;span class="c1"&gt;# （6）调用Skip()方法以获取更多的处理&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftClick&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightClick&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;leftClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rightClick&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
            &lt;span class="n"&gt;evt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TwoButtonEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myEVT_TWO_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetId&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="c1"&gt;# （7）创建自定义事件&lt;/span&gt;
            &lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetClickCount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clickCount&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                   &lt;span class="c1"&gt;# 添加数据到事件中&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetEventHandler&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ProcessEvent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;             &lt;span class="c1"&gt;# （8）处理事件&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CustomEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Click Count: 0'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TwoButtonPanel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EVT_TWO_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnTwoClick&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# （9）绑定自定义事件&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnTwoClick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;        &lt;span class="c1"&gt;# （10）定义一个事件处理器函数&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetTitle&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Click Count: &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;GetClickCount&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CustomEventFrame&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（1）事件类的构造器申明它是wx.PyCommandEvent的子类。wx.PyEvent和wx.PyCommandEvent是wxPython特殊的构造器你可以用它创建新的事件类并且用于桥接C++代码和Python代码。如果你想直接使用wx.Event，wxPython将在事件处理中看不到你的子类中的新方法，因为C++事件处理器不知道Python子类。如果你使用wx.PyEvent，一个Python实例的引用它被保存，后来被直接传递给事件处理器，允许Python编写的代码被使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（2）全局函数wx.NewEventType()是一个类似wx.NewId()的方法；它返回一个事件类型ID并保证它的唯一性。这个唯一值标识了事件处理系统中的一个事件类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（3）使用新的事件类型作为参数创建了绑定对象。第二个参数介于0和2之间，用于描述wx.EvtHandler.Bind()方法所需要的wxId标识符的数量。在这里，只有一个ID描述了产生命令事件的构件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（4）创建高级命令事件，这个程序必须响应特定的用户事件，比如，左键在任何一个按钮对象上按下。取决于哪个按钮被点击，事件被绑定到OnLeftClick()和OnRightClick()方法。这个处理器设置了一个布尔变量标识被按下的按钮。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（5）（6）Skip()调用在允许在执行事件处理器后做更多的处理。在这里，新的事件类型不需要skip调用；它在处理器代码完成前被分发。但，所有左键按下事件都需要调用Skip()以便处理器不会阻止最后的按钮按下事件。按钮点击事件在这个程序中不会被处理，但wxPython使用它在按钮点击期间进行绘制。如果它被阻止了，用户不会获取到按钮被按下了的反馈。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们选择不绑定到wx.EVT_BUTTON事件还展示如果在这种情况下不调用Skip()将发生什么。查看不同的效果可以注释掉（5）或（6）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;（7）如果左右两个按钮都被点击，代码将产生新事件的实例。事件类型和两个按钮构件的ID作为构件器参数。通常，一个单独的事件类可以有多个事件类型，尽管这个例子不是这样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（8）ProcessEvent()调用将新的事件类型注入到事件处理系统，如3.4.1所描述的那样。GetEventHandler()调用返回了一个wx.EvtHandler类型的实例。在多数情况下，返回的实例是构件对象自身，但如果其它wx.EvtHandler()方法被推到了事件处理器堆栈，则堆栈顶的项将作为返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（9）自定义的事件被绑定，在这里使用了（3）创建的绑定器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（10）事件处理器函数，它修改窗口的标题为事件中的点击计数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从这点来看，你的自定义事件可以做任何wxPython预定义的事件可以做的事件，比如创建不同的构件触发相同的事件。创建事件是自定义wxPython中的一个重要部分。&lt;/p&gt;
&lt;h2&gt;3.7 小结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;wxPython应用使用基于事件流来控制。应用的多数时间用于主循环，等侍事件并分发它们到适当的事件处理器函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有wxPython事件都是wx.Event类的子类。低级事件，比如鼠标点击，被用于构建高级指令事件，比如按钮被点击或菜单项被选择。这些由wxPython构件产生的高级指令事件是wx.CommandEvent类的子类。多数事件类通过事件类型来进行更细的归类，不同类型的事件使用相同的数据集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为捕获事件和函数间的关系，wxPython使用wx.PyEventBinder类的实例。有很多预定义的这个类的实例，每个对应于一种特定的事件类型。每个wxPython构件都是wx.EvtHandler类的子类。wx.EvtHandler类有一个Bind()方法，它通常在初始化时调用，带一个事件绑定器实例和一个事件处理器函数作为参数。根据具体的事件类型，其它wxPython对象的ID也可能需要传递给Bind()调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件通常被发送到产生它们的对象中来查找一个绑定了处理器的对象。如果事件是一个命令事件，这个事件将被向容器层级结构的上层传播直到找到这个事件类型的处理器。一量事件处理器被找到，这个事件的处理结束，除非处理器调用了事件的Skip()方法。你可以使用Skip()方法来允许多个处理器响应单个事件，或者让事件的默认行为产生。使用wx.App中的一些方法可以控制主循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在wxPython中创建自定义事件，表达自定义构件的行为。自定义事件是wx.PyEvent的子类，自定义命令事件是wx.PyCommandEvent的子类。为了创建自定义事件，新的类必须被定义，必须为每种事件类型创建一个新绑定器对象并由新类来管理。最后，事件必须在系统的某个地方产生，通过调用ProcessEvent()方法传递一个新的实例到事件处理系统。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Chap 4 使用PyCrust简化wxPython处理&lt;/h1&gt;
&lt;p&gt;PyCrust是一个图形化shell程序，是wxPython编写的，你可以使用它帮助分析wxPython程序。&lt;/p&gt;
&lt;p&gt;为什么叫PyCrust？当当Patrick O'Brien使用wxPython创建一个交互式Python shell时，最显而易见的名称&amp;mdash;&amp;mdash;PyShell&amp;mdash;&amp;mdash;已经被使用。因而选择了PyCrust。&lt;/p&gt;
&lt;p&gt;PyCrust是一个大的Py包的一部分，这个包包含了其它一些有相近功能的程序包括PyFilling，PyAlaMode，PyalaCarte，和PyShell。将这些程序组合到一个图形界面，点击操作的环境中，可以与wxPython运行时功能进行交互和进行自省。PyCrust实现了这个主题中最完整的功能。&lt;/p&gt;
&lt;p&gt;这章，我们将展示PyCrust和相关程序的功能，及如何使用它们来让你与wxPython工作得更顺利。我们将先从Python的shell入手，然后是PyCrust的特点，最后，将涵盖Py包中的其它程序。&lt;/p&gt;
&lt;h2&gt;如何与wxPython程序交互？&lt;/h2&gt;
&lt;p&gt;Python与其它语言的相比比较引人注意的功能是它可以有两种方式使用：你可以运行已经编写好的Python程序，或者在命令提示符下交互的方式运行Python程序。&lt;/p&gt;
&lt;p&gt;（本章未完，主要介绍PyCrust的使用）&lt;/p&gt;
&lt;h1&gt;Chap 5 创建你的蓝图&lt;/h1&gt;
&lt;p&gt;本意讨论使用MVC设计模式来保持显示和数据的分离。最后将讨论如何对wxPython代码进行单元测试。&lt;/p&gt;
&lt;h2&gt;5.1 重构是如何帮助我提升我的代码的？&lt;/h2&gt;
&lt;p&gt;保证UI代码可控性的关键就是&amp;ldquo;重构&amp;rdquo;，或不断提升已有代码的设计和结构。重构的目的就是保持代码的状态，使它在将来易于阅读和管理。表5.1包含了重构应遵循的一些原则。最重要的基础目标就是要记得将来的人能读懂这些代码。努力使那个人工作轻松一些&amp;mdash;&amp;mdash;毕竟，这个人也有可能是你。&lt;/p&gt;
&lt;p&gt;表5.1 重构的一些重要原则&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;原则&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;不重复&lt;/td&gt;
&lt;td align="left"&gt;避免多段代码有相同的功能。当这些代码要修改时将非常头痛。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;同一时间只做一件事&lt;/td&gt;
&lt;td align="left"&gt;方法应该只做一件事，并且仅仅只做一件事。不同的事情应该移到不同的方法中。方法应该保持简短。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;保持较浅的嵌套&lt;/td&gt;
&lt;td align="left"&gt;尽量保持代码的嵌套不超过2至3层。深层的嵌套代码最好选择放到分开的方法中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;避免直接量魔法（magic literals）&lt;/td&gt;
&lt;td align="left"&gt;字符串和数字直接量应该保持尽量少。一个较好的管理直接量的方法是将它们存储于主代码之外，存储于列表或字典中。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中的一些原则对于Python代码尤为重要。因为Python是基于缩进语法的，精简的方法非常易于阅读。长的方法，难于解析，特别是当不能在一屏完全显示时。另外，在Python中深层的嵌套将使代码难于跟踪。毕竟，Python是一种避免重复的语言，特别是由于它可以把函数当作参数传递的简易性。&lt;/p&gt;
&lt;h3 id="511yi-ge-zhong-gou-de-li-zi"&gt;5.1.1一个重构的例子&lt;/h3&gt;
&lt;p&gt;我们通过一个重构的例子来展示如何在实际中使用这些原则。图5.1展示了一个可能是被作为Microsoft Access数据库前端的窗口。&lt;/p&gt;
&lt;p&gt;&lt;img alt="figure_5_1.png" src="/wxPython/figure_5_1.png"/&gt;&lt;/p&gt;
&lt;p&gt;布局比前面看到的复杂一点，但对于真实世界的应用来说，它仍然非常简单。代码5.1展示了生成图5.1所示程序的恶劣的代码。这就是那种大家所说的混乱的UI代码。将多个问题压缩到少量的代码行中可能有些夸张，但这将是你在布局代码中遇到的典型问题。&lt;/p&gt;
&lt;p&gt;代码5.1，生成图5.1的未重构的代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;wx&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RecactorExample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'Refactor Example'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                          &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;340&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Panel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"White"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;prevButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;lt;&amp;lt; PREV"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnPrev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prevButton&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;nextButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"NEXT &amp;gt;&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;160&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnNext&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nextButton&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_CLOSE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;menuBar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MenuBar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;menu1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;openMenuItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Open"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Copy in status bar"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnOpen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;openMenuItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;quitMenuItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Quit"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Quit"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;quitMenuItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menu1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;File"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menu2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Menu&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;copyItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Copy"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Copy"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCopy&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;copyItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cutItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"C&amp;amp;ut"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Cut"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnCut&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cutItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;pasteItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Paste"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Paste"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_MENU&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnPaste&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pasteItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Edit"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetMenuBar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;menuBar&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StaticText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"First Name"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"White"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TextCtrl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                           &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;static2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StaticText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"Last Name"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;static2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SetBackgroundColour&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"White"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;text2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TextCtrl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NewId&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                            &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;firstButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"FIRST"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnFirst&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;firstButton&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;AppendSeparator&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;opItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;menu2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"&amp;amp;Options..."&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"Display Options"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnOptions&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;optItem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;lastButton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Button&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panel&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"LAST"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;240&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EVT_BUTTON&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;OnLast&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lastButton&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnPrev&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnNext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnLast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnFirst&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnOpen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCopy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCut&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnPaste&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnOptions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;OnCloseWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Destroy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'__main__'&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;PySimpleApp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RefactorExample&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="o"&gt;=-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;MainLoop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分类来看这个代码是如何与表格5.1相背的。从正面来看，这里没有深层嵌套。负面来看，表5.1中的其它三条都不符合。表5.2总结了重构可以提升的地方。&lt;/p&gt;
&lt;p&gt;表5.2 重构清单5.1&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;原则&lt;/th&gt;
&lt;th align="left"&gt;代码中的问题&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;不重复&lt;/td&gt;
&lt;td align="left"&gt;多个模式是重复的，包括&amp;ldquo;创建一个按钮，设置它的action&amp;rdquo;，&amp;ldquo;添加菜单项，设置它的action&amp;rdquo;和&amp;ldquo;创建文本输入项的文字&amp;rdquo;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;同一时刻只做一件事&lt;/td&gt;
&lt;td align="left"&gt;这个代码做了多个事情。在基础的frame的设置中，它创建了菜单条，添加了按钮，添加了文本项。更恶劣的是，这三个函数是混在一起在，在后面的修改中我们将添加在方法的结尾。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;避免魔法直接量&lt;/td&gt;
&lt;td align="left"&gt;每个按钮，在构造器中菜单项和文本框都有一个字符串和一个直接量。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="512-kai-shi-zhong-gou"&gt;5.1.2 开始重构&lt;/h3&gt;
&lt;h2&gt;5.2 如何保持Model和View的分离&lt;/h2&gt;</content><category term="python"></category><category term="wxpython"></category></entry><entry><title>高级OA Framework开发主题——支持浏览后退按钮的用例</title><link href="/adv_back_use_cases.html" rel="alternate"></link><published>2008-07-04T00:00:00+08:00</published><updated>2008-07-04T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-04:/adv_back_use_cases.html</id><summary type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;本文档描述了与标准后退行为相关的公用应用设计模式，并包含了各个步骤的实现细节。&lt;/p&gt;
&lt;h2&gt;需要阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="/adv_backbutton.html#goals"&gt;Supporting the Browser Back Button - Target Goals&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;一般规则&lt;/h1&gt;
&lt;p&gt;通常，你的产品在用户使用后退按钮时应该遵循下面的规则。参见下面的特殊事务流以了解实现和行为的细节。&lt;/p&gt;</summary><content type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;本文档描述了与标准后退行为相关的公用应用设计模式，并包含了各个步骤的实现细节。&lt;/p&gt;
&lt;h2&gt;需要阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href="/adv_backbutton.html#goals"&gt;Supporting the Browser Back Button - Target Goals&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;一般规则&lt;/h1&gt;
&lt;p&gt;通常，你的产品在用户使用后退按钮时应该遵循下面的规则。参见下面的特殊事务流以了解实现和行为的细节。&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>高级OA Framework开发主题——支持浏览后退按钮</title><link href="/adv_backbutton.html" rel="alternate"></link><published>2008-07-04T00:00:00+08:00</published><updated>2008-07-04T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-07-04:/adv_backbutton.html</id><summary type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;本文档提供了一组&lt;a href="#goals"&gt;目标&lt;/a&gt;并描述了编码标准，你必须遵守以确保对浏览器后退按钮的支持。&lt;/p&gt;
&lt;p&gt;可用性测试显示用户非常依赖于浏览器后退按钮。不幸的是，这个导航偏好在事务型的应用中将导致一系列潜在的故障点。例如，思考在OA Framework应用中在下面的场景中使用浏览器后退按钮将导致不可预料的问题。&lt;/p&gt;
&lt;table class="table"&gt;
&lt;tr&gt;
&lt;th&gt;用户导航&lt;/th&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户从表格中删除了一行数据页面被重绘并显示了提示信息标明数据行已经被删除（数据行不再显示在表格中）。然后用户按下浏览器后退按钮，页面将显示出数据行仍然在表格中时的页面。这时用户再次尝试删除数据行。&lt;/td&gt;
&lt;td&gt;浏览器缓存了页面内容。如果用户执行的一个动作修改了数据状态，然后使用浏览器后退按钮，浏览的页面缓存没有反映出中间层的状态（在这里，是一个不存在的数据行）。当用户试图对缓存页面中被删除的行进行删除或其它处理时，将导致运行时错误。而支持浏览器后退按钮的页面将检测到这个错误并显示出用户友好的提示信息标明数据行已经被删除了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在构物车结算处理时，用户选择了&amp;ldquo;提交定单&amp;rdquo;按钮购买端口。但不知什么原因，用户使用浏览器后退按钮从确认页面退回了定单提交页面并再次点击了&amp;ldquo;提交定单&amp;rdquo;按钮（可能她想修改定单数量）。&lt;/td&gt;
&lt;td&gt;这个场景与前面描述的第一个场景类似，但未加保护的动作将导致&amp;ldquo;成功&amp;rdquo;执行两次交易。（定单可能会被创建两次，而这并不是用户期望的）。支持浏览器后退按钮的页面将可以检查到两次相同的提交并显示出用户友好的提示信息标明定单已经存在了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户从Page1导航到Page2，然后使用退出按钮返回Page1。然后在Page1中点击了一个表单提交组件，这将导致一个未处理的异常（NullPointerException, IndexOutOfBoundsException）。&lt;/td&gt;
&lt;td&gt;OA …&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</summary><content type="html">&lt;h1&gt;概述&lt;/h1&gt;
&lt;p&gt;本文档提供了一组&lt;a href="#goals"&gt;目标&lt;/a&gt;并描述了编码标准，你必须遵守以确保对浏览器后退按钮的支持。&lt;/p&gt;
&lt;p&gt;可用性测试显示用户非常依赖于浏览器后退按钮。不幸的是，这个导航偏好在事务型的应用中将导致一系列潜在的故障点。例如，思考在OA Framework应用中在下面的场景中使用浏览器后退按钮将导致不可预料的问题。&lt;/p&gt;
&lt;table class="table"&gt;
&lt;tr&gt;
&lt;th&gt;用户导航&lt;/th&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户从表格中删除了一行数据页面被重绘并显示了提示信息标明数据行已经被删除（数据行不再显示在表格中）。然后用户按下浏览器后退按钮，页面将显示出数据行仍然在表格中时的页面。这时用户再次尝试删除数据行。&lt;/td&gt;
&lt;td&gt;浏览器缓存了页面内容。如果用户执行的一个动作修改了数据状态，然后使用浏览器后退按钮，浏览的页面缓存没有反映出中间层的状态（在这里，是一个不存在的数据行）。当用户试图对缓存页面中被删除的行进行删除或其它处理时，将导致运行时错误。而支持浏览器后退按钮的页面将检测到这个错误并显示出用户友好的提示信息标明数据行已经被删除了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在构物车结算处理时，用户选择了&amp;ldquo;提交定单&amp;rdquo;按钮购买端口。但不知什么原因，用户使用浏览器后退按钮从确认页面退回了定单提交页面并再次点击了&amp;ldquo;提交定单&amp;rdquo;按钮（可能她想修改定单数量）。&lt;/td&gt;
&lt;td&gt;这个场景与前面描述的第一个场景类似，但未加保护的动作将导致&amp;ldquo;成功&amp;rdquo;执行两次交易。（定单可能会被创建两次，而这并不是用户期望的）。支持浏览器后退按钮的页面将可以检查到两次相同的提交并显示出用户友好的提示信息标明定单已经存在了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户从Page1导航到Page2，然后使用退出按钮返回Page1。然后在Page1中点击了一个表单提交组件，这将导致一个未处理的异常（NullPointerException, IndexOutOfBoundsException）。&lt;/td&gt;
&lt;td&gt;OA Framework&amp;ldquo;Page 1&amp;rdquo;预期的web bean层级结构处理是处于某种状态的，和/或它预期的事务、session或BC4J对象状态值是存在的。当使用后退按钮导航时，这些状态可能丢失。如果页面不符合预期，则将显示unhandled exceptions给用户。支持浏览器后退的页面将预料到在这种场景中将丢失状态，它或者有能力重建状态并继续执行通常的功能，或显示用户友好的提示信息标题页面在使用浏览器后退按钮后不可以再被访问。&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a name="goals"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;目标&lt;/h2&gt;
&lt;p&gt;为避免出现上面类似问题的出现，使用这些目标来指导我们理解什么是&amp;ldquo;支持&amp;rdquo;浏览器后退按钮。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="#goal1"&gt;在处理浏览后退按钮时提供一致的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#goal2"&gt;避免状态变更导致的严重的不可预知的异常&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name="goal1"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="mu-biao-1zai-chu-li-liu-lan-hou-tui-an-niu-shi-ti-gong-yi-zhi-de-xing-wei"&gt;目标1：在处理浏览后退按钮时提供一致的行为&lt;/h3&gt;
&lt;p&gt;在处理浏览器后退按钮时保持一致性是很重要的。使用下面的子目标来保持一致性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;允许简单的、直接的操作重复除非技术上存在限制。&lt;/p&gt;
&lt;p&gt;当用户执行查询或查看记录明细时使用调查流；当用户使用导航按钮并再次向前时，允许无缝的查询和查看明细，不显示错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在逻辑事务活动时允许事务重复&lt;/p&gt;
&lt;p&gt;在这个上下文中的逻辑事务流指包含一个或多个页面的任务并带有决定性的结束点（事务提交）。例如对一行或多个选中数据行的单页面的update，多步的create和单个动作的删除（带commit）。。用户可以逻辑事务中使用浏览器后退按钮，并在逻辑事务执行过程上中执行操作而不出现错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免会引起歧义的事务、操作已经被删除的数据的事务或将导致无意识的用户操作的事务。&lt;/p&gt;
&lt;p&gt;为确保事务的完整性，如果可以则限制后退按钮后执行动作。例如，创建流（Create flow）在表单提交动作后点击浏览后退按钮应该不可重入。因为它不清楚用户是想要更新前面创建的记录还是创建一个新的重复记录。这种情况下应该显示错误对话框。操作于已经被删除的数据上时也需要显示明显的错误对话框。&lt;/p&gt;
&lt;p&gt;如果你在用户在一个页面选择一条记录后在另一个页面修改选中的数据行有特殊的更新流（Update flow）；则应选择与创建流（Create flow）类似的受限规则显示的告诉用户数据行正在被修改。或者，如果你没有记住选中数据行的机制则重复相同的更新操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tip:&lt;/strong&gt; 为支持浏览器后退按钮，尽管更可取的办法是允许页面的重入，但有疑问的情况下，最好限制页面的重入，对用户来说这样也比显示unhandled exceptions或执行无意识的事务要好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="goal2"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="mu-biao-2zai-zhuang-tai-gai-bian-shi-bi-mian-yan-zhong-de-unexpected-exceptions"&gt;目标2：在状态改变时避免严重的Unexpected Exceptions&lt;/h3&gt;
&lt;p&gt;你的最小目标是应该避免严重的unexpected exception，如NullPointerExcpetion或IndexOutOfBoundException，它将显示不可读的信息给用户。应该用用户可读的文本信息对话框来取代异常信息。&lt;/p&gt;
&lt;p&gt;参见 &lt;a href="/adv_back_use_cases.html#general"&gt;Use Case-Specific General Standards&lt;/a&gt; 了解这个目标的更多细节信息。&lt;/p&gt;
&lt;h2&gt;内容&lt;/h2&gt;
&lt;h2&gt;需要阅读&lt;/h2&gt;
&lt;p&gt;本文档假定你已经阅读了下面的内容：
Anatomy of an OA Framework Page
OA Framework State Management
Implementing the Model
Implementing the View
Implementing the Controller&lt;/p&gt;
&lt;h1&gt;概述相关工具和行为&lt;/h1&gt;
&lt;p&gt;深入编码标准前，了解OA和BC4J frameworks提供的内置对象和工具的行为对于你编写支持浏览器后退按钮的页面是很重要的。下一节的&lt;a href="#standards"&gt;编码标准&lt;/a&gt;提供了使用这些来处理后退按钮问题的介绍。&lt;/p&gt;
&lt;h2&gt;唯一的页面实例ID和页面状态缓存&lt;/h2&gt;
&lt;p&gt;OA Framework对于每个分离的页面请求&amp;mdash;&amp;mdash;包括同一个页面的多次请求&amp;mdash;&amp;mdash;都有一个唯一的页面实例ID（一个增长的页面计数参数被添加到form action URL和每个生成的页面链接）。。当form提交发生在用户点击浏览器后退按钮之后时，OA Framework使用页面计数器标识来检测浏览器后退按钮导航。&lt;/p&gt;
&lt;p&gt;另外，新的方法被添加到oracle.apps.fnd.framework.webui.OAPageContext，它允许你保存和获取页面的状态：savePageState()，getPageState()和removePageState()。参见Javadoc了解其它的信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 注意：&lt;/strong&gt; 如果异常发生在页面处理时，页面状态不会被保存并且它不会被钝化。&lt;/p&gt;
&lt;h2&gt;检查后退按钮导航的方法&lt;/h2&gt;
&lt;p&gt;OAPageContext.isBackNavigationFired()方法使你可以明确的检测到当前请求的浏览器后退按钮导航。这依赖于前面所讲的页面实例ID。&lt;/p&gt;
&lt;p&gt;参见OAPageContext的Javadoc了解使用这个方法的其它信息。&lt;/p&gt;
&lt;h2&gt;Web Bean层级结构的同步&lt;/h2&gt;
&lt;p&gt;在第2章和第3章中讲过，OA Framework在处理HTTP POST时，如果原来缓存的层级结构被丢失它将重建web bean层级结构。具体来说，它将在下面的情况下重新进入整个web bean层级结构的processRequest()。&lt;/p&gt;
&lt;p&gt;恢复丢失的web bean层级结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;POST请求激活了一个新的servlet session或一个被回收的应用模块实例（被钝化后）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST请求失败后转到了新的JVM。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 故障转移支持只在启用了请求级的钝化时才被支持。但是，这个功能目前还只处理测试阶段不被OA Framework所支持。&lt;/p&gt;
&lt;p&gt;使用中间层web bean状态同步客户端UI状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;POST请求是在用户使用浏览器后退按钮后的页面发起的。OA Framework通过调用OAPageContext.isBackNavigationFired()方法检查这种情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST请求从oracle.apps.fnd.framework.webui.OADialogPage发起，请求目标为打开这个对话框的初始页面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当form被提交时能重新创建web bean层级结构是一项重要的特性因为它确保了用户的工作可以在不被打断的并被保持一致的情况下被处理。但是，它不能强制要求代码规则确保任何支持后退按钮访问页面都可以在这种情况下被重建。。&lt;/p&gt;
&lt;h2&gt;UI&amp;ldquo;事务单元（Transaction Unit）&amp;rdquo;&lt;/h2&gt;
&lt;p&gt;oracle.apps.fnd.framework.webui.TransactionUnitHelper类允许你描绘用户接口&amp;ldquo;事务单元&amp;rdquo;用于标识出在事务提交后不适当的导航。在这些情况下非常有用：当多个分离的UI任务（每个都有自己的提交点commit points）共享相同的根应用模块&amp;mdash;&amp;mdash;因此是相同的数据库事务。通过事务单元标识器，你可以标明一个特定UI任务的开始和结束，并且如果用户意外导航比如浏览器后退按钮。你可以检查事务单元状态并作出反映确保不合适的动作不会执行BC4J缓存中的不需要的数据不会被提交。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户在Employee Summary页查找employees并选择 &lt;strong&gt;Create Employee&lt;/strong&gt; 按钮。&lt;/p&gt;
&lt;p&gt;你可以开始一个create employee 事务单元。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户在Create Employee页面输入一些数据然后点击 &lt;strong&gt;Apply&lt;/strong&gt; 提交修改。&lt;/p&gt;
&lt;p&gt;结束create employee 事务单元。作为 &lt;strong&gt;Apply&lt;/strong&gt; 按钮处理的一部分，Create Employee页面forward到summary Page并在那里显示一个确认信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户点击浏览器后退按钮退回Create Employee页面然后再次修改数据并点击 &lt;strong&gt;Apply&lt;/strong&gt; 按钮。&lt;/p&gt;
&lt;p&gt;通过检查事务单元的状态OA Framework显示一个出错对话框页面，因为在这个范例模块中修改一个新创建的数据行是不允许的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这里没有当前的create employee 事务单元，因为用户没有通过 &lt;strong&gt;Create Employee&lt;/strong&gt; 按钮来导航，如果那样将触发创建一个新的事务单元。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面的&lt;a href="#specific"&gt;Use Case-Specific Standards&lt;/a&gt;提供了如何使用这个技巧的细节。&lt;/p&gt;
&lt;h2&gt;事务撤销（Transaction Undo）&lt;/h2&gt;
&lt;p&gt;在EBS 12版是不支持事务撤销的。&lt;/p&gt;
&lt;h2&gt;视图对象的主键比较（View Object Primary Key Comparison）&lt;/h2&gt;
&lt;p&gt;假定VO对象有一个主键或ROWID属性，OA Framwork将在处理processFormData()时自动检查从表单提交的数据，检查是否有&amp;ldquo;数据过期（stale data）&amp;rdquo;。如果页面数据行的主键或ROWID与VO中同一行（如果数据行的集合已经被修改或数据行已经被删除）数据的主键或ROWID不匹配，OA Framework将显示一个标准的&amp;ldquo;数据过期&amp;rdquo;的出错页面。&lt;/p&gt;
&lt;p&gt;如果定义了主键，而不是依赖于ROWID属性，OA Framework将尝试在结果集中使用主键查找到匹配的数据行。如果找到了，则&amp;ldquo;数据过期&amp;rdquo;错误将被避免，并且用户继续工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework只在VO对象当前的结果集（current view object result set）中查找匹配的数据行。如果VO对象的WHERE子句对结果集进行了限制，匹配有可能不能匹配，这也将产生&amp;ldquo;数据过期&amp;rdquo;的错误提示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用笔记&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;数据过期&amp;rdquo;检测机制的设计目的主要是为了捕捉对已经被删除的数据行进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了优化性能，对于没有表单元素的只读表格OA Framework不会执行数据过期的检查。对于某些特殊情况需要对只读表格进行数据过期检查的，可以表格区域的最后添加一个虚拟的可更新隐藏字段（ &lt;strong&gt;formValue&lt;/strong&gt; ）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了获取&amp;ldquo;数据过期&amp;rdquo;错误的根本原因，可以启用开发模式（Developer Mode）或诊断模式（Diagnostic Mode）。当这两种模式启用时，面向开发者的附加内容将显示在对话框页面的消息中，帮助诊断代码错误。参见&lt;a href="{filename}test_test.md"&gt;测试OA Framework应用&lt;/a&gt;以了解启用这些模式的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;数据过期&amp;rdquo;错误的意外出现也有可能是与VO对象的初始值有关。参见下面的&lt;a href="#uncond"&gt;避免无条件的VO对象/事务状态初始值&lt;/a&gt;以了解更多信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;已知问题：&lt;/strong&gt; 当前的VO对象主键比较逻辑趋向于过度保护；某些情况下，&amp;ldquo;数据过期&amp;rdquo;错误可能会出现在不需要的地方。例如，在通过浏览器后退按钮回退后以新的查询条件执行查询将导致&amp;ldquo;数据过期&amp;rdquo;的错误。为了在只读表格中避免这个问题，你可以在oracle.apps.fnd.framework.webui.beans.table.OATableBean或oracle.apps.fnd.framework.webui.beans.table.OAAdvancedTableBean上使用setSkipProcessFormData(pageContext,true)API。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;在锁定过程中BC4J过期数据检查（BC4J Stale Data Check During Locking）&lt;/h2&gt;
&lt;p&gt;当BC4J试图在数据库提交操作之前锁定行时将使用默认的OA Framework锁方案，如果当前用户查询过的行已经被另一个用户删除或修改它将自动尝试并决定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果行被删除了，BC4J将抛出oracle.jbo.RowAlreadyDeletedException。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果行已经被修改，BC4J将抛出oracle.jbo.RowInconsistentException。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这两种情况下，OA Framework将自动将这些低级的异常转化为用户友好的错误信息。&lt;/p&gt;
&lt;p&gt;这个检查在用户使用后退按钮并再次保存对过期数据的修改时也有好处。&lt;/p&gt;
&lt;p&gt;关于BC4J锁的更多信息，参见第五章&lt;a href="/bus_java.html"&gt;实现Java实体对象&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;标准错误对话框（Standard Error Dialogs）&lt;/h2&gt;
&lt;p&gt;OA Framework包含了一些标准错误对话框。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NAVIGATION_ERROR - 这个错误信息通知用户不能在点击浏览器后退按钮后继续。并指示用户回到全局主页（global Home page）恢复导航并重新启动事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FAILOVER_STATE_LOSS_ERROR - 这个错误信息通知用户在用户session或系统失效后不能继续。并指示用户回到全局主页恢复导航并重新启动事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATE_LOSS_ERROR - 两个特殊错误信息的组合。指示用户在使用后退按钮、用户session过期或系统失效后不能继续。并指示用户回到全局主页恢复导航并重新启动事务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;

  &lt;span class="c1"&gt;// Display a standard error message related to state loss due to Back button&lt;/span&gt;
  &lt;span class="c1"&gt;// navigation or failover as appropriate.&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isBackNavigationFired&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;redirectToDialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OADialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NAVIGATION_ERROR&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;redirectToDialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OADialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FAILOVER_STATE_LOSS_ERROR&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以直接使用pageContext.redirectToDialogPage(new OADialogPage(STATE_LOSS_ERROR))。但是，我们强烈建议你创建怀具体环境相关的消息提高对客户的实用性。&lt;/p&gt;
&lt;h2&gt;AM State Required 标识（AM State Required Flag）（Deprecated）&lt;/h2&gt;
&lt;p&gt;应用模块的AM State Required标识在新的开发中不再被推荐使用。如果你有页面使用了这个功能，并且它的表现与下面章节中的编码标准是一致的，则不需要修改你的实现。&lt;/p&gt;
&lt;h1&gt;编码标准（Coding Standards）&lt;/h1&gt;
&lt;p&gt;尽管在编码标准一章中所有的OA Framework编码标准都已经列出，但这一节提供了将每个标准应用到你的代码中的更多细节信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这些主题也链接到了第八章的摘要列表。&lt;/p&gt;
&lt;p&gt;编码标准被分为两个大的分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#general"&gt;一般标准&lt;/a&gt;应用于所有的使用情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="#specific"&gt;特殊情况标准&lt;/a&gt;描述了在特殊应用场景中如何处理后退按钮，如何在一个只读摘要页面中处理删除动作，或如何处理关联到一个可更新页面的多步创建动作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a name="general"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一般标准&lt;/h2&gt;
&lt;h3 id="1-ding-yi-vodui-xiang-de-zhu-jian-mo-xing-bian-ma-biao-zhun-m39"&gt;1. 定义VO对象的主键 (模型编码标准&lt;a href="{filename}cs_mdlgeneral.md#M39#M39"&gt;M39&lt;/a&gt;)&lt;/h3&gt;
&lt;p&gt;为了使得上面所述的VO对象的主键可以进行比较，所有VO必须一个主键或以ROWID来代替。主键适合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例外：&lt;/strong&gt; 如果是一个不包含逻辑主键的简单只读VO对象，则不需要创建主键。比如，一个单列VO对象查询的是某列的合计值而并不包含逻辑主键。&lt;/p&gt;
&lt;p&gt;如果你需要了解如何定义VO对象的主键，参见&lt;a href="/build_model.html"&gt;实现模型&lt;/a&gt;。如果没有主键则应该使用ROWID，只需要在VO对象的SQL中选择ROWID伪列对应的属性名称为 &lt;strong&gt;Rowid&lt;/strong&gt; 或 &lt;strong&gt;RowId&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id="2-bu-yao-jia-she-vodui-xiang-de-zhuang-tai-mo-xing-bian-ma-biao-zhun-m38m37"&gt;2. 不要假设VO对象的状态（模型编码标准&lt;a href="{filename}cs_mdlgeneral.md#M38#M38"&gt;M38&lt;/a&gt;，&lt;a href="{filename}cs_mdlgeneral.md#M37#M37"&gt;M37&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;对于VO对象的状态永远不要臆测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不要总是认为VO对象一定有数据行。对从VO对象中获取的数据行进行null检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于查询页面中使用动态WHERE子句的VO对象，在执行查询前总是清除先前在的WHERE子句参数。这确保了之前的设置不会影响当前的查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于动态创建的VO对象，在创建之前总是使用find进行检查。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面的代码描述了这些规则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Bad Code&lt;/span&gt;
&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAllRowsInRange&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="na"&gt;getAttribute&lt;/span&gt;&lt;span class="o"&gt;(...);&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;--&lt;/span&gt; &lt;span class="n"&gt;assumes&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;exist&lt;/span&gt;
&lt;span class="c1"&gt;// Good Code&lt;/span&gt;
&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getAllRowsInRange&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;   &lt;span class="o"&gt;&amp;lt;--&lt;/span&gt; &lt;span class="n"&gt;allows&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;possibility&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;cannot&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;found&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Take proper action.&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;rows&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="na"&gt;getAttribute&lt;/span&gt;&lt;span class="o"&gt;(...);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使动态设置WHERE子句（不管它是否为null）之前，总是先清空参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Bad Code&lt;/span&gt;

&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"empno &amp;lt; 10"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"empno = :1"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClauseParam&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;// Good Code&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"empno &amp;lt; 10"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClauseParams&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"empno = :1"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClauseParams&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClauseParam&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;some&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClause&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setWhereClauseParams&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要动态创建VO对象或VO对象的属性，在创建之前先检查同名的对象是否已经存在：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// Bad Code&lt;/span&gt;
&lt;span class="n"&gt;ViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyVO"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...);&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addDynamicAttribute&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyAttr"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Good Code&lt;/span&gt;
&lt;span class="c1"&gt;// First check whether the VO with the same name exists or not.&lt;/span&gt;

&lt;span class="n"&gt;ViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyVO"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyVO"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Check whether the attribute with the same name exists or not.&lt;/span&gt;
&lt;span class="c1"&gt;// Note that for attributes, we need to use try-catch clause.&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lookupAttributeDef&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyAttr"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addDynamicAttribute&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"MyAttr"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="3-zai-processrequestzhi-wai-xiu-gai-web-beanshu-xing-kong-zhi-qi-bian-ma-biao-zhun-c16c15"&gt;3. 在processRequest之外修改Web Bean属性（控制器编码标准&lt;a href="{filename}cs_ctrlgeneral.md#C6#C6"&gt;C16&lt;/a&gt;，&lt;a href="{filename}cs_ctrlgeneral.md#C15#C15"&gt;C15&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;不要在processFormData()或processFormRequest()中添加修改web bean的逻辑。如果你需要在处理form提交请求过程中修改web bean层级结构或修改web bean属性，你可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;参见第四章&lt;a href="{filename}feat_ppr.md"&gt;动态用户界面&lt;/a&gt;将属性绑定到SPEL上和使用页面区域渲染。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用OAPageContext.setForward*()方法退回页面，并半retainAM参数设置为true，然后在processRequest()中执行你的bean处理逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果OA Framework由于上面描述过的原因需要重建web bean层级结构，所有相关逻辑必须包含在processRequest()方法中。而且，任何使得要修改web bean层级结构（包含web bean属性）的信息，必须被添加为 &lt;strong&gt;URL参数（URL parameter）&lt;/strong&gt;。换言之，如果你需要以某种方式在页面跳转（forward）时以编程方式修改web bean属性或层级结构，则这些在你检查用用以决定是否修改web bean的信息必须在调用forward（OAPageContext.setForward*()）时通过&amp;ldquo;参数（parameter）&amp;rdquo;(com.sun.java.util.collections.HashMap)指定。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.sun.java.util.collections.HashMap&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="c1"&gt;// As a result of a button press, return to the current page setting&lt;/span&gt;
&lt;span class="c1"&gt;// a URL parameter value to be used to modify the page layout.&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"someButton"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;HashMap&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"showRegion"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"RegionA"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setForwardURLToCurrentPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// added to the request as URL parameters&lt;/span&gt;
                                           &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// retain the AM&lt;/span&gt;
                                           &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ADD_BREAD_CRUMB_NO&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                           &lt;span class="n"&gt;OAWebBeanConstants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;IGNORE_MESSAGES&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;


&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"RegionA"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"showRegion"&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Change your layout accordingly...&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 使用OAPageContext.putParameter()或隐藏域在这种情况下不行，因为这些值不会被作为URL参数添加到请求。&lt;/p&gt;
&lt;p&gt;下面的例子描述了一个主键值如何被传递到setForward*()方法的HashMap参数中并被用于重建合适的web bean层级结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Page A包含了一个动态部分，它根据用户从列表中的选择显示不同的区域。Page A默认显示 &lt;strong&gt;Region1&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户在列表中选中了一个用于决定显示区域值。然后你跳转回页面，并将个值通过OAPageContext.setForwardURLToCurrentPaqge()方法设置到了&amp;ldquo;参数&amp;rdquo;HashMap中。这保证了这个值被作为URL参数添加到了请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户修改了她的主意从列表中选择了不同的项，这样你的代码将forward到页面并显示 &lt;strong&gt;Region3&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户选择浏览器后退按钮退回Page A将显示Page 2。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 浏览器的HTML缓存，显示的是 &lt;strong&gt;Region2&lt;/strong&gt; ，不再与中间层的web bean层级结构匹配，中间层包含的是 &lt;strong&gt;Region3&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户在显示于 &lt;strong&gt;Region2&lt;/strong&gt; 的字段中输入一些值然后点击 &lt;strong&gt;Submit&lt;/strong&gt; 按钮。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OA Framework检测到浏览器后退按钮，在响应时，重建web bean层级结构并包含了 &lt;strong&gt;Region2&lt;/strong&gt; 和用户添加到请求的数据。这确保了中间层与浏览器缓存正确同步了动作处理没有出现错误。&lt;/p&gt;
&lt;h3 id="4-bi-mian-wu-tiao-jian-voshi-wu-zhuang-tai-chu-shi-zhi-kong-zhi-qi-bian-ma-biao-zhun-c32"&gt;4. 避免无条件VO/事务状态初始值（控制器编码标准&lt;a href="{filename}cs_ctrlgeneral.md#C32#C32"&gt;C32&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;在上面的&lt;a href="#hier_synch"&gt;Web Bean层级结构同步&lt;/a&gt;一节中描述过processRequest()方法可能重复的进入，避免无条件的VO对象和事务状态初始值。&lt;/p&gt;
&lt;p&gt;初始操作包括下面的情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在VO对象上调用executeQuery()从数据库中查询数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在VO对象的insertRow(row)方法之后调用setMaxFetchSize(0)手工插入数据行，而不是从数据库查询。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用OAPageContext.putTransactionValue()，OAPageContext.putTransactionTransientValue()，OAViewObjectImpl.putValue()，OAApplicationModuleImpl.putValue()或OAPageContext.putSessionValue()来创建事务或session状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应该避免无条件初始化是因为下面两个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当processRequest()方法重入时，无条件初始将导致事务状态丢失。例如，用户对于transient VO属性的修改将丢失，VO对象的当前行数据行将重置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多余的执行查询和状态初始化性能上是不可取的（&lt;a href="http://boulter.com/blog/2004/08/19/performant-is-not-a-word/"&gt;performant&lt;/a&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参见&lt;a href="{filename}bus_vo.md#init#init"&gt;VO对象细节：初始化规则&lt;/a&gt;了解如何对VO对象执行适当的初始化。&lt;/p&gt;
&lt;h4 id="shi-wu-zhuang-tai"&gt;事务状态&lt;/h4&gt;
&lt;p&gt;如果你使用OAPageContext.putTransactionValue()等方法管理事务状态，则总应该检查它是否已经存在。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poTrxStep"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;){&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putTransactioinValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"poTrxStep"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"1"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如果事务值（transaction value）可以改变过程并且你只需要初始化这个值一次，则这个检查是很重要的。&lt;/p&gt;
&lt;h3 id="5-qia-dang-de-pei-zhi-dui-hua-kuang-ye-mian-kong-zhi-qi-bian-ma-biao-zhun-c30_1"&gt;5. 恰当的配置对话框页面（控制器编码标准&lt;a href="{filename}cs_ctrlgeneral.md#C30#C30"&gt;C30&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;如果在导航到对话框页面时，需要根据用户对对话框页面问题的响应来交换数据，可以配置按钮来提交它的表单到调用页面。参见&lt;a href="{filename}ebs_feat_dialog.md"&gt;对话框页面&lt;/a&gt;了解操作细节。OA Framework将在调用processFormData()和processFormRequest()之前重新进入processRequest()，以确保你的页面能预期到&lt;a href="#uncond"&gt;无条件VO对象/事务初始化&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通常，你不需要关心对话框页面的后退按钮的支持。在极少数情况下对话框页面提交表单到它自身而不是提交到调用它的页面，你必须确保对话框页面可以像其它页面一样被重建。换方言之，任何写在processRequest()和processFormRequest()中对话框控制器代码必须预料和处理可能的状态丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用OADialogPage中的deprecated的方法setReleaseAllRootApplicationModules和setReleaseRootApplicationModule。如果使用了这些方法，则用户导航到OA Framework页面如Preference页，并用 &lt;strong&gt;Cancel&lt;/strong&gt; 按钮返回对话框页面时对话框页面的状态时将失效。参见Javadoc以了解这些方法的更多信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="6-zheng-que-de-tong-guo-ye-mian-yu-zhuang-tai-tong-xun-kong-zhi-qi-bian-ma-biao-zhun-c20c17"&gt;6. 正确的通过页面与状态通讯（控制器编码标准&lt;a href="{filename}cs_ctrlgeneral.md#C20#C20"&gt;C20&lt;/a&gt;，&lt;a href="{filename}cs_ctrlgeneral.md#C17#C17"&gt;C17&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;在考虑在特定情况下使用哪种通讯方法之前，先了解一下有哪些可用的选项。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;方法&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;URL 参数&lt;/td&gt;
&lt;td align="left"&gt;你可以直接添加参数及其值到URL。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;隐藏域OAFormValueBean&lt;/td&gt;
&lt;td align="left"&gt;HTML页面隐藏域的值在form提交时将添加到请求中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;FormParameter OAFormParameterBean&lt;/td&gt;
&lt;td align="left"&gt;HTML页面隐藏域的值在form提交时将添加到请求，与OAFormValueBean不同，这个值在每次form提交时会被清空（在fireAction或firePartialAction事件方法给它设置新值之前）。 &lt;strong&gt;注意：&lt;/strong&gt; 这个组件的使用是保留的，是专门用于配置fireAction和firePartialAction事件的。参见第四章的&lt;a href="{filename}feat_submitform.md"&gt;Declarative Form Submit&lt;/a&gt;和&lt;a href="{filename}ebs_feat_ppr.md"&gt;动态用户界面&lt;/a&gt;以了解更多细节。不要直接在你的页面中添加FormParameter beans。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;OAPageContext.putParameter()&lt;/td&gt;
&lt;td align="left"&gt;将参数值添加到特殊的页面缓存中，这个值在单个请求是持久化的。 &lt;strong&gt;注意：&lt;/strong&gt; 如果，用户导航到个性化或首选项页面然后返回你的页面。如果你只依赖于putParameter()设置的值，则它将不能正确重建页面。这是因为导航流承担了多次请求。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Transaction Value OAPageContext.putTransactionValue()&lt;/td&gt;
&lt;td align="left"&gt;将值添加应用模块的事务中，它在应用模块被保留时将一直存在。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Application Module Value OAApplicationModuleImpl.putValue()&lt;/td&gt;
&lt;td align="left"&gt;将值添加到应用模块中，它在应用模块被保留时将一直存在。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;View Object Value OAViewObjectImpl.putValue()&lt;/td&gt;
&lt;td align="left"&gt;将值添加VO对象，它将在应用模块被保留时一直存在。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Transient Transaction Value OAPageContext.putTransactionTransientValue()&lt;/td&gt;
&lt;td align="left"&gt;事务值存在于当前应用模块中，但仅限于当前JVM。 &lt;strong&gt;注意：&lt;/strong&gt; 这些不会被钝化，因此如果当前的应用模块被钝化并因为其它原因被激活，这些值将会丢失。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Application Module Transient Value OAApplicationModuleImpl.putTransientValue()&lt;/td&gt;
&lt;td align="left"&gt;应用模块值存在于当前JVM中。 &lt;strong&gt;注意：&lt;/strong&gt; 这些不会被钝化，因此如果当前的应用模块被钝化并因为其它原因被激活，这些值将会丢失。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ViewObjectTransientValue OAViewObjectImpl.putTransientValue()&lt;/td&gt;
&lt;td align="left"&gt;VO对象值存在于当前JVM。 &lt;strong&gt;注意：&lt;/strong&gt; 这些不会被钝化，因此如果当前的VO对象被钝化并因为其它原因被激活，这些值将会丢失。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Session Value OAPageContext.putSessionValue()&lt;/td&gt;
&lt;td align="left"&gt;添加到servlet session中的值生存于整个session周期。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;TransientSessionValue OAPageContext.putTransientSessionValue()&lt;/td&gt;
&lt;td align="left"&gt;Session值存在于当前JVM的session中。 &lt;strong&gt;注意：&lt;/strong&gt; 这些值不会被钝化，因此如果当前的session的状态被钝化并因为其它原因被激活，这些值将会丢失。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;浏览器cookie不包含在可用的通讯列表技术中。不要使用浏览器cookie来存储应用中的信息。浏览器可以拒绝cookie值，并且对于cookie的数量也有限制。浏览器cookie通常只在OA Framework内部使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这不适合于用自动强制页面刷新来解决后退问题。如果你因为其它原因需要使用页面刷新，请联系OA Framework团队。&lt;/p&gt;
&lt;h4 id="yong-fa-tui-jian"&gt;用法推荐&lt;/h4&gt;
&lt;p&gt;这节描述了正确的方法在可预期的游览后退按钮操作时与页面相关状态进行通讯。这些推荐方法包括启用&amp;ldquo;Return to&amp;rdquo;链接在不同的模块间导航并确保个性化和首选项模块能与你的页面无缝集成。例如，当用户在个性模块时选择&amp;ldquo;Cancel&amp;rdquo;按钮，你的页面应该能够正确的重建。&lt;/p&gt;
&lt;p&gt;参见&lt;a href="{filename}ess_state.md"&gt;OA Framework状态管理&lt;/a&gt;了解更多相关的技术细节。&lt;/p&gt;
&lt;p&gt;&lt;a name="intra-app-long"&gt;&lt;/a&gt;
应用内导航&lt;/p&gt;
&lt;p&gt;与用于构建目标页面的简单的状态值通讯时，使用URL参数（URL Parameters）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果是在form提交的环境下与状态通讯，使用OAPageContext.setForward*()方法的&amp;ldquo;paramters&amp;rdquo;HashMap。如果可能，应该避免使用OAPageContext.putParameter()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是在GET请求中与状态通讯，直接添加组件的Destination URI的静态绑定值将变成URL参数。在选择菜单项时你也可以将URL参数添加到请求中。参见&lt;a href="{filename}feat_tabs.md"&gt;Tabs/Navigation&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 通过浏览地址栏设置的值将显示给用户。用户通过查看页面源码也可以看到隐藏域值。在这两种情况下，敏感的数据值必须被如&lt;a href="/build_view.html#urlparams"&gt;实现视图：URL参数&lt;/a&gt;中描述的进行加密。&lt;/p&gt;
&lt;p&gt;为了根据更复杂或长时间存在的状态值来构建目标页面，可以使用下面的与应用模块相关的缓存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在事务中缓存值，如果你不需要钝化支持可以使用OAPageContext.putTransactionValue()或OAPageContext.putTransactionTransientValue()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在应用模块中缓存值，如果不需要钝化支持可以调用oracle.apps.fnd.framework.server.OAApplicationModuleImpl.putValue()或OAApplicationModuleImple.putTransientValue()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在VO对象中缓存值，如果不需要钝化支持oracle.apps.fnd.framework.server.OAViewObjectImpl.putValue()或OAViewObjectImpl.putTransientValue()。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用这些缓存策略时，要记得在代码中处理潜在的状态丢失。换言之，在使用值之前总是需要检查所需要的值是否存在，如果它为null或为空，你可以选择重建并重新缓存这个值，如果不行则需要显示一个用户友好的状态丢失的对话框消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例外：&lt;/strong&gt; 如果页面已经使用了如&lt;a href="#specific"&gt;Use Case-Specific Coding Standards&lt;/a&gt;中的UI事务单元来保护，则你不需要检查这些值是否已经存在。&lt;/p&gt;
&lt;p&gt;另外，为了使这个缓存策略能正确的工作，必须遵循下面的规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不要为了省事而在只读页面中使用OAApplicationModule，总是使用自己的应用模块类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免在页面被渲染前调用OAPageContext.releaseRootApplicationModule()来释放应用模块；这将导致过早的丢失页面状态。可以通过配置保留级别（retention levels）为 &lt;strong&gt;CONNECTION_AGNOSTIC&lt;/strong&gt; 或 &lt;strong&gt;MANAGE_STATE&lt;/strong&gt; 将你的根应用模块申明为无状态连接。参见&lt;a href="{filename}adv_passive.md#ret_level#ret_level"&gt;OA Framework State Persistence Model (Passivation)&lt;/a&gt;以了解更多信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用间导航&lt;/p&gt;
&lt;p&gt;应用内页面流上面已经讨论过了，在交叉页面流中导航最简单的方法是使用URL参数（URL parameters）。&lt;/p&gt;
&lt;p&gt;当原页面和目标页面使用了不同的应用模块时如果需要使用复杂的或长时间存在的值来构建目标页面时，你不能依赖于上面描述过的应用内导航。而应该在原始页面调用OAPageContext.putParameter()或OAPageContext.putSessionValue()/OAPageContext.putTransientSessionValue()来传递值到目标模块，然后在它的应用模块中获取和缓存这些值。目标页面必须：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;复制（&amp;ldquo;迁移（transition）&amp;rdquo;）参数/session值到根UI应用模块。换言之，获取参数或session值然后将它们存储于如&lt;a href="#intra-app-long"&gt;应用内导航&lt;/a&gt;中描述的事务、应用模块或VO对象中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果输入值被缓存于session中，则在复制它们后应该将它从session中删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从应用模块缓存中读取值，总是要考虑应用模块的状态可能会丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面的例子描绘了目标页面控制器的processRequest()方法使用了一个私有的方法&amp;ldquo;迁移&amp;rdquo;传递的值到应用模块缓存中。（这里假定在原页面使用了OAPageContext.putParameter()方法）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Always call this first.&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// Call this before trying to retrieve the value from the transaction.&lt;/span&gt;
  &lt;span class="n"&gt;transitionPageState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;required page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// Handle the loss of page state values when the application module is&lt;/span&gt;
  &lt;span class="c1"&gt;// released. If one of the required page state values does not exist&lt;/span&gt;
  &lt;span class="c1"&gt;// redirect to a context-specific state loss error page.&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Note that you are strongly recommended to use context-specific message&lt;/span&gt;
    &lt;span class="c1"&gt;// instead of the following generic messages.&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isBackNavigationFired&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;redirectToDialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OADialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NAVIGATION_ERROR&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;redirectToDialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OADialogPage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FAILOVER_STATE_LOSS_ERROR&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// Otherwise, use the page state and continue processing the request.&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end processRequest()&lt;/span&gt;


&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;transitionPageState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// First inspect one of the required page state values.&lt;/span&gt;
  &lt;span class="c1"&gt;// Use getParameterObject() instead of getParameter() for&lt;/span&gt;
  &lt;span class="c1"&gt;// non-String object types.&lt;/span&gt;
  &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameterObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;required page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Transition the required value.&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;required page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// If you used session values instead of OAPageContext.putParameter to transport&lt;/span&gt;
    &lt;span class="c1"&gt;// the values, then remove the values from session after each transition.&lt;/span&gt;

    &lt;span class="c1"&gt;// Transition other values.&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameterObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;required page state 2&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;required page state 2&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// For optional values, if the value is not present, explicitly remove values&lt;/span&gt;
    &lt;span class="c1"&gt;// from the transaction.&lt;/span&gt;
    &lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameterObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;optional page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;optional page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;removeTransactionValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&amp;lt;optional page state 1&amp;gt;"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end transitionPageState()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 你至少需要一个页面状态值来决定是否需要执行迁移操作。如果只需要一个被所有UI区域共享的session值，并且你决定在每个区域的控制器中都使用transitionPageState()方法，则你可以在最顶层的区域的控制器（page layout region's controller）中对session值执行迁移操作并立即调用OAPageContext.putParameter()传递个额外的标识来向当前请求中的子区域表示需要的值已经存在了。子区域可以直接检查这个额外的标识（译注：而不需要再去重复执行迁移操作）。&lt;/p&gt;
&lt;h4 id="yin-cang-yu"&gt;隐藏域&lt;/h4&gt;
&lt;p&gt;隐藏域可以用于保存不应该显示于页面的应用数据，比如主键。它们不应该用于作为构建目标页面的条件而传递。这是因为当你的页面是通过另一个页面的 &lt;strong&gt;返回（Return to）&lt;/strong&gt; 导航链接来访问时，例如个性化页面时，以前的请求值是放到OAPageContext.putParameter()中的，返回导航是一个新的请求原来的参数已经不再存在了。页面状态也已经丢失，并且存储于隐藏域中的值也已经不能在下面的请求被保存。因此，应该使用上面描述的方法来代替使用隐藏域的方法。&lt;/p&gt;
&lt;h3 id="you-tiao-jian-de-jin-zhi-biao-dan-ti-jiao-dong-zuo_1"&gt;有条件的禁止表单提交动作&lt;/h3&gt;
&lt;p&gt;在某些情况下，在使用浏览后退按钮后用户不应该也不能提交表单。参见下面的&lt;a href="/adv_back_use_cases.html#general"&gt;Use Case-Specific General Standards&lt;/a&gt;指导方针对特殊情况进行处理。&lt;/p&gt;
&lt;h2&gt;使用特殊情况标准&lt;/h2&gt;
&lt;p&gt;除了上面的一般性规则，检查下面的列表看是否有相符合的特殊情况，如果有则应该遵循下面的规则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_create"&gt;只读页面单步创建&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_multistep_create"&gt;只读页面多步创建&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_delet"&gt;只读页面删除&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_update"&gt;只读单页面修改（允许迭代修改）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_single_update"&gt;只读单页面修改（允许单次修改）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#read_only_multistep_update"&gt;只读页面多步修改&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#txn_all"&gt;可修改的摘要页面（Summary）单步或多步创建或修改&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#txn_sub"&gt;可修改的摘要页面（Summary）多步创建或修改和子事务&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#txn_crossprod"&gt;摘要（Summary）和事务页面应用间（Inter-Application（Cross-Product））页面流&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#txn_inline"&gt;可修改摘要页面（Summary）或表格中的动作（复制和移除）&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只读页面&lt;a href="/adv_back_use_cases.html#ppr"&gt;PPR页面刷新&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;测试浏览器后退按钮&lt;/h2&gt;
&lt;p&gt;测试应用对浏览后退按钮的支持：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;手工按&lt;a href="{filename}adv_back_use_cases.mdl"&gt;Use Case-Specific Standards&lt;/a&gt;列表中的导航路径进行测试。除了通过后退按钮导航，也要尝试：&lt;/p&gt;
&lt;p&gt;在事务处理页面有意地输入无效的数据并执行表单提交动作以产生一个校验错误。并使用后退按钮退回摘要页面（Summary）。无效的对象不应该引起其它错误，在正确的重新输入数据后事务页面应该可以开始一个新的事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在每个页面，都选择全局的&amp;ldquo;首页&amp;rdquo;链接然后使用浏览后退按钮返回你的页面。再点击页面中的按钮或表单提交的链接。这可以检查你的页面在状态丢失时健壮性。你的页面应该能够正确的重建或显示一个客户化的用户友好的状态丢失错误对话框。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在每个页面中，选择&amp;ldquo;个性化&amp;rdquo;链接并使用个性化页面的返回链接返回你的页面。在首选项页面执行同样的操作并通过取消按钮返回你的页面。这些页面流将保存你的应用模块状态。因此，你的页面应该能够正确的重建。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>Ext学习笔记</title><link href="/extxue-xi-bi-ji.html" rel="alternate"></link><published>2008-03-19T00:00:00+08:00</published><updated>2008-03-19T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-03-19:/extxue-xi-bi-ji.html</id><summary type="html">&lt;h1&gt;基础&lt;/h1&gt;
&lt;h1&gt;Ext继承机制&lt;/h1&gt;
&lt;h1&gt;Ext对象&lt;/h1&gt;
&lt;p&gt;Ext.onReady()是Ext.EventManager.onDocumentReady()的速写方法。&lt;/p&gt;
&lt;h1&gt;布局管理&lt;/h1&gt;
&lt;h2&gt;Ext.Viewport&lt;/h2&gt;
&lt;p&gt;Ext.Viewport是一个特殊的容器它代表应用的可视区域（浏览器的Viewport）。&lt;/p&gt;
&lt;p&gt;Viewport自动将自己渲染到document.body，因此不需要要调用render方法。它在浏览器的viewport调整大小时自动调整自己的大小并管理窗口（Ext的窗口）的大小改变。&lt;/p&gt;
&lt;h2&gt;Ext.Component&lt;/h2&gt;
&lt;p&gt;Ext.Component是所有Ext组件的基类。所有Component的子类能被乍动
xtype用于标识所需要生成的组件的类型。
下面两个写法效果是一样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;viewport&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Viewport&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
        &lt;span class="nx"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'border'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
            &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;BoxComponent&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
                &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'box'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'north'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'north'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;height&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;
            &lt;span class="p"&gt;}),&lt;/span&gt;
            &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;BoxComponent …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;基础&lt;/h1&gt;
&lt;h1&gt;Ext继承机制&lt;/h1&gt;
&lt;h1&gt;Ext对象&lt;/h1&gt;
&lt;p&gt;Ext.onReady()是Ext.EventManager.onDocumentReady()的速写方法。&lt;/p&gt;
&lt;h1&gt;布局管理&lt;/h1&gt;
&lt;h2&gt;Ext.Viewport&lt;/h2&gt;
&lt;p&gt;Ext.Viewport是一个特殊的容器它代表应用的可视区域（浏览器的Viewport）。&lt;/p&gt;
&lt;p&gt;Viewport自动将自己渲染到document.body，因此不需要要调用render方法。它在浏览器的viewport调整大小时自动调整自己的大小并管理窗口（Ext的窗口）的大小改变。&lt;/p&gt;
&lt;h2&gt;Ext.Component&lt;/h2&gt;
&lt;p&gt;Ext.Component是所有Ext组件的基类。所有Component的子类能被乍动
xtype用于标识所需要生成的组件的类型。
下面两个写法效果是一样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;viewport&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Viewport&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
        &lt;span class="nx"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'border'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
            &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;BoxComponent&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
                &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'box'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'north'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'north'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;height&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;
            &lt;span class="p"&gt;}),&lt;/span&gt;
            &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;BoxComponent&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
                &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'south'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'south'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;height&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;
            &lt;span class="p"&gt;}),&lt;/span&gt;
            &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;BoxComponent&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
                &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'box'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'center'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'center'&lt;/span&gt;
            &lt;span class="p"&gt;})&lt;/span&gt;
        &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;viewport&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Viewport&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
        &lt;span class="nx"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'border'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'box'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'north'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'north'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;height&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;
            &lt;span class="p"&gt;},&lt;/span&gt;
            &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;BoxComponent&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
                &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'south'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'south'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;height&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;
            &lt;span class="p"&gt;}),&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'box'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'center'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'center'&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;其它&lt;/h1&gt;
&lt;h2&gt;ExtJS中FormPanel实现数据加载和提交&lt;/h2&gt;
&lt;p&gt;在使用使用FormPanel时我们通常需要使用它的form对象来加载数据或提交数据。FormPanel中的form对象为Ext.form.BasicForm类型的对象，它有load和submit方法分别用于加载数据和提交数据。而这两个方法都是通过调用Ext.form.BasicForm中的doAction方法来操作的。doAction方法带有两个参数，其中第二个参数为从load或submit方法传递过来的Ext.form.Action对象的配置数据（Config Options）。其中的success和failure属性是用于处理请求成功或失败的函数。但需要注意的是，文档中的说明是这个success或failure取决于Http请求过程是否出错。实际情况却并非这样，我在开发过程中发现HTTP响应代码一直都是200，但被调用的函数却一直都是failure属性对应的函数。通过查看Action.js可以发现响应过来的数据是需要符合一定格式的，Ext.form.Action.Load的API文档开头就说明了响应数据包必须类似下面的格式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;success&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;clientName&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"Fred. Olsen Lines"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;portOfLoading&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"FXT"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;portOfDischarge&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"OSL"&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个说明在我使用ExtJS的时候再次误导了我。我认为只需要响应的数据为类似的格式就可以了。结果仍然出错，查看Action.js中的handleResponse方法可以看出，返回的数据为上面代码的格式，但并不是说从服务端发送过来的数据就是这样的格式，而是需要将Ext.form.Action.Load的result属性设置成上面的格式的数据。从handleResponse也可以看出，Action.js使用了form.reader属性来处理服务端数据。这个属性也可以在初始化FormPanel的时候传递给FormPanel，FormPanel将会把这个属性传递给它内置的BasicForm对象。怎样使用JsonReader来使提取响应数据来使它满足PanelForm的要求呢？再看handleResponse中的代码，在reader存在的情况下，它返回的是所需要的格式的数据，一个包含success属性和data属性的对象，而data属性来自于JsonReader的read方法处理后的结果。再查看JsonReader.js中的read方法，它调用的是readRecords来读取数据，而返回的值是由reader的root属性决定的，从JsonReader.js中还可以看出，root属性对应的JSON对象必须是集合类型的，因此我们在后台发送过来的数据必须也是集合类型，我在这里也出了错。一直认为加载数据到Form里，一次只加载一条，所以从服务端传递过来的数据都是单个的对象，而将JsonReader对象的root设置为单个对象的名称，结果Form中一直都加载不上数据。后来将服务端传递过来的数据修改为集合数型问题解决了。&lt;/p&gt;
&lt;p&gt;小结：&lt;/p&gt;
&lt;p&gt;1.ExtJS中JsonReader对于数据的处理总是一致的，不管你需要的是单条记录还是多条记录，它总是通过total属性判断记录数，通过root属性对应的名称来取记录集合。&lt;/p&gt;
&lt;p&gt;2.FormPanel中处理数据的为内置的BasicForm类型的对象，它通过load和submit方法来加载或提交数据。而这两个方法是通过Ext.form.Action的两个子类Ext.form.Action.Load、Ext.form.Action.Submit来提交请求和调用用户的success和failure方法。决定调用success和failure的并非Http请求是否出错，而是决定于Action.js中handleResponse的处理结果。我们可以通过设置FormPanel的reader配置对象来干预handleResponse对数据的处理。而这个reader也可设置响应数据与FormPanel中字段的对应关系。&lt;/p&gt;
&lt;p&gt;3.多看源码，可以获取更多。&lt;/p&gt;
&lt;p&gt;附：&lt;/p&gt;
&lt;p&gt;表格中双击进行编辑的JS源码，这个代码比官方文档中的处理方式简单一些，觉得官方文档中的edit中加载数据的处理是一种hack的方式，并不太适合实际应用。&lt;/p&gt;
&lt;p&gt;[[http://extjs.com/learn/Tutorial:Using_Ext_grid_form_dialog_to_achieve_paging_list,_create,_edit,_delete_function][ExtJS网站上的CRUD的文章，其中包含有加载数据进行编辑的例子]]&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;onReady&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;newFormWin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;form1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//表格处理&lt;/span&gt;
    &lt;span class="c1"&gt;//Ext.BLANK_IMAGE_URL = 'extjs/resources/images/default/s.gif';&lt;/span&gt;
    &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;QuickTips&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;sm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;CheckboxSelectionModel&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//CheckBox选择列&lt;/span&gt;

    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;cm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ColumnModel&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;
        &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;RowNumberer&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;//行号列&lt;/span&gt;
        &lt;span class="nx"&gt;sm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;header&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'编号'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;dataIndex&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'id'&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;header&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'性别'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;dataIndex&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'sex'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;renderer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s1"&gt;'1'&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;"男"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;"女"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}},&lt;/span&gt; &lt;span class="c1"&gt;//增加性别，自定义renderer，即显示的样式，可以加html代码，来显示图片等。&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;header&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'名称'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;dataIndex&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;header&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'描述'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;dataIndex&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'memo'&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;ds&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Store&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
        &lt;span class="nx"&gt;proxy&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;HttpProxy&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;url&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;ACTION_URL&lt;/span&gt;&lt;span class="p"&gt;}),&lt;/span&gt;&lt;span class="c1"&gt;//调用的动作&lt;/span&gt;
        &lt;span class="nx"&gt;reader&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;JsonReader&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
            &lt;span class="nx"&gt;totalProperty&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'total'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;root&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'list'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;successProperty&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'success'&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
                                        &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'id'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;mapping&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'id'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'string'&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                                         &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'sex'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;mapping&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'sex'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'string'&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                                         &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;mapping&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'name'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'string'&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                                         &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'memo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;mapping&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'memo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'string'&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;//列的映射&lt;/span&gt;
                                        &lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;


    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;grid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;GridPanel&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
        &lt;span class="nx"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'grid'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'center'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'center'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'用户'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;ds&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;sm&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;sm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;cm&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;cm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;bbar&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;PagingToolbar&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
            &lt;span class="nx"&gt;pageSize&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;store&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;displayInfo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;displayMsg&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'显示第 {0} 条到 {1} 条记录，一共 {2} 条'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;emptyMsg&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"没有记录"&lt;/span&gt;
        &lt;span class="p"&gt;})&lt;/span&gt; &lt;span class="c1"&gt;//页脚显示分页&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;


    &lt;span class="c1"&gt;//布局处理&lt;/span&gt;
    &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;state&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Manager&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;setProvider&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;state&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;CookieProvider&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Viewport&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
        &lt;span class="nx"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'border'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;items&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;xtype&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'box'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'north'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;el&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'north'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;height&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'north'&lt;/span&gt;
            &lt;span class="p"&gt;},{&lt;/span&gt;
                &lt;span class="nx"&gt;region&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'south'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;contentEl&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'south'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;split&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;height&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;minSize&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;maxSize&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;collapsible&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'South'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;margins&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'0 0 0 0'&lt;/span&gt;
            &lt;span class="p"&gt;},&lt;/span&gt;
            &lt;span class="nx"&gt;grid&lt;/span&gt;
        &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;

    &lt;span class="c1"&gt;//el:指定html元素用于显示grid&lt;/span&gt;
    &lt;span class="nx"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;render&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//Ext.getCmp('grid').render();//渲染表格&lt;/span&gt;
    &lt;span class="nx"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;load&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;params&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;start&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;limit&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;}});&lt;/span&gt; &lt;span class="c1"&gt;//加载数据&lt;/span&gt;

    &lt;span class="nx"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"rowdblclick"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;loadFormData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;//alert(form1.reader);&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;

    &lt;span class="c1"&gt;// 载入被选择的数据行的表单数据&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;loadFormData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;_record&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;grid&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getSelectionModel&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="nx"&gt;getSelected&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nx"&gt;_record&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'修改操作'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'请选择要修改的一项！'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;myFormWin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="nx"&gt;form1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;form&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;url&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;EDIT_ACTION_URL&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s1"&gt;'?sid='&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;_record&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'id'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                &lt;span class="nx"&gt;waitMsg&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'正在载入数据...'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;success&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;form&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;action&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'编辑'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'载入成功！'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;},&lt;/span&gt;
                &lt;span class="nx"&gt;failure&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;form&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;action&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'编辑'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'载入失败'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;});&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;




    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;myFormWin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// create the window on the first click and reuse on subsequent&lt;/span&gt;
        &lt;span class="c1"&gt;// clicks&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="nx"&gt;newFormWin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;newFormWin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Window&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;el&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'topic-win'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;layout&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'fit'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;width&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;height&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;closeAction&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'hide'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;plain&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;title&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'窗口'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;items&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;form1&lt;/span&gt;
            &lt;span class="p"&gt;});&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nx"&gt;newFormWin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'New1'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;



    &lt;span class="nx"&gt;form1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;FormPanel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// collapsible : true,// 是否可以展开&lt;/span&gt;
        &lt;span class="nx"&gt;labelWidth&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;75&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// label settings here cascade unless overridden&lt;/span&gt;
        &lt;span class="nx"&gt;url&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'AddLevel.action'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;title&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'修改'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;bodyStyle&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'padding:5px 5px 0'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;width&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;350&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;waitMsgTarget&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="c1"&gt;//这个属性决定了load和submit中对数据的处理，list必须是一个集合类型，json格式应该是[]包含的一个数组&lt;/span&gt;
        &lt;span class="nx"&gt;reader&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;JsonReader&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;root&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'list'&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                                        &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'id'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;mapping&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'id'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'string'&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                                         &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'sex'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;mapping&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'sex'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'string'&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                                         &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'memo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;mapping&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'memo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s1"&gt;'string'&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
                                        &lt;span class="p"&gt;]),&lt;/span&gt;
        &lt;span class="nx"&gt;defaults&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;width&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;230&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt;
        &lt;span class="nx"&gt;defaultType&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'textfield'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nx"&gt;items&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;fieldLabel&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'编号'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'id'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;allowBlank&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;fieldLabel&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'性别'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'sex'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;allowBlank&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;form&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;TextArea&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;fieldLabel&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'备注'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'memo'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;growMin&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;234&lt;/span&gt;
        &lt;span class="p"&gt;})],&lt;/span&gt;

        &lt;span class="nx"&gt;buttons&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;text&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'保存'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;disabled&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;handler&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;form1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;form&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;isValid&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="nx"&gt;form1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;form&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;submit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="nx"&gt;url&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'AddLevel.action'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="nx"&gt;success&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;from&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;action&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                            &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'保存成功'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'添加级别成功！'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                            &lt;span class="nx"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                                &lt;span class="nx"&gt;params&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                                    &lt;span class="nx"&gt;start&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                    &lt;span class="nx"&gt;limit&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                    &lt;span class="nx"&gt;forumId&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
                                &lt;span class="p"&gt;}&lt;/span&gt;
                            &lt;span class="p"&gt;});&lt;/span&gt;
                        &lt;span class="p"&gt;},&lt;/span&gt;
                        &lt;span class="nx"&gt;failure&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;form&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;action&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                            &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'保存失败'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'添加级别失败！'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                        &lt;span class="p"&gt;},&lt;/span&gt;
                        &lt;span class="nx"&gt;waitMsg&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'正在保存数据，稍后...'&lt;/span&gt;
                    &lt;span class="p"&gt;});&lt;/span&gt;
                    &lt;span class="nx"&gt;dialog&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;hide&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="nx"&gt;Ext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'信息'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'请填写完成再提交!'&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;text&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'取消'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;handler&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;newFormWin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;hide&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}]&lt;/span&gt;
    &lt;span class="p"&gt;});&lt;/span&gt;



&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="extjs"></category><category term="javascript"></category></entry><entry><title>Xah的Emacs Lisp 教程学习笔记</title><link href="/xahde-emacs-lisp-jiao-cheng-xue-xi-bi-ji.html" rel="alternate"></link><published>2008-03-10T00:00:00+08:00</published><updated>2008-03-10T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-03-10:/xahde-emacs-lisp-jiao-cheng-xue-xi-bi-ji.html</id><summary type="html">&lt;h1&gt;例子&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-open-directory-with-explorer&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"在windows中用explorer浏览当前目录"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;shell-command&lt;/span&gt; &lt;span class="s"&gt;"explorer.exe ."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;browse-url&lt;/span&gt; &lt;span class="s"&gt;"www.google.cn"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-display-directory-files&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"执行shell命令并处理它的输出。这里为显示当前目录下的文件"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;shell-command-to-string&lt;/span&gt; &lt;span class="s"&gt;"ls -l"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-display-current-major-mode&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"如果当前为emacs-lisp-mode则显示当前主模式"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="ss"&gt;'emacs-lisp-mode&lt;/span&gt; &lt;span class="nv"&gt;major-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"emacs-lisp-mode"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-regexp-match&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"正则表达式匹配"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;test-string&lt;/span&gt; &lt;span class="s"&gt;"aaaaaaaaaaaa123sfdsfs456"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;regexp-string&lt;/span&gt; &lt;span class="s"&gt;"\\([0-9]+\\)[a-z]+\\([0-9]+\\)"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-match&lt;/span&gt; &lt;span class="nv"&gt;regexp-string&lt;/span&gt; &lt;span class="nv"&gt;test-string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;match-string&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;test-string …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;例子&lt;/h1&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-open-directory-with-explorer&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"在windows中用explorer浏览当前目录"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;shell-command&lt;/span&gt; &lt;span class="s"&gt;"explorer.exe ."&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;browse-url&lt;/span&gt; &lt;span class="s"&gt;"www.google.cn"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-display-directory-files&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"执行shell命令并处理它的输出。这里为显示当前目录下的文件"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;shell-command-to-string&lt;/span&gt; &lt;span class="s"&gt;"ls -l"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-display-current-major-mode&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"如果当前为emacs-lisp-mode则显示当前主模式"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;eq&lt;/span&gt; &lt;span class="ss"&gt;'emacs-lisp-mode&lt;/span&gt; &lt;span class="nv"&gt;major-mode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="s"&gt;"emacs-lisp-mode"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-regexp-match&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"正则表达式匹配"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nv"&gt;test-string&lt;/span&gt; &lt;span class="s"&gt;"aaaaaaaaaaaa123sfdsfs456"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;regexp-string&lt;/span&gt; &lt;span class="s"&gt;"\\([0-9]+\\)[a-z]+\\([0-9]+\\)"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;string-match&lt;/span&gt; &lt;span class="nv"&gt;regexp-string&lt;/span&gt; &lt;span class="nv"&gt;test-string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;concat&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;match-string&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nv"&gt;test-string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;"--"&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;match-string&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nv"&gt;test-string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;dos2unix&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;file-path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"dos换行转unix换行"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;mybuffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;mybuffer&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;find-file&lt;/span&gt; &lt;span class="nv"&gt;file-path&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;replace-string&lt;/span&gt; &lt;span class="s"&gt;"\r\n"&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;1+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;buffer-size&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;save-buffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;kill-buffer&lt;/span&gt; &lt;span class="nv"&gt;mybuffer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-insert-p&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"在光标位置插入&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;backward-char&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-wrap-paragraph&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"在区域前后加&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;insert&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;/p&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;inster&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;p&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-replace-html-chars-in-region&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="s"&gt;"将特殊字符转成html中的符号"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt; &lt;span class="s"&gt;"r"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;save-restriction&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;narrow-to-region&lt;/span&gt; &lt;span class="nv"&gt;start&lt;/span&gt; &lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;replace-match&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;replace-match&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;goto-char&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;point-min&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;search-forward&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="nf"&gt;replace-match&lt;/span&gt; &lt;span class="s"&gt;"&amp;amp;amp;"&lt;/span&gt; &lt;span class="no"&gt;nil&lt;/span&gt; &lt;span class="no"&gt;t&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;defun&lt;/span&gt; &lt;span class="nv"&gt;zj-hash-test&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="s"&gt;"hash table 测试"&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;interactive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;let&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;myhash&lt;/span&gt; &lt;span class="nv"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;;; 创建hash table并告诉elips用equal来测试key是否存在&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;make-hash-table&lt;/span&gt; &lt;span class="nb"&gt;:test&lt;/span&gt; &lt;span class="ss"&gt;'equal&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="c1"&gt;;; 添加数据&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;puthash&lt;/span&gt; &lt;span class="s"&gt;"mary"&lt;/span&gt; &lt;span class="s"&gt;"19"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;puthash&lt;/span&gt; &lt;span class="s"&gt;"jane"&lt;/span&gt; &lt;span class="s"&gt;"19"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;puthash&lt;/span&gt; &lt;span class="s"&gt;"liz"&lt;/span&gt; &lt;span class="s"&gt;"19"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;puthash&lt;/span&gt; &lt;span class="s"&gt;"zj"&lt;/span&gt; &lt;span class="s"&gt;"19"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


    &lt;span class="c1"&gt;;; 修改数据&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;puthash&lt;/span&gt; &lt;span class="s"&gt;"zj"&lt;/span&gt; &lt;span class="s"&gt;"27"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;;; 删除数据&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;remhash&lt;/span&gt; &lt;span class="s"&gt;"liz"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;;; 获取数据&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;setq&lt;/span&gt; &lt;span class="nv"&gt;val&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;gethash&lt;/span&gt; &lt;span class="s"&gt;"zj"&lt;/span&gt; &lt;span class="nv"&gt;myhash&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;message&lt;/span&gt; &lt;span class="nv"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="emacs"></category></entry><entry><title>Linux内核设备驱动第三版读书笔记</title><link href="/linuxnei-he-she-bei-qu-dong-di-san-ban-du-shu-bi-ji.html" rel="alternate"></link><published>2008-01-17T00:00:00+08:00</published><updated>2008-01-17T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2008-01-17:/linuxnei-he-she-bei-qu-dong-di-san-ban-du-shu-bi-ji.html</id><summary type="html">&lt;h1&gt;Chap 2 构建和运行内核&lt;/h1&gt;
&lt;h2&gt;设置测试系统&lt;/h2&gt;
&lt;p&gt;书中的例子以Kernel 2.6.x为基础（2.6.10）。&lt;/p&gt;
&lt;h2&gt;Hello World模块&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;linux/init.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;linux/module.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;MODULE_LICENSE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Dual BSD/GPL"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;hello_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KERN_ALERT&lt;/span&gt; &lt;span class="s"&gt;"Hello, world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;hello_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KERN_ALERT&lt;/span&gt; &lt;span class="s"&gt;"Goodbye, cruel world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;module_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello_init&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;module_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello_exit …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;Chap 2 构建和运行内核&lt;/h1&gt;
&lt;h2&gt;设置测试系统&lt;/h2&gt;
&lt;p&gt;书中的例子以Kernel 2.6.x为基础（2.6.10）。&lt;/p&gt;
&lt;h2&gt;Hello World模块&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;linux/init.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;linux/module.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;MODULE_LICENSE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Dual BSD/GPL"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;hello_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KERN_ALERT&lt;/span&gt; &lt;span class="s"&gt;"Hello, world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;hello_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;KERN_ALERT&lt;/span&gt; &lt;span class="s"&gt;"Goodbye, cruel world&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;module_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello_init&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;module_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello_exit&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个模块包含两个函数，一个在模块被加载到内核时时被调用（hello_init），一个在模块被移除时被调用（hello_exit）。module_init和module_exit这两行使用了特殊的内核宏来标明两个行数所扮演的角色。另一个特殊的宏（MODULE_LICENSE）用于告诉内核这个模块具有自由的许可；如果没有这个申明，内核将在模块加载时发出警告。&lt;/p&gt;
&lt;p&gt;printk函数定义于Linux内核中并对模块有效；它的作用类似标准C库中的printf函数。内核需要自己的打印函数，因为它独立运行，没有C库的辅助。模块可以调用printk，因为在insmod加载它之后，模块被链接到内核并可以访问内核所公开的符号（函数和变量）。字符串KERN_ALERT是消息的优先级。在这个模块中我们指定了一个高的优先级，因为消息在默认优先级下可能显示不出来，这依赖于你运行的内核版本，klogd守护进程的版本和你的配置。&lt;/p&gt;
&lt;p&gt;可以使用insmod和rmmod工具来测试模块。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;% make&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Entering&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt; `&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;2.6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;
&lt;span class="n"&gt;CC&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ldd3&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;misc&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;
&lt;span class="n"&gt;Building&lt;/span&gt; &lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stage&lt;/span&gt; &lt;span class="mf"&gt;2.&lt;/span&gt;
&lt;span class="n"&gt;MODPOST&lt;/span&gt;
&lt;span class="n"&gt;CC&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ldd3&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;misc&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;mod&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;
&lt;span class="n"&gt;LD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ldd3&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;misc&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ko&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Leaving&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt; `&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;2.6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;'&lt;/span&gt;
&lt;span class="c"&gt;% su&lt;/span&gt;
&lt;span class="n"&gt;root&lt;/span&gt;# &lt;span class="n"&gt;insmod&lt;/span&gt; &lt;span class="o"&gt;./&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ko&lt;/span&gt;
&lt;span class="n"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;world&lt;/span&gt;
&lt;span class="n"&gt;root&lt;/span&gt;# &lt;span class="n"&gt;rmmod&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;
&lt;span class="n"&gt;Goodbye&lt;/span&gt; &lt;span class="n"&gt;cruel&lt;/span&gt; &lt;span class="n"&gt;world&lt;/span&gt;
&lt;span class="n"&gt;root&lt;/span&gt;#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为使上面的命令能执行，你必须有一个适当的配置，并且内核树在makefile可以找到的地方（这里是/usr/src/linux-2.6.10）。&lt;/p&gt;
&lt;p&gt;根据你的系统投递消息行的机制不同，你的输出也可能不同。特别是上面的屏幕输出是来自于文本终端；如果你在window系统下的模块终端中运行insmod和rmmod，你可能看不到任何东西。消息可以被发送到某个系统日志文件，比如/var/log/messages（各发行版本不同）。内核消息投递机制在Chap4详述。&lt;/p&gt;
&lt;h2&gt;内核模块与应用的差异&lt;/h2&gt;
&lt;p&gt;多数中小型程序从头至尾执行一个单一的任务，每个内核模块只是注册自己为以后的请求提供服务，它的初始化函数将立即结束。换言之，模块的初始化函数是为将来调用模块的函数作准备的；就好像模块在说&amp;ldquo;我在这里，这是我可以做的。&amp;rdquo;。模块的退出函数（例中的hello_exit）函数在模块被卸载之前被调用。它告诉模块&amp;ldquo;我不存在了；不要再要求我做任何事情。&amp;rdquo;这类似于事件驱动程序，并非所有应用程序都是事件驱动的，但每个内核模块都是的。事件驱动的应用程序和内核代码另一个主要不同的是退出函数：应用程序结束时可以延时来释放资源或做清除操作，内核模块则必须小心撤销init函数设置的所有东西，或保留一小块直到系统被重新启动。&lt;/p&gt;
&lt;p&gt;另外，内核模块卸载的能力是模块化的一个功能，可以节约开发时间，可以测试不同版本的驱动而不用重启机器。&lt;/p&gt;
&lt;p&gt;应用程序中通过链接阶段来解决对外部函数库的引用。比如printf就定义在libc中。内核模块只能链接内核；不能链接库。比如printk函数，就像printf的内核内部的版本被导出到模块中。它表现得像printf函数，只有少量的不同，主要的一个就是缺乏浮点支持。&lt;/p&gt;</content><category term="linux"></category></entry><entry><title>Programming Perl笔记</title><link href="/programming-perlbi-ji.html" rel="alternate"></link><published>2007-12-02T00:00:00+08:00</published><updated>2007-12-02T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-12-02:/programming-perlbi-ji.html</id><summary type="html">&lt;h1&gt;OverView&lt;/h1&gt;
&lt;h2&gt;自然的人工语言&lt;/h2&gt;
&lt;h3 id="bian-liang-yu-fa"&gt;变量语法&lt;/h3&gt;
&lt;p&gt;变量类型&lt;/p&gt;
&lt;p&gt;类型 || 字符 || 例子 || 说明
标量 | $ | $cents | 单个的值（数字或字符串）
数组 | @ | @large | 值列表，键为数字
哈希表 | % | %interest | 一组值，键为字符串
子程序 | &amp;amp; | &amp;amp;how | 一块可被调用的代码
glob | &lt;code&gt;&lt;em&gt;&lt;/em&gt;&lt;/code&gt; | &lt;code&gt;&lt;/code&gt;&lt;/p&gt;struck | 所有被命名为struck的东西
&lt;h3 id="bian-liang-fu-zhi"&gt;变量赋值&lt;/h3&gt;
&lt;h4 id="dan-yi-bian-liang"&gt;单一变量&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$answer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;# 一个整数&lt;/span&gt;
&lt;span class="nv"&gt;$pi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.14159265&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;# 一个实数&lt;/span&gt;
&lt;span class="nv"&gt;$avocados&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;6.02e23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;# 科学计数法&lt;/span&gt;
&lt;span class="nv"&gt;$pet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Camel"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;# 字符串&lt;/span&gt;
&lt;span class="nv"&gt;$sign&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"I love my $pet"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 带插值的字符串&lt;/span&gt;
&lt;span class="nv"&gt;$cost&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'It …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;OverView&lt;/h1&gt;
&lt;h2&gt;自然的人工语言&lt;/h2&gt;
&lt;h3 id="bian-liang-yu-fa"&gt;变量语法&lt;/h3&gt;
&lt;p&gt;变量类型&lt;/p&gt;
&lt;p&gt;类型 || 字符 || 例子 || 说明
标量 | $ | $cents | 单个的值（数字或字符串）
数组 | @ | @large | 值列表，键为数字
哈希表 | % | %interest | 一组值，键为字符串
子程序 | &amp;amp; | &amp;amp;how | 一块可被调用的代码
glob | &lt;code&gt;&lt;em&gt;&lt;/em&gt;&lt;/code&gt; | &lt;code&gt;&lt;/code&gt;&lt;/p&gt;struck | 所有被命名为struck的东西
&lt;h3 id="bian-liang-fu-zhi"&gt;变量赋值&lt;/h3&gt;
&lt;h4 id="dan-yi-bian-liang"&gt;单一变量&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$answer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;# 一个整数&lt;/span&gt;
&lt;span class="nv"&gt;$pi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;3.14159265&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;# 一个实数&lt;/span&gt;
&lt;span class="nv"&gt;$avocados&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;6.02e23&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="c1"&gt;# 科学计数法&lt;/span&gt;
&lt;span class="nv"&gt;$pet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Camel"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;# 字符串&lt;/span&gt;
&lt;span class="nv"&gt;$sign&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"I love my $pet"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 带插值的字符串&lt;/span&gt;
&lt;span class="nv"&gt;$cost&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'It costs $100'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;# 无插值的字符串&lt;/span&gt;
&lt;span class="nv"&gt;$thence&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$whence&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;# 另一个变量的值&lt;/span&gt;
&lt;span class="nv"&gt;$salsa&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$moles&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nv"&gt;$avocados&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;# 表达式&lt;/span&gt;
&lt;span class="nv"&gt;$exit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"vi $file"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;# 命令返回的数字值&lt;/span&gt;
&lt;span class="nv"&gt;$cwd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sb"&gt;`pwd`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;# 命令输出的字符串&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标量也可以引用其它数据结构，包括子程序和对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$ary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;@myarray&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            &lt;span class="c1"&gt;# 一个命名数组的引用&lt;/span&gt;
&lt;span class="nv"&gt;$hsh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="nv"&gt;%myhash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;# 一个命名哈希的引用&lt;/span&gt;
&lt;span class="nv"&gt;$sub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;\&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mysub&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;              &lt;span class="c1"&gt;# 一个命名子程序的引用&lt;/span&gt;

&lt;span class="nv"&gt;$ary&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;          &lt;span class="c1"&gt;# 未命名数组的引用&lt;/span&gt;
&lt;span class="nv"&gt;$hsh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Na&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Cl&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;# 未命名哈希的引用&lt;/span&gt;
&lt;span class="nv"&gt;$sub&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;sub&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nv"&gt;$state&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;# 未命名的子程序&lt;/span&gt;

&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Camel&lt;/span&gt; &lt;span class="s"&gt;"Amelia"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 对象的引用&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果使用了一个未被赋值过的变量，这个未初始化过的变量将自动按需要产生。根据最小惊讶原则，变量创建时可能带的null值，或""或0，依赖于你在什么地方使用它们，变量将被自动解释为字符串，数字或"true"和"false"（布尔变量）。在人类语言中语言环境相当重要。在Perl中，多个操作符希望某一类厅异值作为参数。有时将更具体，将这些参数称作数字环境，字符串环境，或布尔环境。（后面也将谈及列表环境，它与标量环境是相对应的。）Perl将自根据当前环境的需要将数据进行转换。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$camels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;'123'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nv"&gt;$camels&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;$camels的初始值是一个字符串，但它被转换成数字后加1，然后转换回字符串被输出为124。"\n"换行符也处于字符串环境中，但由于它已经是一个字符串了，因此不需要转换。但主注意我们在它上面使用了双引号&amp;mdash;&amp;mdash;使用单引号的'\n'将产生包含两个字符的字符串，内容为斜线和&amp;ldquo;n&amp;rdquo;，它不是一个换行符。&lt;/p&gt;
&lt;p&gt;因此，在某种意义上来说，双引号和单引号也是另一种特殊的环境。对引号内的字符串的解释取决于你使用的引号类型。（双引号环境是Perl中的&amp;ldquo;内插（interpolative）&amp;rdquo;环境，它也被许多其它的与双引号不同的操作符支持。&lt;/p&gt;
&lt;p&gt;类似地，当你给引用一个&amp;ldquo;解除引用（dereference）&amp;rdquo;环境时表示得像引用，但另一方面又表现得像一个标量。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Camel&lt;/span&gt; &lt;span class="s"&gt;"Amelia"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="nv"&gt;$fido&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nb"&gt;die&lt;/span&gt; &lt;span class="s"&gt;"dead camel"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nv"&gt;$fido&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;saddle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里创建了一个Camel对象的引用并把它赋给变量&lt;span class="math"&gt;\(fido。在下一行，我们把\)&lt;/span&gt;fido作为一个布尔型的标量来检查它是否为&amp;ldquo;true&amp;rdquo;，如果不为true抛出异常。但在最后一行，我们把&lt;span class="math"&gt;\(fido作为一个引用，并要求它在\)&lt;/span&gt;fido中持有的对象中查找saddle()方法，这发生在Camel类，因此Perl在Camel对象上查找saddle()方法。&lt;/p&gt;
&lt;h4 id="fu-shu-bian-liang"&gt;复数变量&lt;/h4&gt;
&lt;p&gt;某些类型的变量持有逻辑上配合在一起的多个值。Perl有两种多值变量：数组和哈希。有些情况下，这些行为像标量&amp;mdash;&amp;mdash;比如，他们在需要时被自动创建。但它们与标量不同，当你给它们赋值时，它们为右值提供了一个列表（list）环境而不是一个标量环境。&lt;/p&gt;
&lt;p&gt;数组和哈布之间也不同。你需要使用数字来查找时应该使用数组。需要通过名称来查找时使用哈希。这是两个补充概念。&lt;/p&gt;
&lt;h5 id="shu-zu"&gt;数组&lt;/h5&gt;
&lt;p&gt;数组是一个标量的列表，通过标量在列表中的位置来访问。列表中可以包含数字，字符串，或两者都有。（它也可以包含子数组或子哈希的引用）给数组赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;@home&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"couch"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"chair"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"table"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"stove"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;反过来，你在列表环境中使用@home，比如在列表赋值的右边，你将得到同样的值。因此你可以像下面这样从数组中设置四个标量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$potato&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$lift&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$tennis&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$pipe&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;@home&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这被称为列表赋值。理论上它们是并行发生的，因此你可以像下面这样交换变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$alpha&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;$omega&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$omega&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;$alpha&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与C里一样，数组下标从0开始，通过方括号访问。因为处理的元素是标量，因此你需要在前面加$。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$home&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"couch"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$home&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"chair"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$home&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"table"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$home&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"stove"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于数组是有序的，你可以在上面做更多复杂的操作，比如作为堆栈执行push和pop操作。毕竟堆栈也只是一个有序的列表，有一个开始的结束。特别是结束。Perl把数组的结束作为栈顶。（尽管多数Perl程序员把数组当作是水平的，栈顶在右边。）&lt;/p&gt;
&lt;h5 id="ha-xi"&gt;哈希&lt;/h5&gt;
&lt;p&gt;哈希是一组无序标量的集合，通过关联到每个标量的字符串值来访问。由于这个原因哈希经常被叫作关联数组。
由于哈希中的key不能由它们的位置自动提供，你必须提供key。你可以像数组一样提供一个列表给哈希，但列表中的项将作为键值对分割。哈希使用%来标识。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;%longday&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Sun"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Sunday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Mon"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Monday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Tue"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Tuesday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;"Wed"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Wednesday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Thu"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Thursday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Fri"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;"Friday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Sat"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Saturday"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这难于阅读perl提供了=&amp;gt;，使得更容易区分哈希中的键和值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;%longday&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;"Sun"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Sunday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Mon"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Monday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Tue"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Tuesday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Wed"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Wednesday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Thu"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Thursday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Fri"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Friday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;"Sat"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s"&gt;"Saturday"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哈希的排序，可以使用keys函数获取哈希的key列表然后用sort函数进行排序。&lt;/p&gt;
&lt;p&gt;由于哈希是一种奇怪的数组，你必须使用大括号来选择其中的元素。需要再次注意的是你处理的元素是标量，因此应该在它的前面使用$而不是%。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Adam"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Eve"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="fu-za-shu-ju-jie-gou_1"&gt;复杂数据结构&lt;/h4&gt;
&lt;p&gt;在hash元素中保存list时等号右边应该使用方括号，因为在Perl中小括号和其中逗号不足以将list保存到标量中（小括号用于分组，逗号用于分隔）。下面的写法是错误的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Rachel"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Bilhah"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Zilpah"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;# WRONG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正确写法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Rachel"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Bilhah"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Zilpah"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;        &lt;span class="c1"&gt;# ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个语句创建了一个未命名的array并将它的引用放到hash元素&lt;code&gt;$wife{"Jacob"}&lt;/code&gt;中。这种方式也是Perl处理多维数组和嵌套数据结构的方式。与使用普通array和hash一样，也可以按下面的方式赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Rachel"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Bilhah"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Zilpah"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哈希中的元素为另一个哈希，而这个哈希中的元素为数组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;"Leah"&lt;/span&gt;   &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Reuben"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Simeon"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Levi"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Judah"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Issachar"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Zebulun"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s"&gt;"Rachel"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Joseph"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Benjamin"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s"&gt;"Bilhah"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Dan"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Naphtali"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="s"&gt;"Zilpah"&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"Gad"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"Asher"&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它比下面的方式简洁多了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Reuben"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Simeon"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Levi"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Judah"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Issachar"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Leah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Zebulun"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Rachel"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Joseph"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Rachel"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Benjamin"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Bilhah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Dan"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Bilhah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Naphtali"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Zilpah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Gad"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$kids_of_wife&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;"Jacob"&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="s"&gt;"Zilpah"&lt;/span&gt;&lt;span class="p"&gt;}[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"Asher"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以使用这种方式添加更多的层，但在内部的描述方式是一样的。&lt;/p&gt;
&lt;p&gt;在这里最重要的一点是Perl允许你将复杂的数据结构描述为一个简单的标量。通过这种简单的封装，Perl构建了面向对象结构。例如前面调用的Camel构造器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Camel&lt;/span&gt; &lt;span class="s"&gt;"Amelia"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们创建了一个Camel对象它被描述为一个标量$fido。但在Camel的内部它更复杂一些。对于面向对象的程序员，我们不需要了解Camel的内部（除非我们是实现Camel类方法的人）。但通常，类似Camel的类是由一个包含Camel的各个属性的hash构成，比如它的名称（在这里是&amp;rdquo;Amelia"，而不是&amp;ldquo;fido&amp;rdquo;），和hump（驼峰）的数量。&lt;/p&gt;
&lt;h4 id="jian-dan-shu-ju-jie-gou"&gt;简单数据结构&lt;/h4&gt;
&lt;p&gt;与真实的语言环境中单词依据不同的环境有不同的含义一样。Perl使用了多种方式来标明当前的环境。其中一个重要的局部环境申明就是package。假设你要在Perl中谈论Camel。你可以这样开始你的模块：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;Camel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将产生多个值得注意的影响。其一就是Perl将假定从这个点开始任何未指明的动词或名词都是关于Camel的。它将自动为任何全局名称前面添加模块名作为前缀&amp;ldquo;Camel::&amp;rdquo;。因此代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;Camel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;fetch&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样&lt;span class="math"&gt;\(fido的真实名称为\)&lt;/span&gt;Camel::fido（&amp;amp;fetch的真实名称为&amp;amp;Camel::fetch，但我们先不谈论动词）。这表示如果另一个模块为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;package&lt;/span&gt; &lt;span class="nn"&gt;Dog&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;fetch&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perl不会迷惑，因为&lt;span class="math"&gt;\(fido的真实名称为\)&lt;/span&gt;Dog::fido，而不是$Camel::fido。包只是建立了一个命名空间。你可以创建任意多个命名空间，但由于同一时间只处于其中一个，你可以假设其它命名空间不存在。这种简单是基于假设的。（当然，这过于简单化了，这只是我们在这章所做的。）&lt;/p&gt;
&lt;p&gt;命名空间使得&amp;amp;Camel::fetch和&amp;amp;Dog::fetch不会迷惑，但包真正好的地方在于它对你的动作进行了分类以便其它包使用它们。当我们说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Camel&lt;/span&gt; &lt;span class="s"&gt;"Amelia"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们实际调用了Camel包的&amp;amp;new动作，它的全名为&amp;amp;Camel:new。前面所说的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$fido&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;saddle&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的是&amp;amp;Camel::saddle子程序，因为$dido知道它指向的是Camel类型的数据。这就是面向对象编程的工作方式。&lt;/p&gt;
&lt;p&gt;使用已经存在的包时，使用&lt;code&gt;use&lt;/code&gt;申明，这不仅是为了调用另一个包中的动作，也将检查那个模块是否已经从磁盘加载过了。实际上，你必须在使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$fido&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Camel&lt;/span&gt; &lt;span class="s"&gt;"Amelia"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前，使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;Camel&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;否则，Perl不知道Camel的定义。&lt;/p&gt;
&lt;p&gt;事实上一些内置模块不需要实际引入它们的动词。这些特殊模块被称为&lt;code&gt;pragmas&lt;/code&gt;。比如，你经常可以看到人们使用&lt;code&gt;strict&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="nn"&gt;strict&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;strict模块将使Perl加强对程序的检查，你对一些事务必须更加显式的指定，比如变量的作用范围等。这对于大型项目是很有帮助的。默认情况下Perl为小型项目而优化，但使用strict模块，Perl也能用于需要更多可维护性的大项目。&lt;/p&gt;
&lt;h3 id="dong-ci_1"&gt;动词&lt;/h3&gt;
&lt;p&gt;与其它命令式计算机语言一样，Perl中的动作是命令：它们告诉Perl解释器做什么。另一方面与自然语言一样，Perl动词的含义也依赖于具体的环境。以动词开头的语句通常是纯命令，被整个执行。（有时称这些动词为子程序，特别是当他们是用户定义的时候。）一个常用的内置命令是print命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"Adam's wif is $wife{'Adam'}.\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将产生下面输出：
&lt;example&gt;
Adam's wife is Eve.
&lt;/example&gt;
但在某些祈使语句内包含有&amp;rdquo;语气&amp;ldquo;。一些动词是用于提问的，对于条件语句非常有用，比如if语句。其它动词将它们的输入参数轮换为返回值，我们称这些动词为函数。&lt;/p&gt;
&lt;p&gt;比如内置的exp函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$e&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;exp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;# 2.718281828459 or thereabouts&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但Perl中子程序和函数没有明确区别。动词有时也被称作操作符（当内置时），或子过程。可以按你的喜好来叫&amp;mdash;&amp;mdash;他们都返回一个值，它可能是一个没有意义的值，你可以或使用或忽略它。&lt;/p&gt;
&lt;p&gt;历史上的，Perl需要在任何用户定义的子过程前面加一个&lt;code&gt;&amp;amp;&lt;/code&gt;符号。但从Perl 5开始，&amp;amp;符号变为可选项，因此用户定义的动词与内置动词有相同的语法。当我们谈论子程序的名称时，我们仍将使用&amp;amp;符号，比如当我们获取它的引用时（$fetcher = \&amp;amp;fetch;）。从语言上来说，你可以把&amp;amp;符号当作不定词，&amp;ldquo;to fetch&amp;ldquo;或类似&amp;rdquo;do fetch&amp;ldquo;。但我们说&amp;rdquo;do fetch&amp;ldquo;时我们可以只说&amp;rdquo;fetch&amp;ldquo;。这也是我们在Perl5中抛弃强制使用&amp;amp;符号的实际原因。&lt;/p&gt;
&lt;h2&gt;一个求平均值的例子&lt;/h2&gt;
&lt;p&gt;这个例子用于求数据平均值，数据：
&lt;example&gt;
No&amp;euml;l 25
Ben 76
Clementine 49
Norm 66
Chris 92
Doug 42
Carol 25
Ben 12
Clementine 0
Norm 66
...
&lt;/example&gt;
它保存于名为grades的文件中。&lt;/p&gt;
&lt;p&gt;程序如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;  &lt;span class="c1"&gt;#!/usr/bin/perl&lt;/span&gt;
 &lt;span class="mi"&gt;2&lt;/span&gt;  
 &lt;span class="mi"&gt;3&lt;/span&gt;  &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GRADES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"grades"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="nb"&gt;die&lt;/span&gt; &lt;span class="s"&gt;"Can't open grades: $!\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sr"&gt;&amp;lt;GRADES&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="mi"&gt;5&lt;/span&gt;      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$student&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$grade&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
 &lt;span class="mi"&gt;6&lt;/span&gt;      &lt;span class="nv"&gt;$grades&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;$student&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="o"&gt;.=&lt;/span&gt; &lt;span class="nv"&gt;$grade&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="mi"&gt;7&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="mi"&gt;8&lt;/span&gt; 
 &lt;span class="mi"&gt;9&lt;/span&gt;  &lt;span class="k"&gt;foreach&lt;/span&gt; &lt;span class="nv"&gt;$student&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sort&lt;/span&gt; &lt;span class="nb"&gt;keys&lt;/span&gt; &lt;span class="nv"&gt;%grades&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="mi"&gt;10&lt;/span&gt;      &lt;span class="nv"&gt;$scores&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;11&lt;/span&gt;      &lt;span class="nv"&gt;$total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    
&lt;span class="mi"&gt;12&lt;/span&gt;      &lt;span class="nv"&gt;@grades&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;" "&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$grades&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nv"&gt;$student&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;
&lt;span class="mi"&gt;13&lt;/span&gt;      &lt;span class="k"&gt;foreach&lt;/span&gt; &lt;span class="nv"&gt;$grade&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;@grades&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="mi"&gt;14&lt;/span&gt;          &lt;span class="nv"&gt;$total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nv"&gt;$grade&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;15&lt;/span&gt;          &lt;span class="nv"&gt;$scores&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;16&lt;/span&gt;      &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="mi"&gt;17&lt;/span&gt;      &lt;span class="nv"&gt;$average&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nv"&gt;$total&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="nv"&gt;$scores&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;18&lt;/span&gt;      &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"$student: $grades{$student}\tAverage: $average\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="mi"&gt;19&lt;/span&gt;  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行时使用-w开关以获取警告信息。&lt;/p&gt;
&lt;h2&gt;文件句柄&lt;/h2&gt;
&lt;p&gt;在求平均值的例子中的GRADES是Perl中的另一种数据类型，文件句柄（filehandle）。文件句柄是你给一个文件，设备，socket或管道起的名字，帮助你记得他们是做什么的，隐藏了如缓冲等复杂的东西。（在内部文件句柄像C++等语言中的流。）&lt;/p&gt;
&lt;p&gt;文件句柄使用很容易在不同的地方读写数据。这部分使得Perl成为了一种非常好的脱水语言，它可以在同一时间处理很多文件和操作。&lt;/p&gt;
&lt;p&gt;使用open创建文件句柄并将它绑定到文件。open函数至少需要两个参数：文件句柄和要关联的文件名。Perl也提供了一些预定义的文件句柄。标准输入STDIN，标准输出STDOUT和STDERR，STDERR允许你和程序伪造输出到你的输出中。&lt;/p&gt;
&lt;p&gt;由于你可以使用open创建用于多种目的的文件句柄（输入，输出，管道），因此需要指定你需要的是哪种行为。你可以在命令行上，在文件句前添加字符，&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"filename"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;               &lt;span class="c1"&gt;# read from existing file&lt;/span&gt;
&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"&amp;lt;filename"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;              &lt;span class="c1"&gt;#   (same thing, explicitly)&lt;/span&gt;
&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"&amp;gt;filename"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;              &lt;span class="c1"&gt;# create file and write to it&lt;/span&gt;
&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"&amp;gt;&amp;gt;filename"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;             &lt;span class="c1"&gt;# append to existing file&lt;/span&gt;
&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"| output-pipe-command"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# set up an output filter&lt;/span&gt;
&lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SESAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"input-pipe-command |"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;# set up an input filter&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件句柄的命名是任意的。一旦打开，文件句柄SESAME就可以使用，直到显式的关闭它（close(SESAME)），或直到在后面的程序中使了open将这个句柄指向了另一个文件。打开一个已经打开的句柄将隐式的关闭先前打开的文件，使用它变为不可达的句柄，并打开一个不同的文件。对于这个操作要小心。有时会出现意外，比如使用&lt;code&gt;open(&lt;span class="math"&gt;\(handle,\)&lt;/span&gt;file)&lt;/code&gt;时，&lt;span class="math"&gt;\(handle包含了一个constant的字符串。确保\)&lt;/span&gt;handle的唯一性，否则你将在同一个句柄上打开新文件。或者$handle未定义，Perl将填充它。&lt;/p&gt;
&lt;p&gt;可以用&amp;lt;&amp;gt;操作符读取文件中的行。尖括号包含文件句柄（&lt;sesame&gt;）。空的操作符&amp;lt;&amp;gt;将从命令行上指定的所有文件中读入行，或从STDIN中读入。（这是许多过滤程序的标准行为。）一个使用STDIN文件句柄的例子：&lt;/sesame&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="bp"&gt;STDOUT&lt;/span&gt; &lt;span class="s"&gt;"Enter a number: "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;# ask for a number&lt;/span&gt;
&lt;span class="nv"&gt;$number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sr"&gt;&amp;lt;STDIN&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                        &lt;span class="c1"&gt;# input the number&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="bp"&gt;STDOUT&lt;/span&gt; &lt;span class="s"&gt;"The number is $number.\n"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# print the number&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;STDIN是缺省输入，STDOUT是缺省输出。&lt;/p&gt;
&lt;p&gt;行读入操作符不会自动移除换行符需要使用chop移除它。通常可以这样做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;chop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sr"&gt;&amp;lt;STDIN&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;操作符&lt;/h2&gt;
&lt;h2&gt;控制结构&lt;/h2&gt;
&lt;h3 id="truede-ding-yi"&gt;True的定义&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;非""和非"0"的字符串为true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除0外的任何数字为true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何引用都为true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何未定义的值都为false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;正则表达式&lt;/h2&gt;
&lt;h2&gt;列表处理&lt;/h2&gt;
&lt;p&gt;Perl中有两个重要的环境，标量环境（处理单一的东西）和列表环境（处理复数的东西）。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="perl"></category></entry><entry><title>实现服务端功能之——Java实体对象</title><link href="/bus_java.html" rel="alternate"></link><published>2007-09-02T00:00:00+08:00</published><updated>2007-09-02T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-09-02:/bus_java.html</id><summary type="html">&lt;h1&gt;关于实体对象&lt;/h1&gt;
&lt;p&gt;实体对象包含了业务逻辑和对表的DML操作。&lt;/p&gt;
&lt;h2&gt;对象模型和关键类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.server.OAEntityCache：这个缓冲用于存储特殊实体的查询过的行。映射到同样的实体的多个视图对象共享相同的实体缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;yourentityname&gt;EOImpl继承oracle.apps.fnd.framework.server.OAEntityImpl：这是实体对象本身。当实例化后，它代表数据中的一行。&lt;/yourentityname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.server.OAEntityDefImpl：表示描述实体对象的元数据，包括属性（attributes）、事件、校验器、关联和属性（properties）。当实例化后，它描述了实体对象类的所有实例。实体定义类是一个单例类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;yourentityname&gt;Expert继承oracle.apps.fnd.framework.server.OAEntityExpert：这是一个特殊的单例辅助类，它用于注册一个实体。&lt;/yourentityname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.jbo.Key：这是一个不可变的主、外键或复合主键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;创建 …&lt;/h1&gt;</summary><content type="html">&lt;h1&gt;关于实体对象&lt;/h1&gt;
&lt;p&gt;实体对象包含了业务逻辑和对表的DML操作。&lt;/p&gt;
&lt;h2&gt;对象模型和关键类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.server.OAEntityCache：这个缓冲用于存储特殊实体的查询过的行。映射到同样的实体的多个视图对象共享相同的实体缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;yourentityname&gt;EOImpl继承oracle.apps.fnd.framework.server.OAEntityImpl：这是实体对象本身。当实例化后，它代表数据中的一行。&lt;/yourentityname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.server.OAEntityDefImpl：表示描述实体对象的元数据，包括属性（attributes）、事件、校验器、关联和属性（properties）。当实例化后，它描述了实体对象类的所有实例。实体定义类是一个单例类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;yourentityname&gt;Expert继承oracle.apps.fnd.framework.server.OAEntityExpert：这是一个特殊的单例辅助类，它用于注册一个实体。&lt;/yourentityname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.jbo.Key：这是一个不可变的主、外键或复合主键。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;创建&lt;/h1&gt;
&lt;p&gt;为了创建实体对象，必须调用对应的上层视图对象中的createRow方法然后再调用insertRow方法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// In the application module; this example from the OA Framework&lt;/span&gt;
&lt;span class="c1"&gt;// ToolBox Tutorial will instantiate a SupplierEOImpl.&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSuppliersVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;insertRow&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRow&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;

  &lt;span class="c1"&gt;// Always call this after you perform a row insert. See the Entity Object&lt;/span&gt;
  &lt;span class="c1"&gt;// New / Initial section below for additional information.&lt;/span&gt;
  &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setNewRowState&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;STATUS_INITIALIZED&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;视图对象的createRow方法调用下层实体对象的create()方法。可以在实体的create()方法中添加初始化代码，可以参考oracle.apps.fnd.framework.toolbox.tutorial.server.SupplierEOImpl类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;警告：&lt;/strong&gt; 不要将初始化逻辑放到实体对象的构造器中；总是应该将这些代码添加到create()方法中super.create(attributeList)方法调用的后面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 如果默认值可以在设计时决定，并且是为特定的UI而决定的，也可以通过在设计器中设置item的Initial Value属性来指定默认值。这些值可以被用户个性化；而不需要创建实体你的对象的子类并覆盖create()方法来设置默认值。查看Defaulting章节查看细节信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * In the SupplierEOImpl class; initialize a new supplier.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="n"&gt;Public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AttributeList&lt;/span&gt; &lt;span class="n"&gt;attributeList&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;create&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attributeList&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
  &lt;span class="n"&gt;OADBTransaction&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// Supplier id is obtained from the table's sequence&lt;/span&gt;
  &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;supplierId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSequenceValue&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"FWK_TBX_SUPPLIERS_S"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;setSupplierId&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supplierId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// Start date should be set to sysdate&lt;/span&gt;
  &lt;span class="n"&gt;setStartDate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getCurrentDBDate&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end create()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 当在实体对象中设置值时，总是使用set&lt;attributename&gt;(val)代替setAttribute("&lt;attributename&gt;", val)方法可以提高性能，因为前者跳过了查找字段的步骤。如果需要忽略编程方式实现的属性校验而仍需要执行设计时定义的校验时，可以直接调用setAttributeInternal()。查看Entity Object and View Object Attribute Setters以获取更多信息。&lt;/attributename&gt;&lt;/attributename&gt;&lt;/p&gt;
&lt;h2&gt;复合实体关联&lt;/h2&gt;
&lt;p&gt;在复合关联中BC4J将在设置父对象主键属性值时自动设置子实体对象。父对象主键值是在调用create()方法时通过attributeList参数传递进去的，并且在super.create(attributeList)被执行时被设置值。&lt;/p&gt;
&lt;p&gt;不要尝试自己来处理主键值。&lt;/p&gt;
&lt;h2&gt;实体对象的Initial/New状态&lt;/h2&gt;
&lt;p&gt;缺省情况下，实体对象被创建时row状态为STATUS_NEW，并且BC4J将它们添加到它们的校验器中并且post监听。这时，任何事件触发校验或数据库提交sequence包括这些实体对象。（By default, entity objects are created with the     row state of STATUS_NEW, and BC4J adds them to its validation and post listener lists. In this case, any event that triggers a validation or database post sequence includes these entity objects.）&lt;/p&gt;
&lt;p&gt;如OA Framework Model Coding Standards中的规定，应该将通过显式的在视图对象中调用创建新行的方法后立即调用ViewRowImpl对象的setNewRowState(STATE_INITIALIZED)方法。&lt;/p&gt;
&lt;p&gt;当执行这个后，BC4J将从事务中和校验监听列表中移除对应的实体对象，这样它们将不会被校验或提交到数据库。当用户做出修改（属性的&amp;ldquo;setter&amp;rdquo;被调用后），实体对象的状态修改为STATUS_NEW，并且BC4J返回它到validation/post lists。你也可以在ViewRowImpl上调用setNewRowState(STATUS_NEW)在任何时候手工改变状态。&lt;/p&gt;
&lt;h2&gt;特殊&amp;ldquo;Create&amp;rdquo;的情况&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&amp;ldquo;Flattened&amp;rdquo;主／从处于单一行中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在OA Framework ToolBox教程中，我们有主／从实体显示于同一行中，&amp;ldquo;flattened&amp;rdquo;行中。比如采购单包含了很多行，它们依次包含了多个供货商，在我们的UI中，我们将采购单的行和供货单实现为1:1的关系。&lt;/p&gt;
&lt;p&gt;尽管BC4J可以很容易的为单个视图对象行创建多个不同类型的实体对象&amp;mdash;&amp;mdash;这些实体对象是不相关的或是平等的&amp;mdash;&amp;mdash;在一个对象是另一个对象子对象时需要你介入。在这种情况下，必须在你的视图对象行实现的create()方法中添加下面的代码，以确保正确的父对象的主键被设置到低层次的子对象的实体中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// The following is required to support the creating the master/detail line&lt;/span&gt;
&lt;span class="c1"&gt;// and shipment entities that have been "flattened" into a single row in&lt;/span&gt;
&lt;span class="c1"&gt;// POLineShipFullVO with a 1:1 join.&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// If you don't do this, BC4J will automatically treat them like peers and&lt;/span&gt;
&lt;span class="c1"&gt;// try to set the po header id as the parent key for both entities.&lt;/span&gt;

&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;jbo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;AttributeList&lt;/span&gt; &lt;span class="n"&gt;nvp&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
&lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt; &lt;span class="n"&gt;lineEO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;getEntity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
  &lt;span class="n"&gt;PurchaseOrderShipmentEOImpl&lt;/span&gt; &lt;span class="n"&gt;shipmentEO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PurchaseOrderShipmentEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;getEntity&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;    

  &lt;span class="k"&gt;try&lt;/span&gt; 
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Create Lines EO &lt;/span&gt;
    &lt;span class="n"&gt;lineEO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;create&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nvp&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 

    &lt;span class="c1"&gt;// Create Shipments EO &lt;/span&gt;
    &lt;span class="n"&gt;shipmentEO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;create&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lineEO&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 

    &lt;span class="c1"&gt;// Calling this ensures that any personalization default values are&lt;/span&gt;
    &lt;span class="c1"&gt;// properly set since the OAF normally sets this in the super.create(), but&lt;/span&gt;
    &lt;span class="c1"&gt;// since this is not called in this workaround, we need another method&lt;/span&gt;
    &lt;span class="c1"&gt;// to ensure customer defaults are applied.&lt;/span&gt;
    &lt;span class="n"&gt;setDefaultValue&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; 
  &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;lineEO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;revert&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 
    &lt;span class="n"&gt;shipmentEO&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;revert&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt; &lt;span class="k"&gt;instanceof&lt;/span&gt; &lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;jbo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;JboException&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
    &lt;span class="o"&gt;{&lt;/span&gt; 
      &lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;jbo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;JboException&lt;/span&gt; &lt;span class="n"&gt;jboEx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;jbo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;JboException&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 
      &lt;span class="c1"&gt;// Developers have to do the mapping on their own because of the override. &lt;/span&gt;
      &lt;span class="n"&gt;jboEx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;doEntityToVOMapping&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;oracle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;jbo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ViewObject&lt;/span&gt;&lt;span class="o"&gt;[]{&lt;/span&gt;&lt;span class="n"&gt;getViewObject&lt;/span&gt;&lt;span class="o"&gt;()});&lt;/span&gt;    
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;jboEx&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; 
    &lt;span class="o"&gt;}&lt;/span&gt; 
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;wrapperException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end create() &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;实体对象缓存&lt;/h2&gt;
&lt;p&gt;一旦被创建后，BC4J将实体对象因为各种原因被存储于特殊的事务缓冲区中，在JDeveloper BC4J文档中有完整的描述。两个重要的好处在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;处理同一个根应用模块中的多个视图对象可以共享同样的下层实体对象。这意味着在一个视图对象中修改实体后将立即反映到其它引用该实体对象的视图对象中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据修改将被保留在缓冲区中即使视图对象的行集被刷新。比如，在主－从关系中，在 &lt;strong&gt;从&lt;/strong&gt; 视图对象中由实体对象派生的属性值被保存在缓存中，即使用户从一个 &lt;strong&gt;主&lt;/strong&gt; 视图对象转换到另一个。所有数据修改将原封不动的保存在事务生命中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;懂得这个缓冲区的存在是很重要的，因为你必须明确的执行某些验证，比如，当执行唯一性验证时你必须同时检查实体缓冲区和数据库。&lt;/p&gt;
&lt;p&gt;有三种主要方式同时检查缓冲区和数据库：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用findByPrimaryKey()方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;手工迭代缓冲区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用关联对象迭代缓冲区&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;findByPrimaryKey()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;findByPrimaryKey()方法确保先查询缓冲区中与给定的主键相匹配的实体对象，然后查找数据库。这是一个非常用有的方法，但它并不是一个轻量的方法，因为它为从数据库中找到的记录实例化实体对象。它将 &lt;strong&gt;整个&lt;/strong&gt; 实体对象放入内存，而不只是主键。这个方法可以&amp;mdash;&amp;mdash;也应该&amp;mdash;&amp;mdash;被用于当你不需要查找一个匹配的情况&amp;mdash;&amp;mdash;比如，当验证一个基于序列的主键。它也适合用于需要在查找到的目标上调用方法以便中间层访问的情况。&lt;/p&gt;
&lt;p&gt;下面的代码来自于oracle.apps.fnd.framework.toolbox.schema.server.SupplierEOImpl类，描述了这个方法的使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setSupplierId&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Supplier id must be unique. To verify this, you must check both the&lt;/span&gt;
    &lt;span class="c1"&gt;// entity cache and the database. In this case, it's appropriate&lt;/span&gt;
    &lt;span class="c1"&gt;// to use findByPrimaryKey( ) because you're unlikely to get a match, and&lt;/span&gt;
    &lt;span class="c1"&gt;// and are therefore unlikely to pull a bunch of large objects into memory.&lt;/span&gt;

    &lt;span class="c1"&gt;// Note that findByPrimaryKey() is guaranteed to check all suppliers. &lt;/span&gt;
    &lt;span class="c1"&gt;// First it checks the entity cache, then it checks the database.&lt;/span&gt;

    &lt;span class="n"&gt;OADBTransaction&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;supplierKey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;EntityDefImpl&lt;/span&gt; &lt;span class="n"&gt;supplierDefinition&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDefinitionObject&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt; &lt;span class="n"&gt;supplier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;supplierDefinition&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findByPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supplierKey&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;supplier&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
             &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
             &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
             &lt;span class="s"&gt;"SupplierId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
             &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Bad attribute value&lt;/span&gt;
             &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message application short name&lt;/span&gt;
             &lt;span class="s"&gt;"FWK_TBX_T_SUP_ID_UNIQUE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name &lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;setAttributeInternal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUPPLIERID&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end setSupplierId()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;手工迭代缓冲区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过手工的方式检查实体缓冲区，以执行与findByPrimaryKey()相同的检查。然后再在另一步中执行对数据库的检查。这种方式的好处是可以避免不必要的实例对象（译：实体）。&lt;/p&gt;
&lt;p&gt;下面的例子也是来自于ToolBox教程中SupplierEOImpl类中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Since this value is marked as "mandatory," the BC4J Framework will take&lt;/span&gt;
  &lt;span class="c1"&gt;// care of ensuring that it's a non-null value. However, if it is null, we&lt;/span&gt;
  &lt;span class="c1"&gt;// don't want to proceed with any validation that could result in a NPE.&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="s"&gt;""&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;trim&lt;/span&gt;&lt;span class="o"&gt;()))))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Verify that the name is unique. To do this, we must check both the entity&lt;/span&gt;
    &lt;span class="c1"&gt;// cache and the database. We begin with the entity cache.&lt;/span&gt;
    &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;collections&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Iterator&lt;/span&gt; &lt;span class="n"&gt;supplierIterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
      &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getAllEntityInstancesIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getDBTransaction&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;currentId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSupplierId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;supplierIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt; &lt;span class="n"&gt;cachedSupplier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;supplierIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;next&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

      &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;cachedName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cachedSupplier&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
      &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;cachedId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cachedSupplier&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSupplierId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

      &lt;span class="c1"&gt;// We found a match for the name we're trying to set, so throw an&lt;/span&gt;
      &lt;span class="c1"&gt;// exception. Note that we need to exclude this EO from our test.&lt;/span&gt;

      &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cachedName&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cachedName&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;    
        &lt;span class="n"&gt;cachedId&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                               &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                               &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                               &lt;span class="s"&gt;"Name"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                               &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                               &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                               &lt;span class="s"&gt;"FWK_TBX_T_SUP_DUP_NAME"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name &lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// Now we want to check the database for any occurrences of the supplier&lt;/span&gt;
    &lt;span class="c1"&gt;// name. The most efficient way to check this is with a validation view&lt;/span&gt;
    &lt;span class="c1"&gt;// object which we add to a special "Validation" application module.&lt;/span&gt;
    &lt;span class="n"&gt;OADBTransaction&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;vam&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// Look to see if the VAM has already been created in this transaction. If not,&lt;/span&gt;
    &lt;span class="c1"&gt;// create it.&lt;/span&gt;
    &lt;span class="n"&gt;vam&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAApplicationModule&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"supplierVAM"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vam&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt; 
      &lt;span class="n"&gt;vam&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAApplicationModule&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createApplicationModule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"supplierVAM"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
         &lt;span class="s"&gt;"oracle.apps.fnd.framework.toolbox.schema.server.SupplierVAM"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// Now, we use a lightweight "validation" view object to see if a supplier exists&lt;/span&gt;
    &lt;span class="c1"&gt;// with the given name.&lt;/span&gt;
    &lt;span class="n"&gt;SupplierNameVVOImpl&lt;/span&gt; &lt;span class="n"&gt;valNameVo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SupplierNameVVOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;vam&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findViewObject&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"SupplierNameVVO"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;valNameVo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;initQuery&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;valNameVo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
            &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
            &lt;span class="s"&gt;"Name"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
            &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
            &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message application short name&lt;/span&gt;
            &lt;span class="s"&gt;"FWK_TBX_T_SUP_DUP_NAME"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="n"&gt;setAttributeInternal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NAME&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end setName()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;关联对象迭代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这与findByPrimaryKey()类似，它保证同时检查实体缓冲区和数据库。它也将会将找到的实体对象加载到内存，这用于需要调用实体中方法时。与findByPrimaryKey()方法不同，它可以通过任何key查找任何类型的实体对象，这只用于与当前对象间通过关联对象相关联的实体对象。&lt;/p&gt;
&lt;p&gt;下面的代码描述了根复合实体对象使用关联对象查找它的所有子对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;checkLineExists&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt; 
  &lt;span class="c1"&gt;// A purchase order header must have at least 1 associated line.&lt;/span&gt;
  &lt;span class="c1"&gt;// To check this, we first do a manual check of the entity cache&lt;/span&gt;
  &lt;span class="c1"&gt;// If we find a line for this header, we're done (note that the entity cache won't&lt;/span&gt;
  &lt;span class="c1"&gt;// include EOs that are DELETED or DEAD).&lt;/span&gt;

  &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;java&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;util&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;collections&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;Iterator&lt;/span&gt; &lt;span class="n"&gt;fastIterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDefinitionObject&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getAllEntityInstancesIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getDBTransaction&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;

  &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;currentHeaderId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getHeaderId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt; &lt;span class="n"&gt;fastIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt; &lt;span class="n"&gt;cachedLine&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;fastIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;next&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;cachedHeaderId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cachedLine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHeaderId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// If we find a match, we're done. Don't forget to look ONLY for lines&lt;/span&gt;
    &lt;span class="c1"&gt;// for this header... The entity cache can include lines for other headers&lt;/span&gt;
    &lt;span class="c1"&gt;// also.&lt;/span&gt;

    &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;cachedHeaderId&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cachedHeaderId&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentHeaderId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;))&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// We haven't found any matches in the cache yet, so now we need to check&lt;/span&gt;
  &lt;span class="c1"&gt;// the database...    &lt;/span&gt;

  &lt;span class="c1"&gt;// In this example, we're illustrating the use of the association between the&lt;/span&gt;
  &lt;span class="c1"&gt;// header and its lines to iterate through all the shipments.  This will&lt;/span&gt;
  &lt;span class="c1"&gt;// check both the cache and the database, and will bring all the rows&lt;/span&gt;
  &lt;span class="c1"&gt;// into the middle tier.&lt;/span&gt;
  &lt;span class="c1"&gt;// Note that this looks only at lines for this&lt;/span&gt;
  &lt;span class="c1"&gt;// header so we don't need to filter our results, so it is convenient.&lt;/span&gt;
  &lt;span class="n"&gt;RowIterator&lt;/span&gt; &lt;span class="n"&gt;linesIterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPurchaseOrderLineEO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="n"&gt;linesIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;()))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OARowValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OARowValException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                &lt;span class="s"&gt;"FWK_TBX_T_PO_NO_LINES"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end checkLineExists()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;实体状态&lt;/h2&gt;
&lt;p&gt;每个实体对象都有一个相关的&amp;ldquo;实体状态&amp;rdquo;它描述了实体的状态与下层数据库和事务关联。可以调用getEntityState()检查实体的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; BC4J从实体缓冲区中自动移除任何状态为STATUS_DEAD的实体对象，因此你不需要在查找&amp;ldquo;好&amp;rdquo;的实体对象时关心手工排除这些对象的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;STATUS_NEW 实体对象在当前事务中是新的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATUS_DELETED 实体对象来自于数据库并且在当前事务中已经被删除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATUS_MODIFIED 实体对象来自于数据库并且已经被改变了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATUS_UNMODIFIED 实体对象来源于数据库并且没有被改变为，或者已经被改变过并且改变已经被提交&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATUS_DEAD 实体对象在当前事务中是新的并且已经被删除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STATUS_INITIALIZED 实体对象牌&amp;ldquo;临时（temporary）&amp;rdquo;状态并且将不会被提交或校验&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;修改／校验&lt;/h1&gt;
&lt;p&gt;这节描述如何正确执行属性级和实体级的校验。&lt;/p&gt;
&lt;h2&gt;属性级校验&lt;/h2&gt;
&lt;p&gt;如&lt;a href="/build_view.html"&gt;实现视图&lt;/a&gt;一章中描述的，当向页面发起HTTP POST请求时修改的值时，OA Framework将这些值回写到下层的视图对象，再通过调用实体对象的setter方法将这些值写入下层的实体对象。&lt;/p&gt;
&lt;p&gt;因此每个属性的校验应该被添加到它的setter方法中（查看ToolBox的PurchaseOrderHeaderEOImpl的setHeaderId()方法，如下），调用实体对象的setter方法执行的是属性级的校验。&lt;/p&gt;
&lt;p&gt;如果显示的指定了校验（比如，你在JDeveloper Entity Object Wizard中指定一个属性在它被保存后不能被更新），这个校验是在setAttributeInternal()方法中执行的，你应该将它放在你自己的校验逻辑的后面执行。它也将在validateEntity()中执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Sets the PO Header Id.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Business Rules:&lt;/span&gt;
&lt;span class="cm"&gt; * Required; cannot be null.&lt;/span&gt;
&lt;span class="cm"&gt; * Cannot be updated on a committed row.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setHeaderId&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// BC4J validates that this can be updated only on a new line. This&lt;/span&gt;
  &lt;span class="c1"&gt;// adds the additional check of only allowing an update if the value&lt;/span&gt;
  &lt;span class="c1"&gt;// is null to prevent changes while the object is in memory.&lt;/span&gt;

  &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getHeaderId&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                 &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                                 &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                                 &lt;span class="s"&gt;"HeaderId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                                 &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                                 &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                 &lt;span class="s"&gt;"DEBUG -- need message name"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;OADBTransaction&lt;/span&gt; &lt;span class="n"&gt;transaction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OADBTransaction&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// findByPrimaryKey() is guaranteed to first check the entity cache, then check&lt;/span&gt;
    &lt;span class="c1"&gt;// the database. This is an appropriate use of this method because finding a    &lt;/span&gt;
    &lt;span class="c1"&gt;// match would be the exception rather than the rule so we're not worried &lt;/span&gt;
    &lt;span class="c1"&gt;// about pulling entities into the middle tier.&lt;/span&gt;

    &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;headerKey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;EntityDefImpl&lt;/span&gt; &lt;span class="n"&gt;hdrDef&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PurchaseOrderHeaderEOImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDefinitionObject&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;PurchaseOrderHeaderEOImpl&lt;/span&gt; &lt;span class="n"&gt;hdrEO&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
      &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PurchaseOrderHeaderEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;hdrDef&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;findByPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;transaction&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;headerKey&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hdrEO&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                   &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                                   &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                                   &lt;span class="s"&gt;"HeaderId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                                   &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                                   &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                   &lt;span class="s"&gt;"FWK_TBX_T_PO_ID_UNIQUE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;

  &lt;span class="c1"&gt;// Executes declarative validation, and finally sets the new value.&lt;/span&gt;
  &lt;span class="n"&gt;setAttributeInternal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HEADERID&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end setHeaderId()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;不同的&amp;ldquo;Set&amp;rdquo;方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有多种方法可以设置实体变量的值。在编码中，通常调用set&lt;attributename&gt;()和setAttributeInternal()。查看Entity Object and View Object Attribute Setters获取更多的信息。&lt;/attributename&gt;&lt;/p&gt;
&lt;h2&gt;交叉属性校验&lt;/h2&gt;
&lt;p&gt;任何与两个个或更多属性值相关的校验应该被包含在validateEntity()方法中；不要将交叉属性校验放在单个属性的setter方法中，因为属性值的设置可能是无序的。&lt;/p&gt;
&lt;h2&gt;实体校验&lt;/h2&gt;
&lt;p&gt;当OA Framework在HTTP POST处理周期中设置实体对象值时，它总会校验它接触到的视图对象的行，它依次在下层的实体对象（一个或多个）上调用validateEntity()方法。而且，entities are validated again prior to posting (up to 10 times in a composition).&lt;/p&gt;
&lt;p&gt;任何操作于行级的逻辑&amp;mdash;&amp;mdash;且对被重复调用不是非常敏感的校验&amp;mdash;&amp;mdash;应该被包含在validateEntity()方法中。&lt;/p&gt;
&lt;p&gt;下面的PurchaseOrderHeaderEOImpl代码描述了实体级的校验：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Performs entity-level validation including cross-attribute validation that&lt;/span&gt;
&lt;span class="cm"&gt; * is not appropriately performed in a single attribute setter.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;validateEntity&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;validateEntity&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// If our supplier value has changed, verify that the order is in an "IN_PROCESS"&lt;/span&gt;
  &lt;span class="c1"&gt;// or "REJECTED" state. Changes to the supplier in any other state are disallowed. &lt;/span&gt;
  &lt;span class="c1"&gt;// Note that these checks for supplier and site are both performed here&lt;/span&gt;
  &lt;span class="c1"&gt;// because they are doing cross-attribute validation.&lt;/span&gt;

  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getStatusCode&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(((&lt;/span&gt;&lt;span class="s"&gt;"APPROVED"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"COMPLETED"&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Start by getting the original value and comparing it to the current&lt;/span&gt;
    &lt;span class="c1"&gt;// value. Changes at this point are invalid.&lt;/span&gt;

    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;oldSupplierId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;getPostedAttribute&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUPPLIERID&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;currentSupplierId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSupplierId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oldSupplierId&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentSupplierId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                   &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                                   &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                                   &lt;span class="s"&gt;"SupplierId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                                   &lt;span class="n"&gt;currentSupplierId&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                                   &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                   &lt;span class="s"&gt;"FWK_TBX_T_PO_SUPPLIER_NOUPDATE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// If our supplier site has changed, verify that the order is in an "IN_PROCESS"&lt;/span&gt;
    &lt;span class="c1"&gt;// state. Changes to the supplier site in any other state are disallowed.&lt;/span&gt;

    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;oldSiteId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Number&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;getPostedAttribute&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SUPPLIERSITEID&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;currentSiteId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getSupplierSiteId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oldSiteId&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currentSiteId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                  &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                                  &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                                  &lt;span class="s"&gt;"SupplierId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                                  &lt;span class="n"&gt;currentSiteId&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                                  &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                  &lt;span class="s"&gt;"FWK_TBX_T_PO_SUPSITE_NOUPDATE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt; 

  &lt;span class="c1"&gt;// Verify that our supplier site is valid for the supplier and make sure it is&lt;/span&gt;
  &lt;span class="c1"&gt;// an active "Purchasing" site.&lt;/span&gt;

  &lt;span class="n"&gt;SupplierEntityExpert&lt;/span&gt; &lt;span class="n"&gt;supplierExpert&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
    &lt;span class="n"&gt;SupplierEOImpl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSupplierEntityExpert&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(!(&lt;/span&gt;&lt;span class="n"&gt;supplierExpert&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isSiteValidForPurchasing&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getSupplierId&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;getSupplierSiteId&lt;/span&gt;&lt;span class="o"&gt;())))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAAttrValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                 &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO name&lt;/span&gt;
                                 &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// EO PK&lt;/span&gt;
                                 &lt;span class="s"&gt;"SupplierSiteId"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Attribute Name&lt;/span&gt;
                                 &lt;span class="n"&gt;getSupplierSiteId&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="c1"&gt;// Attribute value&lt;/span&gt;
                                 &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                 &lt;span class="s"&gt;"FWK_TBX_T_PO_SUPSITE_INVALID"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end validateEntity();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;交叉实体校验&lt;/h2&gt;
&lt;p&gt;开发者经常认为他们需要实现&amp;ldquo;交叉实体（cross-entity）&amp;rdquo;校验，一个实体对象在校验中调用另一个的方法。在OA Framework中，&amp;ldquo;交叉实体校验&amp;rdquo;意味着某些非常特殊的东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实体A和实体B在执行validateEntity()方法时各自己引用对方（因为实体A需要从实体B获得一些属性，实体B需要从实体A获得一些属性）and...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;期望两个对象都是&amp;ldquo;脏（dirty）&amp;rdquo;对象（需要校验）在同一个事务中and...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个实体对象必须是有效的，以便引用它的对象获取属性值用于自己的校验。这样问题就来了：哪个实体应该先校验？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 对于复合关联的主／从实体对象这不是个问题，因为子对象将会先于父对象被校验，且BC4J Framework将校验复合层级结构向上10次的校验，从底部到顶部直到所有实体都是有效的。&lt;/p&gt;
&lt;p&gt;需要&amp;ldquo;交叉实体校验&amp;rdquo;的环境是非常少见的。如果你觉得需要，解决的办法是创建一个特殊的&amp;ldquo;调停者&amp;rdquo;对象实现BC4J的ValidationListener接口。简单来说，这个对象交叉实体中的哪个对象的校验先执行。&lt;/p&gt;
&lt;h2&gt;不妥当的校验失败处理&lt;/h2&gt;
&lt;p&gt;在实体级的校验方法（validateEntity()，set&lt;attributename&gt;()或其它）中调用Transaction.rollback()，Transaction.clearEntityCache()执行回滚或清除BC4J缓冲的操作。如果因为某些原因需要执行这些操作，你必须按下面的方法在 &lt;strong&gt;应用模块／事务级（application module/transaction level）&lt;/strong&gt; 捕获校验异常，并执行你需要的方法。比如，在应用模块级执行回滚是安全的；在实体级执行回滚或清理实体缓冲区却不是，并且可能导致不可预知的行为。&lt;/attributename&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Bad&lt;/span&gt; &lt;span class="n"&gt;Code&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;---------&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;validateEntity&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="n"&gt;DBTransaction&lt;/span&gt; &lt;span class="n"&gt;txn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getDBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="c1"&gt;// Do not issue a rollback from within the EO.&lt;/span&gt;
  &lt;span class="n"&gt;txn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rollback&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(...);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Good&lt;/span&gt; &lt;span class="n"&gt;Code&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;----------&lt;/span&gt;
&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;validateEntity&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="o"&gt;...&lt;/span&gt;
  &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(...);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// The following logic is written at the application-module level.&lt;/span&gt;

&lt;span class="k"&gt;try&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;txn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Cache the exception thrown by the validation logic in the EO, &lt;/span&gt;
  &lt;span class="c1"&gt;// and perform the rollback.&lt;/span&gt;
  &lt;span class="n"&gt;txn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rollback&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;删除&lt;/h1&gt;
&lt;p&gt;为了删除实体对象，可以在对应的视图对象上调用remove()方法，如下面的应用模块中的代码所示。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Deletes a purchase order from the PoSimpleSummaryVO using the&lt;/span&gt;
&lt;span class="cm"&gt; * poHeaderId parameter.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Boolean&lt;/span&gt; &lt;span class="nf"&gt;delete&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;poHeaderId&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// First, we need to find the selected purchase order in our VO.&lt;/span&gt;
  &lt;span class="c1"&gt;// When we find it, we call remove( ) on the row which in turn&lt;/span&gt;
  &lt;span class="c1"&gt;// calls remove on the associated PurchaseOrderHeaderEOImpl object.&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;poToDelete&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Integer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;parseInt&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;poHeaderId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="n"&gt;OAViewObject&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPoSimpleSummaryVO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 
  &lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// This tells us the number of rows that have been fetched in the&lt;/span&gt;
  &lt;span class="c1"&gt;// row set, and will not pull additional rows in like some of the&lt;/span&gt;
  &lt;span class="c1"&gt;// other "get count" methods.&lt;/span&gt;
  &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getFetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;rowFound&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

  &lt;span class="c1"&gt;// We use a separate iterator -- even though we could step through the&lt;/span&gt;
  &lt;span class="c1"&gt;// rows without it -- because we don't want to affect row currency.&lt;/span&gt;
  &lt;span class="n"&gt;RowSetIterator&lt;/span&gt; &lt;span class="n"&gt;deleteIter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"deleteIter"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; 
  &lt;span class="o"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeStart&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
    &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setRangeSize&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;fetchedRowCount&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt; 
    &lt;span class="o"&gt;{&lt;/span&gt; 
      &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PoSimpleSummaryVORowImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRowAtRangeIndex&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; 

      &lt;span class="c1"&gt;// For performance reasons, we generate ViewRowImpls for all&lt;/span&gt;
      &lt;span class="c1"&gt;// View Objects. When we need to obtain an attribute value,&lt;/span&gt;
      &lt;span class="c1"&gt;// we use the named accessors instead of a generic String lookup.&lt;/span&gt;

      &lt;span class="c1"&gt;// Number primaryKey = (Number)row.getAttribute("HeaderId");&lt;/span&gt;
      &lt;span class="n"&gt;Number&lt;/span&gt; &lt;span class="n"&gt;primaryKey&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getHeaderId&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;primaryKey&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;compareTo&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;poToDelete&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;row&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;rowFound&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;getTransaction&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// only one possible selected row in this case&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt; 
    &lt;span class="o"&gt;}&lt;/span&gt; 
  &lt;span class="o"&gt;}&lt;/span&gt; 

  &lt;span class="c1"&gt;// Always close iterators.&lt;/span&gt;
  &lt;span class="n"&gt;deleteIter&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;closeRowSetIterator&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; 
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Boolean&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rowFound&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end delete()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;校验和级联删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;row.remove()方法依次调用下层实体对象的remove()方法。为实现特殊的删除行为，比如，检查删除操作是否被允许，或实现级联删除，应该在实体的remove()方法中添加代码，如下所描述的TooBox中的PurchaseOrderHeaderEOImpl。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 由于Oracle Applications编码规范禁止使用数据库的级联删除功能。BC4J Framework需要我们手工为多层的purchase order业务对象实现自己的级联删除，每个实体对象在在执行super.remove()之前，先删除它自己的直接子对象。如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Marks all the lines for deletion, then mark the header for deletion.&lt;/span&gt;
&lt;span class="cm"&gt; * You can delete a purchase order only if it is "In Process" or "Rejected."&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;status&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getStatusCode&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="s"&gt;"IN_PROCESS"&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"REJECTED"&lt;/span&gt;&lt;span class="n"&gt;Equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;status&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;

    &lt;span class="c1"&gt;// Note this is a good use of the header -&amp;gt; lines association since we&lt;/span&gt;
    &lt;span class="c1"&gt;// want to call remove( ) on each line.&lt;/span&gt;
    &lt;span class="n"&gt;RowIterator&lt;/span&gt; &lt;span class="n"&gt;linesIterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getPurchaseOrderLineEO&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;linesIterator&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

      &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;linesIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasNext&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt;
      &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PurchaseOrderLineEOImpl&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;linesIterator&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;next&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; 
    &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;remove&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// Must be called last in this case.&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;else&lt;/span&gt; 
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OARowValException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OARowValException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;TYP_ENTITY_OBJECT&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                                &lt;span class="n"&gt;getEntityDef&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getFullName&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                                &lt;span class="n"&gt;getPrimaryKey&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                                &lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="c1"&gt;// Message product short name&lt;/span&gt;
                                &lt;span class="s"&gt;"FWK_TBX_T_PO_NO_DELETE"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Message name&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// end remove()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;锁&lt;/h1&gt;
&lt;p&gt;BC4J支持下面的锁技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;悲观锁 BC4J在执行setAttribute()方法时锁定实体对象对应的数据库行（在做出任何修改之前）。如果行已经被锁，BC4J将招聘一个AlreadyLockedException异常。这也是BC4J缺省的锁模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;乐观锁 BC4J在执行数据库post处理逻辑时锁定实体对象对应的数据库行。如果行已经被锁，BC4J将抛出AlreadyLockedException异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; OA Framework默认使用乐观锁并且推荐使用，由于连接池使传统的悲观锁不能实行。但是对于基于Form的应用是使用悲观锁的。&lt;/p&gt;
&lt;p&gt;如果你需要悲观锁，你必须改变事务的行为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// In the application module...&lt;/span&gt;

&lt;span class="n"&gt;OADBTransaction&lt;/span&gt; &lt;span class="n"&gt;txn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getOADBTransaction&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;txn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setLockingMode&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;LOCK_PESSIMISTIC&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;过期数据侦测&lt;/h2&gt;
&lt;p&gt;当BC4J锁定一行时，它试着决定行对象是否被其它用户删除或修改，因为它是为当前用户而查询的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果行已经被删除了，BC4J抛出RowAlreadyDeletedException。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果行已经被修改，BC4J抛出RowInconsistentException。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为覆盖缺省的逐行比较的检测行为，可以在实体对象属性定义向导中使用属性级的Chage Indicator标志。如果某个属性的这个标志被选中，BC4J限制对这个属性的比较。Oracle Application PL/SQL API通常使用OBJECT_VERSION_NUMBER表列检查数据的改变，这列也可以影响实体对象。查看下面的Object Version Number Column。&lt;/p&gt;
&lt;h1&gt;提交&lt;/h1&gt;
&lt;p&gt;当准备提交实体对象的修改时，只要简单的从应用模块中调用getTransaction()Commit()。当调用这个方法时，你的对象被校验（如果需要），posted和committed。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;commit()方法调用oracle.apps.fnd.framework.OADBTransaction.validate()方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;validate()方法检查所有需要校验的根实体对象的&amp;ldquo;Validation Listener&amp;ldquo;。（在多个实体组成的复合对象，只有根实体对象被添加到Validation list）。校验完成后在commit前，它将不会存在于list中，因为当对象校验成功后，BC4J将会从validation list中移除它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;技巧：&lt;/strong&gt; 也可以调用OADBTransaction.validate()方法在任何地方强制进行校验。它执行相同的功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对象位于validation list中，OADBTransaction validate()方法将调用实体的final viladate()方法，现依次调用validateEntity()执行你的校验逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在BC4J中对于list中各个实体的校验顺序是随机的。但是，在一个复合对象中，比如一个采购单有多个供货商。BC4J总是在校验父对象前校验子对象。BC4J只会将复合对象的根实体放入validation list中（子对象不会被包含进来）。当根实体对象调用super.validateEntity时，BC4J调用它的子对象的validate，直到遍历整个层级结构。由于这个原因，你应该在你的校验逻辑之前调用super.validateEntity以保证父对象在校验子对象后才校验自己。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;commit方法调用OADBTransaction postChanges方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;postChanges方法检查&amp;ldquo;Post Listener&amp;rdquo;获得实体对象中哪些数据需要被提交（posted）到数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于post list中的任何对象，OADBTransaction postChanges方法调用实体的postChanges方法。当对象被提交（posted），BC4J将它从post list中移除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有错误发生，数据库commit被发出，任何数据库锁被释放。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;回滚&lt;/h1&gt;
&lt;p&gt;OA Framework为post和commit动作实现了一个&amp;ldquo;all or nothing&amp;ldquo;的事务处理方式。不管错误是否严重，如果数据库post或commit失败，OA Framework：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发起JDBC rollback释放数据库锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这不会影响中间层的状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;恢复视图行对象的状态以便于事务发起第二次尝试。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这意味着你不需要显式的rollback失败的实体对象事务；OA Framework将在post或commit失败后自动显示出用户友好的错误信息。下面的例子描述了用户按下Apply按钮后commit和后来显示&amp;ldquo;Confirmation&amp;ldquo;对话框的情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// In the root application module&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;apply&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;getTransaction&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="n"&gt;Commit&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt; 

&lt;span class="c1"&gt;// In the controller&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;processFormData&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OAPageContext&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;OAWebBean&lt;/span&gt; &lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;processFormRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;webBean&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="c1"&gt;// Handle the user pressing the "Apply" button&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getParameter&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"Apply"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;OAApplicationModule&lt;/span&gt; &lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getRootApplicationModule&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// No need for any special exception handling.  You can just display the&lt;/span&gt;
    &lt;span class="c1"&gt;// confirmation message because the OAF won't reach this code if the post/commit&lt;/span&gt;
    &lt;span class="c1"&gt;// fails.&lt;/span&gt;
    &lt;span class="n"&gt;am&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;invokeMethod&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"apply"&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;OAException&lt;/span&gt; &lt;span class="n"&gt;confirmMessage&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; 
      &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"ICX"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"FWK_TBX_T_SUPPLIER_CREATE_CONF"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
                       &lt;span class="n"&gt;OAException&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;CONFIRMATION&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;pageContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;putDialogMessage&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;confirmMessage&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;回滚方法&lt;/h2&gt;
&lt;p&gt;手工清除中间层视图对象和实体对象缓冲，可以从应用模块中调用getTransaction().rollback()。这也将roll back任何数据库修改并清除任何缓存于事务中的值。查找Support the Browser Back Button了解这对于创建实体对象的作用。&lt;/p&gt;
&lt;p&gt;如果执行PL/SQL过程需要显式的roll back数据库而不影响中间层，可以在应用模块中调用getTransaction().executeCommand("rollback")。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 如BC4J Native JDBC Statement Management中说过的。Transaction.rollback()会调用vo.clearCache()关闭相关的视图对象的JDBC结果集（游标）。比如，如果按下面的顺序执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;executeQuery&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;Transaction&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;rollback&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;vo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;next&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SQL异常&amp;ldquo;ORA-01002: fetch out of sequence&amp;rdquo;（这通常是由于在数据库中执行rollback使打开的cursors失效）将不会发生，因为Transaction.rollback()关闭了游标，强制vo.next()重新执行视图对象的查询并打开一个新的有效游标。&lt;/p&gt;
&lt;p&gt;当Transaction.rollback() roll back 数据库状态和中间层业务对象状态，下层直接JDBC调用并不会有意识的rollback任何中间层业务对象的状态，因此不要关闭JDBC游标。&lt;/p&gt;
&lt;p&gt;i. Transaction.executeCommand("rollback")调用或&lt;/p&gt;
&lt;p&gt;ii. BC4J的&amp;ldquo;rollback to savepoint&amp;rdquo;数据库调用是在Transaction.postChanges()或Transaction.commit()方法调用时validation或post出错时，由内部发出的的。尽管实体对象或视图对象中用户修改的数据仍然存在，实体的post state已经变回modified state以便用户可以再次发起post/commit。&lt;/p&gt;
&lt;p&gt;BC4J Framework不会补偿JDBC或数据库的rollback，无效的JDBC和数据库游标中的结果集（当数据库执行rollback调用后，游标被打开）。因此，如果你需要使用Transaction.executeCommand("rollback")，请先查看M52 model coding standards。&lt;/p&gt;
&lt;p&gt;如果需要覆盖post处理或EntityImpl中的beforeCommid，请先参考下节不当的Post处理。&lt;/p&gt;
&lt;h2&gt;不当的Post处理&lt;/h2&gt;
&lt;p&gt;在下面的情况下避免调用executeQuery()：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在视图对象的EntityImpl的post处理器方法（postChanges，beforePost，afterPost）中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在beforeCommit中并且随后试图在相同的视图对象中使用vo.next()，vo.first()等方法获取行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;未完成！！&lt;/p&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>OA Framework应用构建之——错误处理</title><link href="/build_error.html" rel="alternate"></link><published>2007-08-21T00:00:00+08:00</published><updated>2007-08-21T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-08-21:/build_error.html</id><summary type="html">&lt;h1&gt;异常类型&lt;/h1&gt;
&lt;p&gt;OA Framework处理三种基本类型的异常：通用、校验和严重。这些类型在这节中简单的描述；特殊异常的使用在下面介绍。&lt;/p&gt;
&lt;h2&gt;通用异常&lt;/h2&gt;
&lt;p&gt;BC4J框架中的错误是通过抛出类型为oracle.jbo.JBOException的隐式（runtime）异常。OA Framework中有自己的对应的版本为oracle.apps.fnd.framework.OAException。这个特殊化的版本提供了一种机制，可以将多个异常捆绑在一起，并使用Oracle应用消息字典（Oracle Applications Message Dictionary）翻译这些异常信息，以便显示出有用的信息。在任何代码中，通常可以抛出一个OAException类型的页面级别异常。&lt;/p&gt;
&lt;h2&gt;校验异常&lt;/h2&gt;
&lt;p&gt;校验异常是从实体对象和视图对象中抛出的，可以是由于属性级或行级的校验失败引起。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.OAAttrValException 特殊版本的OAException，用于属性级校验失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.OARowValException 特殊版本的OAException，用于行（row）（entity）级校验失败 …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h1&gt;异常类型&lt;/h1&gt;
&lt;p&gt;OA Framework处理三种基本类型的异常：通用、校验和严重。这些类型在这节中简单的描述；特殊异常的使用在下面介绍。&lt;/p&gt;
&lt;h2&gt;通用异常&lt;/h2&gt;
&lt;p&gt;BC4J框架中的错误是通过抛出类型为oracle.jbo.JBOException的隐式（runtime）异常。OA Framework中有自己的对应的版本为oracle.apps.fnd.framework.OAException。这个特殊化的版本提供了一种机制，可以将多个异常捆绑在一起，并使用Oracle应用消息字典（Oracle Applications Message Dictionary）翻译这些异常信息，以便显示出有用的信息。在任何代码中，通常可以抛出一个OAException类型的页面级别异常。&lt;/p&gt;
&lt;h2&gt;校验异常&lt;/h2&gt;
&lt;p&gt;校验异常是从实体对象和视图对象中抛出的，可以是由于属性级或行级的校验失败引起。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.OAAttrValException 特殊版本的OAException，用于属性级校验失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oracle.apps.fnd.framework.OARowValException 特殊版本的OAException，用于行（row）（entity）级校验失败。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OA Framework使用下面的方式显示错误信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;属性级异常将在错误项目（item）和页面顶部标示出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行级异常将在错误行（row）和页面顶部标示出来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;页面级异常通常在页面顶部标示出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;严重异常&lt;/h2&gt;
&lt;p&gt;严重（severe）（或称为&amp;ldquo;毁灭（fatal）&amp;rdquo;）性的异常包括不希望出现的系统级的错误（比如NullPointerException）和所选的JBOException如：NoDefExcpetion。可以直接在代码中抛出严重异常。&lt;/p&gt;
&lt;p&gt;如果严重异常发生，用户将被定向到OAErrorPage（异常被渲染在页面的中间，页面是区域渲染的，页面显示了用户友好的错误信息，并包含了一个指向堆栈跟踪细节的链接）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 这是一个未翻译过的信息客户可以在站点中修改。&lt;/p&gt;
&lt;h2&gt;Oracle工作流通知&lt;/h2&gt;</content><category term="oracle"></category><category term="ebs"></category><category term="oaf"></category></entry><entry><title>Emacs Muse标记规则学习</title><link href="/emacs-musebiao-ji-gui-ze-xue-xi.html" rel="alternate"></link><published>2007-06-19T00:00:00+08:00</published><updated>2007-06-19T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-06-19:/emacs-musebiao-ji-gui-ze-xue-xi.html</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* 段落
在Muse中段落必须通过一个空行来隔开

这是一个新段落

      六个或更多空白字元(tab或空格)开始的一行表示一个居中的段落

* 标题
&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
* First level

** Second level

*** Third level
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;
* 水平线
四个或者更多破折号表示一个水平线，确保其前后都是空行，否则它将被段看作段落的一部分

----


* 强调文本

使用某些特别地认可的字符包围文本以强调文本：

&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
*emphasis*
**strong emphasis**
***very strong emphasis***
_underlined_
=verbatim and monospace=
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;

上面的列表生成：
*emphasis*

**strong emphasis**

***very strong emphasis***

_underlined_

=verbatim and monospace=

* 添加脚注

A footnote reference is simply …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* 段落
在Muse中段落必须通过一个空行来隔开

这是一个新段落

      六个或更多空白字元(tab或空格)开始的一行表示一个居中的段落

* 标题
&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
* First level

** Second level

*** Third level
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;
* 水平线
四个或者更多破折号表示一个水平线，确保其前后都是空行，否则它将被段看作段落的一部分

----


* 强调文本

使用某些特别地认可的字符包围文本以强调文本：

&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
*emphasis*
**strong emphasis**
***very strong emphasis***
_underlined_
=verbatim and monospace=
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;

上面的列表生成：
*emphasis*

**strong emphasis**

***very strong emphasis***

_underlined_

=verbatim and monospace=

* 添加脚注

A footnote reference is simply a number in square
brackets&lt;span class="nt"&gt;&amp;lt;verbatim&amp;gt;&lt;/span&gt;[1]&lt;span class="nt"&gt;&amp;lt;/verbatim&amp;gt;&lt;/span&gt;.[1] To define the footnote, place
this definition at the bottom of your file.  =footnote-mode= can be
used to greatly facilitate the creation of these kinds of footnotes.

&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
 Footnotes:
 [1]  Footnotes are defined by the same number in brackets
      occurring at the beginning of a line.  Use footnote-mode's
      C-c ! a command, to very easily insert footnotes while
      typing.  Use C-x C-x to return to the point of insertion.
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;

* 诗章
诗要求空白字符被保留，使用下面的格式
&lt;span class="nt"&gt;&amp;lt;example&amp;gt;&lt;/span&gt;
&amp;gt;A line of Emacs verse;
&amp;gt;   forgive its being so terse.
&lt;span class="nt"&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;

&amp;gt; A line of Emacs verse;
&amp;gt;   forgive its being so terse.

* 抄录段落

脚注:
[1]这是一条脚注
&lt;/pre&gt;&lt;/div&gt;</content><category term="emacs"></category></entry><entry><title>gawk笔记</title><link href="/gawkbi-ji.html" rel="alternate"></link><published>2007-06-19T00:00:00+08:00</published><updated>2007-06-19T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-06-19:/gawkbi-ji.html</id><summary type="html">&lt;h1&gt;I.简介&lt;/h1&gt;
&lt;p&gt;gawk的主要功能是针对档案的第一行搜寻指令的patterns。当一行里有符合指定的patterns，gawk就会在此行执行指定的actions。gawk依此方式处理输入档案的每一行直到输入档案结束。
gawk程序由很多的pattern与action所组成，action写在大括号{}里面。一个pattern后面就跟着一个action。整个gawk程序像下面的样子：
pattern {action}
pattern {action}
在gawk程序里面，pattern和action都能被省略，但是不能两个同时省略。如果pattern被省略，对于文件中的每一行，action都会被执行。如果action被省略，内定的action则会打印出所有符合pattern的输入行。&lt;/p&gt;
&lt;h2&gt;1.执行gawk程序&lt;/h2&gt;
&lt;p&gt;有两种方式&lt;/p&gt;
&lt;h3 id="axie-zai-ming-ling-xing"&gt;a.写在命令行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'program' input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bxie-zai-dan-du-de-cheng-xu-wen-jian-zhong"&gt;b.写在单独的程序文件中&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk -f program-file input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当程序文件不止一个时，可以写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk -f program-file1 -f program-file2 ... input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.一个简单的例子 …&lt;/h2&gt;</summary><content type="html">&lt;h1&gt;I.简介&lt;/h1&gt;
&lt;p&gt;gawk的主要功能是针对档案的第一行搜寻指令的patterns。当一行里有符合指定的patterns，gawk就会在此行执行指定的actions。gawk依此方式处理输入档案的每一行直到输入档案结束。
gawk程序由很多的pattern与action所组成，action写在大括号{}里面。一个pattern后面就跟着一个action。整个gawk程序像下面的样子：
pattern {action}
pattern {action}
在gawk程序里面，pattern和action都能被省略，但是不能两个同时省略。如果pattern被省略，对于文件中的每一行，action都会被执行。如果action被省略，内定的action则会打印出所有符合pattern的输入行。&lt;/p&gt;
&lt;h2&gt;1.执行gawk程序&lt;/h2&gt;
&lt;p&gt;有两种方式&lt;/p&gt;
&lt;h3 id="axie-zai-ming-ling-xing"&gt;a.写在命令行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'program' input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="bxie-zai-dan-du-de-cheng-xu-wen-jian-zhong"&gt;b.写在单独的程序文件中&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk -f program-file input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当程序文件不止一个时，可以写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk -f program-file1 -f program-file2 ... input-file1 input-file2 ...
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.一个简单的例子&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '/foo/{print $0}' BBS-list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际的gawk程序为/foo/{print $0}，/foo/为pattern，意为搜索文件里的每一行是否含有子字串'foo'，如果含有'foo'则执行action。action为print $0，表示将现在这一行的内容打印出来。BBS-list是要处理的文件名。&lt;/p&gt;
&lt;h2&gt;3.一个较复杂的例子&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '$1 == "Feb" {sum=$2+$3}END{print sum}' shipped
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子会将输入文件shipped的第一个栏位与"Feb"做比较，如果相等，则其对应的第2栏位与第3栏位的值会被加到变量sum。对于输入文件中的每一行重复上述动作，直到输入文件的每一行都被处理过为止。最后将sum的值打印出来。END{print sum}的意思为在所有的输入读完之后，执行一次print sum的动作，也就是把sum的值打印出来。&lt;/p&gt;
&lt;h1&gt;II.读入输入文件&lt;/h1&gt;
&lt;p&gt;gawk的输入可以从标准输入或指定的文件里读取。输入的读取单位被称为"记录"(records)，gawk在做处理时，是一个记录一个记录地处理。每个记录的内定值是一行(line)，一个记录又被分为多个栏位(fields)。&lt;/p&gt;
&lt;h2&gt;1.如何将输入分解成记录(records)&lt;/h2&gt;
&lt;p&gt;gawk语言会把输入分解成记录(records)。记录与记录之间是以record separator隔开，record separator的内定值是表示新一行的字符(newline character)，因此内定的record separator使得文字的每一行是一个记录。
record separator随着内置的缺省变量RS的改变而改变。RS是一个字符串，它的内定值是"\n"。仅有RS的第一个字符是有效的，它被当作record separator，而RS的其它字符将被忽略。
内置变量FNR会储存当前的输入文件已经被读取的记录数量。内置变量NR会存储
目前为止所有的输入文件
已经被读取的记录个数。&lt;/p&gt;
&lt;h2&gt;2.栏位(field)&lt;/h2&gt;
&lt;p&gt;gawk会自动将每个记录分解成多个栏位(field)。类似于字母在一行里面，gawk的内定动作会认为栏位之间是以whitespace分开。在gawk里，whitespace的意思是一个或多个空白或者tabs。
在gawk程序里面，以'&lt;span class="math"&gt;\(1'表示第一个栏位，'\)&lt;/span&gt;2'表示第二个栏位，依次类推。举例来说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;This seems like a pretty nice example.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个栏位或&lt;span class="math"&gt;\(1是"This"，第二个栏位或\)&lt;/span&gt;2是"seems"，依次类推。特别要注意的是第七个栏位或&lt;span class="math"&gt;\(7是'example.'，而非'example'。
不论有多少个栏位，\)&lt;/span&gt;NF可以用来表示一个记录的最后一个栏位。上面的例子中&lt;span class="math"&gt;\(NF与\)&lt;/span&gt;7相同，也就是'example.'。
NF是一个内置变量，它的值表示目前这个记录的栏位个数。
$0，是一个特例，它表示整个记录不。
一个比较复杂的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '$1~/foo/{print $0}' BBS-list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子是把输入文件BBS-list的每个记录的第一个栏位检查，如果它含有字符串'foo'，则这一个记录会被打印出来。&lt;/p&gt;
&lt;h2&gt;3.如何将记录分解成栏位&lt;/h2&gt;
&lt;p&gt;gawk根据field separator将一个记录分解成栏位。field separator以内置变量FS表示。
举例来说，假如field separator是'foo'，则下面的行:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;moo goo gai pan
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会被分成三个栏位：'m'、'g'、'gai pan'。
在gawk程序里，可以使用&lt;code&gt;'='&lt;/code&gt;来改变FS的值。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'BEGIN{FS=","};{print $2}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入行如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;John Q.Smith,29 Oak St.,Walamazoo,MI 42139
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行gawk的结果将打印出子串'29 Oak st.'。BEGIN后面的action会在第一个记录被读取之前执行一次。&lt;/p&gt;
&lt;h1&gt;III.打印&lt;/h1&gt;
&lt;p&gt;在gawk程序里，actions最常做的事情就是打印(printing)。简单的打印，使用print。复杂格式的打印，使用printf。
a.print用在简单、标准的输出格式。格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;print item1,item2,...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出时，各个item之间会以一个空白分开，最后会换行(newline)。
如果'print'之后没有跟任务参数，它与'print $0'的效果一样，它会打印出现在的记录(record)。要打印出空白行可以使用'print ""'。打印出一段固定的文字，可以用双引号将文字的两边括起来，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;'print "Hello there"'。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下例，会把每个输入记录的前两个栏位打印出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{print $1,$2}' shipped
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.输出分隔符&lt;/h2&gt;
&lt;p&gt;前面说过如果print时包含有多个item，item之间用逗号分开，则打印出时各个item会被一个空白隔开。你可以使用任务字符串作为output field separator，可以经由内置参数OFS的设定值来更改output field separator。OFS的初始值为" "，即一个空格。
整个print的输出被称为output record。print输出output record之后，会接着输出一个之串，此字符串称为output record separator。内置参数ORS来指定此字符串。ORS的初始值为"\n"，也就是换行。
下面这个例子会打印出每个记录的第一个栏位和第二个栏位，此二个栏位之间以分号';'分开，每行输出之后会加入一个空白行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'BEGIN {OFS=";"; ORS="\n\n"}{print $1,$2}' BBS-list
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.printf&lt;/h2&gt;
&lt;p&gt;printf会使得输出格式容易精确地控制。printf可以指定每个item打印出的宽度，也可以指定数字的各种型式。
printf的格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;printf format,item1,item2,...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;print与printf的差别是在于format，printf的参数比print多了字符串format。format的型式与ANSI C的printf的格式相同。
printf并不会做自动换行动作。内置变量OFS与ORS对printf无效。&lt;/p&gt;
&lt;h1&gt;IV.pattern的种类&lt;/h1&gt;
&lt;p&gt;这里对gawk的各种pattern形式作一次整理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/regular expression/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个正则表达式当作一个pattern。每当输入记录(record)含有regulare expression就视为符合。&lt;/p&gt;
&lt;p&gt;expression
一个单一的expression。当一个值不为0或者一个字符串不是空的则可视为符合。&lt;/p&gt;
&lt;p&gt;pat1,pat2
一对patterns以逗号分开，指定记录的范围。&lt;/p&gt;
&lt;p&gt;BEGIN
END
这是特别的pattern，gawk在开始执行或要结束时会分别执行相对就于BEGIN或END的action。&lt;/p&gt;
&lt;p&gt;null
这是一个空的pattern，对于每个输入记录都视为符合pattern。&lt;/p&gt;
&lt;h2&gt;1.Regular Expression当作Patterns&lt;/h2&gt;
&lt;p&gt;一个regular expression可简写为regexp，是一种描述字串的方法。一个regular expression以斜线('/')包围当作gawk的pattern。
如果输入记录含有regexp就视为符合。例如：pattern为/foo/，对于任何输入记录含有'foo'则视为符合。
下例会将含有'foo'的输入记录的第2上栏位打印出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '/foo/{print $2}' BBS-list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;regexp也能使用在比较运算中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;exp ~ /regexp/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果exp符合regexp，则结果为真(true)。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;exp !~ /regexp/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果exp不符合regexp，则结果为真。&lt;/p&gt;
&lt;h2&gt;2.比较运算当作Patterns&lt;/h2&gt;
&lt;p&gt;比较的pattern用来测试两个数字或字符串的关系诸如大于、等于、小于。下面列出一些比较的pattern：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x&amp;lt;y
x&amp;lt;=y
x&amp;gt;y
x&amp;gt;=y
x==y
x!=y
x~y
x!~y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面提到的x与y，如果二者皆是数字则视为数字之间的比较，否则它们会被转换成字符串且以字符串的形式做比较。两个字符串比较，会先比较第一个字符，然后比较第二个字符，依此类推，直到有不同的地方出现为止。如果两个字符串在较短的一个结束之前是相等，则视为长的字符串比短的字符串大。例如"10"比"9"小，"abc"比"abcd"小。&lt;/p&gt;
&lt;h2&gt;3.使用布尔运算的Patterns&lt;/h2&gt;
&lt;p&gt;一个布尔pattern是使用布尔运算"||"、"&amp;amp;&amp;amp;"、"!"来组合其它的pattern。
例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '/2400/&amp;amp;&amp;amp;/foo/' BBS-list
gawk '/2400/||/foo/' BBS-list
gawk '! /foo/' BBS-list
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;V.表达式(Expression)作为Action&lt;/h1&gt;
&lt;p&gt;表达式(Expression)是gawk程序里action的基本构成者。&lt;/p&gt;
&lt;h2&gt;1.算术运算&lt;/h2&gt;
&lt;p&gt;gawk里的算术运算如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x+y
x-y
-x
+x
x*y
x/y
x%y
x^y
x**y
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.比较表达式与布尔运算&lt;/h2&gt;
&lt;p&gt;比较运算(Comparison expression)用来比较字符串或数字的关系，运算符号与C语言相同。列表如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;x&amp;lt;y
x&amp;lt;=y
x&amp;gt;=y
x==y
x!=y
x~y
x!~y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较结果为真(true)则其值是1，否则为0。
布尔运算(boolean expression)有下面三种：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;boolean1 &amp;amp;&amp;amp; boolean2
boolean1 || boolean2
! boolean
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.条件表达式(Conditional Expressions)&lt;/h2&gt;
&lt;p&gt;一个条件运算式是一种特别的算式，它含有3个运算符，条件式运算与C语言的三目运算相同：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;selector ? if-true-exp : if-flase-exp
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;VI.Actions里面的流程控制&lt;/h1&gt;
&lt;p&gt;在gawk程序里，流程控制如：if、while等与C语言类似。
很多的控制语句会包括其它的语句，被包括的语句被称为body。假如body里包括一个以上的语句，必须以大括号{}将这些语句括冬候鸟来，而各个语句之间需要以换行(newline)或分号隔开。&lt;/p&gt;
&lt;h2&gt;1.if语句&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (condition) then-body [else else-body]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果condition为真，则执行then-body，否则执行else-body
例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if(x % 2 == 0)
print "x is even"
else
print "x is odd"
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.while语句&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;while(condition)
body
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;while语句做的第一件事就是测试condition，假如condition为真则执行body中的语句，执行完后再测试condition，直到为false。如果第一次测试时condition就为false，则body中的语句从不会被执行。
下面的例子打印出每个输入记录(record)的前三个栏位。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{i=1
while(i&amp;lt;=3){
print $i
i++
}
}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.do-while语句&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;do
body
while(condition)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个do loop执行body一次，然后只要condition是true则会重复执行body。即使开始时conditon为false，body也会执行一次。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{i=1
do{
print $0
i++
}while(i&amp;lt;=10)
}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.for语句&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for(initialization;condition;increment)
body
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此语句开始时会执行initialization，然后只要condition是true，它会重复执行body与做increment。
下面的例子会打印出每个输入记录的前三个栏位：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{for(i=1;i&amp;lt;=3;i++)
print $i
}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.break语句&lt;/h2&gt;
&lt;p&gt;break语句会跳出包含它的for,while,do-while循环的最内层。
下面的例子会找出任何整数的最小除数，它也会判断是否为质数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '# find smallest divisor of num
{ num=$1
for(div=2;div*div&amp;lt;num;div++)
if(num % div == 0)
break
if(num % div == 0)
printf "Smallest divisor of %d is %d\n",num,div
else
printf "%d is prime\n",num}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.continue语句&lt;/h2&gt;
&lt;p&gt;continue语句用于for,while,do-while循环内部，它会跳过循环body中其余的部分，使得它立即进入下一次循环。
下面的例子会打印出0至20的全部数字，但是5并不会被打印出来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'BEGIN{
for(x=0;x&amp;lt;=20;x++){
if(x==5)
continue
printf ("%d",x)
}
print ""
}'
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7.next，next file，exit语句&lt;/h2&gt;
&lt;p&gt;next语句强迫gawk立即停止处理目前的记录(record)而继续下一个记录。
next file语句类似next。然而，它强迫gawk立即停止处理当前的文件。
exit语句会使得gawk程序立即停止执行而跳出。而且如果END出现，它会去执行END的actions。&lt;/p&gt;
&lt;h1&gt;VII.内置函数&lt;/h1&gt;
&lt;p&gt;内置函数是gawk内置的函数，可以在gawk程序的任何地方调用内置函数。&lt;/p&gt;
&lt;h2&gt;1.数值方面的内置函数&lt;/h2&gt;
&lt;p&gt;int(x)求x的整数部分，朝向0的方向做舍去。例如:int(3.9)是3，int(-3.9)是-3。&lt;/p&gt;
&lt;p&gt;sqrt(x)求x的平方根值。&lt;/p&gt;
&lt;p&gt;exp(x)求x的次方。&lt;/p&gt;
&lt;p&gt;log(x)求x的自然对数。&lt;/p&gt;
&lt;p&gt;sin(x)求x的sine值，x是经度量。&lt;/p&gt;
&lt;p&gt;cos(x)求x的cosine值，x是经度量。&lt;/p&gt;
&lt;p&gt;atan2(y,x)求y/x的arctangent值，所求出的值其单位是经度量。&lt;/p&gt;
&lt;p&gt;rand()得出一个伪随机数。此数值在0和1之间，但不等于0或1。
每次执行gawk，rand开始产生数字从相同点或seed。&lt;/p&gt;
&lt;p&gt;srand(x)设定产生随机数的开始点或者seed为x。如果在第二次你设定相同的seed值，你将再度得到相同序列的随机数。如果参数x被省略，则现在日期、时间会被当成seed。这个方法可以使得产生的随机数是真正不可预测的。srand的返回值是前次所设定的seed值。&lt;/p&gt;
&lt;h2&gt;2.字符串方面的内置函数&lt;/h2&gt;
&lt;p&gt;index(in,find)
它会在字符串in里面，寻找字符串find第一次出现的地方，返回值是字符串find出现在字符串in里面的位置。如果在in里找不到find，则返回0。
例如：
print index("prenut","an")
将打印出3。&lt;/p&gt;
&lt;p&gt;length(string)
求出string有几个字符。&lt;/p&gt;
&lt;p&gt;match(string,regexp)
在字符串string里找到符合regexp的最长的最靠左边的子字符串。返回值是regexp在string的开始位置，即index值。match函数会设置内置变量RSTART等于index，它也会设置内置变量RLENGTH等于符合的字符个数。如果不符合，则会设定RSTART为0、RLENGTH为-1。&lt;/p&gt;
&lt;p&gt;sprintf(fomat,expression,...)
举printf类似，但是sprintf并不打印出来，而是返回字符串。
例如：
sprintf("pi = %.2f(approx.)',22/7)
返回的字符串为"pi = 3.14(approx.)"&lt;/p&gt;
&lt;p&gt;sub(regexp,replacement,target)
在字符串target里面，寻找符合regexp的最长、最靠左边的地方，以字符串replacement代替最左边的regexp。
例如：
str = "water,water,everywhere"
sub(/at/,"ith",str)
结果字符串str会变成
"wither,water,everywhere"&lt;/p&gt;
&lt;p&gt;gsub(regexp,replacement,target)
gsub与前面的sub类似。在字符串target里面，寻找符合regexp的所有地方，以字符串replacement代替所有的regexp。
例如：
str="water,water,everywhere"
gsub(/at/,"ith",str)
结果字串str变成
"wither,wither,everywhere"&lt;/p&gt;
&lt;p&gt;substr(string,start,length)
传回字符串string的子串，这个字串的长度为length个字符。
从第start个位置开始。
例如：
substr("washington",5,3)
返回值为"ing"
如果length没有出现，则返回的字符串是从第start个位置开始至结束。
substr("washington",5)
返回值为"ington"&lt;/p&gt;
&lt;p&gt;tolower(string)
将字符串string的大写字母改为小写字母。&lt;/p&gt;
&lt;p&gt;toupper(string)
将字符串string的小写字母改为大写字母。&lt;/p&gt;
&lt;h2&gt;3.输入输出的内置函数&lt;/h2&gt;
&lt;p&gt;close(filename)
将输入或输出的文件关闭&lt;/p&gt;
&lt;p&gt;system(command)
执行操作系统命令，执行完毕后返回gawk&lt;/p&gt;
&lt;h1&gt;VIII.用户定义的函数&lt;/h1&gt;
&lt;p&gt;复杂的gawk程序常常可以使用自己定义的函数来简化。调用自定义的函数与调用内置函数的方法一样。&lt;/p&gt;
&lt;h2&gt;1.函数定义的格式&lt;/h2&gt;
&lt;p&gt;函数的定义可以放在gawk程序的任何地方。
一个自定义函数的格式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;parameter&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;list&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="nx"&gt;body&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;of&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;name是所定义的函数名称，名称可以是字母、数字、下划线，但不能以数字开头。
parameter-list是函数参数，以逗号分开。
body-of-function包含gawk的语句。&lt;/p&gt;
&lt;h2&gt;2.函数定义的例子&lt;/h2&gt;
&lt;p&gt;下面这个例子，将每个记录的第一个栏位之值的平方与第二个栏位之值的平方加起来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;"sum ="&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;SquareSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;$2&lt;/span&gt;&lt;span class="p"&gt;)}&lt;/span&gt;
&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;SquareSum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="nx"&gt;sum&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;y&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;sum&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;IX.范例&lt;/h1&gt;
&lt;p&gt;一些gawk程序的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{if(NF&amp;gt;max)max=NF}
END {print max}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印出所有输入行中，栏位的最大个数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'length($0)&amp;gt;80'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印出超过80个字符的一行。此处只有pattern被列出，action是采用内置的print。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'NF &amp;gt; 0'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印至少有一个栏位的所有行。这是一个简单的方法，将一个文件中的空白行删除。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{if(NF &amp;gt;0)print}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与上例相同&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'BEGIN {for (i=0;i&amp;lt;7;i++)
print int(101 * rand())}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此程序会打印出范围在0-100之间的7个随机数值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ls -l files | gawk '{x+=$4};END{print "total bytes:" x}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印出所有指定文件之bytes数目的总和。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;expand file | gawk '{if(x&amp;lt;length()) x = length()}}
END{print "maxinum line length is " x}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将指定文件里最长一行的长度打印出来。expand会将tab改成space，所以是用实际的右边界来做长度的比较。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'BEGIN {FS=":"}
{print $1 | "sort"} /etc/password
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此程序会将所有用户的登录名称，按字母顺序打印出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{nlines++}
END {print nlines}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将文件的总行数打印出来&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk 'END {print NR}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同上例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gawk '{print NR,$0}'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印文件的内容时，会在每行的最前面打印出行号，它的功能与'cat -n'类似&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="awk"></category><category term="linux"></category></entry><entry><title>Python 编码规则</title><link href="/python-bian-ma-gui-ze.html" rel="alternate"></link><published>2007-06-19T00:00:00+08:00</published><updated>2007-06-19T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-06-19:/python-bian-ma-gui-ze.html</id><summary type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;呆板的坚持使用一致性是傻得没边！(A Foolish Consistency is the Hobgoblin of Little Minds)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打破一条既定规则的两个好理由：
 a. 当应用这个规则是将导致代码可读性下降，即便对某人来说，他已经习惯于按这条规则来阅读代码了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b. 为了和周围的代码保持一致而打破规则（也许是历史原因）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码布局
 a. 缩进
使用Emacs的Python-mode的默认4个空格。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;永远不要混用制表符和空格，最流行的方式是采用空格，其次是使用制表符。混合空格和制表符的代码将被转换成空格。（Emacs中，选中整个缓冲区，按ESC-x去除制表符（untabilfy))。调用Python解释器时-t选项，可对混合制表符和空白的发出警告，-tt时警告将变成错误。&lt;/p&gt;
&lt;p&gt;b. 行
将行限制在79个字符，对顺序排放的大文本块或者注释推荐限制在72个字符。&lt;/p&gt;
&lt;p&gt;折叠长行的首选方法是使用Python支持的圆括号，方括号和花括号内的行延续。如果需要你可以在表达式周围增加一对额外的圆括号，但有时使用反斜杠看起来更好。&lt;/p&gt;
&lt;p&gt;c. 空行&lt;/p&gt;
&lt;p&gt;用两行空行分割顶层函数和类的定义，类内方法的定义使用单个行分割，额外的空行可被用于相关函数组成的群。在一组相关的单句中间可以省略空行。&lt;/p&gt;
&lt;p&gt;当空行用于分割方法的定义时，在'class'行和第一个方法定义之间也需要一个空行。&lt;/p&gt;
&lt;p&gt;在函数中使用空行时 …&lt;/p&gt;</summary><content type="html">&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;呆板的坚持使用一致性是傻得没边！(A Foolish Consistency is the Hobgoblin of Little Minds)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打破一条既定规则的两个好理由：
 a. 当应用这个规则是将导致代码可读性下降，即便对某人来说，他已经习惯于按这条规则来阅读代码了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b. 为了和周围的代码保持一致而打破规则（也许是历史原因）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码布局
 a. 缩进
使用Emacs的Python-mode的默认4个空格。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;永远不要混用制表符和空格，最流行的方式是采用空格，其次是使用制表符。混合空格和制表符的代码将被转换成空格。（Emacs中，选中整个缓冲区，按ESC-x去除制表符（untabilfy))。调用Python解释器时-t选项，可对混合制表符和空白的发出警告，-tt时警告将变成错误。&lt;/p&gt;
&lt;p&gt;b. 行
将行限制在79个字符，对顺序排放的大文本块或者注释推荐限制在72个字符。&lt;/p&gt;
&lt;p&gt;折叠长行的首选方法是使用Python支持的圆括号，方括号和花括号内的行延续。如果需要你可以在表达式周围增加一对额外的圆括号，但有时使用反斜杠看起来更好。&lt;/p&gt;
&lt;p&gt;c. 空行&lt;/p&gt;
&lt;p&gt;用两行空行分割顶层函数和类的定义，类内方法的定义使用单个行分割，额外的空行可被用于相关函数组成的群。在一组相关的单句中间可以省略空行。&lt;/p&gt;
&lt;p&gt;当空行用于分割方法的定义时，在'class'行和第一个方法定义之间也需要一个空行。&lt;/p&gt;
&lt;p&gt;在函数中使用空行时，表示一个逻辑段落。&lt;/p&gt;
&lt;p&gt;Python接受Ctrl+L换页符作为空格，Emacs和一些打印工具视这个为分页符。因此可以在代码中用它来为相关代码片段分页。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编码
Python核心发布中的代码必须始终使用ASCII或Latin=1(ISO-8859-1).使用ASCII的文件不必有译码cookie(coding cookie)。Latin-1公当注释或文档字符串涉及作者名字需要Latin-1时才被使用；另外\x转义字符是在字符串中包含非ASCII数据的首选方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Python 2.4以后内核支持Unicode。&lt;/p&gt;
&lt;p&gt;不论什么情况使用UTF-8吧！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导入
通常应该在单独的行中导入，例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;No&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="n"&gt;Yes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样也是可以的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;type&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;StringType&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ListType&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Imports通常被放置在文件的顶部，仅在模块注释和文档字符串之后，在模块的全局变量和常量之前。Imports应该有顺序的成组放置：&lt;/p&gt;
&lt;p&gt;a. 标准库的导入&lt;/p&gt;
&lt;p&gt;b. 相关的主包的导入&lt;/p&gt;
&lt;p&gt;c. 特定应用的导入&lt;/p&gt;
&lt;p&gt;应该在每组导入之间放置一个空行&lt;/p&gt;
&lt;p&gt;对于内部包的导入是不推荐使用相对导入，所有的导入都应使用包的绝对路径&lt;/p&gt;
&lt;p&gt;从一个包含类的模块中导入类时，通常可以写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;MyClass&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;MyClass&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;foo.bar.YourClass&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;YourClass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这样写导致了本地名字冲突，就写成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;MyClass&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;foo.bar.YourClass&lt;/span&gt; &lt;span class="nn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;YourClass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即使用"MyClass.MyClass"和"foo.bar.YourClass.YourClass"&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空格
  Guido不喜欢在以下地方出现空格：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a. 紧挨着圆括号、方括号、花括号的&lt;/p&gt;
&lt;p&gt;b. 紧贴在逗号、分号、冒号前的&lt;/p&gt;
&lt;p&gt;c. 紧贴着函数调用的参数列表前开式括号的，如"spam (1)"要写成"spam(1)"&lt;/p&gt;
&lt;p&gt;d. 紧贴在索引或切片开始的开式括号前的&lt;/p&gt;
&lt;p&gt;e. 在赋值（或其它）运算符周围的用于和其它并排的一个以上的空格&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其它建议
 a. 始终在这些二元运算符两边放置一个空格：=,==,&amp;lt;,&amp;gt;,!=,&amp;lt;&amp;gt;,&amp;lt;=,&amp;gt;=,is,is not,in,not in布尔运算符and,or,not。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b. 按你的看法在算术运算符周围插入空格，始终保持二元运算符两边空格的致。&lt;/p&gt;
&lt;p&gt;c. 不要在用于指定关键字参数或默认参数值的"&lt;code&gt;=&lt;/code&gt;"周围使用空格。&lt;/p&gt;
&lt;p&gt;e. 不要将多条语句写在同一行上&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注释
 a. 同代码不一致的注释比没注释更差，当代码修改时，始终优先更新注释。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;b. 注释应该是完整的句子。如果注释是一个句子或短语，首字母应该大写，除非是一个小写开头的标识符（永远不要修改标识符的大小写）。&lt;/p&gt;
&lt;p&gt;c. 如果注释很短，最好省略末尾的句号。注释块通常由一个或多个完整句子构成的段落组成。每个句子应该以句号结束。&lt;/p&gt;
&lt;p&gt;d. 应该在句末，句号后使用两个空格，以便Emacs的断行和填充工作能正常工作。"."给出了文档结构的提示&lt;/p&gt;
&lt;p&gt;e. 用英语书写时，断词和空格是可用的。&lt;/p&gt;
&lt;p&gt;f. 非英语国家的Python程序员，请使用英语写你的注释，除非你120%的确信，这些代码不会被不懂你语言的人阅读。&lt;/p&gt;
&lt;p&gt;g. 编写使用统一的文档化注释格式有得于良好习惯和团队建议！&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;注释块
 a. 注释块通常应用于跟随着一些（或全部）代码并和这些代码有着相同的缩进层次。注释块中每行以#和一个空格开始。注释块中的段落以仅含单个#的行分割，注释块上下方最好有一空行包围（或上方两行下方一行，对一个新函数定义段的注释。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行内注释
一个行内注释是和语句在同一行的注释，行内注释应该谨慎使用。行内注释应该至少用两个空格和语句分开，它们应该以#和单个空格开始。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文档化
应该一直遵守编写好的文档字符串(docstring)的约定。
为所有公共模块、函数、类和方法编写文档字符串。文档字符串对非公开的方法不是必要的，但你应该有一个描述这个方法做什么的注释，这个注释应该在"def"这个行后&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多行文档字符串最后的""",应该单独成行。&lt;/p&gt;
&lt;p&gt;单行文档字符串最后的""",可以在同一行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;版本标记
例：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;__version__=="$Revision: 1.4$"
# $Source: E:/cvsroot/python_doc/pep8.txt,v$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个行应该包含在模块的文档字符串之后，所有代码之前，上下用一个空行分隔。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命名约定
应该避免的名字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;永远不要用字符'l'，'O'，或'I'作单字符的变量名。在某些字体中，这些字符不能与数字1和0分开，当然要使用'l'时，使用'L'代替它。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;模块名
模块应该是不含下划线的、 简短的、小写的名字。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为模块名被映射到文件名，有些文件系统大小写不敏感并且截短长名字，模块名被选为相当短是重要的。&lt;/p&gt;
&lt;p&gt;当一个用C或C++写的扩展模块有一个伴随的Python模块，这个Python模块提供了一个更高层的接口时，C/C++模块有一个前导下划线。&lt;/p&gt;
&lt;p&gt;Python包应该是不含下划线的、简短的、全小写的名字。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;类名
类名总是使用首字母大写单词串的约定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常名
如果模块对所有情况定义了单个异常，它通常被叫做"error"或"Error"。似乎内建（扩展）模块使用"error"，而Python模块通常用"Error"，趋势似乎是倾向于使用CapWords异常名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局变量名
让我们希望这些变量打算只被用于模块内部，这些约定与那些用于函数的约定差不多，被设计为可以通过"from M import *"来使用的那些模块，应该在那些不想被导入的全局变量（还有内部函数和类）前加一个下划线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数名
函数名应该为小写，可能用下划线风格单词可以增加可读性。mixedCase仅被允许用于这种风格已经占优势的上下文，以便保持向后兼容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法名称和实例变量
这段大体和函数相同，通常用小写，必要时使用下划线。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用一个前导下划线仅用于不打算作为类的公共接口的内部方法和实例变量。&lt;/p&gt;
&lt;p&gt;使用两个前导下划线以表示类私有的名字。通常双前导下划线应该只用来避免与类（可以为子类化所设计）中的属性发生名字冲突。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承的设计
始终要确定一个类中的方法和实例变量是否要被公开，通常，永远不要将数据变量公开，除非你本质上实现的只是记录，人们总是共喜欢给类提供一个函数的接口作为替换。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同样，确定你的属性是否应该为私有的，私有的与非私有的区别在于：前者永远不会被用在一个派生类中，而后者可能会。是的，你应该在大脑中就用继承设计好了你的类。&lt;/p&gt;
&lt;p&gt;私有属性必须有两个前置下划线，无后置下划线。&lt;/p&gt;
&lt;p&gt;非公有属性必须有一个前导下划线，无后置下划线。&lt;/p&gt;
&lt;p&gt;公共属性没有前导和后置下划线，除非它们与保留字冲突，在这种情况下，单个后置下划线比前置或混乱的拼写要好，例如：class_比klass好。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计建议&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同象None之类的单值进行比较，应该永远用：'is'或'is not'来做，当你本意是"if x is not None时，对写成"if x"要小心－－例如当你测试一下默认值为None的变量或参数是否被设置为其它值时，这个其它值也可能是一个在布尔上下文中为假的值！&lt;/p&gt;
&lt;p&gt;基于类的异常总是好过基于字符串的异常，模块和包应该定义它们自己的域内特定的基异常类（base exception class），基类应该是内建的Exception类的子类，还始终包含一个类的的文档字符串，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;MessageError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
      &lt;span class="s2"&gt;"""Base class for errors in the email package."""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用字符串方法代替字符串模块，除非必须向后兼容Python2.0以前的版本。字符串方法总是非常快，而且和unicode字符串共用同样的API。&lt;/p&gt;
&lt;p&gt;在检查前缀和后缀时避免对字符串进行切片。&lt;/p&gt;
&lt;p&gt;用startswith()和endswith()代替，因为它们是明确的并且错误更少，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;No&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;[:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;Yes&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startswith&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="o"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例外是如果你的代码必须工作在Python1.5.2以前。&lt;/p&gt;
&lt;p&gt;对象类型的比较应该始终用isinstance()代替直接比较类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;No&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;):&lt;/span&gt;
&lt;span class="n"&gt;Yes&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;isinstance&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查一个对象是否是字符串时，谨记它也可能是unicode字符串！在Python2.3，str和unicode有公共的基类，basestring，所以你可以这样做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if isinstance(obj,basestring)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python2.2类型模块为此定义了StringType类型。&lt;/p&gt;
&lt;p&gt;对序列，（字符串（strings)，列表(lists)，元组(tuple)）使用空列表是false这个事实，因此"if not seq"或"if seq"比"if len(seq)"或"if not len(seq)"好。&lt;/p&gt;
&lt;p&gt;书写字符串文字时不要依赖于有意义的的后置空格，这种后置空格在视觉上是不可辩别的，并且有些编辑器会把它们修整掉。&lt;/p&gt;
&lt;p&gt;不要用==来比较布尔型的值以确定是True或False。 &lt;/p&gt;</content><category term="python"></category></entry><entry><title>Sed Tips</title><link href="/sed-tips.html" rel="alternate"></link><published>2007-06-19T00:00:00+08:00</published><updated>2007-06-19T00:00:00+08:00</updated><author><name>Jamsa</name></author><id>tag:None,2007-06-19:/sed-tips.html</id><summary type="html">&lt;h1&gt;I介绍&lt;/h1&gt;
&lt;h2&gt;1. sed可以完成的工作&lt;/h2&gt;
&lt;p&gt;sed最常用在编辑那些需要不断重复某些编辑动作的文件上。&lt;/p&gt;
&lt;p&gt;可以用sed完成一些重复性的工作。&lt;/p&gt;
&lt;p&gt;sed可以一次执行多个不同的编辑动作。&lt;/p&gt;
&lt;h2&gt;2. sed能做哪些编辑动作&lt;/h2&gt;
&lt;p&gt;删除、修改、添加、插入、合并文件中的资料行，或读入其它文件的资料到文件中，也可以替换其中的字符串、转换其中的字母等。&lt;/p&gt;
&lt;h2&gt;3. sed工作流程&lt;/h2&gt;
&lt;p&gt;从输入中读入内容，操作完毕后发送到标准输出。&lt;/p&gt;
&lt;h1&gt;II使用sed&lt;/h1&gt;
&lt;p&gt;sed命令可以分成编辑指令与文件指令两部分。编辑指令负责控制所有编辑工作，文件指令处理文件。编辑指令由位址与函数两部分组件，位址指令用于定位对象，而编辑指令用于编辑对象。&lt;/p&gt;
&lt;h2&gt;1. 命令行上的编辑指令&lt;/h2&gt;
&lt;p&gt;在命令行上执行sed指令时用-e参数，如果sed指令在文件中用-f参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -e '编辑指令1' -e '编辑指令2' ...文件一 ...文件二
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -e '1,10d' -e 's/yellow/black/g' yel.dat …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h1&gt;I介绍&lt;/h1&gt;
&lt;h2&gt;1. sed可以完成的工作&lt;/h2&gt;
&lt;p&gt;sed最常用在编辑那些需要不断重复某些编辑动作的文件上。&lt;/p&gt;
&lt;p&gt;可以用sed完成一些重复性的工作。&lt;/p&gt;
&lt;p&gt;sed可以一次执行多个不同的编辑动作。&lt;/p&gt;
&lt;h2&gt;2. sed能做哪些编辑动作&lt;/h2&gt;
&lt;p&gt;删除、修改、添加、插入、合并文件中的资料行，或读入其它文件的资料到文件中，也可以替换其中的字符串、转换其中的字母等。&lt;/p&gt;
&lt;h2&gt;3. sed工作流程&lt;/h2&gt;
&lt;p&gt;从输入中读入内容，操作完毕后发送到标准输出。&lt;/p&gt;
&lt;h1&gt;II使用sed&lt;/h1&gt;
&lt;p&gt;sed命令可以分成编辑指令与文件指令两部分。编辑指令负责控制所有编辑工作，文件指令处理文件。编辑指令由位址与函数两部分组件，位址指令用于定位对象，而编辑指令用于编辑对象。&lt;/p&gt;
&lt;h2&gt;1. 命令行上的编辑指令&lt;/h2&gt;
&lt;p&gt;在命令行上执行sed指令时用-e参数，如果sed指令在文件中用-f参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -e '编辑指令1' -e '编辑指令2' ...文件一 ...文件二
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sed -e '1,10d' -e 's/yellow/black/g' yel.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在面的命令中'1,10d'执行删除1到10行，s/yellow/black/g'将yellow字符串替换成black字符串。&lt;/p&gt;
&lt;h2&gt;2. 编辑指令的格式如下：&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[address1[,address2]]function[argument]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;address1,address2为行数或者正则表达式，用于定位所编辑的对象。function[argument]为sed的内置函数，表示在对象上执行的动作。&lt;/p&gt;
&lt;h2&gt;3. 定位(address)参数的表示方法：&lt;/h2&gt;
&lt;p&gt;下面举例以使用函数参数d为例：&lt;/p&gt;
&lt;p&gt;a. 删除文件内第10行的内容，则指令为10d&lt;/p&gt;
&lt;p&gt;b. 删除含有'man'字符串的行，指令为/man/d&lt;/p&gt;
&lt;p&gt;c. 删除文件内第10行到第20行，为10,20d&lt;/p&gt;
&lt;p&gt;d. 删除第10行到含有'man'字符串的行，则指令为10,/man/d&lt;/p&gt;
&lt;p&gt;定位参数的说明：&lt;/p&gt;
&lt;p&gt;a. 定位参数为十进制数字：此数字表示行数。&lt;/p&gt;
&lt;p&gt;b. 定位参数为正则表达式，当输入中有符合该表达式时，执行编辑动作。&lt;/p&gt;
&lt;h2&gt;4. 函数参数&lt;/h2&gt;
&lt;p&gt;函數參數    功能&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;: label     建立 script file 內指令互相參考的位置。 
#   建立註解 
{ }     集合有相同位址參數的指令。 
!   不執行函數參數。 
=   印出資料行數( line number )。 
a\  添加使用者輸入的資料。 
b label     將執行的指令跳至由 : 建立的參考位置。 
c\  以使用者輸入的資料取代資料。
d   刪除資料。 
D   刪除 pattern space 內第一個 newline 字母 \ 前的資料。 
g   拷貝資料從 hold space。 
G   添加資料從 hold space 至 pattern space 。 
h   拷貝資料從 pattern space 至 hold space 。 
H   添加資料從 pattern space 至 hold space 。 
l   印出 l 資料中的 nonprinting character 用 ASCII 碼。 
i\  插入添加使用者輸入的資料行。 
n   讀入下一筆資料。 
N   添加下一筆資料到 pattern space。 
p   印出資料。 
P   印出 pattern space 內第一個 newline 字母 \ 前的資料。 
q   跳出 sed 編輯。 
r   讀入它檔內容。 
s   替換字串。 
t label     先執行一替換的編輯指令 , 如果替換成牛p&amp;gt;則將編輯指令跳至 : label 處執行。 
w   寫資料到它檔內。 
x   交換 hold space 與 pattern space 內容。 
y   轉換(transform)字元。
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5. 执行文件中的编辑指令&lt;/h2&gt;
&lt;p&gt;当执行的指令过多时，可以将指令放到文件中。用sed -f script_file执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -f script_file ...文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -f ysb.scr yel.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，ysb.scr的内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1,10d
s/yellow/black/g
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6. 执行多个文件的编辑&lt;/h2&gt;
&lt;p&gt;在sed命令行上，一次可以执行编辑多个文件，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e 's/yellow/blue/g' white.dat red.dat black.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sed将从左至右依次处理各个文件。&lt;/p&gt;
&lt;h2&gt;7. 执行输出控制&lt;/h2&gt;
&lt;p&gt;默认情况下处理后的结果输出到标准输出。但通过-n，可以将输出的控制权交给sed，由编辑指令来决定结果是否输出。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -n -e '/white/p' white.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上例中-n与编辑指令/white/p一起配合控制输出。-n将输出控制权交给编辑指令，/white/p将含有'white'的字符串打印出来。&lt;/p&gt;
&lt;h1&gt;III范例&lt;/h1&gt;
&lt;p&gt;操作需求描述：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    将文件中...资料，执行...(动作)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当需要执行多个动作时，指令形式如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    位置参数{
        函数参数1
        函数参数2
        函数参数3
         .
         .
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1. 替换文件中的资料&lt;/h2&gt;
&lt;p&gt;a. 将文件中含'machine'字符串的资料选中的'phi'字符串替换成'beta'字符串&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '/machine/s/phi/beta/g' input.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b. 将文件中第5行资料，替换成'This is a test.'&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '5c\
    This is a test.
    ' input.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c. 将文件中1至100行的资料替换成如下两行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    How are you?
    data be deleted!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '1,100c\
    How are you?\
    data be deleted!
    ' input.dat
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. 移动文件中的资料&lt;/h2&gt;
&lt;p&gt;可以使用sed中的hold space暂存编辑中的资料，用函数w将文件资料搬到它档内存储，或者用函数r半它档内容搬到文件内。当执行函数参数h,H时会将pattern space资料暂存到hold space,当执行x,g,G时，会将暂存的资料取到pattern space&lt;/p&gt;
&lt;p&gt;a. 将文件中前100行，搬到文件第300行后。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -f mov.src 文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mov.src 内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1,100{
H
d
}
300G
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;1,100{
H
d
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表示将文件前100行，先储存在hold space之后删除。指令300G表示将hold space内的资料，添加在第300行后输出。&lt;/p&gt;
&lt;p&gt;b. 将文件中含'phi'字符串的行，搬至mach.inf中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '/phi/w mach.inf' 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c. 将mach.inf中的内容，移到文件中含'beta'字符串的行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '/beta/r march.inf' 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外由于sed是一个流编辑器，理论上输出后的文件资料不可能再搬回来编辑。&lt;/p&gt;
&lt;h2&gt;3. 删除文件中的资料&lt;/h2&gt;
&lt;p&gt;因为sed是行编辑器，所以sed很容易删除行，或者整个资料。一般用d或D来删除。&lt;/p&gt;
&lt;p&gt;a. 将文件内的所有空白行全部删除：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '/^$/d' 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正则表达式中'^&lt;span class="math"&gt;\('表示空白，'^'表示行开头，'\)&lt;/span&gt;'表示行结尾。&lt;/p&gt;
&lt;p&gt;b. 将文件内连续的空白行，删除成一行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -e '/^$/{
    N
    /^$/D
    }' 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中N表示将空白的下一行资料加至pattern space内。函数参数/^$/D表示，当添加的是空白行时，删除第一行空白行，而且剩下的空白行则再重新执行一次指令。如此反复，最后只留下一行空白行了。&lt;/p&gt;
&lt;h2&gt;4. 搜索文件中的资料&lt;/h2&gt;
&lt;p&gt;sed可以执行类似UNIX命令grep的功能。理论上可以用正则表达式将文件中匹配的内容输出。&lt;/p&gt;
&lt;p&gt;例如将文件中包含'gamma'的内容输出&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -n -e '/gamma/p' 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但sed是行编辑器，它搜寻基本上是以行为单位。因此，当一些字符串因换行被拆分成两部分时，一般的方法即不可行。此时，就必须以合并行的方式来搜寻这些资料。例：&lt;/p&gt;
&lt;p&gt;将文件中仿'omega'字符串的资料输出。其命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    sed -f gp.scr 文件名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gp.scr内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/omega/b
N
h
s/.*\n//
/omega/b
g
D
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上述sed script中，因函数参数b形成类似C语言中的case结构，使得sed可以分别处理当资料内含'omega'字串，当'omega'字符串被拆成两行，以及资料内没有'omega'字串的情况。下面分三种情况讨论：&lt;/p&gt;
&lt;p&gt;a. 当资料内仿'omega'，则执行编辑指令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/omega/b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它表示当资料内含有'omega'字符串时，sed不再执行它后面的指令，而直接将它输出。&lt;/p&gt;
&lt;p&gt;b. 当资料内没有'omega'，则执行编辑指令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;N
h
s/.*\n//
/omega/b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，函数参数N，表示将下一行资料读入使得pattern space内含前后两行资料。函数参数h表示将pattern space内的前后两行资料存入hold space。函数参数s/.*\n//，它表示将pattern space内的前后两行资料进行合并成一行。/omega/b，它表示如果合并后的资料内含'omega'字符串，则不再执行后面的指令，而将此资料自动输出。&lt;/p&gt;
&lt;p&gt;c. 当合并后的资料依旧不含'omega'，则执行编辑指令如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;g
D
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，函数参数g，它表示将hold space内合并前的两行资料放回pattern space。函数参数D，它表示删除两行资料中的第一行资料，并让剩下的那行资料，重新执行sed script。如此，无论是资料行内或行间的字符串都可以搜索到。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' &amp;&amp; location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' }, Macros: {} }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="linux"></category><category term="sed"></category></entry></feed>