<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="author" content="Jamsa" />
        <meta name="robots" content="index, follow"/>

        <meta property="og:title" content="SICP读书笔记"/>
        <meta property="og:url" content="/sicpdu-shu-bi-ji.html"/>
        <meta property="og:site_name" content="Jamsa的笔记"/>
        <meta property="og:type" content="article"/>

        <link rel="canonical" href="/sicpdu-shu-bi-ji.html" />

        <title>SICP读书笔记 | Jamsa的笔记</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" />
        

        <link rel="stylesheet" type="text/css" href="/theme/css/main.css" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Jamsa的笔记 Atom Feed" />

        <script type="text/javascript">var switchTo5x=true;</script>
        <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
        <script type="text/javascript">
         stLight.options({
             publisher: "",
             doNotHash: false,
             doNotCopy: false,
             hashAddressBar: false
         });
        </script>
    </head>

    <body id="index">
        <div class="row-fluid">
            <div class="span10 offset1">
                <header id="banner" >
                    <h1>
                        <a href="/">Jamsa的笔记 </a>
                    </h1>
                    <nav class="navbar">
                        <div class="navbar-inner">
                            <ul class="nav">
                                <li ><a href="/category/da-shu-ju.html">大数据</a></li>
                                <li ><a href="/category/fang-fa.html">方法</a></li>
                                <li ><a href="/category/ji-qi-xue-xi.html">机器学习</a></li>
                                <li class="active"><a href="/category/kai-fa.html">开发</a></li>
                                <li ><a href="/category/qian-duan.html">前端</a></li>
                                <li ><a href="/category/xiao-lu.html">效率</a></li>
                                <li ><a href="/category/yi-dong.html">移动</a></li>
                            </ul>

                        </div>
                    </nav>
                </header><!-- /#banner -->
            </div>
        </div>

        <div class="row-fluid">
            <div class="span10 offset1">
                <div class="row-fluid">
<div class="span10 offset1">
  <section>
    <article>
      <header>
        <h1 class="entry-title">
          <a href="/sicpdu-shu-bi-ji.html" rel="bookmark"
             title="Permalink to SICP读书笔记">SICP读书笔记</a></h1>
      </header>
      <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="/author/jamsa.html">Jamsa</a>
    </address>

    in <a href="/category/kai-fa.html">开发</a>

    on 2010-08-31

        |
        tags:         <a href="/tag/lisp.html">lisp</a>
        <a href="/tag/scheme.html">scheme</a>



    
</footer><!-- /.post-info -->

        <h1>Chap.1 Building Abstractions with Procedures</h1>
<p>在思考活动中通过简单的想法尽力实现强大能量，首要有三： 1. 将多个简单的想法组合成单个的复杂的想法，因而可以完成所有复杂的想法。2. 将两个想法，不论它们是简单或复杂，放到一起，将他们彼此设置并立即观察他们，而不将它们组织成一个想法，通过这种方法可以得到想法之间的关系。3. 将他们从现实的已经存在的其它想法中分离出来：这称为抽象，这样可以构成这些想法的通用想法。</p>
<p>计算机语言完成任务的三个机制：</p>
<ul>
<li>
<p>原生表达式，它描述了语言所关心的最简单的实体。</p>
</li>
<li>
<p>组合的方法，复合元素是从简单元素构成的。</p>
</li>
<li>
<p>抽象的方法，通过抽象复合元素可以被命名和作为单元被处理。</p>
</li>
</ul>
<p>在编程过程中，我们处理两种类型的元素：过程和数据。数据是要处理的&ldquo;原材料&rdquo;，而过程是处理数据的规则的描述。因此，任何一门强大的编程语言应该能够 描述原生数据类型和原生过程，应该有组合和抽象过程和数据的方法。</p>
<h2>Exercise 1.2 将下面的表达式转换为form</h2>
<p><img alt="ch1-z-g-3" src="/SICP/ch1-z-g-3.gif"/></p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="mi">5</span> <span class="mi">4</span> <span class="p">(</span><span class="nb">- </span><span class="mi">2</span> <span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">6</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">4</span> <span class="mi">3</span><span class="p">)))))</span> <span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="p">(</span><span class="nb">- </span><span class="mi">6</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="mi">2</span> <span class="mi">7</span><span class="p">)))</span>
</pre></div>
<h2>Exercise 1.3 定义一个过程接收3个参数返回最大的两个参数的平方和</h2>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">square</span> <span class="nv">a</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">a</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum-max-square</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&gt;= </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
                   <span class="p">((</span><span class="nb">&gt;= </span><span class="nv">a</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
                   <span class="p">(</span><span class="k">else </span><span class="mi">0</span><span class="p">)))</span>
     <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&gt;= </span><span class="nv">b</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span>
                   <span class="p">((</span><span class="nb">&gt;= </span><span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span>
                   <span class="p">(</span><span class="k">else </span><span class="mi">0</span><span class="p">)))</span>
     <span class="p">(</span><span class="nf">square</span> <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">&gt;= </span><span class="nv">c</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span>
                   <span class="p">((</span><span class="nb">&gt;= </span><span class="nv">c</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span>
                   <span class="p">(</span><span class="k">else </span><span class="mi">0</span><span class="p">)))))</span>
</pre></div>
<h2>Exercise 1.4 观察下面的求值模型它整合了操作符和表达式。</h2>
<p>这个例子体现了 scheme 与 common lisp 的区别。</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">a-plus-abs-b</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">((</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">b</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">+</span> <span class="nv">-</span><span class="p">)</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">))</span>
</pre></div>
<p>它将根据 b 是否大于 0 来决定对 a 和 b 进行加或减操作。</p>
<h2>Exercise 1.5 应用序或正则序测试</h2>
<p>Ben Bitdiddle 发明了一种检测解释器是应用序还是正则序的方法。先定义两个过程：</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">p</span><span class="p">)</span> <span class="p">(</span><span class="nf">p</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">test</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="nv">y</span><span class="p">))</span>
</pre></div>
<p>然后对下面的表达式求值：</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="nf">test</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">p</span><span class="p">))</span>
</pre></div>
<p>很显然 p 的定义是不正确的，当解释器是应用序的时候会先对参数求值。因此对 (p) 求值时程序将出错。如果程序是正则序则 (p) 不会被立即求值，因为 (= x 0) 将返回真值，整个 test 表达式将返回 0 。</p>
<h2>Section 1.17 牛顿法求平方根</h2>
<p>如果猜想y是x的平方，则下一个更接近x平方根的值是((y+x/y))/2</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">average</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">average</span> <span class="nv">guess</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="nv">guess</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">abs </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nf">square</span> <span class="nv">guess</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span> <span class="mf">0.001</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sqrt-iter</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
      <span class="nv">guess</span>
      <span class="p">(</span><span class="nf">sqrt-iter</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
                 <span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">"第一种平方根算法："</span><span class="p">)</span>
<span class="p">(</span><span class="nf">sqrt-iter</span> <span class="mf">1.0</span> <span class="mi">9</span><span class="p">)</span>
<span class="p">(</span><span class="nf">sqrt-iter</span> <span class="mf">1.0</span> <span class="mf">21.0</span><span class="p">)</span>
</pre></div>
<h2>Exercise 1.6 能否通过 cond 来定义 if</h2>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">new-if</span> <span class="nv">predicate</span> <span class="nv">then-clause</span> <span class="nv">else-clause</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">(</span><span class="nf">predicate</span> <span class="nv">then-clause</span><span class="p">)</span>
        <span class="p">(</span><span class="k">else </span><span class="nv">else-clause</span><span class="p">)))</span>
</pre></div>
<p>当测试用 new-if 来实现 Section 1.17 中的求平方根的方法时有可能会出现错误。因为通常 if 是一个特殊的 form 。它只会在条件为真时才对 then 子句求值。而 new-if 只是一个函数，它有可能会对所有参数都求值（比如解释器使用应用序）。在这用于 1.17 中的 sqrt-iter 中时将导致无限循环。</p>
<h2>Exercise 1.7</h2>
<p>原来的 section 1.17 中的 good-enough? 是比较猜测值的平方与被开方数的差的绝对值小于某个值。这种方法在对那些很小的数求平方根时并不是很有效。一个更好的办法是将它改进成比较两次猜测值之差是否小于某个给定的值。</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">last-value</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">average</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">average</span> <span class="nv">guess</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="nv">guess</span><span class="p">)))</span>

<span class="c1">;last-guess表示上一次猜测的值</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="nv">last-guess</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">abs </span><span class="p">(</span><span class="nb">- </span><span class="nv">guess</span> <span class="nv">last-guess</span><span class="p">))</span> <span class="mf">0.000001</span><span class="p">))</span>

<span class="c1">;修改了这个递归计算过程的参数，添加了上次猜测结果</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sqrt-iter</span> <span class="nv">guess</span> <span class="nv">x</span> <span class="nv">last-guess</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="nv">last-guess</span><span class="p">)</span>
      <span class="nv">guess</span>
      <span class="p">(</span><span class="nf">sqrt-iter</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
                 <span class="nv">x</span> <span class="nv">guess</span><span class="p">)))</span>

<span class="c1">;保证将猜测值设置为与上个猜测值之差的绝对值大于那个比较值0.000001</span>
<span class="p">(</span><span class="nf">print</span> <span class="s">"第二种平方根算法："</span><span class="p">)</span>
<span class="p">(</span><span class="nf">sqrt-iter</span> <span class="mf">1.0</span> <span class="mf">9.0</span> <span class="mi">100</span><span class="p">)</span>
<span class="p">(</span><span class="nf">sqrt-iter</span> <span class="mf">1.0</span> <span class="mf">21.0</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
<h2>Exercise 1.8 牛顿法求立方根</h2>
<p>如果 y 接近 x 的立方根，那么更接近的值是 (x/y*y+2y)/3 。对应的求立方根的程序为：</p>
<div class="highlight"><pre><span></span><span class="c1">;逼近算法</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">/ </span><span class="nv">x</span> <span class="p">(</span><span class="nf">square</span> <span class="nv">guess</span><span class="p">))</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">guess</span><span class="p">))</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1">;精度检查</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="nv">last-guess</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nb">abs </span><span class="p">(</span><span class="nb">- </span><span class="nv">guess</span> <span class="nv">last-guess</span><span class="p">))</span> <span class="mf">0.000001</span><span class="p">))</span>
<span class="c1">;迭代过程</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cube-iter</span> <span class="nv">guess</span> <span class="nv">x</span> <span class="nv">last-guess</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">good-enough?</span> <span class="nv">guess</span> <span class="nv">last-guess</span><span class="p">)</span>
      <span class="nv">guess</span>
      <span class="p">(</span><span class="nf">cube-iter</span> <span class="p">(</span><span class="nf">improve</span> <span class="nv">guess</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">guess</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">print</span> <span class="s">"求立方根算法求27的立方根:"</span><span class="p">)</span>
<span class="p">(</span><span class="nf">cube-iter</span> <span class="mf">1.0</span> <span class="mi">27</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
<p>只是在 exercise 1.7 的基础上替换了 improve 方法。</p>
<h2>Section 1.2 过程和它们所产生的计算</h2>
<h3 id="section-122-xian-xing-di-gui-he-die-dai">Section 1.2.2 线性递归和迭代</h3>
<h4 id="exercise-19-miao-hui-xian-xing-die-dai-he-xian-xing-di-gui-de-ji-suan-guo-cheng">Exercise 1.9 描绘线性迭代和线性递归的计算过程</h4>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-rec</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">a</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nv">b</span>
      <span class="p">(</span><span class="nf">inc</span> <span class="p">(</span><span class="nf">add-rec</span> <span class="p">(</span><span class="nf">dec</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">))))</span>
<span class="c1">;(add-rec 4 5)</span>
<span class="c1">;(inc (add-rec 3 5))</span>
<span class="c1">;(inc (inc (add-rec 2 5)))</span>
<span class="c1">;(inc (inc (inc (add-rec 1 5))))</span>
<span class="c1">;(inc (inc (inc (inc (add-rec 0 5)))))</span>
<span class="c1">;(inc (inc (inc (inc 5))))</span>
<span class="c1">;(inc (inc (inc 6)))</span>
<span class="c1">;(inc (inc (7)))</span>
<span class="c1">;(inc 8)</span>
<span class="c1">;9</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">add-iter</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">a</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nv">b</span>
      <span class="p">(</span><span class="nf">add-iter</span> <span class="p">(</span><span class="nf">dec</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">inc</span> <span class="nv">b</span><span class="p">))))</span>

<span class="c1">;(add-iter 4 5)</span>
<span class="c1">;(add-iter 3 6)</span>
<span class="c1">;(add-iter 2 7)</span>
<span class="c1">;(add-iter 1 8)</span>
<span class="c1">;(add-iter 0 9)</span>
<span class="c1">;9</span>
</pre></div>
<h4 id="exercise-110-a-ke-man-han-shu">Exercise 1.10 阿克曼函数</h4>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">A</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">y</span> <span class="mi">0</span> <span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">y</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">y</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">A</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
                 <span class="p">(</span><span class="nf">A</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y</span> <span class="mi">1</span><span class="p">))))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">f</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">g</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">1</span> <span class="nv">n</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">h</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nf">A</span> <span class="mi">2</span> <span class="nv">n</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">k</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">5</span> <span class="nv">n</span> <span class="nv">n</span><span class="p">))</span>
</pre></div>
<p>通过使用 f,g,h 和正整数 n ，给出计算 5 乘以 n 的 2 次方的函数 <code>(k n)</code> 的定义。
 - TODO:</p>
<h3 id="section-122-shu-xing-di-gui_1">Section 1.2.2 树形递归</h3>
<p>树形递归也是一种常见的计算模式。例如Fibonacci数的计算。</p>
<div class="highlight"><pre><span></span>Fib(n) = 0                   if n = 0
Fib(n) = 1                   if n = 1
Fib(n) = Fib(n-1) + Fib(n-2) otherwise
</pre></div>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fib</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">fib</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
                 <span class="p">(</span><span class="nf">fib</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">2</span><span class="p">))))))</span>
</pre></div>
<p>它所产生的计算过程是树状的。会随着n的变大计算规模也逐渐变大。并且在计算过程中间会产生许多重复的计算。例如，计算Fib(3)和Fib(4)时都会需要计算Fib(2)和Fib(1)，这样随着n变大会产生许多重复的计算。</p>
<p>如果将它转换成递归方式计算规模就不会随n变大而变大。计算的方法是引入两个中间变量a和b，将它们初始化为Fib(0)和Fib(1)，然后a=a+b，b=a，进而计算出Fib(2)，如此递归直至计算出Fib(n)。</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fib</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">fib-iter</span> <span class="mi">1</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">fib_iter</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">count</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">count</span> <span class="mi">0</span><span class="p">)</span>
      <span class="nv">b</span>
      <span class="p">(</span><span class="nf">fib-iter</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">- </span><span class="nv">count</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>
<ul>
<li>TODO:找零钱的算法</li>
</ul>
<h4 id="exercise-111-fen-bie-yi-di-gui-he-die-dai-de-fang-shi-bian-xie-fn">Exercise 1.11 分别以递归和迭代的方式编写f(n)</h4>
<div class="highlight"><pre><span></span>f(n)=n if n&lt;3 and f(n) = f(n-1)+2f(n-2)+3f(n-3) if n &gt;=3
</pre></div>
<p>递归方式</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">f</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">n</span> <span class="mi">3</span><span class="p">)</span> 
      <span class="nv">n</span>
      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span> 
         <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">2</span><span class="p">)))</span> 
         <span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">3</span><span class="p">))))))</span>
</pre></div>
<p>迭代方式。这里我引入了3个变量a、b和c分别代表f(n-1)、f(n-2)和f(n-3)</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">f1</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">f1-iter</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span> <span class="nv">n</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">f1-iter</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">count</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">count</span> <span class="mi">0</span><span class="p">)</span> 
      <span class="nv">c</span>
      <span class="p">(</span><span class="nf">f1-iter</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">a</span> <span class="nv">b</span> <span class="p">(</span><span class="nb">- </span><span class="nv">count</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>
<h4 id="exercise-112-pa-si-qia-san-jiao">Exercise 1.12 帕斯卡三角</h4>
<p>编写递归过程计算帕斯卡三角的元素。</p>
<p>我首先归纳帕斯卡三角的元素的计算方法：</p>
<div class="highlight"><pre><span></span>f(n,level) = 1                              如果n=1或n=level
f(n,level) = 0                              如果n&lt;1或n&gt;level则元素不存在
f(n,level) = f(n,level-1) + f(n-1,level-1)  otherswise
</pre></div>
<p>其中level为层次，n为在某层中的位置。</p>
<p>转换成函数定义</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">pascal-triangle</span> <span class="nv">n</span> <span class="nv">level</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">= </span><span class="nv">n</span> <span class="nv">level</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">((</span><span class="k">or </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">n</span> <span class="nv">level</span><span class="p">))</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">pascal-triangle</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">- </span><span class="nv">level</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="nf">pascal-triangle</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">level</span> <span class="mi">1</span><span class="p">))))))</span>
</pre></div>
<h4 id="exercise-113-zheng-ming-fibnshi-zui-jie-jin-mou-shu-de-zheng-shu">Exercise 1.13 证明Fib(n)是最接近某数的整数</h4>
<p><literal style="html">HTML</literal></p>
<ul>
<li>TODO:</li>
</ul>

      </div><!-- /.entry-content -->

    </article>
  </section>
</div>
                </div>
            </div>
        </div>

        <footer id="site-footer">
            <div class="row-fluid">
                <div class="span10 offset1">
                    <address>
                        <p>
                        This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                        </p>
                        <p>
                            <a href="http://github.com/jsliang/pelican-fresh/">Fresh</a> is a responsive theme designed by <a href="http://jsliang.com/">jsliang</a> and <a href="https://github.com/jsliang/pelican-fresh/graphs/contributors">contributors</a>.
                        Special thanks to <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a> and <a href="http://getbootstrap.com/">Twitter Bootstrap</a>.
                        </p>
                    </address>
                </div>
            </div>
        </footer>

        <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>

        <link href="http://apps.bdimg.com/libs/highlight.js/9.1.0/styles/default.min.css" rel="stylesheet">
        <script src="http://apps.bdimg.com/libs/highlight.js/9.1.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>