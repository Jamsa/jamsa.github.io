<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="author" content="Jamsa" />
        <meta name="robots" content="index, follow"/>

        <meta property="og:title" content="汇编语言（王爽）读书笔记"/>
        <meta property="og:url" content="./hui-bian-yu-yan-wang-shuang-du-shu-bi-ji.html"/>
        <meta property="og:site_name" content="Jamsa的笔记"/>
        <meta property="og:type" content="article"/>

        <link rel="canonical" href="./hui-bian-yu-yan-wang-shuang-du-shu-bi-ji.html" />

        <title>汇编语言（王爽）读书笔记 | Jamsa的笔记</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" />
        

        <link rel="stylesheet" type="text/css" href="./theme/css/main.css" />

        <script type="text/javascript">var switchTo5x=true;</script>
        <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
        <script type="text/javascript">
         stLight.options({
             publisher: "",
             doNotHash: false,
             doNotCopy: false,
             hashAddressBar: false
         });
        </script>
    </head>

    <body id="index">
        <div class="row-fluid">
            <div class="span10 offset1">
                <header id="banner" >
                    <h1>
                        <a href="./">Jamsa的笔记 </a>
                    </h1>
                    <nav class="navbar">
                        <div class="navbar-inner">
                            <ul class="nav">
                                <li ><a href="./category/da-shu-ju.html">大数据</a></li>
                                <li ><a href="./category/fang-fa.html">方法</a></li>
                                <li ><a href="./category/ji-qi-xue-xi.html">机器学习</a></li>
                                <li class="active"><a href="./category/kai-fa.html">开发</a></li>
                                <li ><a href="./category/qian-duan.html">前端</a></li>
                                <li ><a href="./category/xiao-lu.html">效率</a></li>
                                <li ><a href="./category/yi-dong.html">移动</a></li>
                            </ul>

                        </div>
                    </nav>
                </header><!-- /#banner -->
            </div>
        </div>

        <div class="row-fluid">
            <div class="span10 offset1">
                <div class="row-fluid">
<div class="span10 offset1">
  <section>
    <article>
      <header>
        <h1 class="entry-title">
          <a href="./hui-bian-yu-yan-wang-shuang-du-shu-bi-ji.html" rel="bookmark"
             title="Permalink to 汇编语言（王爽）读书笔记">汇编语言（王爽）读书笔记</a></h1>
      </header>
      <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2010-09-01

        |
        tags:         <a href="./tag/asm.html">asm</a>


        |
        <a href="./hui-bian-yu-yan-wang-shuang-du-shu-bi-ji.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->

        <h1>基础知识</h1>
<h2>存储单元</h2>
<p>最小信息单位是bit（比特、二进制位），8bit为1Byte（字节）。存储单元以字节为单位计。128个存储单元的存储器可以存储128字节。</p>
<h2>CPU对存储器的读写</h2>
<h3 id="du-xie-shi-cpuyu-wai-bu-qi-jian-jin-xing-3lei-xin-xi-jiao-hu">读写时CPU与外部器件进行3类信息交互：</h3>
<ul>
<li>
<p>存储单元的地址（地址信息）</p>
</li>
<li>
<p>器件的选择，读或写的命令（控制信息）</p>
</li>
<li>
<p>读或写的数据（数据信息）</p>
</li>
</ul>
<h3 id="du-xie-guo-cheng">读写过程</h3>
<h4 id="cpucong-3hao-dan-yuan-zhong-du-qu-shu-ju-guo-cheng">CPU从3号单元中读取数据过程</h4>
<ol>
<li>
<p>CPU通过地址线将地址信息3发出。</p>
</li>
<li>
<p>CPU通过控制线发出内存读取命令，选中存储芯片，并通知它，将要从中读取。</p>
</li>
<li>
<p>存储器将3号单元中的数据通过数据线送入CPU。</p>
</li>
</ol>
<h4 id="cpuxiang-3hao-dan-yuan-xie-ru-shu-ju">CPU向3号单元写入数据</h4>
<ol>
<li>
<p>CPU通过地址线将地址信息3发出。</p>
</li>
<li>
<p>CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。</p>
</li>
<li>
<p>CPU通过数据线将数据送入内存的3号单元中。</p>
</li>
</ol>
<h3 id="di-zhi-zong-xian_1">地址总线</h3>
<p>一个CPU有N根地址线，则可以立这个CPU的地址总线宽度为N。这样CPU可以最多寻找2的N次方个内存单元。</p>
<h3 id="shu-ju-zong-xian">数据总线</h3>
<p>CPU与内存或其它器件之间的数据传递是通过数据总线进行的。数据总线宽度决定了CPU和外界的数据传送速度（宽度不足时将需要进行多次传送）。8088CPU数据总线宽度为8，8086CPU的数据总线宽度为16。</p>
<h3 id="kong-zhi-zong-xian">控制总线</h3>
<p>控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。它决定了CPU对外部器件的控制能力。</p>
<h3 id="di-zhi-kong-jian-gai-shu">地址空间概述</h3>
<p>主板上的核心器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有：CPU、存储器、外围芯片组、扩展插槽（插有RAM内存条和各类接口卡）等。</p>
<p>PC上的存储器芯片从读写属性上分为两类：RAM和ROM。从功能和连接上分为：RAM、BIOS及接口卡上的RAM（例如：显存）。</p>
<p>这些存储器在物理上是独立的器件，但它们都和CPU的总线相连；CPU对它们进行读或写的时候都通过控制线发出内存读写命令。即CPU在操纵和控制它们的时候，把它们都当作内存来对侍，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。</p>
<p>所有物理存储器被看作由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段。CPU在这段地址空间中读写数据，实际上就是在对相应的物理存储器中读写数据。</p>
<p>内存地址空间的大小受CPU地址总线宽度的限制。8086CPU的地址总线宽度为20,可以传送2的20次方个不同的地址信息（内存单元），地址空间大小为1MB。80386CPU的地址总线宽度为32,则内在地址空间最大约为4GB。</p>
<h1>寄存器（CPU工作原理）</h1>
<p>CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章所说的总线相对于CPU内部来说是外部总线。在CPU中：运算器进行信息处理；寄存器进行信息存储；控制器控制各种器件进行工作；内部总线连接各种器件，在它们之间进行数据的传送。</p>
<p>对于汇编程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。程序员通过改变各种上寄存器中的内容来实现对CPU的控制。</p>
<p>8086CPU中有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>
<h2>通用寄存器</h2>
<p>8086CPU的所有寄存器都是16位的，可以存储两个字节。AX、BX、CX、DX四个寄存器通常用来存放一般性的数据，被称为通用寄存器。</p>
<p>8086CPU的上代CPU中寄存器是8位的，为保证兼容性，8086CPU中的AX、BX、CX、DX四个寄存器都可以分为两个独立的8位寄存器来使用：</p>
<ul>
<li>
<p>AX可分为AH和AL</p>
</li>
<li>
<p>BX可分为BH和BL</p>
</li>
<li>
<p>CX可分为CH和CL</p>
</li>
<li>
<p>DX可分为DH和DL</p>
</li>
</ul>
<p>8086CPU可以一次性处理两种尺寸的数据：byte（字节，8位），可存在8位寄存器中，word（字，16位），可存在16位寄存器中。</p>
<h2>物理地址</h2>
<p>CPU访问内存单元时，要给出内存单元的地址。所有内存单元构成的存储空间是一个一维的线性空间，每个内存单元在这个空间中都有惟一的地址，这个地址被称为物理地址。</p>
<p>CPU通过地址总线卷入存储器的必须是一个内在单元的物理地址。在CPU向地址总线上发出物理地址之前，必须在内部先形成这个物理地址。</p>
<h2>16位结构的CPU</h2>
<p>16位结构的CPU有下面几方面的结构特性：</p>
<ul>
<li>
<p>运算器一次最多可以处理16位的数据</p>
</li>
<li>
<p>寄存器的最大宽度为16位</p>
</li>
<li>
<p>寄存器和运算器之间的通路为16位。</p>
</li>
</ul>
<p>内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次处理、传输、暂存16位地址。</p>
<h2>8086CPU给出物理地址的方法</h2>
<p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂存的地址为16位。如果将地址从内部简单的发出，那就只能送出16位地址，表现出的寻址能力只有64KB。</p>
<p>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</p>
<p>当8086CPU要读写内存时：</p>
<ol>
<li>
<p>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址</p>
</li>
<li>
<p>段地址和偏移地址通过内部总线送入一个称为地址加法器的部件</p>
</li>
<li>
<p>地址加法器将两个16位地址合并成为一个20位的物理地址</p>
</li>
<li>
<p>地址加法器通过内部总线将20位物理地址送入输入输出控制电路</p>
</li>
<li>
<p>输入输出控制电路将20位物理地址送上地址总线</p>
</li>
<li>
<p>20位物理地址被地址总线传送到存储器</p>
</li>
</ol>
<p>地址加法器采用 <em>物理地址＝段地址X16+偏移地址</em> 的方法用段地址和偏移地址合成物理地址。</p>
<h2>段的概念</h2>
<p>将若干地址连续内在单元看作一个段，用段地址X16的起始地址（基础地址），用领衔地址定位段中的内在单元。有两点需要注意：段地址X16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位的寻址能力为64KB，所以一个段的长度最大为64KB。</p>
<h2>段寄存器</h2>
<p>8086CPU有4个段寄存器：CS、DS、SS、ES。</p>
<h2>CS和IP</h2>
<p>CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS主代码段寄存器，IP为指令指针寄存器。</p>
<p>在8086CPU中，任意时刻，设CS中内容为M，IP中的内容为N，8086CPU将从内存MX16+N单元开始，读取下一条指令并执行。</p>
<p>8086CPU加电启动或复位后CS和IP被设置为CS=F000H，IP=FFF0H，CPU从内存FFFF0H单元中读取指令执行。</p>
<h2>修改CS、IP的指令</h2>
<p>大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。</p>
<p>但是mov指令不能用于设置CS、IP的值，因为8086CPU没有提供这样的功能。8086CPU提供了jmp指令来改变CS、IP的内容。</p>
<p>若想同时修改CS、IP的内容，可用指令&ldquo;jmp 段地址: 偏移地址&rdquo;完成，如：</p>
<div class="highlight"><pre><span></span><span class="nf">jmp</span> <span class="mi">2</span><span class="no">AE3</span><span class="p">:</span><span class="mi">3</span>
<span class="nf">jmp</span> <span class="mi">3</span><span class="p">:</span><span class="mi">0</span><span class="no">B16</span>
</pre></div>
<p>若想仅修改IP的内容，可以用指令&ldquo;jmp 某一合法寄存器&rdquo;完成，如：</p>
<div class="highlight"><pre><span></span><span class="nf">jmp</span> <span class="no">ax</span>
</pre></div>
<h2>代码段</h2>
<p>在编程时，可根据需要，将一组内存单元定义为一个段。长度为<code>N(N&lt;=64KB)</code>的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。</p>
<p>将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS:IP指向的内存单元中的内容为指令。</p>
<h3 id="debugcheng-xu">Debug程序</h3>
<ul>
<li>
<p>R命令查看、改变CPU寄存器的内容，&ldquo;r&rdquo;查看，&ldquo;r ax&rdquo;修改ax的内容。</p>
</li>
<li>
<p>D命令查看内存中的内容，&ldquo;d 段地址:偏移地址&rdquo;将显示指定的内存单元开始的128个内存单元的内容。</p>
</li>
<li>
<p>E命令改写内存中的内容，&ldquo;e 起始地址 数据 数据 数据......&rdquo;，实际上也可以用它来直接写入机器码。</p>
</li>
<li>
<p>T指令逐条执行代码。</p>
</li>
<li>
<p>P执行中断调用。</p>
</li>
<li>
<p>A命令以汇编指令的形式在内存中写入机器指令。简单的A命令从一个预设的地址开始输入指令。&ldquo;A 1000:0&rdquo;从1000:0开始的内存中写入指令。</p>
</li>
</ul>
<h1>寄存器（内存访问）</h1>
<h2>内存中字的存储</h2>
<p>CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。在内存中存储时，由于内存单元是字节单元，则一个字要用两个地址连续的内存单元来存放，这个字的低位字节放在低地址单元中，高位字节存放在高地址单元中。</p>
<p>字单元，即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。</p>
<h2>DS和[address]</h2>
<p>CPu要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。8086中有一个DS寄存器，通常用来存放要访问数据的段地址。</p>
<p>前面使用mov指令，可以完成两种传送：</p>
<ol>
<li>
<p>将数据直接送入寄存器</p>
</li>
<li>
<p>将一个寄存器中的内容送入另一个寄存器</p>
</li>
</ol>
<p>也可以使用mov将一个内存单元中的内容送入一个寄存器中。格式：mov 寄存器名，内在单元地址。</p>
<p>内存单元偏移地址放在[]中。段地址由CPU自动取ds中的数据。</p>
<p>不能使用类似mov ds, 1000h来将1000h送入ds。只能通过寄存器中转。</p>
<div class="highlight"><pre><span></span><span class="nf">mov</span> <span class="no">bx</span><span class="p">,</span><span class="mi">1000</span><span class="no">h</span>
<span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span><span class="no">bx</span>
</pre></div>
<p>从寄存器送入内存单元。例如，使用mov [0],al可以将al的数据传送到当前数据段中偏移地址为0的内存单元里。</p>
<h2>字的传送</h2>
<p>我们只要在mov指令中给出16位寄存器就可以进行16位数据的传送了。</p>
<h2>mov、add、sub指令</h2>
<p>mov指令形式：</p>
<ul>
<li>
<p>mov 寄存器, 数据     如：mov ax, 8</p>
</li>
<li>
<p>mov 寄存器, 寄存器   如：mov ax,bx</p>
</li>
<li>
<p>mov 寄存器, 内存单元   如：mov ax,[0]</p>
</li>
<li>
<p>mov 内存单元, 寄存器   如：mov [0],bx</p>
</li>
<li>
<p>mov 段寄存器, 寄存器   如：mov ds,bx</p>
</li>
<li>
<p>mov 寄存器, 段寄存器   如：mov bx,ds</p>
</li>
<li>
<p>mov 内存单元, 段寄存器 如：mov [0],cs</p>
</li>
<li>
<p>mov 段寄存器, 内存单元 如：mov ds,[0]</p>
</li>
<li>
<p>不能使用 mov 段寄存器, 数据</p>
</li>
</ul>
<p>add和sub指令同mov一样，都操作两个对象。它们可以有以下几种形式：</p>
<ul>
<li>
<p>add 寄存器, 数据     如：add ax,8</p>
</li>
<li>
<p>add 寄存器, 寄存器   如：add ax,bx</p>
</li>
<li>
<p>add 寄存器, 内存单元  如：add ax, [0]</p>
</li>
<li>
<p>add 内存单元, 寄存器  如：add [0],ax</p>
</li>
<li>
<p>sub 寄存器, 数据     如：sub ax,8</p>
</li>
<li>
<p>sub 寄存器, 寄存器   如：sub ax,bx</p>
</li>
<li>
<p>sub 寄存器, 内存单元  如：sub ax, [0]</p>
</li>
<li>
<p>sub 内在单元, 寄存器  如：sub [0],ax</p>
</li>
</ul>
<h2>数据段</h2>
<p>将一段内存将作数据段，是编程时的一种安排，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。</p>
<h2>栈</h2>
<p>栈是一种具有特殊的访问方式的存储空间。栈的操作规则为LIFO（Last In First Out），先进先出。</p>
<h2>CPU提供的栈机制</h2>
<p>8086CPU提供的入栈和出栈指令为PUSH和POP。</p>
<p>8086CPU中有两个寄存器来存放栈顶的地址，段寄存器SS和寄存器SP，栈顶的段地址放在SS中，偏移地址放在SP中。栈为空时，栈中没有元素，也就不存在栈顶的元素，所以SS:SP只指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2。栈操作时变化的是SP的值，内存中的数据不会被清空，只会被覆盖。</p>
<h2>栈顶超界的问题</h2>
<p>当栈满时再使用push指令，或栈空时再使用pop指令都将发生栈顶超界的问题，这将覆盖栈空间外的数据。</p>
<p>8086CPU不保证对栈的操作不会超界。</p>
<p>在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，执行出入栈的时候要注意防止超界。</p>
<h2>push和pop指令</h2>
<p>指令格式：</p>
<ul>
<li>
<p>push 寄存器</p>
</li>
<li>
<p>pop 寄存器</p>
</li>
<li>
<p>push 段寄存器</p>
</li>
<li>
<p>pop 段寄存器</p>
</li>
<li>
<p>push 内存单元</p>
</li>
<li>
<p>pop 内存单元</p>
</li>
</ul>
<p>指令执行时，可以只给出内存单元的偏移地址，段地址在指令执行时，CPU从ds中取得。</p>
<p>push和pop指令同mov指令不同，CPU执行mov指令时只需要一步操作，就是传送，而执行push、pop指令时需要两步操作。执行push时，先改变SP，然后向SS:SP处传送。执行pop时，先读取SS:SP的数据，然后改变SP。</p>
<h2>栈段</h2>
<p>栈段也仅仅是编程时的一种安排。我们可以将长度为<code>N(N&lt;=64K)</code>的组地址连续，起始地址为16的倍数的内存单元当作栈空间来使用。</p>
<h1>第一个程序</h1>
<h2>源程序</h2>
<h3 id="wei-zhi-ling">伪指令</h3>
<p>汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译的机器指令，是终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行。伪指令由编译器来执行，编译器根据伪指令来进行相关的编译工作。</p>
<ol>
<li>segment和ends是一对成对使用的伪指令，这是在写可被编译的汇编程序时，必须要用到的一对伪指令。它的功能是定义一个段，segment说明段开始，ends说明段结束。使用格式为：</li>
</ol>
<div class="highlight"><pre><span></span><span class="err">段名</span> <span class="nf">segment</span>
<span class="err">.</span>
<span class="err">.</span>
<span class="err">段名</span> <span class="nf">ends</span>
</pre></div>
<p>一个汇编程序由多个段组成，这些段被用来存放代码、数据或当作栈空间来使用。</p>
<p>一个有意义的汇编程序中至少有一个段，这个段用来存放代码。</p>
<ol>
<li>
<p>end是一个汇编程序的结束标记，</p>
</li>
<li>
<p>assume这条伪指令的含义为&ldquo;假设&rdquo;。它假设某一段寄存器和程序中的某一个用segments...ends定义的段相关联。通过assume说明这种关联，在情况下，编译程序可以将段寄存器和某一个具体的段联系。assume并不是一条非要深入理解不可的伪指令，以后我们编程时，记着用assume将有特定用途的段和相关的段寄存器关联起来即可。</p>
</li>
</ol>
<p>比如我们用codes segment ... codesg ends定义了名为codseg的段。我们在程序开头，用assume cs:codeseg将用作代码段的段codesg和CPU中的段寄存器cs联系起来。</p>
<h3 id="yuan-cheng-xu-zhong-de-cheng-xu">源程序中的&ldquo;程序&rdquo;</h3>
<p>汇编语言写的源程序，包括伪指令和汇编指令，伪指令由编译器来处理，它们并不实现我们编程的最终目的。我们这里所说的程序是指源程序中最终由计算机执行、处理的指令或数据。</p>
<h3 id="biao-hao">标号</h3>
<p>汇编源程序中，除了汇编指令和伪指令外，还有一些标号，如&ldquo;codesg&rdquo;。一个标号指代了一个地址。比如codesg在segment的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p>
<h3 id="cheng-xu-de-jie-gou">程序的结构</h3>
<p>源程序由一些段构成。我们可以在这些段中存放代码、数据、或将某个段当作栈空间。基本要素：</p>
<div class="highlight"><pre><span></span><span class="nf">assume</span> <span class="no">cs</span><span class="p">:</span><span class="no">abc</span>
<span class="nf">abc</span> <span class="no">segment</span>
  <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="mi">2</span>
  <span class="nf">add</span> <span class="no">ax</span><span class="p">,</span><span class="no">ax</span>
  <span class="nf">add</span> <span class="no">ax</span><span class="p">,</span><span class="no">ax</span>

<span class="nf">abc</span> <span class="no">ends</span>

<span class="nf">end</span>
</pre></div>
<h3 id="cheng-xu-fan-hui">程序返回</h3>
<p>通过下面的两条指令返回：</p>
<div class="highlight"><pre><span></span><span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="mi">4</span><span class="no">c00H</span>
<span class="nf">int</span> <span class="mi">21</span><span class="no">H</span>
</pre></div>
<h3 id="yu-fa-cuo-wu-he-luo-ji-cuo-wu">语法错误和逻辑错误</h3>
<h2>编译源程序</h2>
<p>编译过程中将得到3个输出文件：目标文件（.obj）、列表文件（.lst）、交叉引用文件（.crf）。目标文件是我们最终要得到的结果，另外两个只是中间结果。</p>
<h2>连接器的简单解释</h2>
<ul>
<li>
<p>当源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件</p>
</li>
<li>
<p>程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件</p>
</li>
<li>
<p>一个源文件编译后，得到了存有机器码的目标文件，目标文件中有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。</p>
</li>
</ul>
<h3 id="yi-jian-hua-de-fang-shi-jin-xing-bian-yi-he-lian-jie">以简化的方式进行编译和连接</h3>
<p>编译和连接1.asm</p>
<div class="highlight"><pre><span></span><span class="nf">masm</span> <span class="mi">1</span><span class="c">;</span>
<span class="no">link</span> <span class="mi">1</span><span class="c">;</span>
</pre></div>
<h2>可执行文件中的程序将入内存并运行的原理</h2>
<p>DOS中如果用户要执行一个程序，则输入该程序的可执行文件名，command首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置CS:IP指向程序的入口，此后，command暂停运行，CPU运行程序。程序运行结束后，返回到command中，command再次显示当前盘符和当前路径组成的提示符，等侍用户的输入。</p>
<h2>程序执行过程的跟踪</h2>
<p>用Debug将程序加载入内存。</p>
<p>DOS中EXE加载的过程。</p>
<ul>
<li>
<p>找到一段起始地址为SA:0000的容量足够的空闲内存区</p>
</li>
<li>
<p>在这段内存区的前256字节中，创建一个称为程序段的前缀 （PSP）的数据区，DOS要利用PSP来和被加载的程序进行通信。</p>
</li>
<li>
<p>从PSP的后面将程序装入，程序的地址被设置为SA+10H:0；（空闲的内存区从SA:0开始，0-255字节为PSP，从256字节处开始存放程序，为更好地区分PSP和程序。DOS一般将它们划分到不同的段中，所以，有了这样的地址安排：空闲内存区：SA:0，PSP区：SA:0，程序区SA+10H:0。注意：PSP区和程序区虽然物理地址连接，却有不同的段地址。）</p>
</li>
<li>
<p>将内存区的段地址存入DS中，初始化其它相关寄存器后，设置CS:IP指向程序入口。</p>
</li>
</ul>
<p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为9，则程序所在的内存区的地址为ds:0</p>
<p>这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信。从256字节处向后的空间存放的是程序。</p>
<h1>[bx]和loop指令</h1>
<ol>
<li>[bx]和内存单元的描述</li>
</ol>
<p>[bx]同样表示一个内存单元，它的偏移地址在bx中。</p>
<ol>
<li>loop</li>
</ol>
<p>循环指令</p>
<ol>
<li>我们定义的描述性的符号&ldquo;()&rdquo;</li>
</ol>
<p>在下面的内容中，将使用&ldquo;()&rdquo;来表示一个寄存器或内存单元中的内容。它所表示的内容有两种类型：字节或字。是哪种类型将由寄存器名或具体的运算决定。</p>
<ol>
<li>约定符号idata表示常量</li>
</ol>
<p>后面，将使用idata表示常量。</p>
<h2>[bx]</h2>
<ul>
<li>mov ax,[bx]</li>
</ul>
<p>将bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，将SA:EA处的数据送入ax中。</p>
<ul>
<li>mov [bx],ax</li>
</ul>
<p>bx中存放的数据作为一个偏移地址，段地址SA默认在ds中，将ax中的数据送入SA:EA处。</p>
<h2>Loop指令</h2>
<p>指令格式是：loop 标号。CPU执行loop指令时，要进行两步操作：</p>
<ul>
<li>
<p>(cx)=(cx)-1</p>
</li>
<li>
<p>判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</p>
</li>
</ul>
<h2>在Debug中跟踪用loop指令实现的循环程序</h2>
<ul>
<li>
<p>在汇编程序中数据不能以字母开头。所以A000h要写为0A000h。</p>
</li>
<li>
<p>在Debug中使用G来继续执行程序。或者g 0012之类的指令转到cs:0012处开始跟踪。</p>
</li>
</ul>
<h2>Debug和汇编编译器Masm对指令的不同处理</h2>
<p>Debug和编译器masm对形如&ldquo;mov ax,[0]&rdquo;这类的指令在解释上不同。Debug会将[0]解释为一个内存单元。而0是内存单元的偏移地址；而编译器将[0]就解释为了0。</p>
<p>当前我们将偏移地址送入bx寄存器，用[bx]的方式来访问内存单元。如：</p>
<div class="highlight"><pre><span></span><span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="mi">2000</span><span class="no">h</span>
<span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span><span class="no">ax</span>
<span class="nf">mov</span> <span class="no">bx</span><span class="p">,</span><span class="mi">0</span>
<span class="nf">mov</span> <span class="no">al</span><span class="p">,[</span><span class="no">bx</span><span class="p">]</span>
</pre></div>
<p>如果希望像在Debug中那样，在&ldquo;[]&rdquo;中直接给出内存单元的偏移地址。只需要在&ldquo;[]&rdquo;的前面显式的给出段地址所在的寄存器。</p>
<div class="highlight"><pre><span></span><span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="mi">2000</span><span class="no">h</span>
<span class="nf">mov</span> <span class="no">ds</span><span class="p">,</span><span class="no">ax</span>
<span class="nf">mov</span> <span class="no">al</span><span class="p">,</span><span class="no">ds</span><span class="p">:[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
<h2>段前缀</h2>
<ol>
<li>
<p>mov ax,ds:[bx]</p>
</li>
<li>
<p>mov ax,cs:[bx]</p>
</li>
<li>
<p>mov ax,ss:[bx]</p>
</li>
<li>
<p>mov as,es:[bx]</p>
</li>
<li>
<p>mov ax,ss:[0]</p>
</li>
<li>
<p>mov ax,cs:[0]</p>
</li>
</ol>
<p>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的&ldquo;ds:&rdquo;、&ldquo;cs&rdquo;、&ldquo;ss&rdquo;或&ldquo;es&rdquo;，称为段前缀。</p>
<h2>一段安全的空间</h2>
<p>在8086模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据或代码。</p>
<p>一般在PC机中，DOS和其他合法程序一般都不会使用0:200~0:300的256个字节的空间。所以我们使用这段空间是安全的。</p>
<h1>包含多个段的程序</h1>
<p>程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行过程中间向操作系统申请。</p>
<p>若要一个程序在加载的时候取得所需的空间，则必须要在源程序中做出说明。我们通过在源程序中定义段来进行内存空间的获取。</p>
<h2>在代码段中使用数据</h2>
<div class="highlight"><pre><span></span><span class="nf">assume</span> <span class="no">cs</span><span class="p">:</span><span class="no">code</span>
<span class="nf">code</span> <span class="no">segment</span>
  <span class="nf">dw</span> <span class="mi">0123</span><span class="no">H</span><span class="p">,</span><span class="mi">0456</span><span class="no">H</span><span class="p">,</span><span class="mi">0789</span><span class="no">H</span><span class="p">,</span><span class="mi">0</span><span class="no">abcH</span><span class="p">,</span><span class="mi">0</span><span class="no">defH</span><span class="p">,</span><span class="mi">0</span><span class="no">fedH</span><span class="p">,</span><span class="mi">0</span><span class="no">cbaH</span><span class="p">,</span><span class="mi">0987</span><span class="no">h</span>
  <span class="nl">start:</span>    <span class="nf">mov</span> <span class="no">bx</span><span class="p">,</span><span class="mi">0</span>
            <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="mi">0</span>
            <span class="nf">mov</span> <span class="no">cx</span><span class="p">,</span><span class="mi">8</span>
      <span class="nl">s:</span>    <span class="nf">add</span> <span class="no">ax</span><span class="p">,</span><span class="no">cs</span><span class="p">:[</span><span class="no">bx</span><span class="p">]</span>
           <span class="nf">add</span> <span class="no">bx</span><span class="p">,</span><span class="mi">2</span>
           <span class="nf">loop</span> <span class="no">s</span>
  <span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="mi">4</span><span class="no">c00h</span>
  <span class="nf">int</span> <span class="mi">21</span><span class="no">h</span>
<span class="nf">code</span> <span class="no">ends</span>
<span class="nf">end</span> <span class="no">start</span>
</pre></div>
<p>这里代码段定义了一些字型数据。因此代码段的起始位置不再是代码，代码的起始位置由start来标明，代码结束由end start来标明。</p>
<h2>在代码段中使用栈</h2>
<h2>将数据、代码、栈放入不同的段</h2>
<h1>更灵活的定位内存地址的方法</h1>
<h2>and和or指令</h2>
<h2>以字符形式给出数据</h2>
<div class="highlight"><pre><span></span><span class="nf">db</span> <span class="err">'</span><span class="no">unIX</span><span class="err">'</span>   <span class="err">相当于</span> <span class="no">db</span> <span class="mi">75</span><span class="no">H</span><span class="p">,</span><span class="mi">6</span><span class="no">EH</span><span class="p">,</span><span class="mi">49</span><span class="no">H</span><span class="p">,</span><span class="mi">58</span><span class="no">H</span>
<span class="nf">mov</span> <span class="no">al</span><span class="p">,</span> <span class="err">'</span><span class="no">a</span><span class="err">'</span> <span class="err">相当于</span> <span class="no">mov</span> <span class="no">al</span><span class="p">,</span><span class="mi">61</span><span class="no">H</span>
</pre></div>
<h2>[bx+idata]</h2>
<p>它的偏移地址为(bx)+idata（bx中的数值加上idata）。也可以写作idata[bx]。</p>
<h2>SI和DI</h2>
<p>SI和DI是8086CPU中和bx功能相近的寄存器，SI和DI不能够分成两个8位寄存器来使用。</p>
<h2>[bx+si]和[bx+di]</h2>
<p>这两者的含义相似。表示一个内存单元，它的偏移地址为(bx)+(si)，即bx中的数值加上si中的数值。</p>
<h2>[bx+si+idata]和[bx+di+idata]</h2>
<p>这两者的含义相似。表示一个内存单元，它的偏移地址为(bx)+(si)+idata，即bx中的数值加上si中的数值再加上idata。</p>
<h2>不同的寻址方式的灵活应用</h2>
<ol>
<li>
<p>[idata]用一个常量来表示地址，可用于直接定位一个内存单元；</p>
</li>
<li>
<p>[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；</p>
</li>
<li>
<p>[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；</p>
</li>
<li>
<p>[bx+si]用两个变量表示地址；</p>
</li>
<li>
<p>[bx+si+idata]用两个变量和一个常量表示地址。</p>
</li>
</ol>
<p>一般来说，在需要暂存数据的时候，我们都应该使用栈。</p>
<h1>数据处理的两个基本问题</h1>
<p>下面将使用reg来表示寄存器，sreg表示段寄存器。</p>
<p>reg包括：ax,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di</p>
<p>sreg包括：ds,ss,cs,es</p>
<h2>bx、si、di、bp</h2>
<ol>
<li>
<p>在8086CPU中，只有这4个寄存器可以用在&ldquo;[...]&rdquo;中来进行内存单元的寻址。</p>
</li>
<li>
<p>在[...]中，这4个寄存器可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di。</p>
</li>
<li>
<p>只要在[...]中使用寄存器bp，而指令没有显式的给出段地址，段地址默认在ss中。</p>
</li>
</ol>
<h2>机器指令处理的数据所在位置</h2>
<p>绝大部分机器指令都是进行数据处理的指令，处理大致可分为三类：读取、写入、运算。在机器指令这一层来讲，关不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在三个地方：CPU内部、内存、端口。</p>
<h2>汇编语言中数据位置的表达</h2>
<ul>
<li>立即数（idata）</li>
</ul>
<p>对于直接包含在机器指令中的数据，在汇编指令中直接给出，如：</p>
<div class="highlight"><pre><span></span><span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="mi">1</span>
<span class="nf">add</span> <span class="no">bx</span><span class="p">,</span><span class="mi">2000</span><span class="no">h</span>
<span class="nf">or</span> <span class="no">bx</span><span class="p">,</span><span class="mi">00010000</span><span class="no">b</span>
<span class="nf">mov</span> <span class="no">al</span><span class="p">,</span><span class="err">'</span><span class="no">a</span><span class="err">'</span>
</pre></div>
<ul>
<li>
<p>寄存器</p>
</li>
<li>
<p>段地址（SA）和偏移地址（EA）</p>
</li>
</ul>
<p>指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。存放段寄存器可以是默认的，如：</p>
<div class="highlight"><pre><span></span><span class="nf">mov</span> <span class="no">ax</span><span class="p">,[</span><span class="mi">0</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">ax</span><span class="p">,[</span><span class="no">di</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">ax</span><span class="p">,[</span><span class="no">bx</span><span class="err">+</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">ax</span><span class="p">,[</span><span class="no">bx</span><span class="err">+</span><span class="no">si</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">ax</span><span class="p">[</span><span class="no">bx</span><span class="err">+</span><span class="no">si</span><span class="err">+</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
<p>等指令，段地址默认在ds中：</p>
<div class="highlight"><pre><span></span><span class="nf">mov</span> <span class="no">ax</span><span class="p">,[</span><span class="no">bp</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">ax</span><span class="p">,[</span><span class="no">bp</span><span class="err">+</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">ax</span><span class="p">,[</span><span class="no">bp</span><span class="err">+</span><span class="no">si</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">ax</span><span class="p">,[</span><span class="no">bp</span><span class="err">+</span><span class="no">si</span><span class="err">+</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
<p>等指令，段地址默认在ss中。</p>
<p>存放段地址的寄存器也可以显性的给出，如：</p>
<div class="highlight"><pre><span></span><span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="no">ds</span><span class="p">:[</span><span class="no">bp</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="no">es</span><span class="p">:[</span><span class="no">bx</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="no">ss</span><span class="p">:[</span><span class="no">bx</span><span class="err">+</span><span class="no">si</span><span class="p">]</span>
<span class="nf">mov</span> <span class="no">ax</span><span class="p">,</span><span class="no">cs</span><span class="p">:[</span><span class="no">bx</span><span class="err">+</span><span class="no">si</span><span class="err">+</span><span class="mi">8</span><span class="p">]</span>
</pre></div>
<h2>寻址方式</h2>
<p>当数据存放在内在中的时候，我们可以用多种方式来给定这个内存单元的偏移地
址，这种定位内存单元的方法一般被称为寻址方式。
<table class="table table table-condensed table-bordered table-hover">
<tr>
<td>寻址方式</td>
<td>含义</td>
<td>名称</td>
<td>常用格式举例</td>
</tr>
<tr>
<td>[idata]</td>
<td>EA=idata;SA=(ds)</td>
<td>直接寻址</td>
<td>[idata]</td>
</tr>
<tr>
<td>
     [bx]<br/>
     [si]<br/>
     [di]<br/>
     [bp]<br/>
</td>
<td>
     EA=(bx);SA=(ds)<br/>
     EA=(si);SA=(ds)<br/>
     EA=(di);SA=(ds)<br/>
     EA=(bp);SA=(ss)<br/>
</td>
<td>寄存器相对寻址</td>
<td>
     用于结构体：         <br/> 
     [bx].idata          <br/>
     用于数组：           <br/>
     idata[si],idata[di] <br/>
     用于二维数组         <br/>
     [bx][idata]         <br/>
</td>
</tr>
</table></p>

      </div><!-- /.entry-content -->
      <div class="comments">
        <h2>Comments</h2>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          var disqus_identifier = "hui-bian-yu-yan-wang-shuang-du-shu-bi-ji.html";
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//jamsa-github-io.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
      </div>

    </article>
  </section>
</div>
                </div>
            </div>
        </div>

        <footer id="site-footer">
            <div class="row-fluid">
                <div class="span10 offset1">
                    <address>
                        <p>
                        This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                        </p>
                        <p>
                            <a href="http://github.com/jsliang/pelican-fresh/">Fresh</a> is a responsive theme designed by <a href="http://jsliang.com/">jsliang</a> and <a href="https://github.com/jsliang/pelican-fresh/graphs/contributors">contributors</a>.
                        Special thanks to <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a> and <a href="http://getbootstrap.com/">Twitter Bootstrap</a>.
                        </p>
                    </address>
                </div>
            </div>
        </footer>

<script type="text/javascript">
    var disqus_shortname = 'jamsa-github-io';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
        <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>

        <link href="http://apps.bdimg.com/libs/highlight.js/9.1.0/styles/default.min.css" rel="stylesheet">
        <script src="http://apps.bdimg.com/libs/highlight.js/9.1.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>