<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta name="author" content="Jamsa" />
        <meta name="robots" content="index, follow"/>

        <meta property="og:title" content="Rust所有权系统"/>
        <meta property="og:url" content="./rustsuo-you-quan-xi-tong.html"/>
        <meta property="og:site_name" content="Jamsa的笔记"/>
        <meta property="og:type" content="article"/>

        <link rel="canonical" href="./rustsuo-you-quan-xi-tong.html" />

        <title>Rust所有权系统 | Jamsa的笔记</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" />
        <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" />
        

        <link rel="stylesheet" type="text/css" href="./theme/css/main.css" />

        <script type="text/javascript">var switchTo5x=true;</script>
        <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
        <script type="text/javascript">
         stLight.options({
             publisher: "",
             doNotHash: false,
             doNotCopy: false,
             hashAddressBar: false
         });
        </script>
    </head>

    <body id="index">
        <div class="row-fluid">
            <div class="span10 offset1">
                <header id="banner" >
                    <h1>
                        <a href="./">Jamsa的笔记 </a>
                    </h1>
                    <nav class="navbar">
                        <div class="navbar-inner">
                            <ul class="nav">
                                <li ><a href="./category/da-shu-ju.html">大数据</a></li>
                                <li ><a href="./category/fang-fa.html">方法</a></li>
                                <li ><a href="./category/ji-qi-xue-xi.html">机器学习</a></li>
                                <li class="active"><a href="./category/kai-fa.html">开发</a></li>
                                <li ><a href="./category/qian-duan.html">前端</a></li>
                                <li ><a href="./category/xiao-lu.html">效率</a></li>
                                <li ><a href="./category/yi-dong.html">移动</a></li>
                            </ul>

                        </div>
                    </nav>
                </header><!-- /#banner -->
            </div>
        </div>

        <div class="row-fluid">
            <div class="span10 offset1">
                <div class="row-fluid">
<div class="span10 offset1">
  <section>
    <article>
      <header>
        <h1 class="entry-title">
          <a href="./rustsuo-you-quan-xi-tong.html" rel="bookmark"
             title="Permalink to Rust所有权系统">Rust所有权系统</a></h1>
      </header>
      <div class="entry-content">
<footer class="post-info">
    <address class="vcard author">
        by <a class="url fn" href="./author/jamsa.html">Jamsa</a>
    </address>

    in <a href="./category/kai-fa.html">开发</a>

    on 2018-08-21

        |
        tags:         <a href="./tag/rust.html">rust</a>


        |
        <a href="./rustsuo-you-quan-xi-tong.html#disqus_thread">comments</a>

    
</footer><!-- /.post-info -->

        <p>本文是读《Rust程序设计语言第二版》所有权相关内容的笔记。阅读这本书所敲的代码放在<a href="https://github.com/Jamsa/trpl/blob/master/src/ownership.rs">Github</a>上。代码没有按书的结构分章节创建工程，而是将所有代码放在一个单独的工程中。</p>
<h1>所有权</h1>
<p>所有权是Rust中最为独特的功能，它使得Rust无需垃圾回收即可保障内存安全。</p>
<h2>所有权规则</h2>
<ul>
<li>
<p>Rust中每个值都有一个被称为所有者的变量。</p>
</li>
<li>
<p>值有且只能有一个所有者。</p>
</li>
<li>
<p>当所有者离开作用域，这个值将被丢弃。</p>
</li>
</ul>
<h2>内存分配</h2>
<p>以字符串为例，字符串字面量在编译时已经知道它的内容，它被直接硬编码进最终的可执行文件。它的快速高效来自于其不可变性。对于<code>String</code>类型，它为了支持可变，需要在堆上分配一块在编译时未知大小的内存来存储内容。这意味着：</p>
<p>1.　内存需要在运行时向操作系统申请。</p>
<p>1.　需要一个在处理完<code>String</code>时将内存返还给操作系统的方法。</p>
<p>内存申请在所有编程语言中都是非常通用的。内存的返还在不同语言中则各有区别。在有<code>GC</code>的语言中，<code>GC</code>记录并清除不再使用的内存。没有<code>GC</code>时，识别不再使用的内在，调用代码释放它就是程序员的责任了，如使用<code>allocate</code>和<code>free</code>。</p>
<p>Rust采用了不同的策略：内存在变量离开作用域后就被自动释放。当变量离开作用域，Rust为其调用<code>drop</code>函数，<code>String</code>类的作者可以在这里放置释放内存的代码。（类似<code>C++</code>的<code>RAII</code>）</p>
<h2>变量与数据交互</h2>
<h3 id="jiao-hu-fang-shi-yi-yi-dong">交互方式一：移动</h3>
<p>将一个变量赋值给另一个变量时，将复制变量（不是值）。如以下代码：</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>字符串变量<code>s1</code>由一个指向存放字符串内容的指针、字符串长度、字符串容量三部分组成。当把<code>s1</code>赋给<code>s2</code>时，会复制指针、长度、容量，但并不会复制指针所指向的数据（值）。</p>
<p><img alt="String" src="./trpl/trpl_ownership_string.png"/></p>
<p>这样一来，<code>s1</code>和s2<code>就都指向了同一块内存区域。前面提到过当变量离开作用域时，会自动调用</code>drop<code>释放内存。如果</code>s1<code>和</code>s2<code>都释放，会导致同一块内存被释放两次，产生</code>二次释放`问题，产生内存污染和安全漏洞。</p>
<p>为了保证内存安全，在这种场景下Rust会认为<code>s1</code>不再有效，不需要再次释放。在Rust中这个赋值会复制指针、长度、容量，而不会拷贝数据，听起来像是&ldquo;浅拷贝&rdquo;。在这个过程中Rust会让第一个变量无效化，这个操作被称为<code>移动（move）</code>。以下代码会编译报错：</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"></span>

<span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"{}, world!"</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">);</span><span class="w"></span>
</pre></div>
<p>因为<code>s1</code>赋给<code>s2</code>之后，相当于<code>s1</code>被移动到了<code>s2</code>，因此<code>s1</code>不再有效。</p>
<p><img alt="移动" src="./trpl/trpl_ownership_move.png"/></p>
<h3 id="jiao-hu-fang-shi-er-ke-long">交互方式二：克隆</h3>
<p>如果确实需要进行深度复制指针指向的数据，可以使用<code>clone</code>方法。下面的<code>s1</code>和<code>s2</code>都有效：</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span><span class="w"></span>

<span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"s1 = {}, s2 = {}"</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">);</span><span class="w"></span>
</pre></div>
<h3 id="zhan-shang-de-shu-ju-kao-bei">栈上的数据：拷贝</h3>
<p>对于整形等在编译期已知大小的类型是存储在栈上的，其值拷贝速度非常快，在赋值时会直接被复制（值）。</p>
<h2>所有权与函数</h2>
<p>将值传给函数在主义上与给变量赋值相似。向函数传递值可能会移动或复制，就像赋值语句一样。</p>
<p>返回值也可以转移作用域。函数返回值的所有权发生转移。</p>
<p>第个函数都获取并返回所有权代码会比较冗余。比如：</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span>: <span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">();</span><span class="w"> </span><span class="c1">// len() returns the length of a String.</span>

<span class="w">    </span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>这时可以使用<code>引用</code>功能。</p>
<h1>引用与借用</h1>
<p>在调用<code>calculate_length</code>时，我们并不希望<code>s</code>的所有权转移至函数内，通常会希望<code>s</code>在调用完函数后仍然可用。这种情况下我们可以使用<code>引用</code>而不是直接获取所有权。</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">"The length of '{}' is {}."</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span>: <span class="kp">&amp;</span><span class="nb">String</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p><code>&amp;</code>符号就是引用，它允许你使用值，但是并不获取其所有权。<code>s</code>引用指向变量<code>s1</code>，但并不取得<code>s1</code>的指针（<code>s1</code>包括指向数据的指针、容量、长度）所指向的数据（值）的所有权。当引用离开作用域时，其指向的值不会被丢弃。</p>
<p><img alt="引用" src="./trpl/trpl_ownership_ref.png"/></p>
<p>与使用<code>&amp;</code>相对应的操作是解引用，解引用运算符为<code>*</code>。</p>
<p>获取引用作为函数参数称为<code>借用</code>。</p>
<h2>可变引用</h2>
<p>如变量一样，引用默认也是不允许修改引用值的。使用<code>&amp;mut s</code>创建<code>s</code>可变引用。可变引用的限制：在特定作用域中的特定数据，有且只有一个可变引用。以下代码将会报错：</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
</pre></div>
<p>Rust中通过这种方式也避免了数据竞争的发生，因为在编译期就会检查存在数据竞争的代码。</p>
<p>可以使用大括号来创建新的作用域，以允许拥有多个可变引用，这仍然不是<code>同时</code>拥有：</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span><span class="w"></span>

<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>

<span class="p">}</span><span class="w"> </span><span class="c1">// r1 goes out of scope here, so we can make a new reference with no problems.</span>

<span class="kd">let</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">s</span><span class="p">;</span><span class="w"></span>
</pre></div>
<h2>悬垂引用</h2>
<p>存在指针的语言中，容易通过释放内存时保留指向它的指针而生成一个悬垂指针，其指向的内存可能已经被分配给其它持有者。因此，悬垂指针容易产生各种问题。Rust编译器确保引用永远也不会变成悬垂状态：当我们拥有数据的引用，编译器确保数据不会在引用之前离开作用域。</p>
<p>以下代码是无法编译通过的：</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">reference_to_nothing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dangle</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">dangle</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="o">&amp;</span><span class="n">s</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>产生的错误为：</p>
<div class="highlight"><pre><span></span>error[E0106]: missing lifetime specifier
 --&gt; dangle.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</pre></div>
<p>错误信息与<a href="./rustbian-liang-sheng-ming-zhou-qi-guan-li.html">生命周期</a>有关。</p>
<p>因为<code>s</code>是在<code>dangle</code>函数内创建的，当<code>dangle</code>的代码执行完毕后，<code>s</code>将被释放，当试图返回它的引用时，Rust能检测出这种错误。</p>
<p>这种情况下需要返回变量，而不是其引用。返回时所有权将被转移出函数。</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">no_dangle</span><span class="p">()</span><span class="w"> </span>-&gt; <span class="nb">String</span> <span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="n">s</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<h2>引用的使用规则</h2>
<ul>
<li>
<p>在任意时间，只能拥有如下中的一个</p>
</li>
<li>
<p>一个可变引用</p>
</li>
<li>
<p>任意数量的不可变引用</p>
</li>
<li>
<p>引用必须总是有效的</p>
</li>
</ul>
<h1>Slices</h1>
<p><code>slice</code>是另一个没有所有权的数据类型。它允许你引用集合中的一段连续的元素，而不引用整个集合。</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">String</span>::<span class="n">from</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">);</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">hello</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">..</span><span class="mi">5</span><span class="p">];</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">world</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="p">..</span><span class="mi">11</span><span class="p">];</span><span class="w"></span>
</pre></div>
<p>其内存结构如下：</p>
<p><img alt="Slice" src="./trpl/trpl_ownership_slice.png"/></p>
<p>字符串<code>slice</code>的类型声明写作<code>&amp;str</code>。</p>
<p>字符串字面值就是<code>slice</code>，如<code>let s = "Hello, world!";</code>。</p>
<p><code>Slice</code>不只是针对字符串，也可以对其它所有类型的集合使用<code>slice</code>。</p>

      </div><!-- /.entry-content -->
      <div class="comments">
        <h2>Comments</h2>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          var disqus_identifier = "rustsuo-you-quan-xi-tong.html";
          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//jamsa-github-io.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
      </div>

    </article>
  </section>
</div>
                </div>
            </div>
        </div>

        <footer id="site-footer">
            <div class="row-fluid">
                <div class="span10 offset1">
                    <address>
                        <p>
                        This blog is proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                        </p>
                        <p>
                            <a href="http://github.com/jsliang/pelican-fresh/">Fresh</a> is a responsive theme designed by <a href="http://jsliang.com/">jsliang</a> and <a href="https://github.com/jsliang/pelican-fresh/graphs/contributors">contributors</a>.
                        Special thanks to <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a> and <a href="http://getbootstrap.com/">Twitter Bootstrap</a>.
                        </p>
                    </address>
                </div>
            </div>
        </footer>

<script type="text/javascript">
    var disqus_shortname = 'jamsa-github-io';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
        <script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/bootstrap/2.3.2/js/bootstrap.min.js"></script>

        <link href="http://apps.bdimg.com/libs/highlight.js/9.1.0/styles/default.min.css" rel="stylesheet">
        <script src="http://apps.bdimg.com/libs/highlight.js/9.1.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script>
         var _hmt = _hmt || [];
         (function() {
           var hm = document.createElement("script");
           hm.src = "https://hm.baidu.com/hm.js?5e20e9cdd1185d24ece1dae11118a04f";
           var s = document.getElementsByTagName("script")[0]; 
           s.parentNode.insertBefore(hm, s);
         })();
        </script>
</body>
</html>